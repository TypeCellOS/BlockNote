diff --git a/dist/Skip-gsWxt5h3.js b/dist/Skip-gsWxt5h3.js
new file mode 100644
index 0000000000000000000000000000000000000000..93bd674d8435f825ec1aa5919de6568f13859c3e
--- /dev/null
+++ b/dist/Skip-gsWxt5h3.js
@@ -0,0 +1,11889 @@
+import { ObservableV2 } from 'lib0/observable';
+import * as array from 'lib0/array';
+import * as math from 'lib0/math';
+import * as encoding from 'lib0/encoding';
+import * as decoding from 'lib0/decoding';
+import * as traits from 'lib0/traits';
+import * as random from 'lib0/random';
+import * as map from 'lib0/map';
+import * as promise from 'lib0/promise';
+import * as buffer from 'lib0/buffer';
+import * as error from 'lib0/error';
+import * as f from 'lib0/function';
+import { callAll } from 'lib0/function';
+import * as set from 'lib0/set';
+import * as logging from 'lib0/logging';
+import * as time from 'lib0/time';
+import * as binary from 'lib0/binary';
+import * as string from 'lib0/string';
+import * as delta from 'lib0/delta';
+import * as rabin from 'lib0/hash/rabin';
+import * as iterator from 'lib0/iterator';
+import * as object from 'lib0/object';
+import * as env from 'lib0/environment';
+import * as s from 'lib0/schema';
+
+/**
+ * This is an abstract interface that all Connectors should implement to keep them interchangeable.
+ *
+ * @note This interface is experimental and it is not advised to actually inherit this class.
+ *       It just serves as typing information.
+ *
+ * @extends {ObservableV2<any>}
+ */
+class AbstractConnector extends ObservableV2 {
+  /**
+   * @param {Doc} ydoc
+   * @param {any} awareness
+   */
+  constructor (ydoc, awareness) {
+    super();
+    this.doc = ydoc;
+    this.awareness = awareness;
+  }
+}
+
+class IdRange {
+  /**
+   * @param {number} clock
+   * @param {number} len
+   */
+  constructor (clock, len) {
+    /**
+     * @type {number}
+     */
+    this.clock = clock;
+    /**
+     * @type {number}
+     */
+    this.len = len;
+  }
+
+  /**
+   * @param {number} clock
+   * @param {number} len
+   */
+  copyWith (clock, len) {
+    return new IdRange(clock, len)
+  }
+
+  /**
+   * Helper method making this compatible with IdMap.
+   *
+   * @return {Array<import('./IdMap.js').AttributionItem<any>>}
+   */
+  get attrs () {
+    return []
+  }
+}
+
+class MaybeIdRange {
+  /**
+   * @param {number} clock
+   * @param {number} len
+   * @param {boolean} exists
+   */
+  constructor (clock, len, exists) {
+    /**
+     * @type {number}
+     */
+    this.clock = clock;
+    /**
+     * @type {number}
+     */
+    this.len = len;
+    /**
+     * @type {boolean}
+     */
+    this.exists = exists;
+  }
+}
+
+/**
+ * @param {number} clock
+ * @param {number} len
+ * @param {boolean} exists
+ * @return {MaybeIdRange}
+ */
+const createMaybeIdRange = (clock, len, exists) => new MaybeIdRange(clock, len, exists);
+
+class IdRanges {
+  /**
+   * @param {Array<IdRange>} ids
+   */
+  constructor (ids) {
+    this.sorted = false;
+    /**
+     * A typical use-case for IdSet is to append data. We heavily optimize this case by allowing the
+     * last item to be mutated ef it isn't used currently.
+     * This flag is true if the last item was exposed to the outside.
+     */
+    this._lastIsUsed = false;
+    /**
+     * @private
+     */
+    this._ids = ids;
+  }
+
+  copy () {
+    return new IdRanges(this._ids.slice())
+  }
+
+  /**
+   * @param {number} clock
+   * @param {number} length
+   */
+  add (clock, length) {
+    const last = this._ids[this._ids.length - 1];
+    if (last.clock + last.len === clock) {
+      if (this._lastIsUsed) {
+        this._ids[this._ids.length - 1] = new IdRange(last.clock, last.len + length);
+        this._lastIsUsed = false;
+      } else {
+        this._ids[this._ids.length - 1].len += length;
+      }
+    } else {
+      this.sorted = false;
+      this._ids.push(new IdRange(clock, length));
+    }
+  }
+
+  /**
+   * Return the list of immutable id ranges, sorted and merged.
+   */
+  getIds () {
+    const ids = this._ids;
+    this._lastIsUsed = true;
+    if (!this.sorted) {
+      this.sorted = true;
+      ids.sort((a, b) => a.clock - b.clock);
+      // merge items without filtering or splicing the array
+      // i is the current pointer
+      // j refers to the current insert position for the pointed item
+      // try to merge dels[i] into dels[j-1] or set dels[j]=dels[i]
+      let i, j;
+      for (i = 1, j = 1; i < ids.length; i++) {
+        const left = ids[j - 1];
+        const right = ids[i];
+        if (left.clock + left.len >= right.clock) {
+          const r = right.clock + right.len - left.clock;
+          if (left.len < r) {
+            ids[j - 1] = new IdRange(left.clock, r);
+          }
+        } else if (left.len === 0) {
+          ids[j - 1] = right;
+        } else {
+          if (j < i) {
+            ids[j] = right;
+          }
+          j++;
+        }
+      }
+      ids.length = ids[j - 1].len === 0 ? j - 1 : j;
+    }
+    return ids
+  }
+}
+
+/**
+ * @implements {traits.EqualityTrait}
+ */
+class IdSet {
+  constructor () {
+    /**
+     * @type {Map<number,IdRanges>}
+     */
+    this.clients = new Map();
+  }
+
+  isEmpty () {
+    return this.clients.size === 0
+  }
+
+  /**
+   * @param {(idrange:IdRange, client:number) => void} f
+   */
+  forEach (f) {
+    this.clients.forEach((ranges, client) => {
+      ranges.getIds().forEach((range) => {
+        f(range, client);
+      });
+    });
+  }
+
+  /**
+   * @param {ID} id
+   * @return {boolean}
+   */
+  hasId (id) {
+    return this.has(id.client, id.clock)
+  }
+
+  /**
+   * @param {number} client
+   * @param {number} clock
+   */
+  has (client, clock) {
+    const dr = this.clients.get(client);
+    if (dr) {
+      return findIndexInIdRanges(dr.getIds(), clock) !== null
+    }
+    return false
+  }
+
+  /**
+   * Return slices of ids that exist in this idset.
+   *
+   * @param {number} client
+   * @param {number} clock
+   * @param {number} len
+   * @return {Array<MaybeIdRange>}
+   */
+  slice (client, clock, len) {
+    const dr = this.clients.get(client);
+    /**
+     * @type {Array<MaybeIdRange>}
+     */
+    const res = [];
+    if (dr) {
+      /**
+       * @type {Array<IdRange>}
+       */
+      const ranges = dr.getIds();
+      let index = findRangeStartInIdRanges(ranges, clock);
+      if (index !== null) {
+        let prev = null;
+        while (index < ranges.length) {
+          let r = ranges[index];
+          if (r.clock < clock) {
+            r = new IdRange(clock, r.len - (clock - r.clock));
+          }
+          if (r.clock + r.len > clock + len) {
+            r = new IdRange(r.clock, clock + len - r.clock);
+          }
+          if (r.len <= 0) break
+          const prevEnd = prev != null ? prev.clock + prev.len : clock;
+          if (prevEnd < r.clock) {
+            res.push(createMaybeIdRange(prevEnd, r.clock - prevEnd, false));
+          }
+          prev = r;
+          res.push(createMaybeIdRange(r.clock, r.len, true));
+          index++;
+        }
+      }
+    }
+    if (res.length > 0) {
+      const last = res[res.length - 1];
+      const end = last.clock + last.len;
+      if (end < clock + len) {
+        res.push(createMaybeIdRange(end, clock + len - end, false));
+      }
+    } else {
+      res.push(createMaybeIdRange(clock, len, false));
+    }
+    return res
+  }
+
+  /**
+   * @param {number} client
+   * @param {number} clock
+   * @param {number} len
+   */
+  add (client, clock, len) {
+    addToIdSet(this, client, clock, len);
+  }
+
+  /**
+   * @param {number} client
+   * @param {number} clock
+   * @param {number} len
+   */
+  delete (client, clock, len) {
+    _deleteRangeFromIdSet(this, client, clock, len);
+  }
+
+  /**
+   * @param {any} other
+   */
+  [traits.EqualityTraitSymbol] (other) {
+    return equalIdSets(this, other)
+  }
+}
+
+/**
+ * @param {IdSet | IdMap<any>} set
+ * @param {number} client
+ * @param {number} clock
+ * @param {number} len
+ */
+const _deleteRangeFromIdSet = (set, client, clock, len) => {
+  const dr = set.clients.get(client);
+  if (dr && len > 0) {
+    const ids = dr.getIds();
+    let index = findRangeStartInIdRanges(ids, clock);
+    if (index != null) {
+      for (let r = ids[index]; index < ids.length && r.clock < clock + len; r = ids[++index]) {
+        if (r.clock < clock) {
+          ids[index] = r.copyWith(r.clock, clock - r.clock);
+          if (clock + len < r.clock + r.len) {
+            ids.splice(index + 1, 0, r.copyWith(clock + len, r.clock + r.len - clock - len));
+          }
+        } else if (clock + len < r.clock + r.len) {
+          // need to retain end
+          ids[index] = r.copyWith(clock + len, r.clock + r.len - clock - len);
+        } else if (ids.length === 1) {
+          set.clients.delete(client);
+          return
+        } else {
+          ids.splice(index--, 1);
+        }
+      }
+    }
+  }
+};
+
+/**
+ * Iterate over all structs that are mentioned by the IdSet.
+ *
+ * @param {Transaction} transaction
+ * @param {IdSet} ds
+ * @param {function(GC|Item):void} f
+ *
+ * @function
+ */
+const iterateStructsByIdSet = (transaction, ds, f) =>
+  ds.clients.forEach((idRanges, clientid) => {
+    const ranges = idRanges.getIds();
+    const structs = /** @type {Array<GC|Item>} */ (transaction.doc.store.clients.get(clientid));
+    if (structs != null) {
+      for (let i = 0; i < ranges.length; i++) {
+        const del = ranges[i];
+        iterateStructs(transaction, structs, del.clock, del.len, f);
+      }
+    }
+  });
+
+/**
+ * @param {Array<IdRange>} dis
+ * @param {number} clock
+ * @return {number|null}
+ *
+ * @private
+ * @function
+ */
+const findIndexInIdRanges = (dis, clock) => {
+  let left = 0;
+  let right = dis.length - 1;
+  while (left <= right) {
+    const midindex = math.floor((left + right) / 2);
+    const mid = dis[midindex];
+    const midclock = mid.clock;
+    if (midclock <= clock) {
+      if (clock < midclock + mid.len) {
+        return midindex
+      }
+      left = midindex + 1;
+    } else {
+      right = midindex - 1;
+    }
+  }
+  return null
+};
+
+/**
+ * Find the first range that contains clock or comes after clock.
+ *
+ * @param {Array<IdRange>} dis
+ * @param {number} clock
+ * @return {number|null}
+ *
+ * @private
+ * @function
+ */
+const findRangeStartInIdRanges = (dis, clock) => {
+  let left = 0;
+  let right = dis.length - 1;
+  while (left <= right) {
+    const midindex = math.floor((left + right) / 2);
+    const mid = dis[midindex];
+    const midclock = mid.clock;
+    if (midclock <= clock) {
+      if (clock < midclock + mid.len) {
+        return midindex
+      }
+      left = midindex + 1;
+    } else {
+      right = midindex - 1;
+    }
+  }
+  return left < dis.length ? left : null
+};
+
+/**
+ * @param {Array<IdSet>} idSets
+ * @return {IdSet} A fresh IdSet
+ */
+const mergeIdSets = idSets => {
+  const merged = new IdSet();
+  for (let dssI = 0; dssI < idSets.length; dssI++) {
+    idSets[dssI].clients.forEach((rangesLeft, client) => {
+      if (!merged.clients.has(client)) {
+        // Write all missing keys from current ds and all following.
+        // If merged already contains `client` current ds has already been added.
+        const ids = rangesLeft.getIds().slice();
+        for (let i = dssI + 1; i < idSets.length; i++) {
+          const nextIds = idSets[i].clients.get(client);
+          if (nextIds) {
+            array.appendTo(ids, nextIds.getIds());
+          }
+        }
+        merged.clients.set(client, new IdRanges(ids));
+      }
+    });
+  }
+  return merged
+};
+
+/**
+ * @template {IdSet | IdMap<any>} S
+ * @param {S} dest
+ * @param {S} src
+ */
+const _insertIntoIdSet = (dest, src) => {
+  src.clients.forEach((srcRanges, client) => {
+    const targetRanges = dest.clients.get(client);
+    if (targetRanges) {
+      array.appendTo(targetRanges.getIds(), srcRanges.getIds());
+      targetRanges.sorted = false;
+    } else {
+      const res = srcRanges.copy();
+      res.sorted = true;
+      dest.clients.set(client, /** @type {any} */ (res));
+    }
+  });
+};
+
+/**
+ * @param {IdSet} dest
+ * @param {IdSet} src
+ */
+const insertIntoIdSet = _insertIntoIdSet;
+
+/**
+ * Remove all ranges from `exclude` from `ds`. The result is a fresh IdSet containing all ranges from `idSet` that are not
+ * in `exclude`.
+ *
+ * @template {IdSet | IdMap<any>} Set
+ * @param {Set} set
+ * @param {IdSet | IdMap<any>} exclude
+ * @return {Set}
+ */
+const _diffSet = (set, exclude) => {
+  /**
+   * @type {Set}
+   */
+  const res = /** @type {any } */ (set instanceof IdSet ? new IdSet() : new IdMap());
+  const Ranges = set instanceof IdSet ? IdRanges : AttrRanges;
+  set.clients.forEach((_setRanges, client) => {
+    /**
+     * @type {Array<IdRange>}
+     */
+    let resRanges = [];
+    const _excludedRanges = exclude.clients.get(client);
+    const setRanges = _setRanges.getIds();
+    if (_excludedRanges == null) {
+      resRanges = setRanges.slice();
+    } else {
+      const excludedRanges = _excludedRanges.getIds();
+      let i = 0; let j = 0;
+      let currRange = setRanges[0];
+      while (i < setRanges.length && j < excludedRanges.length) {
+        const e = excludedRanges[j];
+        if (currRange.clock + currRange.len <= e.clock) { // no overlapping, use next range item
+          if (currRange.len > 0) resRanges.push(currRange);
+          currRange = setRanges[++i];
+        } else if (e.clock + e.len <= currRange.clock) { // no overlapping, use next excluded item
+          j++;
+        } else if (e.clock <= currRange.clock) { // exclude laps into range (we already know that the ranges somehow collide)
+          const newClock = e.clock + e.len;
+          const newLen = currRange.clock + currRange.len - newClock;
+          if (newLen > 0) {
+            currRange = currRange.copyWith(newClock, newLen);
+            j++;
+          } else {
+            // this item is completely overwritten. len=0. We can jump to the next range
+            currRange = setRanges[++i];
+          }
+        } else { // currRange.clock < e.clock -- range laps into exclude => adjust len
+          // beginning can't be empty, add it to the result
+          const nextLen = e.clock - currRange.clock;
+          resRanges.push(currRange.copyWith(currRange.clock, nextLen));
+          // retain the remaining length after exclude in currRange
+          currRange = currRange.copyWith(currRange.clock + e.len + nextLen, math.max(currRange.len - e.len - nextLen, 0));
+          if (currRange.len === 0) currRange = setRanges[++i];
+          else j++;
+        }
+      }
+      if (currRange != null) {
+        resRanges.push(currRange);
+      }
+      i++;
+      while (i < setRanges.length) {
+        resRanges.push(setRanges[i++]);
+      }
+    }
+    // @ts-ignore
+    if (resRanges.length > 0) res.clients.set(client, /** @type {any} */ (new Ranges(resRanges)));
+  });
+  return res
+};
+
+/**
+ * Remove all ranges from `exclude` from `idSet`. The result is a fresh IdSet containing all ranges from `idSet` that are not
+ * in `exclude`.
+ *
+ * @type {(idSet: IdSet, exclude: IdSet|IdMap<any>) => IdSet}
+ */
+const diffIdSet = _diffSet;
+
+/**
+ * @template {IdSet | IdMap<any>} SetA
+ * @template {IdSet | IdMap<any>} SetB
+ * @param {SetA} setA
+ * @param {SetB} setB
+ * @return {SetA extends IdMap<infer A> ? (SetB extends IdMap<infer B> ? IdMap<A | B> : IdMap<A>) : IdSet}
+ */
+const _intersectSets = (setA, setB) => {
+  /**
+   * @type {IdMap<any> | IdSet}
+   */
+  const res = /** @type {any } */ (setA instanceof IdSet ? new IdSet() : new IdMap());
+  const Ranges = setA instanceof IdSet ? IdRanges : AttrRanges;
+  setA.clients.forEach((_aRanges, client) => {
+    /**
+     * @type {Array<IdRange>}
+     */
+    const resRanges = [];
+    const _bRanges = setB.clients.get(client);
+    const aRanges = _aRanges.getIds();
+    if (_bRanges != null) {
+      const bRanges = _bRanges.getIds();
+      for (let a = 0, b = 0; a < aRanges.length && b < bRanges.length;) {
+        const aRange = aRanges[a];
+        const bRange = bRanges[b];
+        // construct overlap
+        const clock = math.max(aRange.clock, bRange.clock);
+        const len = math.min(aRange.len - (clock - aRange.clock), bRange.len - (clock - bRange.clock));
+        if (len > 0) {
+          resRanges.push(aRange instanceof AttrRange
+            ? new AttrRange(clock, len, /** @type {Array<AttributionItem<any>>} */ (aRange.attrs).concat(bRange.attrs))
+            : new IdRange(clock, len)
+          );
+        }
+        if (aRange.clock + aRange.len < bRange.clock + bRange.len) {
+          a++;
+        } else {
+          b++;
+        }
+      }
+    }
+    // @ts-ignore
+    if (resRanges.length > 0) res.clients.set(client, /** @type {any} */ (new Ranges(resRanges)));
+  });
+  return /** @type {any} */ (res)
+};
+
+const intersectSets = _intersectSets;
+
+/**
+ * @param {IdSet} idSet
+ * @param {number} client
+ * @param {number} clock
+ * @param {number} length
+ *
+ * @private
+ * @function
+ */
+const addToIdSet = (idSet, client, clock, length) => {
+  if (length === 0) return
+  const idRanges = idSet.clients.get(client);
+  if (idRanges) {
+    idRanges.add(clock, length);
+  } else {
+    idSet.clients.set(client, new IdRanges([new IdRange(clock, length)]));
+  }
+};
+
+/**
+ * @param {IdSet} idSet
+ * @param {AbstractStruct} struct
+ *
+ * @private
+ * @function
+ */
+const addStructToIdSet = (idSet, struct) => addToIdSet(idSet, struct.id.client, struct.id.clock, struct.length);
+
+const createIdSet = () => new IdSet();
+
+/**
+ * @param {StructStore} ss
+ * @return {IdSet}
+ *
+ * @private
+ * @function
+ */
+const createDeleteSetFromStructStore = ss => {
+  const ds = createIdSet();
+  ss.clients.forEach((structs, client) => {
+    /**
+     * @type {Array<IdRange>}
+     */
+    const dsitems = [];
+    for (let i = 0; i < structs.length; i++) {
+      const struct = structs[i];
+      if (struct.deleted) {
+        const clock = struct.id.clock;
+        let len = struct.length;
+        if (i + 1 < structs.length) {
+          for (let next = structs[i + 1]; i + 1 < structs.length && next.deleted; next = structs[++i + 1]) {
+            len += next.length;
+          }
+        }
+        dsitems.push(new IdRange(clock, len));
+      }
+    }
+    if (dsitems.length > 0) {
+      ds.clients.set(client, new IdRanges(dsitems));
+    }
+  });
+  return ds
+};
+
+/**
+ * @param {Array<GC | Item>} structs
+ * @param {boolean} filterDeleted
+ *
+ */
+const _createInsertSliceFromStructs = (structs, filterDeleted) => {
+  /**
+   * @type {Array<IdRange>}
+   */
+  const iditems = [];
+  for (let i = 0; i < structs.length; i++) {
+    const struct = structs[i];
+    if (!(filterDeleted && struct.deleted)) {
+      const clock = struct.id.clock;
+      let len = struct.length;
+      if (i + 1 < structs.length) {
+        // eslint-disable-next-line
+        for (let next = structs[i + 1]; i + 1 < structs.length && !(filterDeleted && next.deleted); next = structs[++i + 1]) {
+          len += next.length;
+        }
+      }
+      iditems.push(new IdRange(clock, len));
+    }
+  }
+  return iditems
+};
+
+/**
+ * @param {import('../internals.js').StructStore} ss
+ * @param {boolean} filterDeleted
+ */
+const createInsertSetFromStructStore = (ss, filterDeleted) => {
+  const idset = createIdSet();
+  ss.clients.forEach((structs, client) => {
+    const iditems = _createInsertSliceFromStructs(structs, filterDeleted);
+    if (iditems.length !== 0) {
+      idset.clients.set(client, new IdRanges(iditems));
+    }
+  });
+  return idset
+};
+
+/**
+ * @param {IdSetEncoderV1 | IdSetEncoderV2} encoder
+ * @param {IdSet} idSet
+ *
+ * @private
+ * @function
+ */
+const writeIdSet = (encoder, idSet) => {
+  encoding.writeVarUint(encoder.restEncoder, idSet.clients.size);
+  // Ensure that the delete set is written in a deterministic order
+  array.from(idSet.clients.entries())
+    .sort((a, b) => b[0] - a[0])
+    .forEach(([client, _idRanges]) => {
+      const idRanges = _idRanges.getIds();
+      encoder.resetIdSetCurVal();
+      encoding.writeVarUint(encoder.restEncoder, client);
+      const len = idRanges.length;
+      encoding.writeVarUint(encoder.restEncoder, len);
+      for (let i = 0; i < len; i++) {
+        const item = idRanges[i];
+        encoder.writeIdSetClock(item.clock);
+        encoder.writeIdSetLen(item.len);
+      }
+    });
+};
+
+/**
+ * @param {DSDecoderV1 | DSDecoderV2} decoder
+ * @return {IdSet}
+ *
+ * @private
+ * @function
+ */
+const readIdSet = decoder => {
+  const ds = new IdSet();
+  const numClients = decoding.readVarUint(decoder.restDecoder);
+  for (let i = 0; i < numClients; i++) {
+    decoder.resetDsCurVal();
+    const client = decoding.readVarUint(decoder.restDecoder);
+    const numberOfDeletes = decoding.readVarUint(decoder.restDecoder);
+    if (numberOfDeletes > 0) {
+      /**
+       * @type {Array<IdRange>}
+       */
+      const dsRanges = [];
+      for (let i = 0; i < numberOfDeletes; i++) {
+        dsRanges.push(new IdRange(decoder.readDsClock(), decoder.readDsLen()));
+      }
+      ds.clients.set(client, new IdRanges(dsRanges));
+    }
+  }
+  return ds
+};
+
+/**
+ * @todo YDecoder also contains references to String and other Decoders. Would make sense to exchange YDecoder.toUint8Array for YDecoder.DsToUint8Array()..
+ */
+
+/**
+ * @param {DSDecoderV1 | DSDecoderV2} decoder
+ * @param {Transaction} transaction
+ * @param {StructStore} store
+ * @return {Uint8Array<ArrayBuffer>|null} Returns a v2 update containing all deletes that couldn't be applied yet; or null if all deletes were applied successfully.
+ *
+ * @private
+ * @function
+ */
+const readAndApplyDeleteSet = (decoder, transaction, store) => {
+  const unappliedDS = new IdSet();
+  const numClients = decoding.readVarUint(decoder.restDecoder);
+  for (let i = 0; i < numClients; i++) {
+    decoder.resetDsCurVal();
+    const client = decoding.readVarUint(decoder.restDecoder);
+    const numberOfDeletes = decoding.readVarUint(decoder.restDecoder);
+    const structs = store.clients.get(client) || [];
+    const state = getState(store, client);
+    for (let i = 0; i < numberOfDeletes; i++) {
+      const clock = decoder.readDsClock();
+      const clockEnd = clock + decoder.readDsLen();
+      if (clock < state) {
+        if (state < clockEnd) {
+          addToIdSet(unappliedDS, client, state, clockEnd - state);
+        }
+        let index = findIndexSS(structs, clock);
+        /**
+         * We can ignore the case of GC and Delete structs, because we are going to skip them
+         * @type {Item | GC | Skip}
+         */
+        let struct = structs[index];
+        // split the first item if necessary
+        if (!struct.deleted && struct.id.clock < clock && struct instanceof Item) {
+          // increment index, we now want to use the next struct
+          structs.splice(++index, 0, splitItem(transaction, struct, clock - struct.id.clock));
+        }
+        while (index < structs.length) {
+          // @ts-ignore
+          struct = structs[index++];
+          if (struct.id.clock < clockEnd) {
+            if (!struct.deleted) {
+              if (struct instanceof Item) {
+                if (clockEnd < struct.id.clock + struct.length) {
+                  structs.splice(index, 0, splitItem(transaction, struct, clockEnd - struct.id.clock));
+                }
+                struct.delete(transaction);
+              } else { // is a Skip - add range to unappliedDS
+                const c = math.max(struct.id.clock, clock);
+                unappliedDS.add(client, c, math.min(struct.length, clockEnd - c));
+              }
+            }
+          } else {
+            break
+          }
+        }
+      } else {
+        addToIdSet(unappliedDS, client, clock, clockEnd - clock);
+      }
+    }
+  }
+  if (unappliedDS.clients.size > 0) {
+    const ds = new UpdateEncoderV2();
+    encoding.writeVarUint(ds.restEncoder, 0); // encode 0 structs
+    writeIdSet(ds, unappliedDS);
+    return ds.toUint8Array()
+  }
+  return null
+};
+
+/**
+ * @param {IdSet} ds1
+ * @param {IdSet} ds2
+ */
+const equalIdSets = (ds1, ds2) => {
+  if (ds1.clients.size !== ds2.clients.size) return false
+  for (const [client, _deleteItems1] of ds1.clients.entries()) {
+    const deleteItems1 = _deleteItems1.getIds();
+    const deleteItems2 = ds2.clients.get(client)?.getIds();
+    if (deleteItems2 === undefined || deleteItems1.length !== deleteItems2.length) return false
+    for (let i = 0; i < deleteItems1.length; i++) {
+      const di1 = deleteItems1[i];
+      const di2 = deleteItems2[i];
+      if (di1.clock !== di2.clock || di1.len !== di2.len) {
+        return false
+      }
+    }
+  }
+  return true
+};
+
+/**
+ * @module Y
+ */
+
+
+const generateNewClientId = random.uint32;
+
+/**
+ * @typedef {import('../utils/types.js').YTypeConstructors} YTypeConstructors
+ */
+/**
+ * @typedef {import('../utils/types.js').YType} YType
+ */
+
+/**
+ * @typedef {Object} DocOpts
+ * @property {boolean} [DocOpts.gc=true] Disable garbage collection (default: gc=true)
+ * @property {function(Item):boolean} [DocOpts.gcFilter] Will be called before an Item is garbage collected. Return false to keep the Item.
+ * @property {string} [DocOpts.guid] Define a globally unique identifier for this document
+ * @property {string | null} [DocOpts.collectionid] Associate this document with a collection. This only plays a role if your provider has a concept of collection.
+ * @property {any} [DocOpts.meta] Any kind of meta information you want to associate with this document. If this is a subdocument, remote peers will store the meta information as well.
+ * @property {boolean} [DocOpts.autoLoad] If a subdocument, automatically load document. If this is a subdocument, remote peers will load the document as well automatically.
+ * @property {boolean} [DocOpts.shouldLoad] Whether the document should be synced by the provider now. This is toggled to true when you call ydoc.load()
+ * @property {boolean} [DocOpts.isSuggestionDoc] Set to true if this document merely suggests
+ * changes. If this flag is not set in a suggestion document, automatic formatting changes will be
+ * displayed as suggestions, which might not be intended.
+ */
+
+/**
+ * @typedef {Object} DocEvents
+ * @property {function(Doc):void} DocEvents.destroy
+ * @property {function(Doc):void} DocEvents.load
+ * @property {function(boolean, Doc):void} DocEvents.sync
+ * @property {function(Uint8Array<ArrayBuffer>, any, Doc, Transaction):void} DocEvents.update
+ * @property {function(Uint8Array<ArrayBuffer>, any, Doc, Transaction):void} DocEvents.updateV2
+ * @property {function(Doc):void} DocEvents.beforeAllTransactions
+ * @property {function(Transaction, Doc):void} DocEvents.beforeTransaction
+ * @property {function(Transaction, Doc):void} DocEvents.beforeObserverCalls
+ * @property {function(Transaction, Doc):void} DocEvents.afterTransaction
+ * @property {function(Transaction, Doc):void} DocEvents.afterTransactionCleanup
+ * @property {function(Doc, Array<Transaction>):void} DocEvents.afterAllTransactions
+ * @property {function({ loaded: Set<Doc>, added: Set<Doc>, removed: Set<Doc> }, Doc, Transaction):void} DocEvents.subdocs
+ */
+
+/**
+ * A Yjs instance handles the state of shared data.
+ * @extends ObservableV2<DocEvents>
+ */
+class Doc extends ObservableV2 {
+  /**
+   * @param {DocOpts} opts configuration
+   */
+  constructor ({ guid = random.uuidv4(), collectionid = null, gc = true, gcFilter = () => true, meta = null, autoLoad = false, shouldLoad = true, isSuggestionDoc = false } = {}) {
+    super();
+    this.gc = gc;
+    this.gcFilter = gcFilter;
+    this.clientID = generateNewClientId();
+    this.guid = guid;
+    this.collectionid = collectionid;
+    this.isSuggestionDoc = isSuggestionDoc;
+    this.cleanupFormatting = !isSuggestionDoc;
+    /**
+     * @type {Map<string, YType>}
+     */
+    this.share = new Map();
+    this.store = new StructStore();
+    /**
+     * @type {Transaction | null}
+     */
+    this._transaction = null;
+    /**
+     * @type {Array<Transaction>}
+     */
+    this._transactionCleanups = [];
+    /**
+     * @type {Set<Doc>}
+     */
+    this.subdocs = new Set();
+    /**
+     * If this document is a subdocument - a document integrated into another document - then _item is defined.
+     * @type {Item?}
+     */
+    this._item = null;
+    this.shouldLoad = shouldLoad;
+    this.autoLoad = autoLoad;
+    this.meta = meta;
+    /**
+     * This is set to true when the persistence provider loaded the document from the database or when the `sync` event fires.
+     * Note that not all providers implement this feature. Provider authors are encouraged to fire the `load` event when the doc content is loaded from the database.
+     *
+     * @type {boolean}
+     */
+    this.isLoaded = false;
+    /**
+     * This is set to true when the connection provider has successfully synced with a backend.
+     * Note that when using peer-to-peer providers this event may not provide very useful.
+     * Also note that not all providers implement this feature. Provider authors are encouraged to fire
+     * the `sync` event when the doc has been synced (with `true` as a parameter) or if connection is
+     * lost (with false as a parameter).
+     */
+    this.isSynced = false;
+    this.isDestroyed = false;
+    /**
+     * Promise that resolves once the document has been loaded from a persistence provider.
+     */
+    this.whenLoaded = promise.create(resolve => {
+      this.on('load', () => {
+        this.isLoaded = true;
+        resolve(this);
+      });
+    });
+    const provideSyncedPromise = () => promise.create(resolve => {
+      /**
+       * @param {boolean} isSynced
+       */
+      const eventHandler = (isSynced) => {
+        if (isSynced === undefined || isSynced === true) {
+          this.off('sync', eventHandler);
+          resolve();
+        }
+      };
+      this.on('sync', eventHandler);
+    });
+    this.on('sync', isSynced => {
+      if (isSynced === false && this.isSynced) {
+        this.whenSynced = provideSyncedPromise();
+      }
+      this.isSynced = isSynced === undefined || isSynced === true;
+      if (this.isSynced && !this.isLoaded) {
+        this.emit('load', [this]);
+      }
+    });
+    /**
+     * Promise that resolves once the document has been synced with a backend.
+     * This promise is recreated when the connection is lost.
+     * Note the documentation about the `isSynced` property.
+     */
+    this.whenSynced = provideSyncedPromise();
+  }
+
+  /**
+   * Notify the parent document that you request to load data into this subdocument (if it is a subdocument).
+   *
+   * `load()` might be used in the future to request any provider to load the most current data.
+   *
+   * It is safe to call `load()` multiple times.
+   */
+  load () {
+    const item = this._item;
+    if (item !== null && !this.shouldLoad) {
+      transact(/** @type {any} */ (item.parent).doc, transaction => {
+        transaction.subdocsLoaded.add(this);
+      }, null, true);
+    }
+    this.shouldLoad = true;
+  }
+
+  getSubdocs () {
+    return this.subdocs
+  }
+
+  getSubdocGuids () {
+    return new Set(array.from(this.subdocs).map(doc => doc.guid))
+  }
+
+  /**
+   * Changes that happen inside of a transaction are bundled. This means that
+   * the observer fires _after_ the transaction is finished and that all changes
+   * that happened inside of the transaction are sent as one message to the
+   * other peers.
+   *
+   * @template T
+   * @param {function(Transaction):T} f The function that should be executed as a transaction
+   * @param {any} [origin] Origin of who started the transaction. Will be stored on transaction.origin
+   * @return T
+   *
+   * @public
+   */
+  transact (f, origin = null) {
+    return transact(this, f, origin)
+  }
+
+  /**
+   * Define a shared data type.
+   *
+   * Multiple calls of `ydoc.get(name, TypeConstructor)` yield the same result
+   * and do not overwrite each other. I.e.
+   * `ydoc.get(name, Y.Array) === ydoc.get(name, Y.Array)`
+   *
+   * After this method is called, the type is also available on `ydoc.share.get(name)`.
+   *
+   * *Best Practices:*
+   * Define all types right after the Y.Doc instance is created and store them in a separate object.
+   * Also use the typed methods `getText(name)`, `getArray(name)`, ..
+   *
+   * @template {YTypeConstructors} [TypeC=typeof AbstractType]
+   * @example
+   *   const ydoc = new Y.Doc(..)
+   *   const appState = {
+   *     document: ydoc.getText('document')
+   *     comments: ydoc.getArray('comments')
+   *   }
+   *
+   * @param {string} name
+   * @param {TypeC} TypeConstructor The constructor of the type definition. E.g. Y.Text, Y.Array, Y.Map, ...
+   * @return {AbstractType} The created type. Constructed with TypeConstructor
+   *
+   * @public
+   */
+  get (name, TypeConstructor = /** @type {any} */ (AbstractType)) {
+    const type = map.setIfUndefined(this.share, name, () => {
+      // @ts-ignore
+      const t = new TypeConstructor();
+      t._integrate(this, null);
+      return t
+    });
+    const Constr = type.constructor;
+    // @ts-ignore
+    if (TypeConstructor !== AbstractType && Constr !== TypeConstructor) {
+      if (Constr === AbstractType) {
+        // @ts-ignore
+        const t = new TypeConstructor();
+        t._map = type._map;
+        type._map.forEach(/** @param {Item?} n */ n => {
+          for (; n !== null; n = n.left) {
+            // @ts-ignore
+            n.parent = t;
+          }
+        });
+        t._start = type._start;
+        for (let n = t._start; n !== null; n = n.right) {
+          n.parent = t;
+        }
+        t._length = type._length;
+        this.share.set(name, t);
+        t._integrate(this, null);
+        return /** @type {InstanceType<TypeC>} */ (t)
+      } else {
+        throw new Error(`Type with the name ${name} has already been defined with a different constructor`)
+      }
+    }
+    return /** @type {InstanceType<TypeC>} */ (type)
+  }
+
+  /**
+   * @template T
+   * @param {string} [name]
+   * @return {YArray<T>}
+   *
+   * @public
+   */
+  getArray (name = '') {
+    return /** @type {YArray<any>} */ (this.get(name, YArray))
+  }
+
+  /**
+   * @param {string} [name]
+   * @return {YText}
+   *
+   * @public
+   */
+  getText (name = '') {
+    return /** @type {YText} */ (this.get(name, YText))
+  }
+
+  /**
+   * @template T
+   * @param {string} [name]
+   * @return {YMap<T>}
+   *
+   * @public
+   */
+  getMap (name = '') {
+    return /** @type {YMap<T>} */ (this.get(name, YMap))
+  }
+
+  /**
+   * @param {string} [name]
+   * @return {YXmlElement}
+   *
+   * @public
+   */
+  getXmlElement (name = '') {
+    return /** @type {YXmlElement<{[key:string]:string}>} */ (this.get(name, YXmlElement))
+  }
+
+  /**
+   * @param {string} [name]
+   * @return {YXmlFragment}
+   *
+   * @public
+   */
+  getXmlFragment (name = '') {
+    return /** @type {YXmlFragment} */ (this.get(name, YXmlFragment))
+  }
+
+  /**
+   * Converts the entire document into a js object, recursively traversing each yjs type
+   * Doesn't log types that have not been defined (using ydoc.getType(..)).
+   *
+   * @deprecated Do not use this method and rather call toJSON directly on the shared types.
+   *
+   * @return {Object<string, any>}
+   */
+  toJSON () {
+    /**
+     * @type {Object<string, any>}
+     */
+    const doc = {};
+
+    this.share.forEach((value, key) => {
+      doc[key] = value.toJSON();
+    });
+
+    return doc
+  }
+
+  /**
+   * Emit `destroy` event and unregister all event handlers.
+   */
+  destroy () {
+    this.isDestroyed = true;
+    array.from(this.subdocs).forEach(subdoc => subdoc.destroy());
+    const item = this._item;
+    if (item !== null) {
+      this._item = null;
+      const content = /** @type {ContentDoc} */ (item.content);
+      content.doc = new Doc({ guid: this.guid, ...content.opts, shouldLoad: false });
+      content.doc._item = item;
+      transact(/** @type {any} */ (item).parent.doc, transaction => {
+        const doc = content.doc;
+        if (!item.deleted) {
+          transaction.subdocsAdded.add(doc);
+        }
+        transaction.subdocsRemoved.add(this);
+      }, null, true);
+    }
+    // @ts-ignore
+    this.emit('destroyed', [true]); // DEPRECATED!
+    this.emit('destroy', [this]);
+    super.destroy();
+  }
+}
+
+/**
+ * @param {Doc} ydoc
+ * @param {DocOpts} [opts]
+ */
+const cloneDoc = (ydoc, opts) => {
+  const clone = new Doc(opts);
+  applyUpdate(clone, encodeStateAsUpdate(ydoc));
+  return clone
+};
+
+class DSDecoderV1 {
+  /**
+   * @param {decoding.Decoder} decoder
+   */
+  constructor (decoder) {
+    this.restDecoder = decoder;
+  }
+
+  resetDsCurVal () {
+    // nop
+  }
+
+  /**
+   * @return {number}
+   */
+  readDsClock () {
+    return decoding.readVarUint(this.restDecoder)
+  }
+
+  /**
+   * @return {number}
+   */
+  readDsLen () {
+    return decoding.readVarUint(this.restDecoder)
+  }
+}
+
+class UpdateDecoderV1 extends DSDecoderV1 {
+  /**
+   * @return {ID}
+   */
+  readLeftID () {
+    return createID(decoding.readVarUint(this.restDecoder), decoding.readVarUint(this.restDecoder))
+  }
+
+  /**
+   * @return {ID}
+   */
+  readRightID () {
+    return createID(decoding.readVarUint(this.restDecoder), decoding.readVarUint(this.restDecoder))
+  }
+
+  /**
+   * Read the next client id.
+   * Use this in favor of readID whenever possible to reduce the number of objects created.
+   */
+  readClient () {
+    return decoding.readVarUint(this.restDecoder)
+  }
+
+  /**
+   * @return {number} info An unsigned 8-bit integer
+   */
+  readInfo () {
+    return decoding.readUint8(this.restDecoder)
+  }
+
+  /**
+   * @return {string}
+   */
+  readString () {
+    return decoding.readVarString(this.restDecoder)
+  }
+
+  /**
+   * @return {boolean} isKey
+   */
+  readParentInfo () {
+    return decoding.readVarUint(this.restDecoder) === 1
+  }
+
+  /**
+   * @return {number} info An unsigned 8-bit integer
+   */
+  readTypeRef () {
+    return decoding.readVarUint(this.restDecoder)
+  }
+
+  /**
+   * Write len of a struct - well suited for Opt RLE encoder.
+   *
+   * @return {number} len
+   */
+  readLen () {
+    return decoding.readVarUint(this.restDecoder)
+  }
+
+  /**
+   * @return {any}
+   */
+  readAny () {
+    return decoding.readAny(this.restDecoder)
+  }
+
+  /**
+   * @return {Uint8Array}
+   */
+  readBuf () {
+    return buffer.copyUint8Array(decoding.readVarUint8Array(this.restDecoder))
+  }
+
+  /**
+   * Legacy implementation uses JSON parse. We use any-decoding in v2.
+   *
+   * @return {any}
+   */
+  readJSON () {
+    return JSON.parse(decoding.readVarString(this.restDecoder))
+  }
+
+  /**
+   * @return {string}
+   */
+  readKey () {
+    return decoding.readVarString(this.restDecoder)
+  }
+}
+
+class DSDecoderV2 {
+  /**
+   * @param {decoding.Decoder} decoder
+   */
+  constructor (decoder) {
+    /**
+     * @private
+     */
+    this.dsCurrVal = 0;
+    this.restDecoder = decoder;
+  }
+
+  resetDsCurVal () {
+    this.dsCurrVal = 0;
+  }
+
+  /**
+   * @return {number}
+   */
+  readDsClock () {
+    this.dsCurrVal += decoding.readVarUint(this.restDecoder);
+    return this.dsCurrVal
+  }
+
+  /**
+   * @return {number}
+   */
+  readDsLen () {
+    const diff = decoding.readVarUint(this.restDecoder) + 1;
+    this.dsCurrVal += diff;
+    return diff
+  }
+}
+
+class UpdateDecoderV2 extends DSDecoderV2 {
+  /**
+   * @param {decoding.Decoder} decoder
+   */
+  constructor (decoder) {
+    super(decoder);
+    /**
+     * List of cached keys. If the keys[id] does not exist, we read a new key
+     * from stringEncoder and push it to keys.
+     *
+     * @type {Array<string>}
+     */
+    this.keys = [];
+    decoding.readVarUint(decoder); // read feature flag - currently unused
+    this.keyClockDecoder = new decoding.IntDiffOptRleDecoder(decoding.readVarUint8Array(decoder));
+    this.clientDecoder = new decoding.UintOptRleDecoder(decoding.readVarUint8Array(decoder));
+    this.leftClockDecoder = new decoding.IntDiffOptRleDecoder(decoding.readVarUint8Array(decoder));
+    this.rightClockDecoder = new decoding.IntDiffOptRleDecoder(decoding.readVarUint8Array(decoder));
+    this.infoDecoder = new decoding.RleDecoder(decoding.readVarUint8Array(decoder), decoding.readUint8);
+    this.stringDecoder = new decoding.StringDecoder(decoding.readVarUint8Array(decoder));
+    this.parentInfoDecoder = new decoding.RleDecoder(decoding.readVarUint8Array(decoder), decoding.readUint8);
+    this.typeRefDecoder = new decoding.UintOptRleDecoder(decoding.readVarUint8Array(decoder));
+    this.lenDecoder = new decoding.UintOptRleDecoder(decoding.readVarUint8Array(decoder));
+  }
+
+  /**
+   * @return {ID}
+   */
+  readLeftID () {
+    return new ID(this.clientDecoder.read(), this.leftClockDecoder.read())
+  }
+
+  /**
+   * @return {ID}
+   */
+  readRightID () {
+    return new ID(this.clientDecoder.read(), this.rightClockDecoder.read())
+  }
+
+  /**
+   * Read the next client id.
+   * Use this in favor of readID whenever possible to reduce the number of objects created.
+   */
+  readClient () {
+    return this.clientDecoder.read()
+  }
+
+  /**
+   * @return {number} info An unsigned 8-bit integer
+   */
+  readInfo () {
+    return /** @type {number} */ (this.infoDecoder.read())
+  }
+
+  /**
+   * @return {string}
+   */
+  readString () {
+    return this.stringDecoder.read()
+  }
+
+  /**
+   * @return {boolean}
+   */
+  readParentInfo () {
+    return this.parentInfoDecoder.read() === 1
+  }
+
+  /**
+   * @return {number} An unsigned 8-bit integer
+   */
+  readTypeRef () {
+    return this.typeRefDecoder.read()
+  }
+
+  /**
+   * Write len of a struct - well suited for Opt RLE encoder.
+   *
+   * @return {number}
+   */
+  readLen () {
+    return this.lenDecoder.read()
+  }
+
+  /**
+   * @return {any}
+   */
+  readAny () {
+    return decoding.readAny(this.restDecoder)
+  }
+
+  /**
+   * @return {Uint8Array}
+   */
+  readBuf () {
+    return decoding.readVarUint8Array(this.restDecoder)
+  }
+
+  /**
+   * This is mainly here for legacy purposes.
+   *
+   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.
+   *
+   * @return {any}
+   */
+  readJSON () {
+    return decoding.readAny(this.restDecoder)
+  }
+
+  /**
+   * @return {string}
+   */
+  readKey () {
+    const keyClock = this.keyClockDecoder.read();
+    if (keyClock < this.keys.length) {
+      return this.keys[keyClock]
+    } else {
+      const key = this.stringDecoder.read();
+      this.keys.push(key);
+      return key
+    }
+  }
+}
+
+class IdSetEncoderV1 {
+  constructor () {
+    this.restEncoder = encoding.createEncoder();
+  }
+
+  toUint8Array () {
+    return encoding.toUint8Array(this.restEncoder)
+  }
+
+  resetIdSetCurVal () {
+    // nop
+  }
+
+  /**
+   * @param {number} clock
+   */
+  writeIdSetClock (clock) {
+    encoding.writeVarUint(this.restEncoder, clock);
+  }
+
+  /**
+   * @param {number} len
+   */
+  writeIdSetLen (len) {
+    encoding.writeVarUint(this.restEncoder, len);
+  }
+}
+
+class UpdateEncoderV1 extends IdSetEncoderV1 {
+  /**
+   * @param {ID} id
+   */
+  writeLeftID (id) {
+    encoding.writeVarUint(this.restEncoder, id.client);
+    encoding.writeVarUint(this.restEncoder, id.clock);
+  }
+
+  /**
+   * @param {ID} id
+   */
+  writeRightID (id) {
+    encoding.writeVarUint(this.restEncoder, id.client);
+    encoding.writeVarUint(this.restEncoder, id.clock);
+  }
+
+  /**
+   * Use writeClient and writeClock instead of writeID if possible.
+   * @param {number} client
+   */
+  writeClient (client) {
+    encoding.writeVarUint(this.restEncoder, client);
+  }
+
+  /**
+   * @param {number} info An unsigned 8-bit integer
+   */
+  writeInfo (info) {
+    encoding.writeUint8(this.restEncoder, info);
+  }
+
+  /**
+   * @param {string} s
+   */
+  writeString (s) {
+    encoding.writeVarString(this.restEncoder, s);
+  }
+
+  /**
+   * @param {boolean} isYKey
+   */
+  writeParentInfo (isYKey) {
+    encoding.writeVarUint(this.restEncoder, isYKey ? 1 : 0);
+  }
+
+  /**
+   * @param {number} info An unsigned 8-bit integer
+   */
+  writeTypeRef (info) {
+    encoding.writeVarUint(this.restEncoder, info);
+  }
+
+  /**
+   * Write len of a struct - well suited for Opt RLE encoder.
+   *
+   * @param {number} len
+   */
+  writeLen (len) {
+    encoding.writeVarUint(this.restEncoder, len);
+  }
+
+  /**
+   * @param {any} any
+   */
+  writeAny (any) {
+    encoding.writeAny(this.restEncoder, any);
+  }
+
+  /**
+   * @param {Uint8Array} buf
+   */
+  writeBuf (buf) {
+    encoding.writeVarUint8Array(this.restEncoder, buf);
+  }
+
+  /**
+   * @param {any} embed
+   */
+  writeJSON (embed) {
+    encoding.writeVarString(this.restEncoder, JSON.stringify(embed));
+  }
+
+  /**
+   * @param {string} key
+   */
+  writeKey (key) {
+    encoding.writeVarString(this.restEncoder, key);
+  }
+}
+
+class IdSetEncoderV2 {
+  constructor () {
+    this.restEncoder = encoding.createEncoder(); // encodes all the rest / non-optimized
+    this.dsCurrVal = 0;
+  }
+
+  toUint8Array () {
+    return encoding.toUint8Array(this.restEncoder)
+  }
+
+  resetIdSetCurVal () {
+    this.dsCurrVal = 0;
+  }
+
+  /**
+   * @param {number} clock
+   */
+  writeIdSetClock (clock) {
+    const diff = clock - this.dsCurrVal;
+    this.dsCurrVal = clock;
+    encoding.writeVarUint(this.restEncoder, diff);
+  }
+
+  /**
+   * @param {number} len
+   */
+  writeIdSetLen (len) {
+    if (len === 0) {
+      error.unexpectedCase();
+    }
+    encoding.writeVarUint(this.restEncoder, len - 1);
+    this.dsCurrVal += len;
+  }
+}
+
+class UpdateEncoderV2 extends IdSetEncoderV2 {
+  constructor () {
+    super();
+    /**
+     * @type {Map<string,number>}
+     */
+    this.keyMap = new Map();
+    /**
+     * Refers to the next unique key-identifier to me used.
+     * See writeKey method for more information.
+     *
+     * @type {number}
+     */
+    this.keyClock = 0;
+    this.keyClockEncoder = new encoding.IntDiffOptRleEncoder();
+    this.clientEncoder = new encoding.UintOptRleEncoder();
+    this.leftClockEncoder = new encoding.IntDiffOptRleEncoder();
+    this.rightClockEncoder = new encoding.IntDiffOptRleEncoder();
+    this.infoEncoder = new encoding.RleEncoder(encoding.writeUint8);
+    this.stringEncoder = new encoding.StringEncoder();
+    this.parentInfoEncoder = new encoding.RleEncoder(encoding.writeUint8);
+    this.typeRefEncoder = new encoding.UintOptRleEncoder();
+    this.lenEncoder = new encoding.UintOptRleEncoder();
+  }
+
+  toUint8Array () {
+    const encoder = encoding.createEncoder();
+    encoding.writeVarUint(encoder, 0); // this is a feature flag that we might use in the future
+    encoding.writeVarUint8Array(encoder, this.keyClockEncoder.toUint8Array());
+    encoding.writeVarUint8Array(encoder, this.clientEncoder.toUint8Array());
+    encoding.writeVarUint8Array(encoder, this.leftClockEncoder.toUint8Array());
+    encoding.writeVarUint8Array(encoder, this.rightClockEncoder.toUint8Array());
+    encoding.writeVarUint8Array(encoder, encoding.toUint8Array(this.infoEncoder));
+    encoding.writeVarUint8Array(encoder, this.stringEncoder.toUint8Array());
+    encoding.writeVarUint8Array(encoder, encoding.toUint8Array(this.parentInfoEncoder));
+    encoding.writeVarUint8Array(encoder, this.typeRefEncoder.toUint8Array());
+    encoding.writeVarUint8Array(encoder, this.lenEncoder.toUint8Array());
+    // @note The rest encoder is appended! (note the missing var)
+    encoding.writeUint8Array(encoder, encoding.toUint8Array(this.restEncoder));
+    return encoding.toUint8Array(encoder)
+  }
+
+  /**
+   * @param {ID} id
+   */
+  writeLeftID (id) {
+    this.clientEncoder.write(id.client);
+    this.leftClockEncoder.write(id.clock);
+  }
+
+  /**
+   * @param {ID} id
+   */
+  writeRightID (id) {
+    this.clientEncoder.write(id.client);
+    this.rightClockEncoder.write(id.clock);
+  }
+
+  /**
+   * @param {number} client
+   */
+  writeClient (client) {
+    this.clientEncoder.write(client);
+  }
+
+  /**
+   * @param {number} info An unsigned 8-bit integer
+   */
+  writeInfo (info) {
+    this.infoEncoder.write(info);
+  }
+
+  /**
+   * @param {string} s
+   */
+  writeString (s) {
+    this.stringEncoder.write(s);
+  }
+
+  /**
+   * @param {boolean} isYKey
+   */
+  writeParentInfo (isYKey) {
+    this.parentInfoEncoder.write(isYKey ? 1 : 0);
+  }
+
+  /**
+   * @param {number} info An unsigned 8-bit integer
+   */
+  writeTypeRef (info) {
+    this.typeRefEncoder.write(info);
+  }
+
+  /**
+   * Write len of a struct - well suited for Opt RLE encoder.
+   *
+   * @param {number} len
+   */
+  writeLen (len) {
+    this.lenEncoder.write(len);
+  }
+
+  /**
+   * @param {any} any
+   */
+  writeAny (any) {
+    encoding.writeAny(this.restEncoder, any);
+  }
+
+  /**
+   * @param {Uint8Array} buf
+   */
+  writeBuf (buf) {
+    encoding.writeVarUint8Array(this.restEncoder, buf);
+  }
+
+  /**
+   * This is mainly here for legacy purposes.
+   *
+   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.
+   *
+   * @param {any} embed
+   */
+  writeJSON (embed) {
+    encoding.writeAny(this.restEncoder, embed);
+  }
+
+  /**
+   * Property keys are often reused. For example, in y-prosemirror the key `bold` might
+   * occur very often. For a 3d application, the key `position` might occur very often.
+   *
+   * We cache these keys in a Map and refer to them via a unique number.
+   *
+   * @param {string} key
+   */
+  writeKey (key) {
+    const clock = this.keyMap.get(key);
+    if (clock === undefined) {
+      /**
+       * @todo uncomment to introduce this feature finally
+       *
+       * Background. The ContentFormat object was always encoded using writeKey, but the decoder used to use readString.
+       * Furthermore, I forgot to set the keyclock. So everything was working fine.
+       *
+       * However, this feature here is basically useless as it is not being used (it actually only consumes extra memory).
+       *
+       * I don't know yet how to reintroduce this feature..
+       *
+       * Older clients won't be able to read updates when we reintroduce this feature. So this should probably be done using a flag.
+       *
+       */
+      // this.keyMap.set(key, this.keyClock)
+      this.keyClockEncoder.write(this.keyClock++);
+      this.stringEncoder.write(key);
+    } else {
+      this.keyClockEncoder.write(clock);
+    }
+  }
+}
+
+/**
+ * @module encoding
+ */
+/*
+ * We use the first five bits in the info flag for determining the type of the struct.
+ *
+ * 0: GC
+ * 1: Item with Deleted content
+ * 2: Item with JSON content
+ * 3: Item with Binary content
+ * 4: Item with String content
+ * 5: Item with Embed content (for richtext content)
+ * 6: Item with Format content (a formatting marker for richtext content)
+ * 7: Item with Type
+ */
+
+
+/**
+ * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
+ * @param {Array<GC|Item>} structs All structs by `client`
+ * @param {number} client
+ * @param {Array<IdRange>} idranges
+ *
+ * @function
+ */
+const writeStructs = (encoder, structs, client, idranges) => {
+  let structsToWrite = 0; // this accounts for the skips
+  /**
+   * @type {Array<{ start: number, end: number, startClock: number, endClock: number }>}
+   */
+  const indexRanges = [];
+  const firstPossibleClock = structs[0].id.clock;
+  const lastStruct = array.last(structs);
+  const lastPossibleClock = lastStruct.id.clock + lastStruct.length;
+  idranges.forEach(idrange => {
+    const startClock = math.max(idrange.clock, firstPossibleClock);
+    const endClock = math.min(idrange.clock + idrange.len, lastPossibleClock);
+    if (startClock >= endClock) return // structs for this range do not exist
+    // inclusive start
+    const start = findIndexSS(structs, startClock);
+    // exclusive end
+    const end = findIndexSS(structs, endClock - 1) + 1;
+    structsToWrite += end - start;
+    indexRanges.push({
+      start,
+      end,
+      startClock,
+      endClock
+    });
+  });
+  structsToWrite += idranges.length - 1;
+  // start writing with this clock. this is updated to the next clock that we expect to write
+  let clock = indexRanges[0].startClock;
+  // write # encoded structs
+  encoding.writeVarUint(encoder.restEncoder, structsToWrite);
+  encoder.writeClient(client);
+  // write clock
+  encoding.writeVarUint(encoder.restEncoder, clock);
+  indexRanges.forEach(indexRange => {
+    const skipLen = indexRange.startClock - clock;
+    if (skipLen > 0) {
+      new Skip(createID(client, clock), skipLen).write(encoder, 0);
+      clock += skipLen;
+    }
+    for (let i = indexRange.start; i < indexRange.end; i++) {
+      const struct = structs[i];
+      const structEnd = struct.id.clock + struct.length;
+      const offsetEnd = math.max(structEnd - indexRange.endClock, 0);
+      struct.write(encoder, clock - struct.id.clock, offsetEnd);
+      clock = structEnd - offsetEnd;
+    }
+  });
+};
+
+/**
+ * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
+ * @param {StructStore} store
+ * @param {Map<number,number>} _sm
+ *
+ * @private
+ * @function
+ */
+const writeClientsStructs = (encoder, store, _sm) => {
+  // we filter all valid _sm entries into sm
+  const sm = new Map();
+  _sm.forEach((clock, client) => {
+    // only write if new structs are available
+    if (getState(store, client) > clock) {
+      sm.set(client, clock);
+    }
+  });
+  getStateVector(store).forEach((_clock, client) => {
+    if (!_sm.has(client)) {
+      sm.set(client, 0);
+    }
+  });
+  // write # states that were updated
+  encoding.writeVarUint(encoder.restEncoder, sm.size);
+  // Write items with higher client ids first
+  // This heavily improves the conflict algorithm.
+  array.from(sm.entries()).sort((a, b) => b[0] - a[0]).forEach(([client, clock]) => {
+    const structs = /** @type {Array<GC|Item>} */ (store.clients.get(client));
+    const lastStruct = structs[structs.length - 1];
+    writeStructs(encoder, structs, client, [new IdRange(clock, lastStruct.id.clock + lastStruct.length - clock)]);
+  });
+};
+
+/**
+ * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
+ * @param {StructStore} store
+ * @param {IdSet} idset
+ *
+ * @todo at the moment this writes the full deleteset range
+ *
+ * @private
+ * @function
+ */
+const writeStructsFromIdSet = (encoder, store, idset) => {
+  // write # states that were updated
+  encoding.writeVarUint(encoder.restEncoder, idset.clients.size);
+  // Write items with higher client ids first
+  // This heavily improves the conflict algorithm.
+  array.from(idset.clients.entries()).sort((a, b) => b[0] - a[0]).forEach(([client, ids]) => {
+    const idRanges = ids.getIds();
+    const structs = /** @type {Array<GC|Item>} */ (store.clients.get(client));
+    writeStructs(encoder, structs, client, idRanges);
+  });
+};
+
+/**
+ * Resume computing structs generated by struct readers.
+ *
+ * While there is something to do, we integrate structs in this order
+ * 1. top element on stack, if stack is not empty
+ * 2. next element from current struct reader (if empty, use next struct reader)
+ *
+ * If struct causally depends on another struct (ref.missing), we put next reader of
+ * `ref.id.client` on top of stack.
+ *
+ * At some point we find a struct that has no causal dependencies,
+ * then we start emptying the stack.
+ *
+ * It is not possible to have circles: i.e. struct1 (from client1) depends on struct2 (from client2)
+ * depends on struct3 (from client1). Therefore the max stack size is equal to `structReaders.length`.
+ *
+ * This method is implemented in a way so that we can resume computation if this update
+ * causally depends on another update.
+ *
+ * @param {Transaction} transaction
+ * @param {StructStore} store
+ * @param {StructSet} clientsStructRefs
+ * @return { null | { update: Uint8Array<ArrayBuffer>, missing: Map<number,number> } }
+ *
+ * @private
+ * @function
+ */
+const integrateStructs = (transaction, store, clientsStructRefs) => {
+  /**
+   * @type {Array<Item | GC>}
+   */
+  const stack = [];
+  // sort them so that we take the higher id first, in case of conflicts the lower id will probably not conflict with the id from the higher user.
+  let clientsStructRefsIds = array.from(clientsStructRefs.clients.keys()).sort((a, b) => a - b);
+  if (clientsStructRefsIds.length === 0) {
+    return null
+  }
+  const getNextStructTarget = () => {
+    if (clientsStructRefsIds.length === 0) {
+      return null
+    }
+    let nextStructsTarget = /** @type {{i:number,refs:Array<GC|Item>}} */ (clientsStructRefs.clients.get(clientsStructRefsIds[clientsStructRefsIds.length - 1]));
+    while (nextStructsTarget.refs.length === nextStructsTarget.i) {
+      clientsStructRefsIds.pop();
+      if (clientsStructRefsIds.length > 0) {
+        nextStructsTarget = /** @type {{i:number,refs:Array<GC|Item>}} */ (clientsStructRefs.clients.get(clientsStructRefsIds[clientsStructRefsIds.length - 1]));
+      } else {
+        return null
+      }
+    }
+    return nextStructsTarget
+  };
+  let curStructsTarget = getNextStructTarget();
+  if (curStructsTarget === null) {
+    return null
+  }
+
+  /**
+   * @type {StructStore}
+   */
+  const restStructs = new StructStore();
+  const missingSV = new Map();
+  /**
+   * @param {number} client
+   * @param {number} clock
+   */
+  const updateMissingSv = (client, clock) => {
+    const mclock = missingSV.get(client);
+    if (mclock == null || mclock > clock) {
+      missingSV.set(client, clock);
+    }
+  };
+  /**
+   * @type {GC|Item}
+   */
+  let stackHead = /** @type {any} */ (curStructsTarget).refs[/** @type {any} */ (curStructsTarget).i++];
+  // caching the state because it is used very often
+  const state = new Map();
+
+  // // caching the state because it is used very often
+  // const currentInsertSet = createIdSet()
+  // clientsStructRefsIds.forEach(clientId => {
+  //   currentInsertSet.clients.set(clientid, new IdRanges(_createInsertSliceFromStructs(store.clients.get(clientId) ?? [], false)))
+  // })
+
+  const addStackToRestSS = () => {
+    for (const item of stack) {
+      const client = item.id.client;
+      const inapplicableItems = clientsStructRefs.clients.get(client);
+      if (inapplicableItems) {
+        // decrement because we weren't able to apply previous operation
+        inapplicableItems.i--;
+        restStructs.clients.set(client, inapplicableItems.refs.slice(inapplicableItems.i));
+        clientsStructRefs.clients.delete(client);
+        inapplicableItems.i = 0;
+        inapplicableItems.refs = [];
+      } else {
+        // item was the last item on clientsStructRefs and the field was already cleared. Add item to restStructs and continue
+        restStructs.clients.set(client, [item]);
+      }
+      // remove client from clientsStructRefsIds to prevent users from applying the same update again
+      clientsStructRefsIds = clientsStructRefsIds.filter(c => c !== client);
+    }
+    stack.length = 0;
+  };
+
+  // iterate over all struct readers until we are done
+  while (true) {
+    if (stackHead.constructor !== Skip) {
+      const localClock = map.setIfUndefined(state, stackHead.id.client, () => getState(store, stackHead.id.client));
+      const offset = localClock - stackHead.id.clock;
+      const missing = stackHead.getMissing(transaction, store);
+      if (missing !== null) {
+        stack.push(stackHead);
+        // get the struct reader that has the missing struct
+        /**
+         * @type {{ refs: Array<GC|Item>, i: number }}
+         */
+        const structRefs = clientsStructRefs.clients.get(/** @type {number} */ (missing)) || { refs: [], i: 0 };
+        if (structRefs.refs.length === structRefs.i || missing === stackHead.id.client || stack.some(s => s.id.client === missing)) { // @todo this could be optimized!
+          // This update message causally depends on another update message that doesn't exist yet
+          updateMissingSv(/** @type {number} */ (missing), getState(store, missing));
+          addStackToRestSS();
+        } else {
+          stackHead = structRefs.refs[structRefs.i++];
+          continue
+        }
+      } else {
+        // all fine, apply the stackhead
+        // but first add a skip to structs if necessary
+        if (offset < 0) {
+          const skip = new Skip(createID(stackHead.id.client, localClock), -offset);
+          skip.integrate(transaction, 0);
+        }
+        stackHead.integrate(transaction, 0);
+        state.set(stackHead.id.client, math.max(stackHead.id.clock + stackHead.length, localClock));
+      }
+    }
+    // iterate to next stackHead
+    if (stack.length > 0) {
+      stackHead = /** @type {GC|Item} */ (stack.pop());
+    } else if (curStructsTarget !== null && curStructsTarget.i < curStructsTarget.refs.length) {
+      stackHead = /** @type {GC|Item} */ (curStructsTarget.refs[curStructsTarget.i++]);
+    } else {
+      curStructsTarget = getNextStructTarget();
+      if (curStructsTarget === null) {
+        // we are done!
+        break
+      } else {
+        stackHead = /** @type {GC|Item} */ (curStructsTarget.refs[curStructsTarget.i++]);
+      }
+    }
+  }
+  if (restStructs.clients.size > 0) {
+    const encoder = new UpdateEncoderV2();
+    writeClientsStructs(encoder, restStructs, new Map());
+    // write empty deleteset
+    // writeDeleteSet(encoder, new DeleteSet())
+    encoding.writeVarUint(encoder.restEncoder, 0); // => no need for an extra function call, just write 0 deletes
+    return { missing: missingSV, update: encoder.toUint8Array() }
+  }
+  return null
+};
+
+/**
+ * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
+ * @param {Transaction} transaction
+ *
+ * @private
+ * @function
+ */
+const writeStructsFromTransaction = (encoder, transaction) => writeStructsFromIdSet(encoder, transaction.doc.store, transaction.insertSet);
+
+/**
+ * Read and apply a document update.
+ *
+ * This function has the same effect as `applyUpdate` but accepts a decoder.
+ *
+ * @param {decoding.Decoder} decoder
+ * @param {Doc} ydoc
+ * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`
+ * @param {UpdateDecoderV1 | UpdateDecoderV2} [structDecoder]
+ *
+ * @function
+ */
+const readUpdateV2 = (decoder, ydoc, transactionOrigin, structDecoder = new UpdateDecoderV2(decoder)) =>
+  transact(ydoc, transaction => {
+    // force that transaction.local is set to non-local
+    transaction.local = false;
+    let retry = false;
+    const doc = transaction.doc;
+    const store = doc.store;
+    // let start = performance.now()
+    const ss = readStructSet(structDecoder, doc);
+    const knownState = createIdSet();
+    ss.clients.forEach((_, client) => {
+      const storeStructs = store.clients.get(client);
+      if (storeStructs) {
+        const last = storeStructs[storeStructs.length - 1];
+        knownState.add(client, 0, last.id.clock + last.length);
+        // remove known items from ss
+        store.skips.clients.get(client)?.getIds().forEach(idrange => {
+          knownState.delete(client, idrange.clock, idrange.len);
+        });
+      }
+    });
+    // remove known items from ss
+    removeRangesFromStructSet(ss, knownState);
+    // console.log('time to read structs: ', performance.now() - start) // @todo remove
+    // start = performance.now()
+    // console.log('time to merge: ', performance.now() - start) // @todo remove
+    // start = performance.now()
+    const restStructs = integrateStructs(transaction, store, ss);
+    const pending = store.pendingStructs;
+    if (pending) {
+      // check if we can apply something
+      for (const [client, clock] of pending.missing) {
+        if (ss.clients.has(client) || clock < getState(store, client)) {
+          retry = true;
+          break
+        }
+      }
+      if (restStructs) {
+        // merge restStructs into store.pending
+        for (const [client, clock] of restStructs.missing) {
+          const mclock = pending.missing.get(client);
+          if (mclock == null || mclock > clock) {
+            pending.missing.set(client, clock);
+          }
+        }
+        pending.update = mergeUpdatesV2([pending.update, restStructs.update]);
+      }
+    } else {
+      store.pendingStructs = restStructs;
+    }
+    // console.log('time to integrate: ', performance.now() - start) // @todo remove
+    // start = performance.now()
+    const dsRest = readAndApplyDeleteSet(structDecoder, transaction, store);
+    if (store.pendingDs) {
+      // @todo we could make a lower-bound state-vector check as we do above
+      const pendingDSUpdate = new UpdateDecoderV2(decoding.createDecoder(store.pendingDs));
+      decoding.readVarUint(pendingDSUpdate.restDecoder); // read 0 structs, because we only encode deletes in pendingdsupdate
+      const dsRest2 = readAndApplyDeleteSet(pendingDSUpdate, transaction, store);
+      if (dsRest && dsRest2) {
+        // case 1: ds1 != null && ds2 != null
+        store.pendingDs = mergeUpdatesV2([dsRest, dsRest2]);
+      } else {
+        // case 2: ds1 != null
+        // case 3: ds2 != null
+        // case 4: ds1 == null && ds2 == null
+        store.pendingDs = dsRest || dsRest2;
+      }
+    } else {
+      // Either dsRest == null && pendingDs == null OR dsRest != null
+      store.pendingDs = dsRest;
+    }
+    // console.log('time to cleanup: ', performance.now() - start) // @todo remove
+    // start = performance.now()
+
+    // console.log('time to resume delete readers: ', performance.now() - start) // @todo remove
+    // start = performance.now()
+    if (retry) {
+      const update = /** @type {{update: Uint8Array}} */ (store.pendingStructs).update;
+      store.pendingStructs = null;
+      applyUpdateV2(transaction.doc, update);
+    }
+  }, transactionOrigin, false);
+
+/**
+ * Read and apply a document update.
+ *
+ * This function has the same effect as `applyUpdate` but accepts a decoder.
+ *
+ * @param {decoding.Decoder} decoder
+ * @param {Doc} ydoc
+ * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`
+ *
+ * @function
+ */
+const readUpdate = (decoder, ydoc, transactionOrigin) => readUpdateV2(decoder, ydoc, transactionOrigin, new UpdateDecoderV1(decoder));
+
+/**
+ * Apply a document update created by, for example, `y.on('update', update => ..)` or `update = encodeStateAsUpdate()`.
+ *
+ * This function has the same effect as `readUpdate` but accepts an Uint8Array instead of a Decoder.
+ *
+ * @param {Doc} ydoc
+ * @param {Uint8Array} update
+ * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`
+ * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} [YDecoder]
+ *
+ * @function
+ */
+const applyUpdateV2 = (ydoc, update, transactionOrigin, YDecoder = UpdateDecoderV2) => {
+  const decoder = decoding.createDecoder(update);
+  readUpdateV2(decoder, ydoc, transactionOrigin, new YDecoder(decoder));
+};
+
+/**
+ * Apply a document update created by, for example, `y.on('update', update => ..)` or `update = encodeStateAsUpdate()`.
+ *
+ * This function has the same effect as `readUpdate` but accepts an Uint8Array instead of a Decoder.
+ *
+ * @param {Doc} ydoc
+ * @param {Uint8Array} update
+ * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`
+ *
+ * @function
+ */
+const applyUpdate = (ydoc, update, transactionOrigin) => applyUpdateV2(ydoc, update, transactionOrigin, UpdateDecoderV1);
+
+/**
+ * Write all the document as a single update message. If you specify the state of the remote client (`targetStateVector`) it will
+ * only write the operations that are missing.
+ *
+ * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
+ * @param {Doc} doc
+ * @param {Map<number,number>} [targetStateVector] The state of the target that receives the update. Leave empty to write all known structs
+ *
+ * @function
+ */
+const writeStateAsUpdate = (encoder, doc, targetStateVector = new Map()) => {
+  writeClientsStructs(encoder, doc.store, targetStateVector);
+  writeIdSet(encoder, doc.store.ds);
+};
+
+/**
+ * Write all the document as a single update message that can be applied on the remote document. If you specify the state of the remote client (`targetState`) it will
+ * only write the operations that are missing.
+ *
+ * Use `writeStateAsUpdate` instead if you are working with lib0/encoding.js#Encoder
+ *
+ * @param {Doc} doc
+ * @param {Uint8Array} [encodedTargetStateVector] The state of the target that receives the update. Leave empty to write all known structs
+ * @param {UpdateEncoderV1 | UpdateEncoderV2} [encoder]
+ * @return {Uint8Array<ArrayBuffer>}
+ *
+ * @function
+ */
+const encodeStateAsUpdateV2 = (doc, encodedTargetStateVector = new Uint8Array([0]), encoder = new UpdateEncoderV2()) => {
+  const targetStateVector = decodeStateVector(encodedTargetStateVector);
+  writeStateAsUpdate(encoder, doc, targetStateVector);
+  const updates = [encoder.toUint8Array()];
+  // also add the pending updates (if there are any)
+  if (doc.store.pendingDs) {
+    updates.push(doc.store.pendingDs);
+  }
+  if (doc.store.pendingStructs) {
+    updates.push(diffUpdateV2(doc.store.pendingStructs.update, encodedTargetStateVector));
+  }
+  if (updates.length > 1) {
+    if (encoder.constructor === UpdateEncoderV1) {
+      return mergeUpdates(updates.map((update, i) => i === 0 ? update : convertUpdateFormatV2ToV1(update)))
+    } else if (encoder.constructor === UpdateEncoderV2) {
+      return mergeUpdatesV2(updates)
+    }
+  }
+  return updates[0]
+};
+
+/**
+ * Write all the document as a single update message that can be applied on the remote document. If you specify the state of the remote client (`targetState`) it will
+ * only write the operations that are missing.
+ *
+ * Use `writeStateAsUpdate` instead if you are working with lib0/encoding.js#Encoder
+ *
+ * @param {Doc} doc
+ * @param {Uint8Array} [encodedTargetStateVector] The state of the target that receives the update. Leave empty to write all known structs
+ * @return {Uint8Array<ArrayBuffer>}
+ *
+ * @function
+ */
+const encodeStateAsUpdate = (doc, encodedTargetStateVector) => encodeStateAsUpdateV2(doc, encodedTargetStateVector, new UpdateEncoderV1());
+
+/**
+ * Read state vector from Decoder and return as Map
+ *
+ * @param {DSDecoderV1 | DSDecoderV2} decoder
+ * @return {Map<number,number>} Maps `client` to the number next expected `clock` from that client.
+ *
+ * @function
+ */
+const readStateVector = decoder => {
+  const ss = new Map();
+  const ssLength = decoding.readVarUint(decoder.restDecoder);
+  for (let i = 0; i < ssLength; i++) {
+    const client = decoding.readVarUint(decoder.restDecoder);
+    const clock = decoding.readVarUint(decoder.restDecoder);
+    ss.set(client, clock);
+  }
+  return ss
+};
+
+/**
+ * Read decodedState and return State as Map.
+ *
+ * @param {Uint8Array} decodedState
+ * @return {Map<number,number>} Maps `client` to the number next expected `clock` from that client.
+ *
+ * @function
+ */
+// export const decodeStateVectorV2 = decodedState => readStateVector(new DSDecoderV2(decoding.createDecoder(decodedState)))
+
+/**
+ * Read decodedState and return State as Map.
+ *
+ * @param {Uint8Array} decodedState
+ * @return {Map<number,number>} Maps `client` to the number next expected `clock` from that client.
+ *
+ * @function
+ */
+const decodeStateVector = decodedState => readStateVector(new DSDecoderV1(decoding.createDecoder(decodedState)));
+
+/**
+ * @param {IdSetEncoderV1 | IdSetEncoderV2} encoder
+ * @param {Map<number,number>} sv
+ * @function
+ */
+const writeStateVector = (encoder, sv) => {
+  encoding.writeVarUint(encoder.restEncoder, sv.size);
+  array.from(sv.entries()).sort((a, b) => b[0] - a[0]).forEach(([client, clock]) => {
+    encoding.writeVarUint(encoder.restEncoder, client); // @todo use a special client decoder that is based on mapping
+    encoding.writeVarUint(encoder.restEncoder, clock);
+  });
+  return encoder
+};
+
+/**
+ * @param {IdSetEncoderV1 | IdSetEncoderV2} encoder
+ * @param {Doc} doc
+ *
+ * @function
+ */
+const writeDocumentStateVector = (encoder, doc) => writeStateVector(encoder, getStateVector(doc.store));
+
+/**
+ * Encode State as Uint8Array.
+ *
+ * @param {Doc|Map<number,number>} doc
+ * @param {IdSetEncoderV1 | IdSetEncoderV2} [encoder]
+ * @return {Uint8Array}
+ *
+ * @function
+ */
+const encodeStateVectorV2 = (doc, encoder = new IdSetEncoderV2()) => {
+  if (doc instanceof Map) {
+    writeStateVector(encoder, doc);
+  } else {
+    writeDocumentStateVector(encoder, doc);
+  }
+  return encoder.toUint8Array()
+};
+
+/**
+ * Encode State as Uint8Array.
+ *
+ * @param {Doc|Map<number,number>} doc
+ * @return {Uint8Array}
+ *
+ * @function
+ */
+const encodeStateVector = doc => encodeStateVectorV2(doc, new IdSetEncoderV1());
+
+/**
+ * General event handler implementation.
+ *
+ * @template ARG0, ARG1
+ *
+ * @private
+ */
+class EventHandler {
+  constructor () {
+    /**
+     * @type {Array<function(ARG0, ARG1):void>}
+     */
+    this.l = [];
+  }
+}
+
+/**
+ * @template ARG0,ARG1
+ * @returns {EventHandler<ARG0,ARG1>}
+ *
+ * @private
+ * @function
+ */
+const createEventHandler = () => new EventHandler();
+
+/**
+ * Adds an event listener that is called when
+ * {@link EventHandler#callEventListeners} is called.
+ *
+ * @template ARG0,ARG1
+ * @param {EventHandler<ARG0,ARG1>} eventHandler
+ * @param {function(ARG0,ARG1):void} f The event handler.
+ *
+ * @private
+ * @function
+ */
+const addEventHandlerListener = (eventHandler, f) =>
+  eventHandler.l.push(f);
+
+/**
+ * Removes an event listener.
+ *
+ * @template ARG0,ARG1
+ * @param {EventHandler<ARG0,ARG1>} eventHandler
+ * @param {function(ARG0,ARG1):void} f The event handler that was added with
+ *                     {@link EventHandler#addEventListener}
+ *
+ * @private
+ * @function
+ */
+const removeEventHandlerListener = (eventHandler, f) => {
+  const l = eventHandler.l;
+  const len = l.length;
+  eventHandler.l = l.filter(g => f !== g);
+  if (len === eventHandler.l.length) {
+    console.error('[yjs] Tried to remove event handler that doesn\'t exist.');
+  }
+};
+
+/**
+ * Removes all event listeners.
+ * @template ARG0,ARG1
+ * @param {EventHandler<ARG0,ARG1>} eventHandler
+ *
+ * @private
+ * @function
+ */
+const removeAllEventHandlerListeners = eventHandler => {
+  eventHandler.l.length = 0;
+};
+
+/**
+ * Call all event listeners that were added via
+ * {@link EventHandler#addEventListener}.
+ *
+ * @template ARG0,ARG1
+ * @param {EventHandler<ARG0,ARG1>} eventHandler
+ * @param {ARG0} arg0
+ * @param {ARG1} arg1
+ *
+ * @private
+ * @function
+ */
+const callEventHandlerListeners = (eventHandler, arg0, arg1) =>
+  f.callAll(eventHandler.l, [arg0, arg1]);
+
+class ID {
+  /**
+   * @param {number} client client id
+   * @param {number} clock unique per client id, continuous number
+   */
+  constructor (client, clock) {
+    /**
+     * Client id
+     * @type {number}
+     */
+    this.client = client;
+    /**
+     * unique per client id, continuous number
+     * @type {number}
+     */
+    this.clock = clock;
+  }
+}
+
+/**
+ * @param {ID | null} a
+ * @param {ID | null} b
+ * @return {boolean}
+ *
+ * @function
+ */
+const compareIDs = (a, b) => a === b || (a !== null && b !== null && a.client === b.client && a.clock === b.clock);
+
+/**
+ * @param {number} client
+ * @param {number} clock
+ *
+ * @private
+ * @function
+ */
+const createID = (client, clock) => new ID(client, clock);
+
+/**
+ * @param {encoding.Encoder} encoder
+ * @param {ID} id
+ *
+ * @private
+ * @function
+ */
+const writeID = (encoder, id) => {
+  encoding.writeVarUint(encoder, id.client);
+  encoding.writeVarUint(encoder, id.clock);
+};
+
+/**
+ * Read ID.
+ * * If first varUint read is 0xFFFFFF a RootID is returned.
+ * * Otherwise an ID is returned
+ *
+ * @param {decoding.Decoder} decoder
+ * @return {ID}
+ *
+ * @private
+ * @function
+ */
+const readID = decoder =>
+  createID(decoding.readVarUint(decoder), decoding.readVarUint(decoder));
+
+/**
+ * The top types are mapped from y.share.get(keyname) => type.
+ * `type` does not store any information about the `keyname`.
+ * This function finds the correct `keyname` for `type` and throws otherwise.
+ *
+ * @param {AbstractType<any>} type
+ * @return {string}
+ *
+ * @private
+ * @function
+ */
+const findRootTypeKey = type => {
+  // @ts-ignore _y must be defined, otherwise unexpected case
+  for (const [key, value] of type.doc.share.entries()) {
+    if (value === type) {
+      return key
+    }
+  }
+  throw error.unexpectedCase()
+};
+
+/**
+ * Check if `parent` is a parent of `child`.
+ *
+ * @param {import('../utils/types.js').YType} parent
+ * @param {Item|null} child
+ * @return {Boolean} Whether `parent` is a parent of `child`.
+ *
+ * @private
+ * @function
+ */
+const isParentOf = (parent, child) => {
+  while (child !== null) {
+    if (child.parent === parent) {
+      return true
+    }
+    child = /** @type {AbstractType<any>} */ (child.parent)._item;
+  }
+  return false
+};
+
+/**
+ * Convenient helper to log type information.
+ *
+ * Do not use in productive systems as the output can be immense!
+ *
+ * @param {AbstractType<any>} type
+ */
+const logType = type => {
+  const res = [];
+  let n = type._start;
+  while (n) {
+    res.push(n);
+    n = n.right;
+  }
+  console.log('Children: ', res);
+  console.log('Children content: ', res.filter(m => !m.deleted).map(m => m.content));
+};
+
+/**
+ * A relative position is based on the Yjs model and is not affected by document changes.
+ * E.g. If you place a relative position before a certain character, it will always point to this character.
+ * If you place a relative position at the end of a type, it will always point to the end of the type.
+ *
+ * A numeric position is often unsuited for user selections, because it does not change when content is inserted
+ * before or after.
+ *
+ * ```Insert(0, 'x')('a|bc') = 'xa|bc'``` Where | is the relative position.
+ *
+ * One of the properties must be defined.
+ *
+ * @example
+ *   // Current cursor position is at position 10
+ *   const relativePosition = createRelativePositionFromIndex(yText, 10)
+ *   // modify yText
+ *   yText.insert(0, 'abc')
+ *   yText.delete(3, 10)
+ *   // Compute the cursor position
+ *   const absolutePosition = createAbsolutePositionFromRelativePosition(y, relativePosition)
+ *   absolutePosition.type === yText // => true
+ *   console.log('cursor location is ' + absolutePosition.index) // => cursor location is 3
+ *
+ */
+class RelativePosition {
+  /**
+   * @param {ID|null} type
+   * @param {string|null} tname
+   * @param {ID|null} item
+   * @param {number} assoc
+   */
+  constructor (type, tname, item, assoc = 0) {
+    /**
+     * @type {ID|null}
+     */
+    this.type = type;
+    /**
+     * @type {string|null}
+     */
+    this.tname = tname;
+    /**
+     * @type {ID | null}
+     */
+    this.item = item;
+    /**
+     * A relative position is associated to a specific character. By default
+     * assoc >= 0, the relative position is associated to the character
+     * after the meant position.
+     * I.e. position 1 in 'ab' is associated to character 'b'.
+     *
+     * If assoc < 0, then the relative position is associated to the character
+     * before the meant position.
+     *
+     * @type {number}
+     */
+    this.assoc = assoc;
+  }
+}
+
+/**
+ * @param {RelativePosition} rpos
+ * @return {any}
+ */
+const relativePositionToJSON = rpos => {
+  const json = {};
+  if (rpos.type) {
+    json.type = rpos.type;
+  }
+  if (rpos.tname) {
+    json.tname = rpos.tname;
+  }
+  if (rpos.item) {
+    json.item = rpos.item;
+  }
+  if (rpos.assoc != null) {
+    json.assoc = rpos.assoc;
+  }
+  return json
+};
+
+/**
+ * @param {any} json
+ * @return {RelativePosition}
+ *
+ * @function
+ */
+const createRelativePositionFromJSON = json => new RelativePosition(json.type == null ? null : createID(json.type.client, json.type.clock), json.tname ?? null, json.item == null ? null : createID(json.item.client, json.item.clock), json.assoc == null ? 0 : json.assoc);
+
+class AbsolutePosition {
+  /**
+   * @param {AbstractType<any>} type
+   * @param {number} index
+   * @param {number} [assoc]
+   */
+  constructor (type, index, assoc = 0) {
+    /**
+     * @type {AbstractType<any>}
+     */
+    this.type = type;
+    /**
+     * @type {number}
+     */
+    this.index = index;
+    this.assoc = assoc;
+  }
+}
+
+/**
+ * @param {AbstractType<any>} type
+ * @param {number} index
+ * @param {number} [assoc]
+ *
+ * @function
+ */
+const createAbsolutePosition = (type, index, assoc = 0) => new AbsolutePosition(type, index, assoc);
+
+/**
+ * @param {AbstractType<any>} type
+ * @param {ID|null} item
+ * @param {number} [assoc]
+ *
+ * @function
+ */
+const createRelativePosition = (type, item, assoc) => {
+  let typeid = null;
+  let tname = null;
+  if (type._item === null) {
+    tname = findRootTypeKey(type);
+  } else {
+    typeid = createID(type._item.id.client, type._item.id.clock);
+  }
+  return new RelativePosition(typeid, tname, item, assoc)
+};
+
+/**
+ * Create a relativePosition based on a absolute position.
+ *
+ * @param {AbstractType} type The base type (e.g. YText or YArray).
+ * @param {number} index The absolute position.
+ * @param {number} [assoc]
+ * @param {import('../utils/AttributionManager.js').AbstractAttributionManager} attributionManager
+ * @return {RelativePosition}
+ *
+ * @function
+ */
+const createRelativePositionFromTypeIndex = (type, index, assoc = 0, attributionManager = noAttributionsManager) => {
+  let t = type._start;
+  if (assoc < 0) {
+    // associated to the left character or the beginning of a type, increment index if possible.
+    if (index === 0) {
+      return createRelativePosition(type, null, assoc)
+    }
+    index--;
+  }
+  while (t !== null) {
+    const len = attributionManager.contentLength(t);
+    if (len > index) {
+      // case 1: found position somewhere in the linked list
+      return createRelativePosition(type, createID(t.id.client, t.id.clock + index), assoc)
+    }
+    index -= len;
+    if (t.right === null && assoc < 0) {
+      // left-associated position, return last available id
+      return createRelativePosition(type, t.lastId, assoc)
+    }
+    t = t.right;
+  }
+  return createRelativePosition(type, null, assoc)
+};
+
+/**
+ * @param {encoding.Encoder} encoder
+ * @param {RelativePosition} rpos
+ *
+ * @function
+ */
+const writeRelativePosition = (encoder, rpos) => {
+  const { type, tname, item, assoc } = rpos;
+  if (item !== null) {
+    encoding.writeVarUint(encoder, 0);
+    writeID(encoder, item);
+  } else if (tname !== null) {
+    // case 2: found position at the end of the list and type is stored in y.share
+    encoding.writeUint8(encoder, 1);
+    encoding.writeVarString(encoder, tname);
+  } else if (type !== null) {
+    // case 3: found position at the end of the list and type is attached to an item
+    encoding.writeUint8(encoder, 2);
+    writeID(encoder, type);
+  } else {
+    throw error.unexpectedCase()
+  }
+  encoding.writeVarInt(encoder, assoc);
+  return encoder
+};
+
+/**
+ * @param {RelativePosition} rpos
+ * @return {Uint8Array}
+ */
+const encodeRelativePosition = rpos => {
+  const encoder = encoding.createEncoder();
+  writeRelativePosition(encoder, rpos);
+  return encoding.toUint8Array(encoder)
+};
+
+/**
+ * @param {decoding.Decoder} decoder
+ * @return {RelativePosition}
+ *
+ * @function
+ */
+const readRelativePosition = decoder => {
+  let type = null;
+  let tname = null;
+  let itemID = null;
+  switch (decoding.readVarUint(decoder)) {
+    case 0:
+      // case 1: found position somewhere in the linked list
+      itemID = readID(decoder);
+      break
+    case 1:
+      // case 2: found position at the end of the list and type is stored in y.share
+      tname = decoding.readVarString(decoder);
+      break
+    case 2: {
+      // case 3: found position at the end of the list and type is attached to an item
+      type = readID(decoder);
+    }
+  }
+  const assoc = decoding.hasContent(decoder) ? decoding.readVarInt(decoder) : 0;
+  return new RelativePosition(type, tname, itemID, assoc)
+};
+
+/**
+ * @param {Uint8Array} uint8Array
+ * @return {RelativePosition}
+ */
+const decodeRelativePosition = uint8Array => readRelativePosition(decoding.createDecoder(uint8Array));
+
+/**
+ * @param {StructStore} store
+ * @param {ID} id
+ */
+const getItemWithOffset = (store, id) => {
+  const item = getItem(store, id);
+  const diff = id.clock - item.id.clock;
+  return {
+    item, diff
+  }
+};
+
+/**
+ * Transform a relative position to an absolute position.
+ *
+ * If you want to share the relative position with other users, you should set
+ * `followUndoneDeletions` to false to get consistent results across all clients.
+ *
+ * When calculating the absolute position, we try to follow the "undone deletions". This yields
+ * better results for the user who performed undo. However, only the user who performed the undo
+ * will get the better results, the other users don't know which operations recreated a deleted
+ * range of content. There is more information in this ticket: https://github.com/yjs/yjs/issues/638
+ *
+ * @param {RelativePosition} rpos
+ * @param {Doc} doc
+ * @param {boolean} followUndoneDeletions - whether to follow undone deletions - see https://github.com/yjs/yjs/issues/638
+ * @param {import('../utils/AttributionManager.js').AbstractAttributionManager} attributionManager
+ * @return {AbsolutePosition|null}
+ *
+ * @function
+ */
+const createAbsolutePositionFromRelativePosition = (rpos, doc, followUndoneDeletions = true, attributionManager = noAttributionsManager) => {
+  const store = doc.store;
+  const rightID = rpos.item;
+  const typeID = rpos.type;
+  const tname = rpos.tname;
+  const assoc = rpos.assoc;
+  let type = null;
+  let index = 0;
+  if (rightID !== null) {
+    if (getState(store, rightID.client) <= rightID.clock) {
+      return null
+    }
+    const res = followUndoneDeletions ? followRedone(store, rightID) : getItemWithOffset(store, rightID);
+    const right = res.item;
+    if (!(right instanceof Item)) {
+      return null
+    }
+    type = /** @type {AbstractType<any>} */ (right.parent);
+    if (type._item === null || !type._item.deleted) {
+      index = attributionManager.contentLength(right) === 0 ? 0 : (res.diff + (assoc >= 0 ? 0 : 1)); // adjust position based on left association if necessary
+      let n = right.left;
+      while (n !== null) {
+        index += attributionManager.contentLength(n);
+        n = n.left;
+      }
+    }
+  } else {
+    if (tname !== null) {
+      type = doc.get(tname);
+    } else if (typeID !== null) {
+      if (getState(store, typeID.client) <= typeID.clock) {
+        // type does not exist yet
+        return null
+      }
+      const { item } = followUndoneDeletions ? followRedone(store, typeID) : { item: getItem(store, typeID) };
+      if (item instanceof Item && item.content instanceof ContentType) {
+        type = item.content.type;
+      } else {
+        // struct is garbage collected
+        return null
+      }
+    } else {
+      throw error.unexpectedCase()
+    }
+    if (assoc >= 0) {
+      index = type._length;
+    } else {
+      index = 0;
+    }
+  }
+  return createAbsolutePosition(type, index, rpos.assoc)
+};
+
+/**
+ * @param {RelativePosition|null} a
+ * @param {RelativePosition|null} b
+ * @return {boolean}
+ *
+ * @function
+ */
+const compareRelativePositions = (a, b) => a === b || (
+  a !== null && b !== null && a.tname === b.tname && compareIDs(a.item, b.item) && compareIDs(a.type, b.type) && a.assoc === b.assoc
+);
+
+class Snapshot {
+  /**
+   * @param {IdSet} ds
+   * @param {Map<number,number>} sv state map
+   */
+  constructor (ds, sv) {
+    /**
+     * @type {IdSet}
+     */
+    this.ds = ds;
+    /**
+     * State Map
+     * @type {Map<number,number>}
+     */
+    this.sv = sv;
+  }
+}
+
+/**
+ * @param {Snapshot} snap1
+ * @param {Snapshot} snap2
+ * @return {boolean}
+ */
+const equalSnapshots = (snap1, snap2) => {
+  const sv1 = snap1.sv;
+  const sv2 = snap2.sv;
+  if (sv1.size !== sv2.size) {
+    return false
+  }
+  for (const [key, value] of sv1.entries()) {
+    if (sv2.get(key) !== value) {
+      return false
+    }
+  }
+  return equalIdSets(snap1.ds, snap2.ds)
+};
+
+/**
+ * @param {Snapshot} snapshot
+ * @param {IdSetEncoderV1 | IdSetEncoderV2} [encoder]
+ * @return {Uint8Array}
+ */
+const encodeSnapshotV2 = (snapshot, encoder = new IdSetEncoderV2()) => {
+  writeIdSet(encoder, snapshot.ds);
+  writeStateVector(encoder, snapshot.sv);
+  return encoder.toUint8Array()
+};
+
+/**
+ * @param {Snapshot} snapshot
+ * @return {Uint8Array}
+ */
+const encodeSnapshot = snapshot => encodeSnapshotV2(snapshot, new IdSetEncoderV1());
+
+/**
+ * @param {Uint8Array} buf
+ * @param {DSDecoderV1 | DSDecoderV2} [decoder]
+ * @return {Snapshot}
+ */
+const decodeSnapshotV2 = (buf, decoder = new DSDecoderV2(decoding.createDecoder(buf))) => {
+  return new Snapshot(readIdSet(decoder), readStateVector(decoder))
+};
+
+/**
+ * @param {Uint8Array} buf
+ * @return {Snapshot}
+ */
+const decodeSnapshot = buf => decodeSnapshotV2(buf, new DSDecoderV1(decoding.createDecoder(buf)));
+
+/**
+ * @param {IdSet} ds
+ * @param {Map<number,number>} sm
+ * @return {Snapshot}
+ */
+const createSnapshot = (ds, sm) => new Snapshot(ds, sm);
+
+const emptySnapshot = createSnapshot(createIdSet(), new Map());
+
+/**
+ * @param {Doc} doc
+ * @return {Snapshot}
+ */
+const snapshot = doc => createSnapshot(createDeleteSetFromStructStore(doc.store), getStateVector(doc.store));
+
+/**
+ * @param {Item} item
+ * @param {Snapshot|undefined} snapshot
+ *
+ * @protected
+ * @function
+ */
+const isVisible = (item, snapshot) => snapshot === undefined
+  ? !item.deleted
+  : snapshot.sv.has(item.id.client) && (snapshot.sv.get(item.id.client) || 0) > item.id.clock && !snapshot.ds.hasId(item.id);
+
+/**
+ * @param {Transaction} transaction
+ * @param {Snapshot} snapshot
+ */
+const splitSnapshotAffectedStructs = (transaction, snapshot) => {
+  const meta = map.setIfUndefined(transaction.meta, splitSnapshotAffectedStructs, set.create);
+  const store = transaction.doc.store;
+  // check if we already split for this snapshot
+  if (!meta.has(snapshot)) {
+    snapshot.sv.forEach((clock, client) => {
+      if (clock < getState(store, client)) {
+        getItemCleanStart(transaction, createID(client, clock));
+      }
+    });
+    iterateStructsByIdSet(transaction, snapshot.ds, _item => {});
+    meta.add(snapshot);
+  }
+};
+
+/**
+ * @example
+ *  const ydoc = new Y.Doc({ gc: false })
+ *  ydoc.getText().insert(0, 'world!')
+ *  const snapshot = Y.snapshot(ydoc)
+ *  ydoc.getText().insert(0, 'hello ')
+ *  const restored = Y.createDocFromSnapshot(ydoc, snapshot)
+ *  assert(restored.getText().toString() === 'world!')
+ *
+ * @param {Doc} originDoc
+ * @param {Snapshot} snapshot
+ * @param {Doc} [newDoc] Optionally, you may define the Yjs document that receives the data from originDoc
+ * @return {Doc}
+ */
+const createDocFromSnapshot = (originDoc, snapshot, newDoc = new Doc()) => {
+  if (originDoc.gc) {
+    // we should not try to restore a GC-ed document, because some of the restored items might have their content deleted
+    throw new Error('Garbage-collection must be disabled in `originDoc`!')
+  }
+  const { sv, ds } = snapshot;
+
+  const encoder = new UpdateEncoderV2();
+  originDoc.transact(transaction => {
+    let size = 0;
+    sv.forEach(clock => {
+      if (clock > 0) {
+        size++;
+      }
+    });
+    encoding.writeVarUint(encoder.restEncoder, size);
+    // splitting the structs before writing them to the encoder
+    for (const [client, clock] of sv) {
+      if (clock === 0) {
+        continue
+      }
+      if (clock < getState(originDoc.store, client)) {
+        getItemCleanStart(transaction, createID(client, clock));
+      }
+      const structs = originDoc.store.clients.get(client) || [];
+      const lastStructIndex = findIndexSS(structs, clock - 1);
+      // write # encoded structs
+      encoding.writeVarUint(encoder.restEncoder, lastStructIndex + 1);
+      encoder.writeClient(client);
+      // first clock written is 0
+      encoding.writeVarUint(encoder.restEncoder, 0);
+      for (let i = 0; i <= lastStructIndex; i++) {
+        structs[i].write(encoder, 0, 0);
+      }
+    }
+    writeIdSet(encoder, ds);
+  });
+
+  applyUpdateV2(newDoc, encoder.toUint8Array(), 'snapshot');
+  return newDoc
+};
+
+/**
+ * @param {Snapshot} snapshot
+ * @param {Uint8Array} update
+ * @param {typeof UpdateDecoderV2 | typeof UpdateDecoderV1} [YDecoder]
+ */
+const snapshotContainsUpdateV2 = (snapshot, update, YDecoder = UpdateDecoderV2) => {
+  const updateDecoder = new YDecoder(decoding.createDecoder(update));
+  const lazyDecoder = new LazyStructReader(updateDecoder, false);
+  for (let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()) {
+    if ((snapshot.sv.get(curr.id.client) || 0) < curr.id.clock + curr.length) {
+      return false
+    }
+  }
+  const mergedDS = mergeIdSets([snapshot.ds, readIdSet(updateDecoder)]);
+  return equalIdSets(snapshot.ds, mergedDS)
+};
+
+/**
+ * @param {Snapshot} snapshot
+ * @param {Uint8Array} update
+ */
+const snapshotContainsUpdate = (snapshot, update) => snapshotContainsUpdateV2(snapshot, update, UpdateDecoderV1);
+
+class StructStore {
+  constructor () {
+    /**
+     * @type {Map<number,Array<GC|Item>>}
+     */
+    this.clients = new Map();
+    // this.ds = new IdSet()
+    /**
+     * @type {null | { missing: Map<number, number>, update: Uint8Array<ArrayBuffer> }}
+     */
+    this.pendingStructs = null;
+    /**
+     * @type {null | Uint8Array<ArrayBuffer>}
+     */
+    this.pendingDs = null;
+    this.skips = createIdSet();
+  }
+
+  get ds () {
+    return createDeleteSetFromStructStore(this)
+  }
+}
+
+/**
+ * Return the states as a Map<client,clock>.
+ * Note that clock refers to the next expected clock id.
+ *
+ * @param {StructStore} store
+ * @return {Map<number,number>}
+ *
+ * @public
+ * @function
+ */
+const getStateVector = store => {
+  const sm = new Map();
+  store.clients.forEach((structs, client) => {
+    const struct = structs[structs.length - 1];
+    sm.set(client, struct.id.clock + struct.length);
+  });
+  store.skips.clients.forEach((range, client) => {
+    sm.set(client, range.getIds()[0].clock);
+  });
+  return sm
+};
+
+/**
+ * @param {StructStore} store
+ * @param {number} client
+ * @return {number}
+ *
+ * @public
+ * @function
+ */
+const getState = (store, client) => {
+  const structs = store.clients.get(client);
+  if (structs === undefined) {
+    return 0
+  }
+  const lastStruct = structs[structs.length - 1];
+  return lastStruct.id.clock + lastStruct.length
+};
+
+/**
+ * @param {StructStore} store
+ *
+ * @private
+ * @function
+ */
+const integrityCheck = store => {
+  store.clients.forEach(structs => {
+    for (let i = 1; i < structs.length; i++) {
+      const l = structs[i - 1];
+      const r = structs[i];
+      if (l.id.clock + l.length !== r.id.clock) {
+        throw new Error('StructStore failed integrity check')
+      }
+    }
+  });
+};
+
+/**
+ * @param {StructStore} store
+ * @param {GC|Item} struct
+ *
+ * @private
+ * @function
+ */
+const addStruct = (store, struct) => {
+  let structs = store.clients.get(struct.id.client);
+  if (structs === undefined) {
+    structs = [];
+    store.clients.set(struct.id.client, structs);
+  } else {
+    const lastStruct = structs[structs.length - 1];
+    if (lastStruct.id.clock + lastStruct.length !== struct.id.clock) {
+      // this replaces an integrated skip
+      let index = findIndexSS(structs, struct.id.clock);
+      const skip = structs[index];
+      const diffStart = struct.id.clock - skip.id.clock;
+      const diffEnd = skip.id.clock + skip.length - struct.id.clock - struct.length;
+      if (diffStart > 0) {
+        structs.splice(index++, 0, new Skip(createID(struct.id.client, skip.id.clock), diffStart));
+      }
+      if (diffEnd > 0) {
+        structs.splice(index + 1, 0, new Skip(createID(struct.id.client, struct.id.clock + struct.length), diffEnd));
+      }
+      structs[index] = struct;
+      store.skips.delete(struct.id.client, struct.id.clock, struct.length);
+      return
+    }
+  }
+  structs.push(struct);
+};
+
+/**
+ * Perform a binary search on a sorted array
+ * @param {Array<Item|GC>} structs
+ * @param {number} clock
+ * @return {number}
+ *
+ * @private
+ * @function
+ */
+const findIndexSS = (structs, clock) => {
+  let left = 0;
+  let right = structs.length - 1;
+  let mid = structs[right];
+  let midclock = mid.id.clock;
+  if (midclock === clock) {
+    return right
+  }
+  // @todo does it even make sense to pivot the search?
+  // If a good split misses, it might actually increase the time to find the correct item.
+  // Currently, the only advantage is that search with pivoting might find the item on the first try.
+  let midindex = math.floor((clock / (midclock + mid.length - 1)) * right); // pivoting the search
+  while (left <= right) {
+    mid = structs[midindex];
+    midclock = mid.id.clock;
+    if (midclock <= clock) {
+      if (clock < midclock + mid.length) {
+        return midindex
+      }
+      left = midindex + 1;
+    } else {
+      right = midindex - 1;
+    }
+    midindex = math.floor((left + right) / 2);
+  }
+  // Always check state before looking for a struct in StructStore
+  // Therefore the case of not finding a struct is unexpected
+  throw error.unexpectedCase()
+};
+
+/**
+ * Expects that id is actually in store. This function throws or is an infinite loop otherwise.
+ *
+ * @param {StructStore} store
+ * @param {ID} id
+ * @return {GC|Item}
+ *
+ * @private
+ * @function
+ */
+const find = (store, id) => {
+  /**
+   * @type {Array<GC|Item>}
+   */
+  // @ts-ignore
+  const structs = store.clients.get(id.client);
+  return structs[findIndexSS(structs, id.clock)]
+};
+
+/**
+ * Expects that id is actually in store. This function throws or is an infinite loop otherwise.
+ * @private
+ * @function
+ */
+const getItem = /** @type {function(StructStore,ID):Item} */ (find);
+
+/**
+ * @param {Transaction?} transaction
+ * @param {Array<Item|GC>} structs
+ * @param {number} clock
+ */
+const findIndexCleanStart = (transaction, structs, clock) => {
+  const index = findIndexSS(structs, clock);
+  const struct = structs[index];
+  if (struct.id.clock < clock) {
+    structs.splice(index + 1, 0, splitStruct(transaction, struct, clock - struct.id.clock));
+    return index + 1
+  }
+  return index
+};
+
+/**
+ * Expects that id is actually in store. This function throws or is an infinite loop otherwise.
+ *
+ * @param {Transaction} transaction
+ * @param {ID} id
+ * @return {Item}
+ *
+ * @private
+ * @function
+ */
+const getItemCleanStart = (transaction, id) => {
+  const structs = /** @type {Array<Item>} */ (transaction.doc.store.clients.get(id.client));
+  return structs[findIndexCleanStart(transaction, structs, id.clock)]
+};
+
+/**
+ * Expects that id is actually in store. This function throws or is an infinite loop otherwise.
+ *
+ * @param {Transaction} transaction
+ * @param {StructStore} store
+ * @param {ID} id
+ * @return {Item}
+ *
+ * @private
+ * @function
+ */
+const getItemCleanEnd = (transaction, store, id) => {
+  /**
+   * @type {Array<Item>}
+   */
+  // @ts-ignore
+  const structs = store.clients.get(id.client);
+  const index = findIndexSS(structs, id.clock);
+  const struct = structs[index];
+  if (id.clock !== struct.id.clock + struct.length - 1 && struct.constructor !== GC) {
+    structs.splice(index + 1, 0, splitItem(transaction, struct, id.clock - struct.id.clock + 1));
+  }
+  return struct
+};
+
+/**
+ * Replace `item` with `newitem` in store
+ * @param {Transaction} tr
+ * @param {GC|Item} struct
+ * @param {GC|Item} newStruct
+ *
+ * @private
+ * @function
+ */
+const replaceStruct = (tr, struct, newStruct) => {
+  const structs = /** @type {Array<GC|Item>} */ (tr.doc.store.clients.get(struct.id.client));
+  structs[findIndexSS(structs, struct.id.clock)] = newStruct;
+  tr._mergeStructs.push(newStruct);
+};
+
+/**
+ * Iterate over a range of structs
+ *
+ * @param {Transaction} transaction
+ * @param {Array<Item|GC>} structs
+ * @param {number} clockStart Inclusive start
+ * @param {number} len
+ * @param {function(GC|Item):void} f
+ *
+ * @function
+ */
+const iterateStructs = (transaction, structs, clockStart, len, f) => {
+  if (len === 0) {
+    return
+  }
+  const clockEnd = clockStart + len;
+  let index = findIndexCleanStart(transaction, structs, clockStart);
+  let struct;
+  do {
+    struct = structs[index++];
+    if (clockEnd < struct.id.clock + struct.length) {
+      findIndexCleanStart(transaction, structs, clockEnd);
+    }
+    f(struct);
+  } while (index < structs.length && structs[index].id.clock < clockEnd)
+};
+
+/**
+ * A transaction is created for every change on the Yjs model. It is possible
+ * to bundle changes on the Yjs model in a single transaction to
+ * minimize the number on messages sent and the number of observer calls.
+ * If possible the user of this library should bundle as many changes as
+ * possible. Here is an example to illustrate the advantages of bundling:
+ *
+ * @example
+ * const ydoc = new Y.Doc()
+ * const map = ydoc.getMap('map')
+ * // Log content when change is triggered
+ * map.observe(() => {
+ *   console.log('change triggered')
+ * })
+ * // Each change on the map type triggers a log message:
+ * map.set('a', 0) // => "change triggered"
+ * map.set('b', 0) // => "change triggered"
+ * // When put in a transaction, it will trigger the log after the transaction:
+ * ydoc.transact(() => {
+ *   map.set('a', 1)
+ *   map.set('b', 1)
+ * }) // => "change triggered"
+ *
+ * @public
+ */
+class Transaction {
+  /**
+   * @param {Doc} doc
+   * @param {any} origin
+   * @param {boolean} local
+   */
+  constructor (doc, origin, local) {
+    /**
+     * The Yjs instance.
+     * @type {Doc}
+     */
+    this.doc = doc;
+    /**
+     * Describes the set of deleted items by ids
+     */
+    this.deleteSet = createIdSet();
+    /**
+     * Describes the set of items that are cleaned up / deleted by ids. It is a subset of
+     * this.deleteSet
+     */
+    this.cleanUps = createIdSet();
+    /**
+     * Describes the set of inserted items by ids
+     */
+    this.insertSet = createIdSet();
+    /**
+     * Holds the state before the transaction started.
+     * @type {Map<Number,Number>?}
+     */
+    this._beforeState = null;
+    /**
+     * Holds the state after the transaction.
+     * @type {Map<Number,Number>?}
+     */
+    this._afterState = null;
+    /**
+     * All types that were directly modified (property added or child
+     * inserted/deleted). New types are not included in this Set.
+     * Maps from type to parentSubs (`item.parentSub = null` for YArray)
+     * @type {Map<import('../utils/types.js').YType,Set<String|null>>}
+     */
+    this.changed = new Map();
+    /**
+     * Stores the events for the types that observe also child elements.
+     * It is mainly used by `observeDeep`.
+     * @type {Map<import('../utils/types.js').YType,Array<YEvent<any>>>}
+     */
+    this.changedParentTypes = new Map();
+    /**
+     * @type {Array<AbstractStruct>}
+     */
+    this._mergeStructs = [];
+    /**
+     * @type {any}
+     */
+    this.origin = origin;
+    /**
+     * Stores meta information on the transaction
+     * @type {Map<any,any>}
+     */
+    this.meta = new Map();
+    /**
+     * Whether this change originates from this doc.
+     * @type {boolean}
+     */
+    this.local = local;
+    /**
+     * @type {Set<Doc>}
+     */
+    this.subdocsAdded = new Set();
+    /**
+     * @type {Set<Doc>}
+     */
+    this.subdocsRemoved = new Set();
+    /**
+     * @type {Set<Doc>}
+     */
+    this.subdocsLoaded = new Set();
+    /**
+     * @type {boolean}
+     */
+    this._needFormattingCleanup = false;
+    this._done = false;
+  }
+
+  /**
+   * Holds the state before the transaction started.
+   *
+   * @deprecated
+   * @type {Map<Number,Number>}
+   */
+  get beforeState () {
+    if (this._beforeState == null) {
+      const sv = getStateVector(this.doc.store);
+      this.insertSet.clients.forEach((ranges, client) => {
+        sv.set(client, ranges.getIds()[0].clock);
+      });
+      this._beforeState = sv;
+    }
+    return this._beforeState
+  }
+
+  /**
+   * Holds the state after the transaction.
+   *
+   * @deprecated
+   * @type {Map<Number,Number>}
+   */
+  get afterState () {
+    if (!this._done) error.unexpectedCase();
+    if (this._afterState == null) {
+      const sv = getStateVector(this.doc.store);
+      this.insertSet.clients.forEach((_ranges, client) => {
+        const ranges = _ranges.getIds();
+        const d = ranges[ranges.length - 1];
+        sv.set(client, d.clock + d.len);
+      });
+      this._afterState = sv;
+    }
+    return this._afterState
+  }
+}
+
+/**
+ * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
+ * @param {Transaction} transaction
+ * @return {boolean} Whether data was written.
+ */
+const writeUpdateMessageFromTransaction = (encoder, transaction) => {
+  if (transaction.deleteSet.clients.size === 0 && transaction.insertSet.clients.size === 0) {
+    return false
+  }
+  writeStructsFromTransaction(encoder, transaction);
+  writeIdSet(encoder, transaction.deleteSet);
+  return true
+};
+
+/**
+ * @param {Transaction} transaction
+ *
+ * @private
+ * @function
+ */
+const nextID = transaction => {
+  const y = transaction.doc;
+  return createID(y.clientID, getState(y.store, y.clientID))
+};
+
+/**
+ * If `type.parent` was added in current transaction, `type` technically
+ * did not change, it was just added and we should not fire events for `type`.
+ *
+ * @param {Transaction} transaction
+ * @param {import('../utils/types.js').YType} type
+ * @param {string|null} parentSub
+ */
+const addChangedTypeToTransaction = (transaction, type, parentSub) => {
+  const item = type._item;
+  if (item === null || (!item.deleted && !transaction.insertSet.hasId(item.id))) {
+    map.setIfUndefined(transaction.changed, type, set.create).add(parentSub);
+  }
+};
+
+/**
+ * @param {Array<AbstractStruct>} structs
+ * @param {number} pos
+ * @return {number} # of merged structs
+ */
+const tryToMergeWithLefts = (structs, pos) => {
+  let right = structs[pos];
+  let left = structs[pos - 1];
+  let i = pos;
+  for (; i > 0; right = left, left = structs[--i - 1]) {
+    if (left.deleted === right.deleted && left.constructor === right.constructor) {
+      if (left.mergeWith(right)) {
+        if (right instanceof Item && right.parentSub !== null && /** @type {AbstractType<any>} */ (right.parent)._map.get(right.parentSub) === right) {
+          /** @type {AbstractType<any>} */ (right.parent)._map.set(right.parentSub, /** @type {Item} */ (left));
+        }
+        continue
+      }
+    }
+    break
+  }
+  const merged = pos - i;
+  if (merged) {
+    // remove all merged structs from the array
+    structs.splice(pos + 1 - merged, merged);
+  }
+  return merged
+};
+
+/**
+ * @param {Transaction} tr
+ * @param {IdSet} ds
+ * @param {function(Item):boolean} gcFilter
+ */
+const tryGcDeleteSet = (tr, ds, gcFilter) => {
+  for (const [client, _deleteItems] of ds.clients.entries()) {
+    const deleteItems = _deleteItems.getIds();
+    const structs = /** @type {Array<GC|Item>} */ (tr.doc.store.clients.get(client));
+    for (let di = deleteItems.length - 1; di >= 0; di--) {
+      const deleteItem = deleteItems[di];
+      const endDeleteItemClock = deleteItem.clock + deleteItem.len;
+      for (
+        let si = findIndexSS(structs, deleteItem.clock), struct = structs[si];
+        si < structs.length && struct.id.clock < endDeleteItemClock;
+        struct = structs[++si]
+      ) {
+        const struct = structs[si];
+        if (deleteItem.clock + deleteItem.len <= struct.id.clock) {
+          break
+        }
+        if (struct instanceof Item && struct.deleted && !struct.keep && gcFilter(struct)) {
+          struct.gc(tr, false);
+        }
+      }
+    }
+  }
+};
+
+/**
+ * @param {IdSet} ds
+ * @param {StructStore} store
+ */
+const tryMerge = (ds, store) => {
+  // try to merge deleted / gc'd items
+  // merge from right to left for better efficiency and so we don't miss any merge targets
+  ds.clients.forEach((_deleteItems, client) => {
+    const deleteItems = _deleteItems.getIds();
+    const structs = /** @type {Array<GC|Item>} */ (store.clients.get(client));
+    for (let di = deleteItems.length - 1; di >= 0; di--) {
+      const deleteItem = deleteItems[di];
+      // start with merging the item next to the last deleted item
+      const mostRightIndexToCheck = math.min(structs.length - 1, 1 + findIndexSS(structs, deleteItem.clock + deleteItem.len - 1));
+      for (
+        let si = mostRightIndexToCheck, struct = structs[si];
+        si > 0 && struct.id.clock >= deleteItem.clock;
+        struct = structs[si]
+      ) {
+        si -= 1 + tryToMergeWithLefts(structs, si);
+      }
+    }
+  });
+};
+
+/**
+ * @param {Transaction} tr
+ * @param {IdSet} idset
+ * @param {function(Item):boolean} gcFilter
+ */
+const tryGc = (tr, idset, gcFilter) => {
+  tryGcDeleteSet(tr, idset, gcFilter);
+  tryMerge(idset, tr.doc.store);
+};
+
+/**
+ * @param {Array<Transaction>} transactionCleanups
+ * @param {number} i
+ */
+const cleanupTransactions = (transactionCleanups, i) => {
+  if (i < transactionCleanups.length) {
+    const transaction = transactionCleanups[i];
+    transaction._done = true;
+    const doc = transaction.doc;
+    const store = doc.store;
+    const ds = transaction.deleteSet;
+    const mergeStructs = transaction._mergeStructs;
+    // insertIntoIdSet(store.ds, ds)
+    try {
+      doc.emit('beforeObserverCalls', [transaction, doc]);
+      /**
+       * An array of event callbacks.
+       *
+       * Each callback is called even if the other ones throw errors.
+       *
+       * @type {Array<function():void>}
+       */
+      const fs = [];
+      // observe events on changed types
+      transaction.changed.forEach((subs, itemtype) =>
+        fs.push(() => {
+          if (itemtype._item === null || !itemtype._item.deleted) {
+            itemtype._callObserver(transaction, subs);
+          }
+        })
+      );
+      fs.push(() => {
+        // deep observe events
+        transaction.changedParentTypes.forEach((events, type) => {
+          // We need to think about the possibility that the user transforms the
+          // Y.Doc in the event.
+          if (type._dEH.l.length > 0 && (type._item === null || !type._item.deleted)) {
+            events = events
+              .filter(event =>
+                event.target._item === null || !event.target._item.deleted
+              );
+            events
+              .forEach(event => {
+                event.currentTarget = type;
+                // path is relative to the current target
+                event._path = null;
+              });
+            // sort events by path length so that top-level events are fired first.
+            events
+              .sort((event1, event2) => event1.path.length - event2.path.length);
+            // We don't need to check for events.length
+            // because we know it has at least one element
+            callEventHandlerListeners(type._dEH, events, transaction);
+          }
+        });
+      });
+      fs.push(() => doc.emit('afterTransaction', [transaction, doc]));
+      callAll(fs, []);
+      if (transaction._needFormattingCleanup && doc.cleanupFormatting) {
+        cleanupYTextAfterTransaction(transaction);
+      }
+    } finally {
+      // Replace deleted items with ItemDeleted / GC.
+      // This is where content is actually remove from the Yjs Doc.
+      if (doc.gc) {
+        tryGcDeleteSet(transaction, ds, doc.gcFilter);
+      }
+      tryMerge(ds, store);
+
+      // on all affected store.clients props, try to merge
+      transaction.insertSet.clients.forEach((ids, client) => {
+        const firstClock = ids.getIds()[0].clock;
+        const structs = /** @type {Array<GC|Item>} */ (store.clients.get(client));
+        // we iterate from right to left so we can safely remove entries
+        const firstChangePos = math.max(findIndexSS(structs, firstClock), 1);
+        for (let i = structs.length - 1; i >= firstChangePos;) {
+          i -= 1 + tryToMergeWithLefts(structs, i);
+        }
+      });
+      // try to merge mergeStructs
+      // @todo: it makes more sense to transform mergeStructs to a DS, sort it, and merge from right to left
+      //        but at the moment DS does not handle duplicates
+      for (let i = mergeStructs.length - 1; i >= 0; i--) {
+        const { client, clock } = mergeStructs[i].id;
+        const structs = /** @type {Array<GC|Item>} */ (store.clients.get(client));
+        const replacedStructPos = findIndexSS(structs, clock);
+        if (replacedStructPos + 1 < structs.length) {
+          if (tryToMergeWithLefts(structs, replacedStructPos + 1) > 1) {
+            continue // no need to perform next check, both are already merged
+          }
+        }
+        if (replacedStructPos > 0) {
+          tryToMergeWithLefts(structs, replacedStructPos);
+        }
+      }
+      if (!transaction.local && transaction.insertSet.clients.has(doc.clientID)) {
+        logging.print(logging.ORANGE, logging.BOLD, '[yjs] ', logging.UNBOLD, logging.RED, 'Changed the client-id because another client seems to be using it.');
+        doc.clientID = generateNewClientId();
+      }
+      // @todo Merge all the transactions into one and provide send the data as a single update message
+      doc.emit('afterTransactionCleanup', [transaction, doc]);
+      if (doc._observers.has('update')) {
+        const encoder = new UpdateEncoderV1();
+        const hasContent = writeUpdateMessageFromTransaction(encoder, transaction);
+        if (hasContent) {
+          doc.emit('update', [encoder.toUint8Array(), transaction.origin, doc, transaction]);
+        }
+      }
+      if (doc._observers.has('updateV2')) {
+        const encoder = new UpdateEncoderV2();
+        const hasContent = writeUpdateMessageFromTransaction(encoder, transaction);
+        if (hasContent) {
+          doc.emit('updateV2', [encoder.toUint8Array(), transaction.origin, doc, transaction]);
+        }
+      }
+      const { subdocsAdded, subdocsLoaded, subdocsRemoved } = transaction;
+      if (subdocsAdded.size > 0 || subdocsRemoved.size > 0 || subdocsLoaded.size > 0) {
+        subdocsAdded.forEach(subdoc => {
+          subdoc.clientID = doc.clientID;
+          if (subdoc.collectionid == null) {
+            subdoc.collectionid = doc.collectionid;
+          }
+          doc.subdocs.add(subdoc);
+        });
+        subdocsRemoved.forEach(subdoc => doc.subdocs.delete(subdoc));
+        doc.emit('subdocs', [{ loaded: subdocsLoaded, added: subdocsAdded, removed: subdocsRemoved }, doc, transaction]);
+        subdocsRemoved.forEach(subdoc => subdoc.destroy());
+      }
+
+      if (transactionCleanups.length <= i + 1) {
+        doc._transactionCleanups = [];
+        doc.emit('afterAllTransactions', [doc, transactionCleanups]);
+      } else {
+        cleanupTransactions(transactionCleanups, i + 1);
+      }
+    }
+  }
+};
+
+/**
+ * Implements the functionality of `y.transact(()=>{..})`
+ *
+ * @template T
+ * @param {Doc} doc
+ * @param {function(Transaction):T} f
+ * @param {any} [origin=true]
+ * @return {T}
+ *
+ * @function
+ */
+const transact = (doc, f, origin = null, local = true) => {
+  const transactionCleanups = doc._transactionCleanups;
+  let initialCall = false;
+  /**
+   * @type {any}
+   */
+  let result = null;
+  if (doc._transaction === null) {
+    initialCall = true;
+    doc._transaction = new Transaction(doc, origin, local);
+    transactionCleanups.push(doc._transaction);
+    if (transactionCleanups.length === 1) {
+      doc.emit('beforeAllTransactions', [doc]);
+    }
+    doc.emit('beforeTransaction', [doc._transaction, doc]);
+  }
+  try {
+    result = f(doc._transaction);
+  } finally {
+    if (initialCall) {
+      const finishCleanup = doc._transaction === transactionCleanups[0];
+      doc._transaction = null;
+      if (finishCleanup) {
+        // The first transaction ended, now process observer calls.
+        // Observer call may create new transactions for which we need to call the observers and do cleanup.
+        // We don't want to nest these calls, so we execute these calls one after
+        // another.
+        // Also we need to ensure that all cleanups are called, even if the
+        // observes throw errors.
+        // This file is full of hacky try {} finally {} blocks to ensure that an
+        // event can throw errors and also that the cleanup is called.
+        cleanupTransactions(transactionCleanups, 0);
+      }
+    }
+  }
+  return result
+};
+
+class StackItem {
+  /**
+   * @param {IdSet} deletions
+   * @param {IdSet} insertions
+   */
+  constructor (deletions, insertions) {
+    this.insertions = insertions;
+    this.deletions = deletions;
+    /**
+     * Use this to save and restore metadata like selection range
+     */
+    this.meta = new Map();
+  }
+}
+/**
+ * @param {Transaction} tr
+ * @param {UndoManager} um
+ * @param {StackItem} stackItem
+ */
+const clearUndoManagerStackItem = (tr, um, stackItem) => {
+  iterateStructsByIdSet(tr, stackItem.deletions, item => {
+    if (item instanceof Item && um.scope.some(type => type === tr.doc || isParentOf(/** @type {import('../utils/types.js').YType} */ (type), item))) {
+      keepItem(item, false);
+    }
+  });
+};
+
+/**
+ * @param {UndoManager} undoManager
+ * @param {Array<StackItem>} stack
+ * @param {'undo'|'redo'} eventType
+ * @return {StackItem?}
+ */
+const popStackItem = (undoManager, stack, eventType) => {
+  /**
+   * Keep a reference to the transaction so we can fire the event with the changedParentTypes
+   * @type {any}
+   */
+  let _tr = null;
+  const doc = undoManager.doc;
+  const scope = undoManager.scope;
+  transact(doc, transaction => {
+    while (stack.length > 0 && undoManager.currStackItem === null) {
+      const store = doc.store;
+      const stackItem = /** @type {StackItem} */ (stack.pop());
+      /**
+       * @type {Set<Item>}
+       */
+      const itemsToRedo = new Set();
+      /**
+       * @type {Array<Item>}
+       */
+      const itemsToDelete = [];
+      let performedChange = false;
+      iterateStructsByIdSet(transaction, stackItem.insertions, struct => {
+        if (struct instanceof Item) {
+          if (struct.redone !== null) {
+            let { item, diff } = followRedone(store, struct.id);
+            if (diff > 0) {
+              item = getItemCleanStart(transaction, createID(item.id.client, item.id.clock + diff));
+            }
+            struct = item;
+          }
+          if (!struct.deleted && scope.some(type => type === transaction.doc || isParentOf(/** @type {import('../utils/types.js').YType} */ (type), /** @type {Item} */ (struct)))) {
+            itemsToDelete.push(struct);
+          }
+        }
+      });
+      iterateStructsByIdSet(transaction, stackItem.deletions, struct => {
+        if (
+          struct instanceof Item &&
+          scope.some(type => type === transaction.doc || isParentOf(/** @type {import('../utils/types.js').YType} */ (type), struct)) &&
+          // Never redo structs in stackItem.insertions because they were created and deleted in the same capture interval.
+          !stackItem.insertions.hasId(struct.id)
+        ) {
+          itemsToRedo.add(struct);
+        }
+      });
+      itemsToRedo.forEach(struct => {
+        performedChange = redoItem(transaction, struct, itemsToRedo, stackItem.insertions, undoManager.ignoreRemoteMapChanges, undoManager) !== null || performedChange;
+      });
+      // We want to delete in reverse order so that children are deleted before
+      // parents, so we have more information available when items are filtered.
+      for (let i = itemsToDelete.length - 1; i >= 0; i--) {
+        const item = itemsToDelete[i];
+        if (undoManager.deleteFilter(item)) {
+          item.delete(transaction);
+          performedChange = true;
+        }
+      }
+      undoManager.currStackItem = performedChange ? stackItem : null;
+    }
+    transaction.changed.forEach((subProps, type) => {
+      // destroy search marker if necessary
+      if (subProps.has(null) && type._searchMarker) {
+        type._searchMarker.length = 0;
+      }
+    });
+    _tr = transaction;
+  }, undoManager);
+  const res = undoManager.currStackItem;
+  if (res != null) {
+    const changedParentTypes = _tr.changedParentTypes;
+    undoManager.emit('stack-item-popped', [{ stackItem: res, type: eventType, changedParentTypes, origin: undoManager }, undoManager]);
+    undoManager.currStackItem = null;
+  }
+  return res
+};
+
+/**
+ * @typedef {Object} UndoManagerOptions
+ * @property {number} [UndoManagerOptions.captureTimeout=500]
+ * @property {function(Transaction):boolean} [UndoManagerOptions.captureTransaction] Do not capture changes of a Transaction if result false.
+ * @property {function(Item):boolean} [UndoManagerOptions.deleteFilter=()=>true] Sometimes
+ * it is necessary to filter what an Undo/Redo operation can delete. If this
+ * filter returns false, the type/item won't be deleted even it is in the
+ * undo/redo scope.
+ * @property {Set<any>} [UndoManagerOptions.trackedOrigins=new Set([null])]
+ * @property {boolean} [ignoreRemoteMapChanges] Experimental. By default, the UndoManager will never overwrite remote changes. Enable this property to enable overwriting remote changes on key-value changes (Y.Map, properties on Y.Xml, etc..).
+ * @property {Doc} [doc] The document that this UndoManager operates on. Only needed if typeScope is empty.
+ */
+
+/**
+ * @typedef {Object} StackItemEvent
+ * @property {StackItem} StackItemEvent.stackItem
+ * @property {any} StackItemEvent.origin
+ * @property {'undo'|'redo'} StackItemEvent.type
+ * @property {Map<import('../utils/types.js').YType,Array<YEvent<any>>>} StackItemEvent.changedParentTypes
+ */
+
+/**
+ * Fires 'stack-item-added' event when a stack item was added to either the undo- or
+ * the redo-stack. You may store additional stack information via the
+ * metadata property on `event.stackItem.meta` (it is a `Map` of metadata properties).
+ * Fires 'stack-item-popped' event when a stack item was popped from either the
+ * undo- or the redo-stack. You may restore the saved stack information from `event.stackItem.meta`.
+ *
+ * @extends {ObservableV2<{'stack-item-added':function(StackItemEvent, UndoManager):void, 'stack-item-popped': function(StackItemEvent, UndoManager):void, 'stack-cleared': function({ undoStackCleared: boolean, redoStackCleared: boolean }):void, 'stack-item-updated': function(StackItemEvent, UndoManager):void }>}
+ */
+class UndoManager extends ObservableV2 {
+  /**
+   * @param {Doc|import('../utils/types.js').YType|Array<import('../utils/types.js').YType>} typeScope Limits the scope of the UndoManager. If this is set to a ydoc instance, all changes on that ydoc will be undone. If set to a specific type, only changes on that type or its children will be undone. Also accepts an array of types.
+   * @param {UndoManagerOptions} options
+   */
+  constructor (typeScope, {
+    captureTimeout = 500,
+    captureTransaction = _tr => true,
+    deleteFilter = () => true,
+    trackedOrigins = new Set([null]),
+    ignoreRemoteMapChanges = false,
+    doc = /** @type {Doc} */ (array.isArray(typeScope) ? typeScope[0].doc : typeScope instanceof Doc ? typeScope : typeScope.doc)
+  } = {}) {
+    super();
+    /**
+     * @type {Array<import('../utils/types.js').YType | Doc>}
+     */
+    this.scope = [];
+    this.doc = doc;
+    this.addToScope(typeScope);
+    this.deleteFilter = deleteFilter;
+    trackedOrigins.add(this);
+    this.trackedOrigins = trackedOrigins;
+    this.captureTransaction = captureTransaction;
+    /**
+     * @type {Array<StackItem>}
+     */
+    this.undoStack = [];
+    /**
+     * @type {Array<StackItem>}
+     */
+    this.redoStack = [];
+    /**
+     * Whether the client is currently undoing (calling UndoManager.undo)
+     *
+     * @type {boolean}
+     */
+    this.undoing = false;
+    this.redoing = false;
+    /**
+     * The currently popped stack item if UndoManager.undoing or UndoManager.redoing
+     *
+     * @type {StackItem|null}
+     */
+    this.currStackItem = null;
+    this.lastChange = 0;
+    this.ignoreRemoteMapChanges = ignoreRemoteMapChanges;
+    this.captureTimeout = captureTimeout;
+    /**
+     * @param {Transaction} transaction
+     */
+    this.afterTransactionHandler = transaction => {
+      // Only track certain transactions
+      if (
+        !this.captureTransaction(transaction) ||
+        !this.scope.some(type => transaction.changedParentTypes.has(/** @type {import('../utils/types.js').YType} */ (type)) || type === this.doc) ||
+        (!this.trackedOrigins.has(transaction.origin) && (!transaction.origin || !this.trackedOrigins.has(transaction.origin.constructor)))
+      ) {
+        return
+      }
+      const undoing = this.undoing;
+      const redoing = this.redoing;
+      const stack = undoing ? this.redoStack : this.undoStack;
+      if (undoing) {
+        this.stopCapturing(); // next undo should not be appended to last stack item
+      } else if (!redoing) {
+        // neither undoing nor redoing: delete redoStack
+        this.clear(false, true);
+      }
+      const insertions = transaction.insertSet;
+      const now = time.getUnixTime();
+      let didAdd = false;
+      if (this.lastChange > 0 && now - this.lastChange < this.captureTimeout && stack.length > 0 && !undoing && !redoing) {
+        // append change to last stack op
+        const lastOp = stack[stack.length - 1];
+        lastOp.deletions = mergeIdSets([lastOp.deletions, transaction.deleteSet]);
+        lastOp.insertions = mergeIdSets([lastOp.insertions, insertions]);
+      } else {
+        // create a new stack op
+        stack.push(new StackItem(transaction.deleteSet, insertions));
+        didAdd = true;
+      }
+      if (!undoing && !redoing) {
+        this.lastChange = now;
+      }
+      // make sure that deleted structs are not gc'd
+      iterateStructsByIdSet(transaction, transaction.deleteSet, /** @param {Item|GC} item */ item => {
+        if (item instanceof Item && this.scope.some(type => type === transaction.doc || isParentOf(/** @type {import('../utils/types.js').YType} */ (type), item))) {
+          keepItem(item, true);
+        }
+      });
+      /**
+       * @type {[StackItemEvent, UndoManager]}
+       */
+      const changeEvent = [{ stackItem: stack[stack.length - 1], origin: transaction.origin, type: undoing ? 'redo' : 'undo', changedParentTypes: transaction.changedParentTypes }, this];
+      if (didAdd) {
+        this.emit('stack-item-added', changeEvent);
+      } else {
+        this.emit('stack-item-updated', changeEvent);
+      }
+    };
+    this.doc.on('afterTransaction', this.afterTransactionHandler);
+    this.doc.on('destroy', () => {
+      this.destroy();
+    });
+  }
+
+  /**
+   * Extend the scope.
+   *
+   * @param {Array<import('../utils/types.js').YType | Doc> | import('../utils/types.js').YType | Doc} ytypes
+   */
+  addToScope (ytypes) {
+    const tmpSet = new Set(this.scope);
+    ytypes = array.isArray(ytypes) ? ytypes : [ytypes];
+    ytypes.forEach(ytype => {
+      if (!tmpSet.has(ytype)) {
+        tmpSet.add(ytype);
+        if (ytype instanceof AbstractType ? ytype.doc !== this.doc : ytype !== this.doc) logging.warn('[yjs#509] Not same Y.Doc'); // use MultiDocUndoManager instead. also see https://github.com/yjs/yjs/issues/509
+        this.scope.push(ytype);
+      }
+    });
+  }
+
+  /**
+   * @param {any} origin
+   */
+  addTrackedOrigin (origin) {
+    this.trackedOrigins.add(origin);
+  }
+
+  /**
+   * @param {any} origin
+   */
+  removeTrackedOrigin (origin) {
+    this.trackedOrigins.delete(origin);
+  }
+
+  clear (clearUndoStack = true, clearRedoStack = true) {
+    if ((clearUndoStack && this.canUndo()) || (clearRedoStack && this.canRedo())) {
+      this.doc.transact(tr => {
+        if (clearUndoStack) {
+          this.undoStack.forEach(item => clearUndoManagerStackItem(tr, this, item));
+          this.undoStack = [];
+        }
+        if (clearRedoStack) {
+          this.redoStack.forEach(item => clearUndoManagerStackItem(tr, this, item));
+          this.redoStack = [];
+        }
+        this.emit('stack-cleared', [{ undoStackCleared: clearUndoStack, redoStackCleared: clearRedoStack }]);
+      });
+    }
+  }
+
+  /**
+   * UndoManager merges Undo-StackItem if they are created within time-gap
+   * smaller than `options.captureTimeout`. Call `um.stopCapturing()` so that the next
+   * StackItem won't be merged.
+   *
+   *
+   * @example
+   *     // without stopCapturing
+   *     ytext.insert(0, 'a')
+   *     ytext.insert(1, 'b')
+   *     um.undo()
+   *     ytext.toString() // => '' (note that 'ab' was removed)
+   *     // with stopCapturing
+   *     ytext.insert(0, 'a')
+   *     um.stopCapturing()
+   *     ytext.insert(0, 'b')
+   *     um.undo()
+   *     ytext.toString() // => 'a' (note that only 'b' was removed)
+   *
+   */
+  stopCapturing () {
+    this.lastChange = 0;
+  }
+
+  /**
+   * Undo last changes on type.
+   *
+   * @return {StackItem?} Returns StackItem if a change was applied
+   */
+  undo () {
+    this.undoing = true;
+    let res;
+    try {
+      res = popStackItem(this, this.undoStack, 'undo');
+    } finally {
+      this.undoing = false;
+    }
+    return res
+  }
+
+  /**
+   * Redo last undo operation.
+   *
+   * @return {StackItem?} Returns StackItem if a change was applied
+   */
+  redo () {
+    this.redoing = true;
+    let res;
+    try {
+      res = popStackItem(this, this.redoStack, 'redo');
+    } finally {
+      this.redoing = false;
+    }
+    return res
+  }
+
+  /**
+   * Are undo steps available?
+   *
+   * @return {boolean} `true` if undo is possible
+   */
+  canUndo () {
+    return this.undoStack.length > 0
+  }
+
+  /**
+   * Are redo steps available?
+   *
+   * @return {boolean} `true` if redo is possible
+   */
+  canRedo () {
+    return this.redoStack.length > 0
+  }
+
+  destroy () {
+    this.trackedOrigins.delete(this);
+    this.doc.off('afterTransaction', this.afterTransactionHandler);
+    super.destroy();
+  }
+}
+
+/**
+ * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
+ */
+function * lazyStructReaderGenerator (decoder) {
+  const numOfStateUpdates = decoding.readVarUint(decoder.restDecoder);
+  for (let i = 0; i < numOfStateUpdates; i++) {
+    const numberOfStructs = decoding.readVarUint(decoder.restDecoder);
+    const client = decoder.readClient();
+    let clock = decoding.readVarUint(decoder.restDecoder);
+    for (let i = 0; i < numberOfStructs; i++) {
+      const info = decoder.readInfo();
+      // @todo use switch instead of ifs
+      if (info === 10) {
+        const len = decoding.readVarUint(decoder.restDecoder);
+        yield new Skip(createID(client, clock), len);
+        clock += len;
+      } else if ((binary.BITS5 & info) !== 0) {
+        const cantCopyParentInfo = (info & (binary.BIT7 | binary.BIT8)) === 0;
+        // If parent = null and neither left nor right are defined, then we know that `parent` is child of `y`
+        // and we read the next string as parentYKey.
+        // It indicates how we store/retrieve parent from `y.share`
+        // @type {string|null}
+        const struct = new Item(
+          createID(client, clock),
+          null, // left
+          (info & binary.BIT8) === binary.BIT8 ? decoder.readLeftID() : null, // origin
+          null, // right
+          (info & binary.BIT7) === binary.BIT7 ? decoder.readRightID() : null, // right origin
+          // @ts-ignore Force writing a string here.
+          cantCopyParentInfo ? (decoder.readParentInfo() ? decoder.readString() : decoder.readLeftID()) : null, // parent
+          cantCopyParentInfo && (info & binary.BIT6) === binary.BIT6 ? decoder.readString() : null, // parentSub
+          readItemContent(decoder, info) // item content
+        );
+        yield struct;
+        clock += struct.length;
+      } else {
+        const len = decoder.readLen();
+        yield new GC(createID(client, clock), len);
+        clock += len;
+      }
+    }
+  }
+}
+
+class LazyStructReader {
+  /**
+   * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
+   * @param {boolean} filterSkips
+   */
+  constructor (decoder, filterSkips) {
+    this.gen = lazyStructReaderGenerator(decoder);
+    /**
+     * @type {null | Item | Skip | GC}
+     */
+    this.curr = null;
+    this.done = false;
+    this.filterSkips = filterSkips;
+    this.next();
+  }
+
+  /**
+   * @return {Item | GC | Skip |null}
+   */
+  next () {
+    // ignore "Skip" structs
+    do {
+      this.curr = this.gen.next().value || null;
+    } while (this.filterSkips && this.curr !== null && this.curr.constructor === Skip)
+    return this.curr
+  }
+}
+
+/**
+ * @param {Uint8Array} update
+ *
+ */
+const logUpdate = update => logUpdateV2(update, UpdateDecoderV1);
+
+/**
+ * @param {Uint8Array} update
+ * @param {typeof UpdateDecoderV2 | typeof UpdateDecoderV1} [YDecoder]
+ */
+const logUpdateV2 = (update, YDecoder = UpdateDecoderV2) => {
+  const structs = [];
+  const updateDecoder = new YDecoder(decoding.createDecoder(update));
+  const lazyDecoder = new LazyStructReader(updateDecoder, false);
+  for (let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()) {
+    structs.push(curr);
+  }
+  logging.print('Structs: ', structs);
+  const ds = readIdSet(updateDecoder);
+  logging.print('DeleteSet: ', ds);
+};
+
+/**
+ * @param {Uint8Array} update
+ *
+ */
+const decodeUpdate = (update) => decodeUpdateV2(update, UpdateDecoderV1);
+
+/**
+ * @param {Uint8Array} update
+ * @param {typeof UpdateDecoderV2 | typeof UpdateDecoderV1} [YDecoder]
+ *
+ */
+const decodeUpdateV2 = (update, YDecoder = UpdateDecoderV2) => {
+  const structs = [];
+  const updateDecoder = new YDecoder(decoding.createDecoder(update));
+  const lazyDecoder = new LazyStructReader(updateDecoder, false);
+  for (let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()) {
+    structs.push(curr);
+  }
+  return {
+    structs,
+    ds: readIdSet(updateDecoder)
+  }
+};
+
+class LazyStructWriter {
+  /**
+   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
+   */
+  constructor (encoder) {
+    this.currClient = 0;
+    this.startClock = 0;
+    this.written = 0;
+    this.encoder = encoder;
+    /**
+     * We want to write operations lazily, but also we need to know beforehand how many operations we want to write for each client.
+     *
+     * This kind of meta-information (#clients, #structs-per-client-written) is written to the restEncoder.
+     *
+     * We fragment the restEncoder and store a slice of it per-client until we know how many clients there are.
+     * When we flush (toUint8Array) we write the restEncoder using the fragments and the meta-information.
+     *
+     * @type {Array<{ written: number, restEncoder: Uint8Array }>}
+     */
+    this.clientStructs = [];
+  }
+}
+
+/**
+ * @param {Array<Uint8Array<ArrayBuffer>>} updates
+ * @return {Uint8Array<ArrayBuffer>}
+ */
+const mergeUpdates = updates => mergeUpdatesV2(updates, UpdateDecoderV1, UpdateEncoderV1);
+
+/**
+ * @param {Uint8Array} update
+ * @param {typeof IdSetEncoderV1 | typeof IdSetEncoderV2} YEncoder
+ * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} YDecoder
+ * @return {Uint8Array}
+ */
+const encodeStateVectorFromUpdateV2 = (update, YEncoder = IdSetEncoderV2, YDecoder = UpdateDecoderV2) => {
+  const encoder = new YEncoder();
+  const updateDecoder = new LazyStructReader(new YDecoder(decoding.createDecoder(update)), false);
+  let curr = updateDecoder.curr;
+  if (curr !== null) {
+    let size = 0;
+    let currClient = curr.id.client;
+    let stopCounting = curr.id.clock !== 0; // must start at 0
+    let currClock = stopCounting ? 0 : curr.id.clock + curr.length;
+    for (; curr !== null; curr = updateDecoder.next()) {
+      if (currClient !== curr.id.client) {
+        if (currClock !== 0) {
+          size++;
+          // We found a new client
+          // write what we have to the encoder
+          encoding.writeVarUint(encoder.restEncoder, currClient);
+          encoding.writeVarUint(encoder.restEncoder, currClock);
+        }
+        currClient = curr.id.client;
+        currClock = 0;
+        stopCounting = curr.id.clock !== 0;
+      }
+      // we ignore skips
+      if (curr.constructor === Skip) {
+        stopCounting = true;
+      }
+      if (!stopCounting) {
+        currClock = curr.id.clock + curr.length;
+      }
+    }
+    // write what we have
+    if (currClock !== 0) {
+      size++;
+      encoding.writeVarUint(encoder.restEncoder, currClient);
+      encoding.writeVarUint(encoder.restEncoder, currClock);
+    }
+    // prepend the size of the state vector
+    const enc = encoding.createEncoder();
+    encoding.writeVarUint(enc, size);
+    encoding.writeBinaryEncoder(enc, encoder.restEncoder);
+    encoder.restEncoder = enc;
+    return encoder.toUint8Array()
+  } else {
+    encoding.writeVarUint(encoder.restEncoder, 0);
+    return encoder.toUint8Array()
+  }
+};
+
+/**
+ * @param {Uint8Array} update
+ * @return {Uint8Array}
+ */
+const encodeStateVectorFromUpdate = update => encodeStateVectorFromUpdateV2(update, IdSetEncoderV1, UpdateDecoderV1);
+
+/**
+ * @param {Uint8Array} update
+ * @param {typeof UpdateDecoderV2 | typeof UpdateDecoderV1} [YDecoder]
+ */
+const readUpdateIdRangesV2 = (update, YDecoder = UpdateDecoderV2) => {
+  const updateDecoder = new YDecoder(decoding.createDecoder(update));
+  const lazyDecoder = new LazyStructReader(updateDecoder, true);
+  const inserts = createIdSet();
+  let lastClientId = -1;
+  let lastClock = 0;
+  let lastLen = 0;
+  for (let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()) {
+    const currId = curr.id;
+    if (lastClientId === currId.client && lastClock + lastLen === currId.clock) {
+      // default case: extend prev entry
+      lastLen += curr.length;
+    } else {
+      if (lastClientId >= 0) {
+        inserts.add(lastClientId, lastClock, lastLen);
+      }
+      lastClientId = currId.client;
+      lastClock = currId.clock;
+      lastLen = curr.length;
+    }
+  }
+  if (lastClientId >= 0) {
+    inserts.add(lastClientId, lastClock, lastLen);
+  }
+  const deletes = readIdSet(updateDecoder);
+  return { inserts, deletes }
+};
+
+/**
+ * @param {Uint8Array} update
+ */
+const readUpdateIdRanges = update => readUpdateIdRangesV2(update, UpdateDecoderV1);
+
+/**
+ * This method is intended to slice any kind of struct and retrieve the right part.
+ * It does not handle side-effects, so it should only be used by the lazy-encoder.
+ *
+ * @param {Item | GC | Skip} left
+ * @param {number} diff
+ * @return {Item | GC}
+ */
+const sliceStruct = (left, diff) => {
+  if (left.constructor === GC) {
+    const { client, clock } = left.id;
+    return new GC(createID(client, clock + diff), left.length - diff)
+  } else if (left.constructor === Skip) {
+    const { client, clock } = left.id;
+    return new Skip(createID(client, clock + diff), left.length - diff)
+  } else {
+    const leftItem = /** @type {Item} */ (left);
+    const { client, clock } = leftItem.id;
+    return new Item(
+      createID(client, clock + diff),
+      null,
+      createID(client, clock + diff - 1),
+      null,
+      leftItem.rightOrigin,
+      leftItem.parent,
+      leftItem.parentSub,
+      leftItem.content.splice(diff)
+    )
+  }
+};
+
+/**
+ *
+ * This function works similarly to `readUpdateV2`.
+ *
+ * @param {Array<Uint8Array<ArrayBuffer>>} updates
+ * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} [YDecoder]
+ * @param {typeof UpdateEncoderV1 | typeof UpdateEncoderV2} [YEncoder]
+ * @return {Uint8Array<ArrayBuffer>}
+ */
+const mergeUpdatesV2 = (updates, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2) => {
+  if (updates.length === 1) {
+    return updates[0]
+  }
+  const updateDecoders = updates.map(update => new YDecoder(decoding.createDecoder(update)));
+  let lazyStructDecoders = updateDecoders.map(decoder => new LazyStructReader(decoder, true));
+
+  /**
+   * @todo we don't need offset because we always slice before
+   * @type {null | { struct: Item | GC | Skip, offset: number }}
+   */
+  let currWrite = null;
+
+  const updateEncoder = new YEncoder();
+  // write structs lazily
+  const lazyStructEncoder = new LazyStructWriter(updateEncoder);
+
+  // Note: We need to ensure that all lazyStructDecoders are fully consumed
+  // Note: Should merge document updates whenever possible - even from different updates
+  // Note: Should handle that some operations cannot be applied yet ()
+
+  while (true) {
+    // Write higher clients first  sort by clientID & clock and remove decoders without content
+    lazyStructDecoders = lazyStructDecoders.filter(dec => dec.curr !== null);
+    lazyStructDecoders.sort(
+      /** @type {function(any,any):number} */ (dec1, dec2) => {
+        if (dec1.curr.id.client === dec2.curr.id.client) {
+          const clockDiff = dec1.curr.id.clock - dec2.curr.id.clock;
+          if (clockDiff === 0) {
+            // @todo remove references to skip since the structDecoders must filter Skips.
+            return dec1.curr.constructor === dec2.curr.constructor
+              ? 0
+              : dec1.curr.constructor === Skip ? 1 : -1 // we are filtering skips anyway.
+          } else {
+            return clockDiff
+          }
+        } else {
+          return dec2.curr.id.client - dec1.curr.id.client
+        }
+      }
+    );
+    if (lazyStructDecoders.length === 0) {
+      break
+    }
+    const currDecoder = lazyStructDecoders[0];
+    // write from currDecoder until the next operation is from another client or if filler-struct
+    // then we need to reorder the decoders and find the next operation to write
+    const firstClient = /** @type {Item | GC} */ (currDecoder.curr).id.client;
+
+    if (currWrite !== null) {
+      let curr = /** @type {Item | GC | null} */ (currDecoder.curr);
+      let iterated = false;
+
+      // iterate until we find something that we haven't written already
+      // remember: first the high client-ids are written
+      while (curr !== null && curr.id.clock + curr.length <= currWrite.struct.id.clock + currWrite.struct.length && curr.id.client >= currWrite.struct.id.client) {
+        curr = currDecoder.next();
+        iterated = true;
+      }
+      if (
+        curr === null || // current decoder is empty
+        curr.id.client !== firstClient || // check whether there is another decoder that has has updates from `firstClient`
+        (iterated && curr.id.clock > currWrite.struct.id.clock + currWrite.struct.length) // the above while loop was used and we are potentially missing updates
+      ) {
+        continue
+      }
+
+      if (firstClient !== currWrite.struct.id.client) {
+        writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
+        currWrite = { struct: curr, offset: 0 };
+        currDecoder.next();
+      } else {
+        if (currWrite.struct.id.clock + currWrite.struct.length < curr.id.clock) {
+          // @todo write currStruct & set currStruct = Skip(clock = currStruct.id.clock + currStruct.length, length = curr.id.clock - self.clock)
+          if (currWrite.struct.constructor === Skip) {
+            // extend existing skip
+            currWrite.struct.length = curr.id.clock + curr.length - currWrite.struct.id.clock;
+          } else {
+            writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
+            const diff = curr.id.clock - currWrite.struct.id.clock - currWrite.struct.length;
+            /**
+             * @type {Skip}
+             */
+            const struct = new Skip(createID(firstClient, currWrite.struct.id.clock + currWrite.struct.length), diff);
+            currWrite = { struct, offset: 0 };
+          }
+        } else { // if (currWrite.struct.id.clock + currWrite.struct.length >= curr.id.clock) {
+          const diff = currWrite.struct.id.clock + currWrite.struct.length - curr.id.clock;
+          if (diff > 0) {
+            if (currWrite.struct.constructor === Skip) {
+              // prefer to slice Skip because the other struct might contain more information
+              currWrite.struct.length -= diff;
+            } else {
+              curr = sliceStruct(curr, diff);
+            }
+          }
+          if (!currWrite.struct.mergeWith(/** @type {any} */ (curr))) {
+            writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
+            currWrite = { struct: curr, offset: 0 };
+            currDecoder.next();
+          }
+        }
+      }
+    } else {
+      currWrite = { struct: /** @type {Item | GC} */ (currDecoder.curr), offset: 0 };
+      currDecoder.next();
+    }
+    for (
+      let next = currDecoder.curr;
+      next !== null && next.id.client === firstClient && next.id.clock === currWrite.struct.id.clock + currWrite.struct.length && next.constructor !== Skip;
+      next = currDecoder.next()
+    ) {
+      writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
+      currWrite = { struct: next, offset: 0 };
+    }
+  }
+  if (currWrite !== null) {
+    writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
+    currWrite = null;
+  }
+  finishLazyStructWriting(lazyStructEncoder);
+
+  const dss = updateDecoders.map(decoder => readIdSet(decoder));
+  const ds = mergeIdSets(dss);
+  writeIdSet(updateEncoder, ds);
+  return updateEncoder.toUint8Array()
+};
+
+/**
+ * @param {Uint8Array} update
+ * @param {Uint8Array} sv
+ * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} [YDecoder]
+ * @param {typeof UpdateEncoderV1 | typeof UpdateEncoderV2} [YEncoder]
+ */
+const diffUpdateV2 = (update, sv, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2) => {
+  const state = decodeStateVector(sv);
+  const encoder = new YEncoder();
+  const lazyStructWriter = new LazyStructWriter(encoder);
+  const decoder = new YDecoder(decoding.createDecoder(update));
+  const reader = new LazyStructReader(decoder, false);
+  while (reader.curr) {
+    const curr = reader.curr;
+    const currClient = curr.id.client;
+    const svClock = state.get(currClient) || 0;
+    if (reader.curr.constructor === Skip) {
+      // the first written struct shouldn't be a skip
+      reader.next();
+      continue
+    }
+    if (curr.id.clock + curr.length > svClock) {
+      writeStructToLazyStructWriter(lazyStructWriter, curr, math.max(svClock - curr.id.clock, 0));
+      reader.next();
+      while (reader.curr && reader.curr.id.client === currClient) {
+        writeStructToLazyStructWriter(lazyStructWriter, reader.curr, 0);
+        reader.next();
+      }
+    } else {
+      // read until something new comes up
+      while (reader.curr && reader.curr.id.client === currClient && reader.curr.id.clock + reader.curr.length <= svClock) {
+        reader.next();
+      }
+    }
+  }
+  finishLazyStructWriting(lazyStructWriter);
+  // write ds
+  const ds = readIdSet(decoder);
+  writeIdSet(encoder, ds);
+  return encoder.toUint8Array()
+};
+
+/**
+ * @param {Uint8Array} update
+ * @param {Uint8Array} sv
+ */
+const diffUpdate = (update, sv) => diffUpdateV2(update, sv, UpdateDecoderV1, UpdateEncoderV1);
+
+/**
+ * @param {LazyStructWriter} lazyWriter
+ */
+const flushLazyStructWriter = lazyWriter => {
+  if (lazyWriter.written > 0) {
+    lazyWriter.clientStructs.push({ written: lazyWriter.written, restEncoder: encoding.toUint8Array(lazyWriter.encoder.restEncoder) });
+    lazyWriter.encoder.restEncoder = encoding.createEncoder();
+    lazyWriter.written = 0;
+  }
+};
+
+/**
+ * @param {LazyStructWriter} lazyWriter
+ * @param {Item | GC} struct
+ * @param {number} offset
+ */
+const writeStructToLazyStructWriter = (lazyWriter, struct, offset) => {
+  // flush curr if we start another client
+  if (lazyWriter.written > 0 && lazyWriter.currClient !== struct.id.client) {
+    flushLazyStructWriter(lazyWriter);
+  }
+  if (lazyWriter.written === 0) {
+    lazyWriter.currClient = struct.id.client;
+    // write next client
+    lazyWriter.encoder.writeClient(struct.id.client);
+    // write startClock
+    encoding.writeVarUint(lazyWriter.encoder.restEncoder, struct.id.clock + offset);
+  }
+  struct.write(lazyWriter.encoder, offset, 0);
+  lazyWriter.written++;
+};
+/**
+ * Call this function when we collected all parts and want to
+ * put all the parts together. After calling this method,
+ * you can continue using the UpdateEncoder.
+ *
+ * @param {LazyStructWriter} lazyWriter
+ */
+const finishLazyStructWriting = (lazyWriter) => {
+  flushLazyStructWriter(lazyWriter);
+
+  // this is a fresh encoder because we called flushCurr
+  const restEncoder = lazyWriter.encoder.restEncoder;
+
+  /**
+   * Now we put all the fragments together.
+   * This works similarly to `writeClientsStructs`
+   */
+
+  // write # states that were updated - i.e. the clients
+  encoding.writeVarUint(restEncoder, lazyWriter.clientStructs.length);
+
+  for (let i = 0; i < lazyWriter.clientStructs.length; i++) {
+    const partStructs = lazyWriter.clientStructs[i];
+    /**
+     * Works similarly to `writeStructs`
+     */
+    // write # encoded structs
+    encoding.writeVarUint(restEncoder, partStructs.written);
+    // write the rest of the fragment
+    encoding.writeUint8Array(restEncoder, partStructs.restEncoder);
+  }
+};
+
+/**
+ * @param {Uint8Array} update
+ * @param {function(Item|GC|Skip):Item|GC|Skip} blockTransformer
+ * @param {typeof UpdateDecoderV2 | typeof UpdateDecoderV1} YDecoder
+ * @param {typeof UpdateEncoderV2 | typeof UpdateEncoderV1 } YEncoder
+ */
+const convertUpdateFormat = (update, blockTransformer, YDecoder, YEncoder) => {
+  const updateDecoder = new YDecoder(decoding.createDecoder(update));
+  const lazyDecoder = new LazyStructReader(updateDecoder, false);
+  const updateEncoder = new YEncoder();
+  const lazyWriter = new LazyStructWriter(updateEncoder);
+  for (let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()) {
+    writeStructToLazyStructWriter(lazyWriter, blockTransformer(curr), 0);
+  }
+  finishLazyStructWriting(lazyWriter);
+  const ds = readIdSet(updateDecoder);
+  writeIdSet(updateEncoder, ds);
+  return updateEncoder.toUint8Array()
+};
+
+/**
+ * @typedef {Object} ObfuscatorOptions
+ * @property {boolean} [ObfuscatorOptions.formatting=true]
+ * @property {boolean} [ObfuscatorOptions.subdocs=true]
+ * @property {boolean} [ObfuscatorOptions.yxml=true] Whether to obfuscate nodeName / hookName
+ */
+
+/**
+ * @param {ObfuscatorOptions} obfuscator
+ */
+const createObfuscator = ({ formatting = true, subdocs = true, yxml = true } = {}) => {
+  let i = 0;
+  const mapKeyCache = map.create();
+  const nodeNameCache = map.create();
+  const formattingKeyCache = map.create();
+  const formattingValueCache = map.create();
+  formattingValueCache.set(null, null); // end of a formatting range should always be the end of a formatting range
+  /**
+   * @param {Item|GC|Skip} block
+   * @return {Item|GC|Skip}
+   */
+  return block => {
+    switch (block.constructor) {
+      case GC:
+      case Skip:
+        return block
+      case Item: {
+        const item = /** @type {Item} */ (block);
+        const content = item.content;
+        switch (content.constructor) {
+          case ContentDeleted:
+            break
+          case ContentType: {
+            if (yxml) {
+              const type = /** @type {ContentType} */ (content).type;
+              if (type instanceof YXmlElement) {
+                type.nodeName = map.setIfUndefined(nodeNameCache, type.nodeName, () => 'node-' + i);
+              }
+              // @ts-ignore
+              if (type instanceof YXmlHook) {
+                type.hookName = map.setIfUndefined(nodeNameCache, type.hookName, () => 'hook-' + i);
+              }
+            }
+            break
+          }
+          case ContentAny: {
+            const c = /** @type {ContentAny} */ (content);
+            c.arr = c.arr.map(() => i);
+            break
+          }
+          case ContentBinary: {
+            const c = /** @type {ContentBinary} */ (content);
+            c.content = new Uint8Array([i]);
+            break
+          }
+          case ContentDoc: {
+            const c = /** @type {ContentDoc} */ (content);
+            if (subdocs) {
+              c.opts = {};
+              c.doc.guid = i + '';
+            }
+            break
+          }
+          case ContentEmbed: {
+            const c = /** @type {ContentEmbed} */ (content);
+            c.embed = {};
+            break
+          }
+          case ContentFormat: {
+            const c = /** @type {ContentFormat} */ (content);
+            if (formatting) {
+              c.key = map.setIfUndefined(formattingKeyCache, c.key, () => i + '');
+              c.value = map.setIfUndefined(formattingValueCache, c.value, () => ({ i }));
+            }
+            break
+          }
+          case ContentJSON: {
+            const c = /** @type {ContentJSON} */ (content);
+            c.arr = c.arr.map(() => i);
+            break
+          }
+          case ContentString: {
+            const c = /** @type {ContentString} */ (content);
+            c.str = string.repeat((i % 10) + '', c.str.length);
+            break
+          }
+          default:
+            // unknown content type
+            error.unexpectedCase();
+        }
+        if (item.parentSub) {
+          item.parentSub = map.setIfUndefined(mapKeyCache, item.parentSub, () => i + '');
+        }
+        i++;
+        return block
+      }
+      default:
+        // unknown block-type
+        error.unexpectedCase();
+    }
+  }
+};
+
+/**
+ * This function obfuscates the content of a Yjs update. This is useful to share
+ * buggy Yjs documents while significantly limiting the possibility that a
+ * developer can on the user. Note that it might still be possible to deduce
+ * some information by analyzing the "structure" of the document or by analyzing
+ * the typing behavior using the CRDT-related metadata that is still kept fully
+ * intact.
+ *
+ * @param {Uint8Array} update
+ * @param {ObfuscatorOptions} [opts]
+ */
+const obfuscateUpdate = (update, opts) => convertUpdateFormat(update, createObfuscator(opts), UpdateDecoderV1, UpdateEncoderV1);
+
+/**
+ * @param {Uint8Array} update
+ * @param {ObfuscatorOptions} [opts]
+ */
+const obfuscateUpdateV2 = (update, opts) => convertUpdateFormat(update, createObfuscator(opts), UpdateDecoderV2, UpdateEncoderV2);
+
+/**
+ * @param {Uint8Array} update
+ */
+const convertUpdateFormatV1ToV2 = update => convertUpdateFormat(update, f.id, UpdateDecoderV1, UpdateEncoderV2);
+
+/**
+ * @param {Uint8Array} update
+ */
+const convertUpdateFormatV2ToV1 = update => convertUpdateFormat(update, f.id, UpdateDecoderV2, UpdateEncoderV1);
+
+/**
+ * @typedef {import('./types.js').YType} _YType
+ */
+
+/**
+ * @template {AbstractType<any,any>} Target
+ * YEvent describes the changes on a YType.
+ */
+class YEvent {
+  /**
+   * @param {Target} target The changed type.
+   * @param {Transaction} transaction
+   * @param {Set<any>?} subs The keys that changed
+   */
+  constructor (target, transaction, subs) {
+    /**
+     * The type on which this event was created on.
+     * @type {Target}
+     */
+    this.target = target;
+    /**
+     * The current target on which the observe callback is called.
+     * @type {_YType}
+     */
+    this.currentTarget = target;
+    /**
+     * The transaction that triggered this event.
+     * @type {Transaction}
+     */
+    this.transaction = transaction;
+    /**
+     * @type {(Target extends AbstractType<infer D,any> ? D : delta.Delta<any,any,any,any,any>)|null}
+     */
+    this._delta = null;
+    /**
+     * @type {(Target extends AbstractType<infer D,any> ? import('../internals.js').ToDeepEventDelta<D> : delta.Delta<any,any,any,any,any>)|null}
+     */
+    this._deltaDeep = null;
+    /**
+     * @type {Array<string|number>|null}
+     */
+    this._path = null;
+    /**
+     * Whether the children changed.
+     * @type {Boolean}
+     * @private
+     */
+    this.childListChanged = false;
+    /**
+     * Set of all changed attributes.
+     * @type {Set<string>}
+     */
+    this.keysChanged = new Set();
+    subs?.forEach((sub) => {
+      if (sub === null) {
+        this.childListChanged = true;
+      } else {
+        this.keysChanged.add(sub);
+      }
+    });
+  }
+
+  /**
+   * Computes the path from `y` to the changed type.
+   *
+   * @todo v14 should standardize on path: Array<{parent, index}> because that is easier to work with.
+   *
+   * The following property holds:
+   * @example
+   *   let type = y
+   *   event.path.forEach(dir => {
+   *     type = type.get(dir)
+   *   })
+   *   type === event.target // => true
+   */
+  get path () {
+    return this._path || (this._path = getPathTo(this.currentTarget, this.target))
+  }
+
+  /**
+   * Check if a struct is deleted by this event.
+   *
+   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
+   *
+   * @param {AbstractStruct} struct
+   * @return {boolean}
+   */
+  deletes (struct) {
+    return this.transaction.deleteSet.hasId(struct.id)
+  }
+
+  /**
+   * Check if a struct is added by this event.
+   *
+   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
+   *
+   * @param {AbstractStruct} struct
+   * @return {boolean}
+   */
+  adds (struct) {
+    return this.transaction.insertSet.hasId(struct.id)
+  }
+
+  /**
+   * @template {boolean} [Deep=false]
+   * @param {AbstractAttributionManager} am
+   * @param {object} [opts]
+   * @param {Deep} [opts.deep]
+   * @return {Target extends AbstractType<infer D,any> ? (Deep extends true ? import('../internals.js').ToDeepEventDelta<D> : D) : delta.Delta<any,any,any,any>} The Delta representation of this type.
+   *
+   * @public
+   */
+  getDelta (am = noAttributionsManager, { deep } = {}) {
+    const itemsToRender = mergeIdSets([diffIdSet(this.transaction.insertSet, this.transaction.deleteSet), diffIdSet(this.transaction.deleteSet, this.transaction.insertSet)]);
+    /**
+     * @todo this should be done only one in the transaction step
+     *
+     * @type {Map<import('./types.js').YType,Set<string|null>>|null}
+     */
+    let modified = this.transaction.changed;
+    if (deep) {
+      // need to add deep changes to copy of modified
+      const dchanged = new Map();
+      modified.forEach((attrs, type) => {
+        dchanged.set(type, new Set(attrs));
+      });
+      for (let m of modified.keys()) {
+        while (m._item != null) {
+          const item = m._item;
+          const ms = map.setIfUndefined(dchanged, item?.parent, set.create);
+          if (item && !ms.has(item.parentSub)) {
+            ms.add(item.parentSub);
+            m = /** @type {any} */ (item.parent);
+          } else {
+            break
+          }
+        }
+      }
+      modified = dchanged;
+    }
+    return /** @type {any} */ (this.target.getContent(am, { itemsToRender, retainDeletes: true, deletedItems: this.transaction.deleteSet, deep: !!deep, modified }))
+  }
+
+  /**
+   * Compute the changes in the delta format.
+   * A {@link https://quilljs.com/docs/delta/|Quill Delta}) that represents the changes on the document.
+   *
+   * @type {Target extends AbstractType<infer D,any> ? D : delta.Delta<any,any,any,any,any>} The Delta representation of this type.
+   * @public
+   */
+  get delta () {
+    return /** @type {any} */ (this._delta ?? (this._delta = this.getDelta().done()))
+  }
+
+  /**
+   * Compute the changes in the delta format.
+   * A {@link https://quilljs.com/docs/delta/|Quill Delta}) that represents the changes on the document.
+   *
+   * @type {Target extends AbstractType<infer D,any> ? D : delta.Delta<any,any,any,any,any>} The Delta representation of this type.
+   * @public
+   */
+  get deltaDeep () {
+    return /** @type {any} */ (this._deltaDeep ?? (this._deltaDeep = this.getDelta(noAttributionsManager, { deep: true })))
+  }
+}
+
+/**
+ * Compute the path from this type to the specified target.
+ *
+ * @example
+ *   // `child` should be accessible via `type.get(path[0]).get(path[1])..`
+ *   const path = type.getPathTo(child)
+ *   // assuming `type instanceof YArray`
+ *   console.log(path) // might look like => [2, 'key1']
+ *   child === type.get(path[0]).get(path[1])
+ *
+ * @param {_YType} parent
+ * @param {_YType} child target
+ * @param {AbstractAttributionManager} am
+ * @return {Array<string|number>} Path to the target
+ *
+ * @private
+ * @function
+ */
+const getPathTo = (parent, child, am = noAttributionsManager) => {
+  const path = [];
+  const doc = /** @type {Doc} */ (parent.doc);
+  while (child._item !== null && child !== parent) {
+    if (child._item.parentSub !== null) {
+      // parent is map-ish
+      path.unshift(child._item.parentSub);
+    } else {
+      const parent = /** @type {import('../utils/types.js').YType} */ (child._item.parent);
+      // parent is array-ish
+      const apos = /** @type {AbsolutePosition} */ (createAbsolutePositionFromRelativePosition(createRelativePosition(parent, child._item.id), doc, false, am));
+      path.unshift(apos.index);
+    }
+    child = /** @type {_YType} */ (child._item.parent);
+  }
+  return path
+};
+
+/**
+ * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder The decoder object to read data from.
+ * @param {Doc} doc
+ * @return {StructSet}
+ *
+ * @private
+ * @function
+ */
+const readStructSet = (decoder, doc) => {
+  const clientRefs = new StructSet();
+  const numOfStateUpdates = decoding.readVarUint(decoder.restDecoder);
+  for (let i = 0; i < numOfStateUpdates; i++) {
+    const numberOfStructs = decoding.readVarUint(decoder.restDecoder);
+    /**
+     * @type {Array<GC|Item>}
+     */
+    const refs = new Array(numberOfStructs);
+    const client = decoder.readClient();
+    let clock = decoding.readVarUint(decoder.restDecoder);
+    clientRefs.clients.set(client, new StructRange(refs));
+    for (let i = 0; i < numberOfStructs; i++) {
+      const info = decoder.readInfo();
+      switch (binary.BITS5 & info) {
+        case 0: { // GC
+          const len = decoder.readLen();
+          refs[i] = new GC(createID(client, clock), len);
+          clock += len;
+          break
+        }
+        case 10: { // Skip Struct (nothing to apply)
+          // @todo we could reduce the amount of checks by adding Skip struct to clientRefs so we know that something is missing.
+          const len = decoding.readVarUint(decoder.restDecoder);
+          refs[i] = new Skip(createID(client, clock), len);
+          clock += len;
+          break
+        }
+        default: { // Item with content
+          /**
+           * The optimized implementation doesn't use any variables because inlining variables is faster.
+           * Below a non-optimized version is shown that implements the basic algorithm with
+           * a few comments
+           */
+          const cantCopyParentInfo = (info & (binary.BIT7 | binary.BIT8)) === 0;
+          // If parent = null and neither left nor right are defined, then we know that `parent` is child of `y`
+          // and we read the next string as parentYKey.
+          // It indicates how we store/retrieve parent from `y.share`
+          // @type {string|null}
+          const struct = new Item(
+            createID(client, clock),
+            null, // left
+            (info & binary.BIT8) === binary.BIT8 ? decoder.readLeftID() : null, // origin
+            null, // right
+            (info & binary.BIT7) === binary.BIT7 ? decoder.readRightID() : null, // right origin
+            cantCopyParentInfo ? (decoder.readParentInfo() ? doc.get(decoder.readString()) : decoder.readLeftID()) : null, // parent
+            cantCopyParentInfo && (info & binary.BIT6) === binary.BIT6 ? decoder.readString() : null, // parentSub
+            readItemContent(decoder, info) // item content
+          );
+          refs[i] = struct;
+          clock += struct.length;
+        }
+      }
+    }
+  }
+  return clientRefs
+};
+
+/**
+ * Remove item-ranges from the StructSet.
+ *
+ * @param {StructSet} ss
+ * @param {IdSet} exclude
+ */
+const removeRangesFromStructSet = (ss, exclude) => {
+  // @todo walk through ss instead to reduce iterations
+  exclude.clients.forEach((range, client) => {
+    const structs = /** @type {StructRange} */ (ss.clients.get(client))?.refs;
+    if (structs != null) {
+      const firstStruct = structs[0];
+      const lastStruct = structs[structs.length - 1];
+      const idranges = range.getIds();
+      for (let i = 0; i < idranges.length; i++) {
+        const range = idranges[i];
+        let startIndex = 0;
+        if (range.clock >= lastStruct.id.clock + lastStruct.length) continue
+        if (range.clock > firstStruct.id.clock) {
+          startIndex = findIndexCleanStart(null, structs, range.clock);
+        }
+        let endIndex = structs.length; // must be set here, after structs is modified
+        if (range.clock + range.len <= firstStruct.id.clock) continue
+        if (range.clock + range.len < lastStruct.id.clock + lastStruct.length) {
+          endIndex = findIndexCleanStart(null, structs, range.clock + range.len);
+        }
+        if (startIndex < endIndex) {
+          structs[startIndex] = new Skip(new ID(client, range.clock), range.len);
+          const d = endIndex - startIndex;
+          if (d > 1) {
+            structs.splice(startIndex + 1, d - 1);
+          }
+        }
+      }
+    }
+  });
+};
+
+class StructRange {
+  /**
+   * @param {Array<Item|GC>} refs
+   */
+  constructor (refs) {
+    this.i = 0;
+    /**
+     * @type {Array<Item | GC>}
+     */
+    this.refs = refs;
+  }
+}
+
+class StructSet {
+  constructor () {
+    /**
+     * @type {Map<number, StructRange>}
+     */
+    this.clients = map.create();
+  }
+}
+
+/**
+ * @todo rename this to `Attribute`
+ * @template V
+ */
+class AttributionItem {
+  /**
+   * @param {string} name
+   * @param {V} val
+   */
+  constructor (name, val) {
+    this.name = name;
+    this.val = val;
+  }
+
+  hash () {
+    const encoder = encoding.createEncoder();
+    encoding.writeVarString(encoder, this.name);
+    encoding.writeAny(encoder, /** @type {any} */ (this.val));
+    return buffer.toBase64(rabin.fingerprint(rabin.StandardIrreducible128, encoding.toUint8Array(encoder)))
+  }
+}
+
+/**
+ * @todo rename this to `createAttribute`
+ * @template V
+ * @param {string} name
+ * @param {V} val
+ * @return {AttributionItem<V>}
+ */
+const createAttributionItem = (name, val) => new AttributionItem(name, val);
+
+/**
+ * @template T
+ * @param {Array<T>} attrs
+ * @param {T} attr
+ *
+ */
+const idmapAttrsHas = (attrs, attr) => attrs.find(a => a === attr);
+
+/**
+ * @template T
+ * @param {Array<T>} a
+ * @param {Array<T>} b
+ */
+const idmapAttrsEqual = (a, b) => a.length === b.length && a.every(v => idmapAttrsHas(b, v));
+
+/**
+ * @template T
+ * @param {Array<T>} a
+ * @param {Array<T>} b
+ */
+const idmapAttrRangeJoin = (a, b) => a.concat(b.filter(attr => !idmapAttrsHas(a, attr)));
+
+/**
+ * @template Attrs
+ */
+class AttrRange {
+  /**
+   * @param {number} clock
+   * @param {number} len
+   * @param {Array<AttributionItem<Attrs>>} attrs
+   */
+  constructor (clock, len, attrs) {
+    /**
+     * @readonly
+     */
+    this.clock = clock;
+    /**
+     * @readonly
+     */
+    this.len = len;
+    /**
+     * @readonly
+     */
+    this.attrs = attrs;
+  }
+
+  /**
+   * @param {number} clock
+   * @param {number} len
+   */
+  copyWith (clock, len) {
+    return new AttrRange(clock, len, this.attrs)
+  }
+}
+
+/**
+ * @template Attrs
+ * @typedef {{ clock: number, len: number, attrs: Array<AttributionItem<Attrs>>? }} MaybeAttrRange
+ */
+
+/**
+ * @template Attrs
+ *
+ * @param {number} clock
+ * @param {number} len
+ * @param {Array<AttributionItem<Attrs>>?} attrs
+ * @return {MaybeAttrRange<Attrs>}
+ */
+const createMaybeAttrRange = (clock, len, attrs) => new AttrRange(clock, len, /** @type {any} */ (attrs));
+
+/**
+ * Whenever this is instantiated, it must receive a fresh array of ops, not something copied.
+ *
+ * @template Attrs
+ */
+class AttrRanges {
+  /**
+   * @param {Array<AttrRange<Attrs>>} ids
+   */
+  constructor (ids) {
+    this.sorted = false;
+    /**
+     * @private
+     */
+    this._ids = ids;
+  }
+
+  copy () {
+    return new AttrRanges(this._ids.slice())
+  }
+
+  /**
+   * @param {number} clock
+   * @param {number} length
+   * @param {Array<AttributionItem<Attrs>>} attrs
+   */
+  add (clock, length, attrs) {
+    if (length === 0) return
+    this.sorted = false;
+    this._ids.push(new AttrRange(clock, length, attrs));
+  }
+
+  /**
+   * Return the list of id ranges, sorted and merged.
+   */
+  getIds () {
+    const ids = this._ids;
+    if (!this.sorted) {
+      this.sorted = true;
+      ids.sort((a, b) => a.clock - b.clock);
+      /**
+       * algorithm thoughts:
+       * - sort (by clock AND by length), bigger length is to the right (or not, we can't make
+       *   assumptions abouth length after long length has been split)
+       * -- maybe better: sort by clock+length. Then split items from right to left. This way, items are always
+       *   in the right order. But I also need to swap if left items is smaller after split
+       *   --- thought: there is no way to go around swapping. Unless, for each item from left to
+       *   right, when I have to split because one of the look-ahead items is overlapping, i split
+       *   it and merge the attributes into the following ones (that I also need to split). Best is
+       *   probably left to right with lookahead.
+       * - left to right, split overlapping items so that we can make the assumption that either an
+       *   item is overlapping with the next 1-on-1 or it is not overlapping at all (when splitting,
+       *   we can already incorporate the attributes)
+       *   -- better: for each item, go left to right and add own attributes to overlapping items.
+       *   Split them if necessary. After split, i must insert the retainer at a valid position.
+       * - merge items if neighbor has same attributes
+       */
+      for (let i = 0; i < ids.length - 1;) {
+        const range = ids[i];
+        const nextRange = ids[i + 1];
+        // find out how to split range. it must match with next range.
+        // 1) we have space. Split if necessary.
+        // 2) concat attributes in range to the next range. Split range and splice the remainder at
+        // the correct position.
+        if (range.clock < nextRange.clock) { // might need to split range
+          if (range.clock + range.len > nextRange.clock) {
+            // is overlapping
+            const diff = nextRange.clock - range.clock;
+            ids[i] = new AttrRange(range.clock, diff, range.attrs);
+            ids.splice(i + 1, 0, new AttrRange(nextRange.clock, range.len - diff, range.attrs));
+          }
+          i++;
+          continue
+        }
+        // now we know that range.clock === nextRange.clock
+        // merge range with nextRange
+        const largerRange = range.len > nextRange.len ? range : nextRange;
+        const smallerLen = range.len < nextRange.len ? range.len : nextRange.len;
+        ids[i] = new AttrRange(range.clock, smallerLen, idmapAttrRangeJoin(range.attrs, nextRange.attrs));
+        if (range.len === nextRange.len) {
+          ids.splice(i + 1, 1);
+        } else {
+          ids[i + 1] = new AttrRange(range.clock + smallerLen, largerRange.len - smallerLen, largerRange.attrs);
+          array.bubblesortItem(ids, i + 1, (a, b) => a.clock - b.clock);
+        }
+        if (smallerLen === 0) i++;
+      }
+      while (ids.length > 0 && ids[0].len === 0) {
+        ids.splice(0, 1);
+      }
+      // merge items without filtering or splicing the array.
+      // i is the current pointer
+      // j refers to the current insert position for the pointed item
+      // try to merge dels[i] into dels[j-1] or set dels[j]=dels[i]
+      let i, j;
+      for (i = 1, j = 1; i < ids.length; i++) {
+        const left = ids[j - 1];
+        const right = ids[i];
+        if (left.clock + left.len === right.clock && idmapAttrsEqual(left.attrs, right.attrs)) {
+          ids[j - 1] = new AttrRange(left.clock, left.len + right.len, left.attrs);
+        } else if (right.len !== 0) {
+          if (j < i) {
+            ids[j] = right;
+          }
+          j++;
+        }
+      }
+      ids.length = ids.length === 0 ? 0 : (ids[j - 1].len === 0 ? j - 1 : j);
+    }
+    return ids
+  }
+}
+
+/**
+ * Merge multiple idmaps. Ensures that there are no redundant attribution definitions (two
+ * Attributions that describe the same thing).
+ *
+ * @template T
+ * @param {Array<IdMap<T>>} ams
+ * @return {IdMap<T>} A fresh IdSet
+ */
+const mergeIdMaps = ams => {
+  /**
+   * Maps attribution to the attribution of the merged idmap.
+   *
+   * @type {Map<AttributionItem<any>,AttributionItem<any>>}
+   */
+  const attrMapper = new Map();
+  const merged = createIdMap();
+  for (let amsI = 0; amsI < ams.length; amsI++) {
+    ams[amsI].clients.forEach((rangesLeft, client) => {
+      if (!merged.clients.has(client)) {
+        // Write all missing keys from current set and all following.
+        // If merged already contains `client` current ds has already been added.
+        let ids = rangesLeft.getIds().slice();
+        for (let i = amsI + 1; i < ams.length; i++) {
+          const nextIds = ams[i].clients.get(client);
+          if (nextIds) {
+            array.appendTo(ids, nextIds.getIds());
+          }
+        }
+        ids = ids.map(id => new AttrRange(id.clock, id.len, id.attrs.map(attr =>
+          map.setIfUndefined(attrMapper, attr, () =>
+            _ensureAttrs(merged, [attr])[0]
+          )
+        )));
+        merged.clients.set(client, new AttrRanges(ids));
+      }
+    });
+  }
+  return merged
+};
+
+/**
+ * @param {IdSet} idset
+ * @param {Array<AttributionItem<any>>} attrs
+ */
+const createIdMapFromIdSet = (idset, attrs) => {
+  const idmap = createIdMap();
+  // map attrs to idmap
+  attrs = _ensureAttrs(idmap, attrs);
+  // filter out duplicates
+  /**
+   * @type {Array<AttributionItem<any>>}
+   */
+  const checkedAttrs = [];
+  attrs.forEach(attr => {
+    if (!idmapAttrsHas(checkedAttrs, attr)) {
+      checkedAttrs.push(attr);
+    }
+  });
+  idset.clients.forEach((ranges, client) => {
+    const attrRanges = new AttrRanges(ranges.getIds().map(range => new AttrRange(range.clock, range.len, checkedAttrs)));
+    attrRanges.sorted = true; // is sorted because idset is sorted
+    idmap.clients.set(client, attrRanges);
+  });
+  return idmap
+};
+
+/**
+ * @template Attrs
+ */
+class IdMap {
+  constructor () {
+    /**
+     * @type {Map<number,AttrRanges<Attrs>>}
+     */
+    this.clients = new Map();
+    /**
+     * @type {Map<string, AttributionItem<Attrs>>}
+     */
+    this.attrsH = new Map();
+    /**
+     * @type {Set<AttributionItem<Attrs>>}
+     */
+    this.attrs = new Set();
+  }
+
+  /**
+   * @param {(attrRange:AttrRange<Attrs>, client:number) => void} f
+   */
+  forEach (f) {
+    this.clients.forEach((ranges, client) => {
+      ranges.getIds().forEach((range) => {
+        f(range, client);
+      });
+    });
+  }
+
+  /**
+   * @param {ID} id
+   * @return {boolean}
+   */
+  hasId (id) {
+    return this.has(id.client, id.clock)
+  }
+
+  /**
+   * @param {number} client
+   * @param {number} clock
+   * @return {boolean}
+   */
+  has (client, clock) {
+    const dr = this.clients.get(client);
+    if (dr) {
+      return findIndexInIdRanges(dr.getIds(), clock) !== null
+    }
+    return false
+  }
+
+  /**
+   * Return attributions for a slice of ids.
+   *
+   * @param {ID} id
+   * @param {number} len
+   * @return {Array<MaybeAttrRange<Attrs>>}
+   */
+  sliceId (id, len) {
+    return this.slice(id.client, id.clock, len)
+  }
+
+  /**
+   * Return attributions for a slice of ids.
+   *
+   * @param {number} client
+   * @param {number} clock
+   * @param {number} len
+   * @return {Array<MaybeAttrRange<Attrs>>}
+   */
+  slice (client, clock, len) {
+    const dr = this.clients.get(client);
+    /**
+     * @type {Array<MaybeAttrRange<Attrs>>}
+     */
+    const res = [];
+    if (dr) {
+      /**
+       * @type {Array<AttrRange<Attrs>>}
+       */
+      const ranges = dr.getIds();
+      let index = findRangeStartInIdRanges(ranges, clock);
+      if (index !== null) {
+        let prev = null;
+        while (index < ranges.length) {
+          let r = ranges[index];
+          if (r.clock < clock) {
+            r = new AttrRange(clock, r.len - (clock - r.clock), r.attrs);
+          }
+          if (r.clock + r.len > clock + len) {
+            r = new AttrRange(r.clock, clock + len - r.clock, r.attrs);
+          }
+          if (r.len <= 0) break
+          const prevEnd = prev != null ? prev.clock + prev.len : clock;
+          if (prevEnd < r.clock) {
+            res.push(createMaybeAttrRange(prevEnd, r.clock - prevEnd, null));
+          }
+          prev = r;
+          res.push(r);
+          index++;
+        }
+      }
+    }
+    if (res.length > 0) {
+      const last = res[res.length - 1];
+      const end = last.clock + last.len;
+      if (end < clock + len) {
+        res.push(createMaybeAttrRange(end, clock + len - end, null));
+      }
+    } else {
+      res.push(createMaybeAttrRange(clock, len, null));
+    }
+    return res
+  }
+
+  /**
+   * @param {number} client
+   * @param {number} clock
+   * @param {number} len
+   * @param {Array<AttributionItem<Attrs>>} attrs
+   */
+  add (client, clock, len, attrs) {
+    if (len === 0) return
+    attrs = _ensureAttrs(this, attrs);
+    const ranges = this.clients.get(client);
+    if (ranges == null) {
+      this.clients.set(client, new AttrRanges([new AttrRange(clock, len, attrs)]));
+    } else {
+      ranges.add(clock, len, attrs);
+    }
+  }
+
+  /**
+   * @param {number} client
+   * @param {number} clock
+   * @param {number} len
+   */
+  delete (client, clock, len) {
+    _deleteRangeFromIdSet(this, client, clock, len);
+  }
+}
+
+/**
+ * Efficiently encodes IdMap to a binary form. Ensures that information is de-duplicated when
+ * written. Attribute.names are referenced by id. Attributes themselfs are also referenced by id.
+ *
+ * @template Attr
+ * @param {IdSetEncoderV1 | IdSetEncoderV2} encoder
+ * @param {IdMap<Attr>} idmap
+ *
+ * @private
+ * @function
+ */
+const writeIdMap = (encoder, idmap) => {
+  encoding.writeVarUint(encoder.restEncoder, idmap.clients.size);
+  let lastWrittenClientId = 0;
+  /**
+   * @type {Map<AttributionItem<Attr>, number>}
+   */
+  const visitedAttributions = map.create();
+  /**
+   * @type {Map<string, number>}
+   */
+  const visitedAttrNames = map.create();
+  // Ensure that the ids are written in a deterministic order (smaller clientids first)
+  array.from(idmap.clients.entries())
+    .sort((a, b) => a[0] - b[0])
+    .forEach(([client, _idRanges]) => {
+      const attrRanges = _idRanges.getIds();
+      encoder.resetIdSetCurVal();
+      const diff = client - lastWrittenClientId;
+      encoding.writeVarUint(encoder.restEncoder, diff);
+      lastWrittenClientId = client;
+      const len = attrRanges.length;
+      encoding.writeVarUint(encoder.restEncoder, len);
+      for (let i = 0; i < len; i++) {
+        const item = attrRanges[i];
+        const attrs = item.attrs;
+        const attrLen = attrs.length;
+        encoder.writeIdSetClock(item.clock);
+        encoder.writeIdSetLen(item.len);
+        encoding.writeVarUint(encoder.restEncoder, attrLen);
+        for (let j = 0; j < attrLen; j++) {
+          const attr = attrs[j];
+          const attrId = visitedAttributions.get(attr);
+          if (attrId != null) {
+            encoding.writeVarUint(encoder.restEncoder, attrId);
+          } else {
+            const newAttrId = visitedAttributions.size;
+            visitedAttributions.set(attr, newAttrId);
+            encoding.writeVarUint(encoder.restEncoder, newAttrId);
+            const attrNameId = visitedAttrNames.get(attr.name);
+            // write attr.name
+            if (attrNameId != null) {
+              encoding.writeVarUint(encoder.restEncoder, attrNameId);
+            } else {
+              const newAttrNameId = visitedAttrNames.size;
+              encoding.writeVarUint(encoder.restEncoder, newAttrNameId);
+              encoding.writeVarString(encoder.restEncoder, attr.name);
+              visitedAttrNames.set(attr.name, newAttrNameId);
+            }
+            encoding.writeAny(encoder.restEncoder, /** @type {any} */ (attr.val));
+          }
+        }
+      }
+    });
+};
+
+/**
+ * @param {IdMap<any>} idmap
+ */
+const encodeIdMap = idmap => {
+  const encoder = new IdSetEncoderV2();
+  writeIdMap(encoder, idmap);
+  return encoder.toUint8Array()
+};
+
+/**
+ * @param {DSDecoderV1 | DSDecoderV2} decoder
+ * @return {IdMap<any>}
+ *
+ * @private
+ * @function
+ */
+const readIdMap = decoder => {
+  const idmap = new IdMap();
+  const numClients = decoding.readVarUint(decoder.restDecoder);
+  /**
+   * @type {Array<AttributionItem<any>>}
+   */
+  const visitedAttributions = [];
+  /**
+   * @type {Array<string>}
+   */
+  const visitedAttrNames = [];
+  let lastClientId = 0;
+  for (let i = 0; i < numClients; i++) {
+    decoder.resetDsCurVal();
+    const client = lastClientId + decoding.readVarUint(decoder.restDecoder);
+    lastClientId = client;
+    const numberOfDeletes = decoding.readVarUint(decoder.restDecoder);
+    /**
+     * @type {Array<AttrRange<any>>}
+     */
+    const attrRanges = [];
+    for (let i = 0; i < numberOfDeletes; i++) {
+      const rangeClock = decoder.readDsClock();
+      const rangeLen = decoder.readDsLen();
+      /**
+       * @type {Array<AttributionItem<any>>}
+       */
+      const attrs = [];
+      const attrsLen = decoding.readVarUint(decoder.restDecoder);
+      for (let j = 0; j < attrsLen; j++) {
+        const attrId = decoding.readVarUint(decoder.restDecoder);
+        if (attrId >= visitedAttributions.length) {
+          // attrId not known yet
+          const attrNameId = decoding.readVarUint(decoder.restDecoder);
+          if (attrNameId >= visitedAttrNames.length) {
+            visitedAttrNames.push(decoding.readVarString(decoder.restDecoder));
+          }
+          visitedAttributions.push(new AttributionItem(visitedAttrNames[attrNameId], decoding.readAny(decoder.restDecoder)));
+        }
+        attrs.push(visitedAttributions[attrId]);
+      }
+      attrRanges.push(new AttrRange(rangeClock, rangeLen, attrs));
+    }
+    idmap.clients.set(client, new AttrRanges(attrRanges));
+  }
+  visitedAttributions.forEach(attr => {
+    idmap.attrs.add(attr);
+    idmap.attrsH.set(attr.hash(), attr);
+  });
+  return idmap
+};
+
+/**
+ * @param {Uint8Array} data
+ * @return {IdMap<any>}
+ */
+const decodeIdMap = data => readIdMap(new DSDecoderV2(decoding.createDecoder(data)));
+
+/**
+ * @template Attrs
+ * @param {IdMap<Attrs>} idmap
+ * @param {Array<AttributionItem<Attrs>>} attrs
+ * @return {Array<AttributionItem<Attrs>>}
+ */
+const _ensureAttrs = (idmap, attrs) => attrs.map(attr =>
+  idmap.attrs.has(attr)
+    ? attr
+    : map.setIfUndefined(idmap.attrsH, attr.hash(), () => {
+      idmap.attrs.add(attr);
+      return attr
+    }));
+
+const createIdMap = () => new IdMap();
+
+/**
+ * @template T
+ * @param {IdMap<T>} dest
+ * @param {IdMap<T>} src
+ */
+const insertIntoIdMap = _insertIntoIdSet;
+
+/**
+ * Remove all ranges from `exclude` from `ds`. The result is a fresh IdMap containing all ranges from `idSet` that are not
+ * in `exclude`.
+ *
+ * @template {IdMap<any>} ISet
+ * @param {ISet} set
+ * @param {IdSet | IdMap<any>} exclude
+ * @return {ISet}
+ */
+const diffIdMap = (set, exclude) => {
+  const diffed = _diffSet(set, exclude);
+  diffed.attrs = set.attrs;
+  diffed.attrsH = set.attrsH;
+  return diffed
+};
+
+const intersectMaps = _intersectSets;
+
+const attributionJsonSchema = s.$object({
+  insert: s.$array(s.$string).optional,
+  insertedAt: s.$number.optional,
+  delete: s.$array(s.$string).optional,
+  deletedAt: s.$number.optional,
+  format: s.$record(s.$string, s.$array(s.$string)).optional,
+  formatAt: s.$number.optional
+});
+
+/**
+ * @todo rename this to `insertBy`, `insertAt`, ..
+ *
+ * @typedef {s.Unwrap<typeof attributionJsonSchema>} Attribution
+ */
+
+/**
+ * @todo SHOULD NOT RETURN AN OBJECT!
+ * @param {Array<import('./IdMap.js').AttributionItem<any>>?} attrs
+ * @param {boolean} deleted - whether the attributed item is deleted
+ * @return {Attribution?}
+ */
+const createAttributionFromAttributionItems = (attrs, deleted) => {
+  if (attrs == null) {
+    return null
+  }
+  /**
+   * @type {Attribution}
+   */
+  const attribution = {};
+  if (deleted) {
+    attribution.delete = s.$array(s.$string).cast([]);
+  } else {
+    attribution.insert = [];
+  }
+  attrs.forEach(attr => {
+    switch (attr.name) {
+      // eslint-disable-next-line no-fallthrough
+      case 'insert':
+      case 'delete': {
+        const as = /** @type {import('lib0/delta').Attribution} */ (attribution);
+        const ls = as[attr.name] = as[attr.name] ?? [];
+        ls.push(attr.val);
+        break
+      }
+      default: {
+        if (attr.name[0] !== '_') {
+          /** @type {any} */ (attribution)[attr.name] = attr.val;
+        }
+      }
+    }
+  });
+  return attribution
+};
+
+/**
+ * @template T
+ */
+class AttributedContent {
+  /**
+   * @param {AbstractContent} content
+   * @param {number} clock
+   * @param {boolean} deleted
+   * @param {Array<import('./IdMap.js').AttributionItem<T>> | null} attrs
+   * @param {0|1|2} renderBehavior
+   */
+  constructor (content, clock, deleted, attrs, renderBehavior) {
+    this.content = content;
+    this.clock = clock;
+    this.deleted = deleted;
+    this.attrs = attrs;
+    this.render = renderBehavior === 0 ? false : (renderBehavior === 1 ? (!deleted || attrs != null) : true);
+  }
+}
+
+/**
+ * Abstract class for associating Attributions to content / changes
+ *
+ * Should fire an event when the attributions changed _after_ the original change happens. This
+ * Event will be used to update the attribution on the current content.
+ *
+ * @extends {ObservableV2<{change:(idset:IdSet,origin:any,local:boolean)=>void}>}
+ */
+class AbstractAttributionManager extends ObservableV2 {
+  /**
+   * @param {Array<AttributedContent<any>>} _contents - where to write the result
+   * @param {number} _client
+   * @param {number} _clock
+   * @param {boolean} _deleted
+   * @param {AbstractContent} _content
+   * @param {0|1|2} _shouldRender - 0: if undeleted or attributed, render as a retain operation. 1: render only if undeleted or attributed. 2: render as insert operation (if unattributed and deleted, render as delete).
+   */
+  readContent (_contents, _client, _clock, _deleted, _content, _shouldRender) {
+    error.methodUnimplemented();
+  }
+
+  /**
+   * Calculate the length of the attributed content. This is used by iterators that walk through the
+   * content.
+   *
+   * If the content is not countable, it should return 0.
+   *
+   * @param {Item} _item
+   * @return {number}
+   */
+  contentLength (_item) {
+    error.methodUnimplemented();
+  }
+}
+
+/**
+ * @implements AbstractAttributionManager
+ *
+ * @extends {ObservableV2<{change:(idset:IdSet,origin:any,local:boolean)=>void}>}
+ */
+class TwosetAttributionManager extends ObservableV2 {
+  /**
+   * @param {IdMap<any>} inserts
+   * @param {IdMap<any>} deletes
+   */
+  constructor (inserts, deletes) {
+    super();
+    this.inserts = inserts;
+    this.deletes = deletes;
+  }
+
+  /**
+   * @param {Array<AttributedContent<any>>} contents - where to write the result
+   * @param {number} client
+   * @param {number} clock
+   * @param {boolean} deleted
+   * @param {AbstractContent} content
+   * @param {0|1|2} shouldRender - whether this should render or just result in a `retain` operation
+   */
+  readContent (contents, client, clock, deleted, content, shouldRender) {
+    const slice = (deleted ? this.deletes : this.inserts).slice(client, clock, content.getLength());
+    content = slice.length === 1 ? content : content.copy();
+    slice.forEach(s => {
+      const c = content;
+      if (s.len < c.getLength()) {
+        content = c.splice(s.len);
+      }
+      if (!deleted || s.attrs != null || shouldRender) {
+        contents.push(new AttributedContent(c, s.clock, deleted, s.attrs, shouldRender));
+      }
+    });
+  }
+
+  /**
+   * @param {Item} item
+   * @return {number}
+   */
+  contentLength (item) {
+    if (!item.content.isCountable()) {
+      return 0
+    } else if (!item.deleted) {
+      return item.length
+    } else {
+      return this.deletes.sliceId(item.id, item.length).reduce((len, s) => s.attrs != null ? len + s.len : len, 0)
+    }
+  }
+}
+
+/**
+ * Abstract class for associating Attributions to content / changes
+ *
+ * @implements AbstractAttributionManager
+ *
+ * @extends {ObservableV2<{change:(idset:IdSet,origin:any,local:boolean)=>void}>}
+ */
+class NoAttributionsManager extends ObservableV2 {
+  /**
+   * @param {Array<AttributedContent<any>>} contents - where to write the result
+   * @param {number} _client
+   * @param {number} clock
+   * @param {boolean} deleted
+   * @param {AbstractContent} content
+   * @param {0|1|2} shouldRender - whether this should render or just result in a `retain` operation
+   */
+  readContent (contents, _client, clock, deleted, content, shouldRender) {
+    if (!deleted || shouldRender) {
+      contents.push(new AttributedContent(content, clock, deleted, null, shouldRender));
+    }
+  }
+
+  /**
+   * @param {Item} item
+   * @return {number}
+   */
+  contentLength (item) {
+    return (item.deleted || !item.content.isCountable()) ? 0 : item.length
+  }
+}
+
+const noAttributionsManager = new NoAttributionsManager();
+
+/**
+ * @param {StructStore} store
+ * @param {number} client
+ * @param {number} clock
+ * @param {number} len
+ */
+const getItemContent = (store, client, clock, len) => {
+  // Retrieved item is never more fragmented than the newer item.
+  const prevItem = getItem(store, createID(client, clock));
+  const diffStart = clock - prevItem.id.clock;
+  let content = prevItem.length > 1 ? prevItem.content.copy() : prevItem.content;
+  // trim itemContent to the correct size.
+  if (diffStart > 0) {
+    content = content.splice(diffStart);
+  }
+  if (len < content.getLength()) {
+    content.splice(len);
+  }
+  return content
+};
+
+/**
+ * @param {Transaction?} tr - only specify this if you want to fill the content of deleted content
+ * @param {DiffAttributionManager} am
+ * @param {ID} start
+ * @param {ID} end
+ * @param {boolean} collectAll - collect as many items as possible. Accept adding redundant changes.
+ */
+const collectSuggestedChanges = (tr, am, start, end, collectAll) => {
+  const inserts = createIdSet();
+  const deletes = createIdSet();
+  const store = am._nextDoc.store;
+  /**
+   * make sure to collect suggestions until all formats are closed
+   * @type {Set<string>}
+   */
+  const openedCollectedFormats = new Set();
+  /**
+   * @type {Item?}
+   */
+  let item = getItem(store, start);
+  const endItem = start === end ? item : (end == null ? null : getItem(store, end));
+
+  // walk to the left and find first un-attributed change that is rendered
+  while (item.left != null) {
+    item = item.left;
+    if (item.content instanceof ContentFormat && item.content.value == null) {
+      item = item.right;
+      break
+    }
+    if (!item.deleted) {
+      const slice = am.inserts.slice(item.id.client, item.id.clock, item.length);
+      if (slice.some(s => s.attrs === null)) {
+        for (let i = slice.length - 1; i >= 0; i--) {
+          const s = slice[i];
+          if (s.attrs == null) break
+          inserts.add(item.id.client, s.clock, s.len);
+        }
+        item = item.right;
+        break
+      }
+    }
+  }
+  let foundEndItem = false;
+  // eslint-disable-next-line
+  itemLoop: while (item != null) {
+    const itemClient = item.id.client;
+    const slice = (item.deleted ? am.deletes : am.inserts).slice(itemClient, item.id.clock, item.length);
+    foundEndItem ||= item === endItem;
+    if (item.deleted) {
+      // item probably gc'd content. Need to split item and fill with content again
+      for (let i = slice.length - 1; i >= 0; i--) {
+        const s = slice[i];
+        if (s.attrs != null || collectAll) {
+          deletes.add(itemClient, s.clock, s.len);
+          if (collectAll) {
+            // in case item has been added and deleted this might be necessary. the forked document
+            // will automatically filter this if it doesn't have it already.
+            inserts.add(itemClient, s.clock, s.len);
+          }
+        }
+        if (tr != null) {
+          const splicedItem = getItemCleanStart(tr, createID(itemClient, s.clock));
+          if (s.attrs != null) {
+            splicedItem.content = getItemContent(am._prevDocStore, itemClient, s.clock, s.len);
+          }
+        }
+      }
+    } else {
+      if (item.content instanceof ContentFormat) {
+        const { key, value } = item.content;
+        if (value == null) {
+          openedCollectedFormats.delete(key);
+        } else {
+          openedCollectedFormats.add(key);
+        }
+      }
+      for (let i = 0; i < slice.length; i++) {
+        const s = slice[i];
+        if (s.attrs != null) {
+          inserts.add(itemClient, s.clock, s.len);
+        } else if (foundEndItem && openedCollectedFormats.size === 0) {
+          // eslint-disable-next-line
+          break itemLoop
+        }
+      }
+    }
+    item = item.right;
+  }
+  return { inserts, deletes }
+};
+
+/**
+ * @implements AbstractAttributionManager
+ *
+ * @extends {ObservableV2<{change:(idset:IdSet,origin:any,local:boolean)=>void}>}
+ */
+class DiffAttributionManager extends ObservableV2 {
+  /**
+   * @param {Doc} prevDoc
+   * @param {Doc} nextDoc
+   * @param {Object} [options] - options for the attribution manager
+   * @param {Array<import('./IdMap.js').AttributionItem<any>>} [options.attrs] - the attributes to apply to the diff
+   */
+  constructor (prevDoc, nextDoc, { attrs = [] } = {}) {
+    super();
+    const _nextDocInserts = createInsertSetFromStructStore(nextDoc.store, false); // unmaintained
+    const _prevDocInserts = createInsertSetFromStructStore(prevDoc.store, false); // unmaintained
+    const nextDocDeletes = createDeleteSetFromStructStore(nextDoc.store); // maintained
+    const prevDocDeletes = createDeleteSetFromStructStore(prevDoc.store); // maintained
+    this.inserts = createIdMapFromIdSet(diffIdSet(_nextDocInserts, _prevDocInserts), attrs);
+    this.deletes = createIdMapFromIdSet(diffIdSet(nextDocDeletes, prevDocDeletes), attrs);
+    this._prevDoc = prevDoc;
+    this._prevDocStore = prevDoc.store;
+    this._nextDoc = nextDoc;
+    // update before observer calls fired
+    this._nextBOH = nextDoc.on('beforeObserverCalls', tr => {
+      // update inserts
+      const diffInserts = diffIdSet(tr.insertSet, _prevDocInserts);
+      insertIntoIdMap(this.inserts, createIdMapFromIdSet(diffInserts, attrs));
+      // update deletes
+      const diffDeletes = diffIdSet(diffIdSet(tr.deleteSet, prevDocDeletes), this.inserts);
+      insertIntoIdMap(this.deletes, createIdMapFromIdSet(diffDeletes, attrs));
+      // @todo fire update ranges on `diffInserts` and `diffDeletes`
+    });
+    this._prevBOH = prevDoc.on('beforeObserverCalls', tr => {
+      insertIntoIdSet(_prevDocInserts, tr.insertSet);
+      insertIntoIdSet(prevDocDeletes, tr.deleteSet);
+      // insertIntoIdMap(this.inserts, createIdMapFromIdSet(intersectSets(tr.insertSet, this.inserts), [createAttributionItem('acceptInsert', 'unknown')]))
+      if (tr.insertSet.clients.size < 2) {
+        tr.insertSet.forEach((attrRange, client) => {
+          this.inserts.delete(client, attrRange.clock, attrRange.len);
+        });
+      } else {
+        this.inserts = diffIdMap(this.inserts, tr.insertSet);
+      }
+      // insertIntoIdMap(this.deletes, createIdMapFromIdSet(intersectSets(tr.deleteSet, this.deletes), [createAttributionItem('acceptDelete', 'unknown')]))
+      if (tr.deleteSet.clients.size < 2) {
+        tr.deleteSet.forEach((attrRange, client) => {
+          this.deletes.delete(client, attrRange.clock, attrRange.len);
+        });
+      } else {
+        this.deletes = diffIdMap(this.deletes, tr.deleteSet);
+      }
+      // fire event of "changed" attributions. exclude items that were added & deleted in the same
+      // transaction
+      this.emit('change', [diffIdSet(mergeIdSets([tr.insertSet, tr.deleteSet]), intersectSets(tr.insertSet, tr.deleteSet)), tr.origin, tr.local]);
+    });
+    // changes from prevDoc should always flow into suggestionDoc
+    // changes from suggestionDoc only flow into ydoc if suggestion-mode is disabled
+    this._prevUpdateListener = prevDoc.on('update', (update, origin) => {
+      origin !== this && applyUpdate(nextDoc, update);
+    });
+    this._ndUpdateListener = nextDoc.on('update', (update, origin, _doc, tr) => {
+      // only if event is local and suggestion mode is enabled
+      if (!this.suggestionMode && tr.local && (this.suggestionOrigins == null || this.suggestionOrigins.some(o => o === origin))) {
+        applyUpdate(prevDoc, update, this);
+      }
+    });
+    this._afterTrListener = nextDoc.on('afterTransaction', (tr) => {
+      // apply deletes on attributed deletes (content that is already deleted, but is rendered by
+      // the attribution manager)
+      if (!this.suggestionMode && tr.local && (this.suggestionOrigins == null || this.suggestionOrigins.some(o => o === tr.origin))) {
+        const attributedDeletes = tr.meta.get('attributedDeletes');
+        if (attributedDeletes != null) {
+          transact(prevDoc, () => {
+            // apply attributed deletes if there are any
+            const ds = new UpdateEncoderV1();
+            encoding.writeVarUint(ds.restEncoder, 0); // encode 0 structs
+            writeIdSet(ds, attributedDeletes);
+            applyUpdate(prevDoc, ds.toUint8Array());
+          }, this);
+        }
+      }
+    });
+    this.suggestionMode = true;
+    /**
+     * Optionally limit origins that may sync changes to the main doc if suggestion-mode is
+     * disabled.
+     *
+     * @type {Array<any>?}
+     */
+    this.suggestionOrigins = null;
+    this._destroyHandler = nextDoc.on('destroy', this.destroy.bind(this));
+    prevDoc.on('destroy', this._destroyHandler);
+  }
+
+  destroy () {
+    super.destroy();
+    this._nextDoc.off('destroy', this._destroyHandler);
+    this._prevDoc.off('destroy', this._destroyHandler);
+    this._nextDoc.off('beforeObserverCalls', this._nextBOH);
+    this._prevDoc.off('beforeObserverCalls', this._prevBOH);
+    this._prevDoc.off('update', this._prevUpdateListener);
+    this._nextDoc.off('update', this._ndUpdateListener);
+    this._nextDoc.off('afterTransaction', this._afterTrListener);
+  }
+
+  acceptAllChanges () {
+    applyUpdate(this._prevDoc, encodeStateAsUpdate(this._nextDoc));
+  }
+
+  rejectAllChanges () {
+    this._prevDoc.transact(tr => {
+      applyUpdate(this._prevDoc, encodeStateAsUpdate(this._nextDoc));
+      const um = new UndoManager(this._prevDoc);
+      um.undoStack.push(new StackItem(tr.deleteSet, tr.insertSet));
+      um.undo();
+      um.destroy();
+    });
+  }
+
+  /**
+   * @param {ID} start
+   * @param {ID} end
+   */
+  acceptChanges (start, end = start) {
+    const { inserts, deletes } = collectSuggestedChanges(null, this, start, end, true);
+    const encoder = new UpdateEncoderV1();
+    writeStructsFromIdSet(encoder, this._nextDoc.store, inserts);
+    writeIdSet(encoder, deletes);
+    applyUpdate(this._prevDoc, encoder.toUint8Array());
+  }
+
+  /**
+   * @param {ID} start
+   * @param {ID} end
+   */
+  rejectChanges (start, end = start) {
+    this._nextDoc.transact(tr => {
+      const { inserts, deletes } = collectSuggestedChanges(tr, this, start, end, false);
+      const encoder = new UpdateEncoderV1();
+      writeStructsFromIdSet(encoder, this._nextDoc.store, inserts);
+      writeIdSet(encoder, deletes);
+      const um = new UndoManager(this._nextDoc);
+      um.undoStack.push(new StackItem(deletes, inserts));
+      um.undo();
+      um.destroy();
+    });
+    this.acceptChanges(start, end);
+  }
+
+  /**
+   * @param {Array<AttributedContent<any>>} contents - where to write the result
+   * @param {number} client
+   * @param {number} clock
+   * @param {boolean} deleted
+   * @param {AbstractContent} _content
+   * @param {0|1|2} shouldRender - whether this should render or just result in a `retain` operation
+   */
+  readContent (contents, client, clock, deleted, _content, shouldRender) {
+    const slice = (deleted ? this.deletes : this.inserts).slice(client, clock, _content.getLength());
+    /**
+     * @type {AbstractContent?}
+     */
+    let content = slice.length === 1 ? _content : _content.copy();
+    for (let i = 0; i < slice.length; i++) {
+      const s = slice[i];
+      if (content == null || content instanceof ContentDeleted) {
+        if ((!shouldRender && s.attrs == null) || this.inserts.has(client, s.clock)) {
+          continue
+        }
+        // Retrieved item is never more fragmented than the newer item.
+        const prevItem = getItem(this._prevDocStore, createID(client, s.clock));
+        const diffStart = s.clock - prevItem.id.clock;
+        content = prevItem.length > 1 ? prevItem.content.copy() : prevItem.content;
+        // trim itemContent to the correct size.
+        if (diffStart > 0) {
+          content = content.splice(diffStart);
+        }
+      }
+      const c = /** @type {AbstractContent} */ (content);
+      const clen = c.getLength();
+      if (clen < s.len) {
+        slice.splice(i + 1, 0, createMaybeAttrRange(s.clock + clen, s.len - clen, s.attrs));
+        s.len = clen;
+      }
+      content = s.len < clen ? c.splice(s.len) : null;
+      if (shouldRender || !deleted || s.attrs != null) {
+        contents.push(new AttributedContent(c, s.clock, deleted, s.attrs, shouldRender));
+      }
+    }
+  }
+
+  /**
+   * @param {Item} item
+   * @return {number}
+   */
+  contentLength (item) {
+    if (!item.deleted) {
+      return item.content.isCountable() ? item.length : 0
+    }
+    /**
+     * @type {Array<AttributedContent<any>>}
+     */
+    const cs = [];
+    this.readContent(cs, item.id.client, item.id.clock, true, item.content, 0);
+    return cs.reduce((cnt, c) => cnt + ((c.attrs != null && c.content.isCountable()) ? c.content.getLength() : 0), 0)
+  }
+}
+
+/**
+ * Attribute changes from ydoc1 to ydoc2.
+ *
+ * @param {Doc} prevDoc
+ * @param {Doc} nextDoc
+ * @param {Object} [options] - options for the attribution manager
+ * @param {Array<import('./IdMap.js').AttributionItem<any>>} [options.attrs] - the attributes to apply to the diff
+ */
+const createAttributionManagerFromDiff = (prevDoc, nextDoc, options) => new DiffAttributionManager(prevDoc, nextDoc, options);
+
+/**
+ * Intended for projects that used the v13 snapshot feature. With this AttributionManager you can
+ * read content similar to the previous snapshot api. Requires that `ydoc.gc` is turned off.
+ *
+ * @implements AbstractAttributionManager
+ *
+ * @extends {ObservableV2<{change:(idset:IdSet,origin:any,local:boolean)=>void}>}
+ */
+class SnapshotAttributionManager extends ObservableV2 {
+  /**
+   * @param {Snapshot} prevSnapshot
+   * @param {Snapshot} nextSnapshot
+   * @param {Object} [options] - options for the attribution manager
+   * @param {Array<import('./IdMap.js').AttributionItem<any>>} [options.attrs] - the attributes to apply to the diff
+   */
+  constructor (prevSnapshot, nextSnapshot, { attrs = [] } = {}) {
+    super();
+    this.prevSnapshot = prevSnapshot;
+    this.nextSnapshot = nextSnapshot;
+    const inserts = createIdMap();
+    const deletes = createIdMapFromIdSet(diffIdSet(nextSnapshot.ds, prevSnapshot.ds), attrs);
+    nextSnapshot.sv.forEach((clock, client) => {
+      const prevClock = prevSnapshot.sv.get(client) || 0;
+      inserts.add(client, 0, prevClock, []); // content is included in prevSnapshot is rendered without attributes
+      inserts.add(client, prevClock, clock - prevClock, attrs); // content is rendered as "inserted"
+    });
+    this.attrs = mergeIdMaps([diffIdMap(inserts, prevSnapshot.ds), deletes]);
+  }
+
+  /**
+   * @param {Array<AttributedContent<any>>} contents - where to write the result
+   * @param {number} client
+   * @param {number} clock
+   * @param {boolean} _deleted
+   * @param {AbstractContent} content
+   * @param {0|1|2} shouldRender - whether this should render or just result in a `retain` operation
+   */
+  readContent (contents, client, clock, _deleted, content, shouldRender) {
+    if ((this.nextSnapshot.sv.get(client) ?? 0) <= clock) return // future item that should not be displayed
+    const slice = this.attrs.slice(client, clock, content.getLength());
+    content = slice.length === 1 ? content : content.copy();
+    slice.forEach(s => {
+      const deleted = this.nextSnapshot.ds.has(client, s.clock);
+      const nonExistend = (this.nextSnapshot.sv.get(client) ?? 0) <= s.clock;
+      const c = content;
+      if (s.len < c.getLength()) {
+        content = c.splice(s.len);
+      }
+      if (nonExistend) return
+      if (shouldRender || !deleted || (s.attrs != null && s.attrs.length > 0)) {
+        let attrsWithoutChange = s.attrs?.filter(attr => attr.name !== 'change') ?? null;
+        if (s.attrs?.length === 0) {
+          attrsWithoutChange = null;
+        }
+        contents.push(new AttributedContent(c, s.clock, deleted, attrsWithoutChange, shouldRender));
+      }
+    });
+  }
+
+  /**
+   * @param {Item} item
+   * @return {number}
+   */
+  contentLength (item) {
+    return item.content.isCountable()
+      ? (item.deleted
+          ? this.attrs.sliceId(item.id, item.length).reduce((len, s) => s.attrs != null ? len + s.len : len, 0)
+          : item.length
+        )
+      : 0
+  }
+}
+
+/**
+ * @param {Snapshot} prevSnapshot
+ * @param {Snapshot} nextSnapshot
+ * @param {Object} [options] - options for the attribution manager
+ * @param {Array<import('./IdMap.js').AttributionItem<any>>} [options.attrs] - the attributes to apply to the diff
+ */
+const createAttributionManagerFromSnapshots = (prevSnapshot, nextSnapshot = prevSnapshot, options) => new SnapshotAttributionManager(prevSnapshot, nextSnapshot, options);
+
+/**
+ * @param {Doc} v1
+ * @param {Doc} v2
+ * @return {delta.DeltaBuilderAny}
+ */
+const diffDocsToDelta = (v1, v2, { am = createAttributionManagerFromDiff(v1, v2) } = {}) => {
+  const d = delta.create();
+  v2.transact(tr => {
+    v2.share.forEach((type, typename) => {
+      const insertDiff = diffIdSet(createInsertSetFromStructStore(v2.store, false), createInsertSetFromStructStore(v1.store, false));
+      const deleteDiff = diffIdSet(createDeleteSetFromStructStore(v2.store), createDeleteSetFromStructStore(v1.store));
+      // don't render items that have been inserted and then deleted
+      const insertsOnly = diffIdSet(insertDiff, deleteDiff);
+      const deletesOnly = diffIdSet(deleteDiff, insertDiff);
+      const itemsToRender = mergeIdSets([insertsOnly, deleteDiff]);
+      /**
+       * @type {Map<AbstractType, Set<string|null>>}
+       */
+      const changedTypes = new Map();
+      iterateStructsByIdSet(tr, itemsToRender, /** @param {any} item */ item => {
+        while (item instanceof Item) {
+          const parent = /** @type {AbstractType} */ (item.parent);
+          const conf = map.setIfUndefined(changedTypes, parent, set.create);
+          if (conf.has(item.parentSub)) break // has already been marked as modified
+          conf.add(item.parentSub);
+          item = parent._item;
+        }
+      });
+      const typeConf = changedTypes.get(type);
+      if (typeConf) {
+        // @ts-ignore
+        const shareDelta = type.getContent(am, {
+          itemsToRender, retainDeletes: true, deletedItems: deletesOnly, modified: changedTypes, deep: true
+        });
+        d.update(typename, shareDelta);
+      }
+    });
+  });
+  return d
+};
+
+/**
+ * @typedef {import('../utils/types.js').YType} YType_
+ */
+/**
+ * @typedef {import('../utils/types.js').YValue} _YValue
+ */
+
+/**
+ * https://docs.yjs.dev/getting-started/working-with-shared-types#caveats
+ */
+const warnPrematureAccess = () => { logging.warn('Invalid access: Add Yjs type to a document before reading data.'); };
+
+const maxSearchMarker = 80;
+
+/**
+ * A unique timestamp that identifies each marker.
+ *
+ * Time is relative,.. this is more like an ever-increasing clock.
+ *
+ * @type {number}
+ */
+let globalSearchMarkerTimestamp = 0;
+
+class ArraySearchMarker {
+  /**
+   * @param {Item} p
+   * @param {number} index
+   */
+  constructor (p, index) {
+    p.marker = true;
+    this.p = p;
+    this.index = index;
+    this.timestamp = globalSearchMarkerTimestamp++;
+  }
+}
+
+/**
+ * @param {ArraySearchMarker} marker
+ */
+const refreshMarkerTimestamp = marker => { marker.timestamp = globalSearchMarkerTimestamp++; };
+
+/**
+ * This is rather complex so this function is the only thing that should overwrite a marker
+ *
+ * @param {ArraySearchMarker} marker
+ * @param {Item} p
+ * @param {number} index
+ */
+const overwriteMarker = (marker, p, index) => {
+  marker.p.marker = false;
+  marker.p = p;
+  p.marker = true;
+  marker.index = index;
+  marker.timestamp = globalSearchMarkerTimestamp++;
+};
+
+/**
+ * @param {Array<ArraySearchMarker>} searchMarker
+ * @param {Item} p
+ * @param {number} index
+ */
+const markPosition = (searchMarker, p, index) => {
+  if (searchMarker.length >= maxSearchMarker) {
+    // override oldest marker (we don't want to create more objects)
+    const marker = searchMarker.reduce((a, b) => a.timestamp < b.timestamp ? a : b);
+    overwriteMarker(marker, p, index);
+    return marker
+  } else {
+    // create new marker
+    const pm = new ArraySearchMarker(p, index);
+    searchMarker.push(pm);
+    return pm
+  }
+};
+
+/**
+ * Search marker help us to find positions in the associative array faster.
+ *
+ * They speed up the process of finding a position without much bookkeeping.
+ *
+ * A maximum of `maxSearchMarker` objects are created.
+ *
+ * This function always returns a refreshed marker (updated timestamp)
+ *
+ * @param {import('../utils/types.js').YType} yarray
+ * @param {number} index
+ */
+const findMarker = (yarray, index) => {
+  if (yarray._start === null || index === 0 || yarray._searchMarker === null) {
+    return null
+  }
+  const marker = yarray._searchMarker.length === 0 ? null : yarray._searchMarker.reduce((a, b) => math.abs(index - a.index) < math.abs(index - b.index) ? a : b);
+  let p = yarray._start;
+  let pindex = 0;
+  if (marker !== null) {
+    p = marker.p;
+    pindex = marker.index;
+    refreshMarkerTimestamp(marker); // we used it, we might need to use it again
+  }
+  // iterate to right if possible
+  while (p.right !== null && pindex < index) {
+    if (!p.deleted && p.countable) {
+      if (index < pindex + p.length) {
+        break
+      }
+      pindex += p.length;
+    }
+    p = p.right;
+  }
+  // iterate to left if necessary (might be that pindex > index)
+  while (p.left !== null && pindex > index) {
+    p = p.left;
+    if (!p.deleted && p.countable) {
+      pindex -= p.length;
+    }
+  }
+  // we want to make sure that p can't be merged with left, because that would screw up everything
+  // in that cas just return what we have (it is most likely the best marker anyway)
+  // iterate to left until p can't be merged with left
+  while (p.left !== null && p.left.id.client === p.id.client && p.left.id.clock + p.left.length === p.id.clock) {
+    p = p.left;
+    if (!p.deleted && p.countable) {
+      pindex -= p.length;
+    }
+  }
+
+  // @todo remove!
+  // assure position
+  // {
+  //   let start = yarray._start
+  //   let pos = 0
+  //   while (start !== p) {
+  //     if (!start.deleted && start.countable) {
+  //       pos += start.length
+  //     }
+  //     start = /** @type {Item} */ (start.right)
+  //   }
+  //   if (pos !== pindex) {
+  //     debugger
+  //     throw new Error('Gotcha position fail!')
+  //   }
+  // }
+  // if (marker) {
+  //   if (window.lengths == null) {
+  //     window.lengths = []
+  //     window.getLengths = () => window.lengths.sort((a, b) => a - b)
+  //   }
+  //   window.lengths.push(marker.index - pindex)
+  //   console.log('distance', marker.index - pindex, 'len', p && p.parent.length)
+  // }
+  if (marker !== null && math.abs(marker.index - pindex) < /** @type {any} */ (p.parent).length / maxSearchMarker) {
+    // adjust existing marker
+    overwriteMarker(marker, p, pindex);
+    return marker
+  } else {
+    // create new marker
+    return markPosition(yarray._searchMarker, p, pindex)
+  }
+};
+
+/**
+ * Update markers when a change happened.
+ *
+ * This should be called before doing a deletion!
+ *
+ * @param {Array<ArraySearchMarker>} searchMarker
+ * @param {number} index
+ * @param {number} len If insertion, len is positive. If deletion, len is negative.
+ */
+const updateMarkerChanges = (searchMarker, index, len) => {
+  for (let i = searchMarker.length - 1; i >= 0; i--) {
+    const m = searchMarker[i];
+    if (len > 0) {
+      /**
+       * @type {Item|null}
+       */
+      let p = m.p;
+      p.marker = false;
+      // Ideally we just want to do a simple position comparison, but this will only work if
+      // search markers don't point to deleted items for formats.
+      // Iterate marker to prev undeleted countable position so we know what to do when updating a position
+      while (p && (p.deleted || !p.countable)) {
+        p = p.left;
+        if (p && !p.deleted && p.countable) {
+          // adjust position. the loop should break now
+          m.index -= p.length;
+        }
+      }
+      if (p === null || p.marker === true) {
+        // remove search marker if updated position is null or if position is already marked
+        searchMarker.splice(i, 1);
+        continue
+      }
+      m.p = p;
+      p.marker = true;
+    }
+    if (index < m.index || (len > 0 && index === m.index)) { // a simple index <= m.index check would actually suffice
+      m.index = math.max(index, m.index + len);
+    }
+  }
+};
+
+/**
+ * Accumulate all (list) children of a type and return them as an Array.
+ *
+ * @param {import('../utils/types.js').YType} t
+ * @return {Array<Item>}
+ */
+const getTypeChildren = t => {
+  t.doc ?? warnPrematureAccess();
+  let s = t._start;
+  const arr = [];
+  while (s) {
+    arr.push(s);
+    s = s.right;
+  }
+  return arr
+};
+
+/**
+ * Call event listeners with an event. This will also add an event to all
+ * parents (for `.observeDeep` handlers).
+ *
+ * @param {import('../utils/types.js').YType} type
+ * @param {Transaction} transaction
+  * @param {YEvent<any>} event
+ */
+const callTypeObservers = (type, transaction, event) => {
+  const changedType = type;
+  const changedParentTypes = transaction.changedParentTypes;
+  while (true) {
+    // @ts-ignore
+    map.setIfUndefined(changedParentTypes, type, () => []).push(event);
+    if (type._item === null) {
+      break
+    }
+    type = /** @type {import('../utils/types.js').YType} */ (type._item.parent);
+  }
+  callEventHandlerListeners(/** @type {any} */ (changedType._eH), event, transaction);
+};
+
+/**
+ * Abstract Yjs Type class
+ * @template {delta.Delta<any,any,any,any,any>} [EventDelta=any]
+ * @template {AbstractType<any,any>} [Self=any]
+ */
+class AbstractType {
+  constructor () {
+    /**
+     * @type {Item|null}
+     */
+    this._item = null;
+    /**
+     * @type {Map<string,Item>}
+     */
+    this._map = new Map();
+    /**
+     * @type {Item|null}
+     */
+    this._start = null;
+    /**
+     * @type {Doc|null}
+     */
+    this.doc = null;
+    this._length = 0;
+    /**
+     * Event handlers
+     * @type {EventHandler<YEvent<Self>,Transaction>}
+     */
+    this._eH = createEventHandler();
+    /**
+     * Deep event handlers
+     * @type {EventHandler<Array<YEvent<any>>,Transaction>}
+     */
+    this._dEH = createEventHandler();
+    /**
+     * @type {null | Array<ArraySearchMarker>}
+     */
+    this._searchMarker = null;
+    /**
+     * @type {EventDelta?}
+     */
+    this._prelim = null;
+  }
+
+  /**
+   * Returns a fresh delta that can be used to change this YType.
+   * @type {EventDelta}
+   */
+  get change () {
+    return /** @type {any} */ (delta.create())
+  }
+
+  /**
+   * @return {import('../utils/types.js').YType|null}
+   */
+  get parent () {
+    return /** @type {import('../utils/types.js').YType} */ (this._item ? this._item.parent : null)
+  }
+
+  /**
+   * Integrate this type into the Yjs instance.
+   *
+   * * Save this struct in the os
+   * * This type is sent to other client
+   * * Observer functions are fired
+   *
+   * @param {Doc} y The Yjs instance
+   * @param {Item|null} item
+   */
+  _integrate (y, item) {
+    this.doc = y;
+    this._item = item;
+    if (this._prelim) {
+      this.applyDelta(this._prelim);
+      this._prelim = null;
+    }
+  }
+
+  /**
+   * @return {Self}
+   */
+  _copy () {
+    // @ts-ignore
+    return new this.constructor()
+  }
+
+  /**
+   * Makes a copy of this data type that can be included somewhere else.
+   *
+   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
+   *
+   * @return {Self}
+   */
+  clone () {
+    // @todo remove this method from othern types by doing `_copy().apply(this.getContent())`
+    throw error.methodUnimplemented()
+  }
+
+  /**
+   * @param {UpdateEncoderV1 | UpdateEncoderV2} _encoder
+   */
+  _write (_encoder) { }
+
+  /**
+   * The first non-deleted item
+   */
+  get _first () {
+    let n = this._start;
+    while (n !== null && n.deleted) {
+      n = n.right;
+    }
+    return n
+  }
+
+  /**
+   * Creates YEvent and calls all type observers.
+   * Must be implemented by each type.
+   *
+   * @param {Transaction} transaction
+   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
+   */
+  _callObserver (transaction, parentSubs) {
+    const event = new YEvent(/** @type {any} */ (this), transaction, parentSubs);
+    callTypeObservers(/** @type {any} */ (this), transaction, event);
+    if (!transaction.local && this._searchMarker) {
+      this._searchMarker.length = 0;
+    }
+  }
+
+  /**
+   * Observe all events that are created on this type.
+   *
+   * @template {(target: YEvent<Self>, tr: Transaction) => void} F
+   * @param {F} f Observer function
+   * @return {F}
+   */
+  observe (f) {
+    addEventHandlerListener(this._eH, f);
+    return f
+  }
+
+  /**
+   * Observe all events that are created by this type and its children.
+   *
+   * @template {function(Array<YEvent<any>>,Transaction):void} F
+   * @param {F} f Observer function
+   * @return {F}
+   */
+  observeDeep (f) {
+    addEventHandlerListener(this._dEH, f);
+    return f
+  }
+
+  /**
+   * Unregister an observer function.
+   *
+   * @param {(type:YEvent<Self>,tr:Transaction)=>void} f Observer function
+   */
+  unobserve (f) {
+    removeEventHandlerListener(this._eH, f);
+  }
+
+  /**
+   * Unregister an observer function.
+   *
+   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function
+   */
+  unobserveDeep (f) {
+    removeEventHandlerListener(this._dEH, f);
+  }
+
+  /**
+   * @abstract
+   * @return {any}
+   */
+  toJSON () {}
+
+  /**
+   * Render the difference to another ydoc (which can be empty) and highlight the differences with
+   * attributions.
+   *
+   * Note that deleted content that was not deleted in prevYdoc is rendered as an insertion with the
+   * attribution `{ isDeleted: true, .. }`.
+   *
+   * @template {boolean} [Deep=false]
+   *
+   * @param {AbstractAttributionManager} am
+   * @param {Object} [opts]
+   * @param {import('../utils/IdSet.js').IdSet?} [opts.itemsToRender]
+   * @param {boolean} [opts.retainInserts] - if true, retain rendered inserts with attributions
+   * @param {boolean} [opts.retainDeletes] - if true, retain rendered+attributed deletes only
+   * @param {import('../utils/IdSet.js').IdSet?} [opts.deletedItems] - used for computing prevItem in attributes
+   * @param {Map<import('../utils/types.js').YType,Set<string|null>>|null} [opts.modified] - set of types that should be rendered as modified children
+   * @param {Deep} [opts.deep] - render child types as delta
+   * @return {Deep extends true ? ToDeepEventDelta<EventDelta> : EventDelta} The Delta representation of this type.
+   *
+   * @public
+   */
+  getContent (am = noAttributionsManager, opts = {}) {
+    const { itemsToRender = null, retainInserts = false, retainDeletes = false, deletedItems = null, modified = null, deep = false } = opts;
+    const renderAttrs = modified?.get(this) || null;
+    const renderChildren = (modified == null || opts.modified.get(this)?.has(null));
+    /**
+     * @type {EventDelta extends delta.Delta<infer N,infer Attrs,infer Children,infer Text,any> ? delta.DeltaBuilder<N,Attrs,Children,Text,any> : never}
+     */
+    const d = /** @type {any} */ (delta.create(/** @type {any} */ (this).nodeName || null));
+    const optsAll = modified == null ? opts : object.assign({}, opts, { modified: null });
+    typeMapGetDelta(d, /** @type {any} */ (this), renderAttrs, am, deep, modified, deletedItems, itemsToRender, opts, optsAll);
+    if (renderChildren) {
+      /**
+       * @type {delta.FormattingAttributes}
+       */
+      let currentAttributes = {}; // saves all current attributes for insert
+      let usingCurrentAttributes = false;
+      /**
+       * @type {delta.FormattingAttributes}
+       */
+      let changedAttributes = {}; // saves changed attributes for retain
+      let usingChangedAttributes = false;
+      /**
+       * Logic for formatting attribute attribution
+       * Everything that comes after an formatting attribute is formatted by the user that created it.
+       * Two exceptions:
+       * - the user resets formatting to the previously known formatting that is not attributed
+       * - the user deletes a formatting attribute and hence restores the previously known formatting
+       *   that is not attributed.
+       * @type {delta.FormattingAttributes}
+       */
+      const previousUnattributedAttributes = {}; // contains previously known unattributed formatting
+      /**
+       * @type {delta.FormattingAttributes}
+       */
+      const previousAttributes = {}; // The value before changes
+      /**
+       * @type {Array<import('../internals.js').AttributedContent<any>>}
+       */
+      const cs = [];
+      for (let item = this._start; item !== null; cs.length = 0) {
+        if (itemsToRender != null) {
+          for (; item !== null && cs.length < 50; item = item.right) {
+            const rslice = itemsToRender.slice(item.id.client, item.id.clock, item.length);
+            let itemContent = rslice.length > 1 ? item.content.copy() : item.content;
+            for (let ir = 0; ir < rslice.length; ir++) {
+              const idrange = rslice[ir];
+              const content = itemContent;
+              if (ir !== rslice.length - 1) {
+                itemContent = itemContent.splice(idrange.len);
+              }
+              am.readContent(cs, item.id.client, idrange.clock, item.deleted, content, idrange.exists ? 2 : 0);
+            }
+          }
+        } else {
+          for (; item !== null && cs.length < 50; item = item.right) {
+            am.readContent(cs, item.id.client, item.id.clock, item.deleted, item.content, 1);
+          }
+        }
+        for (let i = 0; i < cs.length; i++) {
+          const c = cs[i];
+          // render (attributed) content even if it was deleted
+          const renderContent = c.render && (!c.deleted || c.attrs != null);
+          // content that was just deleted. It is not rendered as an insertion, because it doesn't
+          // have any attributes.
+          const renderDelete = c.render && c.deleted;
+          // existing content that should be retained, only adding changed attributes
+          const retainContent = !c.render && (!c.deleted || c.attrs != null);
+          const attribution = (renderContent || c.content.constructor === ContentFormat) ? createAttributionFromAttributionItems(c.attrs, c.deleted) : null;
+          switch (c.content.constructor) {
+            case ContentDeleted: {
+              if (renderDelete) d.delete(c.content.getLength());
+              break
+            }
+            case ContentString:
+              if (renderContent) {
+                d.usedAttributes = currentAttributes;
+                usingCurrentAttributes = true;
+                if (c.deleted ? retainDeletes : retainInserts) {
+                  d.retain(/** @type {ContentString} */ (c.content).str.length, null, attribution ?? {});
+                } else {
+                  d.insert(/** @type {ContentString} */ (c.content).str, null, attribution);
+                }
+              } else if (renderDelete) {
+                d.delete(c.content.getLength());
+              } else if (retainContent) {
+                d.usedAttributes = changedAttributes;
+                usingChangedAttributes = true;
+                d.retain(c.content.getLength());
+              }
+              break
+            case ContentEmbed:
+            case ContentAny:
+            case ContentJSON:
+            case ContentType:
+            case ContentBinary:
+              if (renderContent) {
+                d.usedAttributes = currentAttributes;
+                usingCurrentAttributes = true;
+                if (c.deleted ? retainDeletes : retainInserts) {
+                  d.retain(c.content.getLength(), null, attribution ?? {});
+                } else if (deep && c.content.constructor === ContentType) {
+                  d.insert([/** @type {any} */(c.content).type.getContent(am, optsAll)], null, attribution);
+                } else {
+                  d.insert(c.content.getContent(), null, attribution);
+                }
+              } else if (renderDelete) {
+                d.delete(1);
+              } else if (retainContent) {
+                if (c.content.constructor === ContentType && modified?.has(/** @type {ContentType} */ (c.content).type)) {
+                  // @todo use current transaction instead
+                  d.modify(/** @type {any} */ (c.content).type.getContent(am, opts));
+                } else {
+                  d.usedAttributes = changedAttributes;
+                  usingChangedAttributes = true;
+                  d.retain(1);
+                }
+              }
+              break
+            case ContentFormat: {
+              const { key, value } = /** @type {ContentFormat} */ (c.content);
+              const currAttrVal = currentAttributes[key] ?? null;
+              if (attribution != null && (c.deleted || !object.hasProperty(previousUnattributedAttributes, key))) {
+                previousUnattributedAttributes[key] = c.deleted ? value : currAttrVal;
+              }
+              // @todo write a function "updateCurrentAttributes" and "updateChangedAttributes"
+              // # Update Attributes
+              if (renderContent || renderDelete) {
+                // create fresh references
+                if (usingCurrentAttributes) {
+                  currentAttributes = object.assign({}, currentAttributes);
+                  usingCurrentAttributes = false;
+                }
+                if (usingChangedAttributes) {
+                  usingChangedAttributes = false;
+                  changedAttributes = object.assign({}, changedAttributes);
+                }
+              }
+              if (renderContent || renderDelete) {
+                if (c.deleted) {
+                  // content was deleted, but is possibly attributed
+                  if (!equalAttrs(value, currAttrVal)) { // do nothing if nothing changed
+                    if (equalAttrs(currAttrVal, previousAttributes[key] ?? null) && changedAttributes[key] !== undefined) {
+                      delete changedAttributes[key];
+                    } else {
+                      changedAttributes[key] = currAttrVal;
+                    }
+                    // current attributes doesn't change
+                    previousAttributes[key] = value;
+                  }
+                } else { // !c.deleted
+                  // content was inserted, and is possibly attributed
+                  if (equalAttrs(value, currAttrVal)) ; else if (equalAttrs(value, previousAttributes[key] ?? null)) {
+                    delete changedAttributes[key];
+                  } else {
+                    changedAttributes[key] = value;
+                  }
+                  if (value == null) {
+                    delete currentAttributes[key];
+                  } else {
+                    currentAttributes[key] = value;
+                  }
+                }
+              } else if (retainContent && !c.deleted) {
+                // fresh reference to currentAttributes only
+                if (usingCurrentAttributes) {
+                  currentAttributes = object.assign({}, currentAttributes);
+                  usingCurrentAttributes = false;
+                }
+                if (usingChangedAttributes && changedAttributes[key] !== undefined) {
+                  usingChangedAttributes = false;
+                  changedAttributes = object.assign({}, changedAttributes);
+                }
+                if (value == null) {
+                  delete currentAttributes[key];
+                } else {
+                  currentAttributes[key] = value;
+                }
+                delete changedAttributes[key];
+                previousAttributes[key] = value;
+              }
+              // # Update Attributions
+              if (attribution != null || object.hasProperty(previousUnattributedAttributes, key)) {
+                /**
+                 * @type {import('../utils/AttributionManager.js').Attribution}
+                 */
+                const formattingAttribution = object.assign({}, d.usedAttribution);
+                const changedAttributedAttributes = /** @type {{ [key: string]: Array<any> }} */ (formattingAttribution.format = object.assign({}, formattingAttribution.format ?? {}));
+                if (attribution == null || equalAttrs(previousUnattributedAttributes[key], currentAttributes[key] ?? null)) {
+                  // an unattributed formatting attribute was found or an attributed formatting
+                  // attribute was found that resets to the previous status
+                  delete changedAttributedAttributes[key];
+                  delete previousUnattributedAttributes[key];
+                } else {
+                  const by = changedAttributedAttributes[key] = (changedAttributedAttributes[key]?.slice() ?? []);
+                  by.push(...((c.deleted ? attribution.delete : attribution.insert) ?? []));
+                  const attributedAt = (c.deleted ? attribution.deletedAt : attribution.insertedAt);
+                  if (attributedAt) formattingAttribution.formatAt = attributedAt;
+                }
+                if (object.isEmpty(changedAttributedAttributes)) {
+                  d.useAttribution(null);
+                } else if (attribution != null) {
+                  const attributedAt = (c.deleted ? attribution.deletedAt : attribution.insertedAt);
+                  if (attributedAt != null) formattingAttribution.formatAt = attributedAt;
+                  d.useAttribution(formattingAttribution);
+                }
+              }
+              break
+            }
+          }
+        }
+      }
+    }
+    return /** @type {any} */ (d.done(false))
+  }
+
+  /**
+   * Render the difference to another ydoc (which can be empty) and highlight the differences with
+   * attributions.
+   *
+   * @param {AbstractAttributionManager} am
+   * @return {ToDeepEventDelta<EventDelta>}
+   */
+  getContentDeep (am = noAttributionsManager) {
+    return /** @type {any} */ (this.getContent(am, { deep: true }))
+  }
+
+  /**
+   * Apply a {@link Delta} on this shared type.
+   *
+   * @param {delta.Delta<any,any,any,any,any>} d The changes to apply on this element.
+   * @param {AbstractAttributionManager} am
+   *
+   * @public
+   */
+  applyDelta (d, am = noAttributionsManager) {
+    if (this.doc == null) {
+      (this._prelim || (this._prelim = /** @type {any} */ (delta.create()))).apply(d);
+    } else {
+      // @todo this was moved here from ytext. Make this more generic
+      transact(this.doc, transaction => {
+        const currPos = new ItemTextListPosition(null, this._start, 0, new Map(), am);
+        for (const op of d.children) {
+          if (delta.$textOp.check(op)) {
+            insertText(transaction, /** @type {any} */ (this), currPos, op.insert, op.format || {});
+          } else if (delta.$insertOp.check(op)) {
+            for (let i = 0; i < op.insert.length; i++) {
+              let ins = op.insert[i];
+              if (delta.$deltaAny.check(ins)) {
+                if (ins.name != null) {
+                  const t = new YXmlElement(ins.name);
+                  t.applyDelta(ins);
+                  ins = t;
+                } else {
+                  error.unexpectedCase();
+                }
+              }
+              insertText(transaction, /** @type {any} */ (this), currPos, ins, op.format || {});
+            }
+          } else if (delta.$retainOp.check(op)) {
+            currPos.formatText(transaction, /** @type {any} */ (this), op.retain, op.format || {});
+          } else if (delta.$deleteOp.check(op)) {
+            deleteText(transaction, currPos, op.delete);
+          } else if (delta.$modifyOp.check(op)) {
+            if (currPos.right) {
+              /** @type {ContentType} */ (currPos.right.content).type.applyDelta(op.value);
+            } else {
+              error.unexpectedCase();
+            }
+            currPos.formatText(transaction, /** @type {any} */ (this), 1, op.format || {});
+          } else {
+            error.unexpectedCase();
+          }
+        }
+        for (const op of d.attrs) {
+          if (delta.$insertOp.check(op)) {
+            typeMapSet(transaction, /** @type {any} */ (this), op.key, op.value);
+          } else if (delta.$deleteOp.check(op)) {
+            typeMapDelete(transaction, /** @type {any} */ (this), op.key);
+          } else {
+            const sub = typeMapGet(/** @type {any} */ (this), op.key);
+            if (!(sub instanceof AbstractType)) {
+              error.unexpectedCase();
+            }
+            sub.applyDelta(op.value);
+          }
+        }
+      });
+    }
+  }
+}
+
+/**
+ * @param {any} a
+ * @param {any} b
+ * @return {boolean}
+ */
+const equalAttrs = (a, b) => a === b || (typeof a === 'object' && typeof b === 'object' && a && b && object.equalFlat(a, b));
+
+/**
+ * @template {delta.Delta<any,any,any,any,any>} D
+ * @typedef {D extends delta.Delta<infer N,infer Attrs,infer Cs,infer Text,any>
+ *   ? delta.Delta<
+ *       N,
+ *       { [K in keyof Attrs]: TypeToDelta<Attrs[K]> },
+ *       TypeToDelta<Cs>,
+ *       Text
+ *     >
+ *   : D
+ * } ToDeepEventDelta
+ */
+
+/**
+ * @template {any} T
+ * @typedef {(Extract<T,AbstractType<any>> extends AbstractType<infer D> ? (unknown extends D ? never : ToDeepEventDelta<D>) : never) | Exclude<T,AbstractType<any>>} TypeToDelta
+ */
+
+/**
+ * @param {AbstractType<any>} type
+ * @param {number} start
+ * @param {number} end
+ * @return {Array<any>}
+ *
+ * @private
+ * @function
+ */
+const typeListSlice = (type, start, end) => {
+  type.doc ?? warnPrematureAccess();
+  if (start < 0) {
+    start = type._length + start;
+  }
+  if (end < 0) {
+    end = type._length + end;
+  }
+  let len = end - start;
+  const cs = [];
+  let n = type._start;
+  while (n !== null && len > 0) {
+    if (n.countable && !n.deleted) {
+      const c = n.content.getContent();
+      if (c.length <= start) {
+        start -= c.length;
+      } else {
+        for (let i = start; i < c.length && len > 0; i++) {
+          cs.push(c[i]);
+          len--;
+        }
+        start = 0;
+      }
+    }
+    n = n.right;
+  }
+  return cs
+};
+
+/**
+ * @param {import('../utils/types.js').YType} type
+ * @return {Array<any>}
+ *
+ * @private
+ * @function
+ */
+const typeListToArray = type => {
+  type.doc ?? warnPrematureAccess();
+  const cs = [];
+  let n = type._start;
+  while (n !== null) {
+    if (n.countable && !n.deleted) {
+      const c = n.content.getContent();
+      for (let i = 0; i < c.length; i++) {
+        cs.push(c[i]);
+      }
+    }
+    n = n.right;
+  }
+  return cs
+};
+
+/**
+ * @param {AbstractType<any>} type
+ * @param {Snapshot} snapshot
+ * @return {Array<any>}
+ *
+ * @private
+ * @function
+ */
+const typeListToArraySnapshot = (type, snapshot) => {
+  const cs = [];
+  let n = type._start;
+  while (n !== null) {
+    if (n.countable && isVisible(n, snapshot)) {
+      const c = n.content.getContent();
+      for (let i = 0; i < c.length; i++) {
+        cs.push(c[i]);
+      }
+    }
+    n = n.right;
+  }
+  return cs
+};
+
+/**
+ * Executes a provided function on once on every element of this YArray.
+ *
+ * @param {AbstractType<any>} type
+ * @param {function(any,number,any):void} f A function to execute on every element of this YArray.
+ *
+ * @private
+ * @function
+ */
+const typeListForEach = (type, f) => {
+  let index = 0;
+  let n = type._start;
+  type.doc ?? warnPrematureAccess();
+  while (n !== null) {
+    if (n.countable && !n.deleted) {
+      const c = n.content.getContent();
+      for (let i = 0; i < c.length; i++) {
+        f(c[i], index++, type);
+      }
+    }
+    n = n.right;
+  }
+};
+
+/**
+ * @template C,R
+ * @param {AbstractType<any>} type
+ * @param {function(C,number,AbstractType<any>):R} f
+ * @return {Array<R>}
+ *
+ * @private
+ * @function
+ */
+const typeListMap = (type, f) => {
+  /**
+   * @type {Array<any>}
+   */
+  const result = [];
+  typeListForEach(type, (c, i) => {
+    result.push(f(c, i, type));
+  });
+  return result
+};
+
+/**
+ * @param {AbstractType} type
+ * @return {IterableIterator<any>}
+ *
+ * @private
+ * @function
+ */
+const typeListCreateIterator = type => {
+  let n = type._start;
+  /**
+   * @type {Array<any>|null}
+   */
+  let currentContent = null;
+  let currentContentIndex = 0;
+  return {
+    [Symbol.iterator] () {
+      return this
+    },
+    next: () => {
+      // find some content
+      if (currentContent === null) {
+        while (n !== null && n.deleted) {
+          n = n.right;
+        }
+        // check if we reached the end, no need to check currentContent, because it does not exist
+        if (n === null) {
+          return {
+            done: true,
+            value: undefined
+          }
+        }
+        // we found n, so we can set currentContent
+        currentContent = n.content.getContent();
+        currentContentIndex = 0;
+        n = n.right; // we used the content of n, now iterate to next
+      }
+      const value = currentContent[currentContentIndex++];
+      // check if we need to empty currentContent
+      if (currentContent.length <= currentContentIndex) {
+        currentContent = null;
+      }
+      return {
+        done: false,
+        value
+      }
+    }
+  }
+};
+
+/**
+ * Executes a provided function on once on every element of this YArray.
+ * Operates on a snapshotted state of the document.
+ *
+ * @param {AbstractType} type
+ * @param {function(any,number,AbstractType):void} f A function to execute on every element of this YArray.
+ * @param {Snapshot} snapshot
+ *
+ * @private
+ * @function
+ */
+const typeListForEachSnapshot = (type, f, snapshot) => {
+  let index = 0;
+  let n = type._start;
+  while (n !== null) {
+    if (n.countable && isVisible(n, snapshot)) {
+      const c = n.content.getContent();
+      for (let i = 0; i < c.length; i++) {
+        f(c[i], index++, type);
+      }
+    }
+    n = n.right;
+  }
+};
+
+/**
+ * @param {import('../utils/types.js').YType} type
+ * @param {number} index
+ * @return {any}
+ *
+ * @private
+ * @function
+ */
+const typeListGet = (type, index) => {
+  type.doc ?? warnPrematureAccess();
+  const marker = findMarker(type, index);
+  let n = type._start;
+  if (marker !== null) {
+    n = marker.p;
+    index -= marker.index;
+  }
+  for (; n !== null; n = n.right) {
+    if (!n.deleted && n.countable) {
+      if (index < n.length) {
+        return n.content.getContent()[index]
+      }
+      index -= n.length;
+    }
+  }
+};
+
+/**
+ * @param {Transaction} transaction
+ * @param {YType_} parent
+ * @param {Item?} referenceItem
+ * @param {Array<_YValue>} content
+ *
+ * @private
+ * @function
+ */
+const typeListInsertGenericsAfter = (transaction, parent, referenceItem, content) => {
+  let left = referenceItem;
+  const doc = transaction.doc;
+  const ownClientId = doc.clientID;
+  const store = doc.store;
+  const right = referenceItem === null ? parent._start : referenceItem.right;
+  /**
+   * @type {Array<Object|Array<any>|number|null>}
+   */
+  let jsonContent = [];
+  const packJsonContent = () => {
+    if (jsonContent.length > 0) {
+      left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentAny(jsonContent));
+      left.integrate(transaction, 0);
+      jsonContent = [];
+    }
+  };
+  content.forEach(c => {
+    if (c === null) {
+      jsonContent.push(c);
+    } else {
+      switch (c.constructor) {
+        case Number:
+        case Object:
+        case undefined:
+        case Boolean:
+        case Array:
+        case String:
+        case BigInt:
+        case Date:
+          jsonContent.push(c);
+          break
+        default:
+          packJsonContent();
+          switch (c.constructor) {
+            case Uint8Array:
+            case ArrayBuffer:
+              left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentBinary(new Uint8Array(/** @type {Uint8Array} */ (c))));
+              left.integrate(transaction, 0);
+              break
+            case Doc:
+              left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentDoc(/** @type {Doc} */ (c)));
+              left.integrate(transaction, 0);
+              break
+            default:
+              if (c instanceof AbstractType) {
+                left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentType(/** @type {any} */ (c)));
+                left.integrate(transaction, 0);
+              } else {
+                throw new Error('Unexpected content type in insert operation')
+              }
+          }
+      }
+    }
+  });
+  packJsonContent();
+};
+
+const lengthExceeded = () => error.create('Length exceeded!');
+
+/**
+ * @param {Transaction} transaction
+ * @param {YType_} parent
+ * @param {number} index
+ * @param {Array<Object<string,any>|Array<any>|number|null|string|Uint8Array>} content
+ *
+ * @private
+ * @function
+ */
+const typeListInsertGenerics = (transaction, parent, index, content) => {
+  if (index > parent._length) {
+    throw lengthExceeded()
+  }
+  if (index === 0) {
+    if (parent._searchMarker) {
+      updateMarkerChanges(parent._searchMarker, index, content.length);
+    }
+    return typeListInsertGenericsAfter(transaction, parent, null, content)
+  }
+  const startIndex = index;
+  const marker = findMarker(parent, index);
+  let n = parent._start;
+  if (marker !== null) {
+    n = marker.p;
+    index -= marker.index;
+    // we need to iterate one to the left so that the algorithm works
+    if (index === 0) {
+      // @todo refactor this as it actually doesn't consider formats
+      n = n.prev; // important! get the left undeleted item so that we can actually decrease index
+      index += (n && n.countable && !n.deleted) ? n.length : 0;
+    }
+  }
+  for (; n !== null; n = n.right) {
+    if (!n.deleted && n.countable) {
+      if (index <= n.length) {
+        if (index < n.length) {
+          // insert in-between
+          getItemCleanStart(transaction, createID(n.id.client, n.id.clock + index));
+        }
+        break
+      }
+      index -= n.length;
+    }
+  }
+  if (parent._searchMarker) {
+    updateMarkerChanges(parent._searchMarker, startIndex, content.length);
+  }
+  return typeListInsertGenericsAfter(transaction, parent, n, content)
+};
+
+/**
+ * Pushing content is special as we generally want to push after the last item. So we don't have to update
+ * the search marker.
+ *
+ * @param {Transaction} transaction
+ * @param {YType_} parent
+ * @param {Array<Object<string,any>|Array<any>|number|null|string|Uint8Array>} content
+ *
+ * @private
+ * @function
+ */
+const typeListPushGenerics = (transaction, parent, content) => {
+  // Use the marker with the highest index and iterate to the right.
+  const marker = (parent._searchMarker || []).reduce((maxMarker, currMarker) => currMarker.index > maxMarker.index ? currMarker : maxMarker, { index: 0, p: parent._start });
+  let n = marker.p;
+  if (n) {
+    while (n.right) {
+      n = n.right;
+    }
+  }
+  return typeListInsertGenericsAfter(transaction, parent, n, content)
+};
+
+/**
+ * @param {Transaction} transaction
+ * @param {import('../utils/types.js').YType} parent
+ * @param {number} index
+ * @param {number} length
+ *
+ * @private
+ * @function
+ */
+const typeListDelete = (transaction, parent, index, length) => {
+  if (length === 0) { return }
+  const startIndex = index;
+  const startLength = length;
+  const marker = findMarker(parent, index);
+  let n = parent._start;
+  if (marker !== null) {
+    n = marker.p;
+    index -= marker.index;
+  }
+  // compute the first item to be deleted
+  for (; n !== null && index > 0; n = n.right) {
+    if (!n.deleted && n.countable) {
+      if (index < n.length) {
+        getItemCleanStart(transaction, createID(n.id.client, n.id.clock + index));
+      }
+      index -= n.length;
+    }
+  }
+  // delete all items until done
+  while (length > 0 && n !== null) {
+    if (!n.deleted) {
+      if (length < n.length) {
+        getItemCleanStart(transaction, createID(n.id.client, n.id.clock + length));
+      }
+      n.delete(transaction);
+      length -= n.length;
+    }
+    n = n.right;
+  }
+  if (length > 0) {
+    throw lengthExceeded()
+  }
+  if (parent._searchMarker) {
+    updateMarkerChanges(parent._searchMarker, startIndex, -startLength + length /* in case we remove the above exception */);
+  }
+};
+
+/**
+ * @param {Transaction} transaction
+ * @param {YType_} parent
+ * @param {string} key
+ *
+ * @private
+ * @function
+ */
+const typeMapDelete = (transaction, parent, key) => {
+  const c = parent._map.get(key);
+  if (c !== undefined) {
+    c.delete(transaction);
+  }
+};
+
+/**
+ * @param {Transaction} transaction
+ * @param {AbstractType} parent
+ * @param {string} key
+ * @param {_YValue} value
+ *
+ * @private
+ * @function
+ */
+const typeMapSet = (transaction, parent, key, value) => {
+  const left = parent._map.get(key) || null;
+  const doc = transaction.doc;
+  const ownClientId = doc.clientID;
+  let content;
+  if (value == null) {
+    content = new ContentAny([value]);
+  } else {
+    switch (value.constructor) {
+      case Number:
+      case Object:
+      case Boolean:
+      case Array:
+      case String:
+      case Date:
+      case BigInt:
+        content = new ContentAny([value]);
+        break
+      case Uint8Array:
+        content = new ContentBinary(/** @type {Uint8Array} */ (value));
+        break
+      case Doc:
+        content = new ContentDoc(/** @type {Doc} */ (value));
+        break
+      default:
+        if (value instanceof AbstractType) {
+          content = new ContentType(/** @type {any} */ (value));
+        } else {
+          throw new Error('Unexpected content type')
+        }
+    }
+  }
+  new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left && left.lastId, null, null, parent, key, content).integrate(transaction, 0);
+};
+
+/**
+ * @param {AbstractType<any,any>} parent
+ * @param {string} key
+ * @return {Object<string,any>|number|null|Array<any>|string|Uint8Array|AbstractType<any>|undefined}
+ *
+ * @private
+ * @function
+ */
+const typeMapGet = (parent, key) => {
+  parent.doc ?? warnPrematureAccess();
+  const val = parent._map.get(key);
+  return val !== undefined && !val.deleted ? val.content.getContent()[val.length - 1] : undefined
+};
+
+/**
+ * @param {AbstractType<any>} parent
+ * @return {Object<string,Object<string,any>|number|null|Array<any>|string|Uint8Array|AbstractType<any>|undefined>}
+ *
+ * @private
+ * @function
+ */
+const typeMapGetAll = (parent) => {
+  /**
+   * @type {Object<string,any>}
+   */
+  const res = {};
+  parent.doc ?? warnPrematureAccess();
+  parent._map.forEach((value, key) => {
+    if (!value.deleted) {
+      res[key] = value.content.getContent()[value.length - 1];
+    }
+  });
+  return res
+};
+
+/**
+ * @todo move this to getContent/getDelta
+ *
+ * Render the difference to another ydoc (which can be empty) and highlight the differences with
+ * attributions.
+ *
+ * Note that deleted content that was not deleted in prevYdoc is rendered as an insertion with the
+ * attribution `{ isDeleted: true, .. }`.
+ *
+ * @template {delta.DeltaBuilder<any,any,any,any>} TypeDelta
+ * @param {TypeDelta} d
+ * @param {YType_} parent
+ * @param {Set<string|null>?} attrsToRender
+ * @param {import('../internals.js').AbstractAttributionManager} am
+ * @param {boolean} deep
+ * @param {Set<import('../utils/types.js').YType>|Map<import('../utils/types.js').YType,any>|null} [modified] - set of types that should be rendered as modified children
+ * @param {import('../utils/IdSet.js').IdSet?} [deletedItems]
+ * @param {import('../utils/IdSet.js').IdSet?} [itemsToRender]
+ * @param {any} [opts]
+ * @param {any} [optsAll]
+ *
+ * @private
+ * @function
+ */
+const typeMapGetDelta = (d, parent, attrsToRender, am, deep, modified, deletedItems, itemsToRender, opts, optsAll) => {
+  // @todo support modified ops!
+  /**
+   * @param {Item} item
+   * @param {string} key
+   */
+  const renderAttrs = (item, key) => {
+    /**
+     * @type {Array<import('../internals.js').AttributedContent<any>>}
+     */
+    const cs = [];
+    am.readContent(cs, item.id.client, item.id.clock, item.deleted, item.content, 1);
+    const { deleted, attrs, content } = cs[cs.length - 1];
+    const attribution = createAttributionFromAttributionItems(attrs, deleted);
+    let c = array.last(content.getContent());
+    if (deleted) {
+      if (itemsToRender == null || itemsToRender.hasId(item.lastId)) {
+        d.unset(key, attribution, c);
+      }
+    } else if (deep && c instanceof AbstractType && modified?.has(c)) {
+      d.update(key, c.getContent(am, opts));
+    } else {
+      // find prev content
+      let prevContentItem = item;
+      // this algorithm is problematic. should check all previous content using am.readcontent
+      for (; prevContentItem.left !== null && deletedItems?.hasId(prevContentItem.left.lastId); prevContentItem = prevContentItem.left) {
+        // nop
+      }
+      const prevValue = (prevContentItem !== item && itemsToRender?.hasId(prevContentItem.lastId)) ? array.last(prevContentItem.content.getContent()) : undefined;
+      if (deep && c instanceof AbstractType) {
+        c = /** @type {any} */(c).getContent(am, optsAll);
+      }
+      d.set(key, c, attribution, prevValue);
+    }
+  };
+  if (attrsToRender == null) {
+    parent._map.forEach(renderAttrs);
+  } else {
+    attrsToRender.forEach(key => key != null && renderAttrs(/** @type {Item} */ (parent._map.get(key)), key));
+  }
+};
+
+/**
+ * @param {AbstractType<any>} parent
+ * @param {string} key
+ * @return {boolean}
+ *
+ * @private
+ * @function
+ */
+const typeMapHas = (parent, key) => {
+  parent.doc ?? warnPrematureAccess();
+  const val = parent._map.get(key);
+  return val !== undefined && !val.deleted
+};
+
+/**
+ * @param {AbstractType<any>} parent
+ * @param {string} key
+ * @param {Snapshot} snapshot
+ * @return {Object<string,any>|number|null|Array<any>|string|Uint8Array|AbstractType<any>|undefined}
+ *
+ * @private
+ * @function
+ */
+const typeMapGetSnapshot = (parent, key, snapshot) => {
+  let v = parent._map.get(key) || null;
+  while (v !== null && (!snapshot.sv.has(v.id.client) || v.id.clock >= (snapshot.sv.get(v.id.client) || 0))) {
+    v = v.left;
+  }
+  return v !== null && isVisible(v, snapshot) ? v.content.getContent()[v.length - 1] : undefined
+};
+
+/**
+ * @param {AbstractType<any>} parent
+ * @param {Snapshot} snapshot
+ * @return {Object<string,Object<string,any>|number|null|Array<any>|string|Uint8Array|AbstractType<any>|undefined>}
+ *
+ * @private
+ * @function
+ */
+const typeMapGetAllSnapshot = (parent, snapshot) => {
+  /**
+   * @type {Object<string,any>}
+   */
+  const res = {};
+  parent._map.forEach((value, key) => {
+    /**
+     * @type {Item|null}
+     */
+    let v = value;
+    while (v !== null && (!snapshot.sv.has(v.id.client) || v.id.clock >= (snapshot.sv.get(v.id.client) || 0))) {
+      v = v.left;
+    }
+    if (v !== null && isVisible(v, snapshot)) {
+      res[key] = v.content.getContent()[v.length - 1];
+    }
+  });
+  return res
+};
+
+/**
+ * @param {AbstractType<any> & { _map: Map<string, Item> }} type
+ * @return {IterableIterator<Array<any>>}
+ *
+ * @private
+ * @function
+ */
+const createMapIterator = type => {
+  type.doc ?? warnPrematureAccess();
+  return iterator.iteratorFilter(type._map.entries(), /** @param {any} entry */ entry => !entry[1].deleted)
+};
+
+/**
+ * @module YArray
+ */
+
+
+/**
+ * A shared Array implementation.
+ * @template {import('../utils/types.js').YValue} T
+ * @extends {AbstractType<delta.ArrayDelta<T>,YArray<T>>}
+ * @implements {Iterable<T>}
+ */
+// @todo remove this
+// @ts-ignore
+class YArray extends AbstractType {
+  constructor () {
+    super();
+    /**
+     * @type {Array<any>?}
+     * @private
+     */
+    this._prelimContent = [];
+    /**
+     * @type {Array<ArraySearchMarker>}
+     */
+    this._searchMarker = [];
+  }
+
+  /**
+   * Construct a new YArray containing the specified items.
+   * @template {import('../utils/types.js').YValue} T
+   * @param {Array<T>} items
+   * @return {YArray<T>}
+   */
+  static from (items) {
+    /**
+     * @type {YArray<T>}
+     */
+    const a = new YArray();
+    a.push(items);
+    return a
+  }
+
+  /**
+   * Integrate this type into the Yjs instance.
+   *
+   * * Save this struct in the os
+   * * This type is sent to other client
+   * * Observer functions are fired
+   *
+   * @param {Doc} y The Yjs instance
+   * @param {Item?} item
+   */
+  _integrate (y, item) {
+    super._integrate(y, item);
+    this.insert(0, /** @type {Array<any>} */ (this._prelimContent));
+    this._prelimContent = null;
+  }
+
+  /**
+   * Makes a copy of this data type that can be included somewhere else.
+   *
+   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
+   *
+   * @return {YArray<T>}
+   */
+  clone () {
+    /**
+     * @type {this}
+     */
+    const arr = /** @type {this} */ (new YArray());
+    arr.insert(0, this.toArray().map(el =>
+      // @ts-ignore
+      el instanceof AbstractType ? /** @type {any} */ (el.clone()) : el
+    ));
+    return arr
+  }
+
+  get length () {
+    this.doc ?? warnPrematureAccess();
+    return this._length
+  }
+
+  /**
+   * Inserts new content at an index.
+   *
+   * Important: This function expects an array of content. Not just a content
+   * object. The reason for this "weirdness" is that inserting several elements
+   * is very efficient when it is done as a single operation.
+   *
+   * @example
+   *  // Insert character 'a' at position 0
+   *  yarray.insert(0, ['a'])
+   *  // Insert numbers 1, 2 at position 1
+   *  yarray.insert(1, [1, 2])
+   *
+   * @param {number} index The index to insert content at.
+   * @param {Array<T>} content The array of content
+   */
+  insert (index, content) {
+    if (this.doc !== null) {
+      transact(this.doc, transaction => {
+        typeListInsertGenerics(transaction, this, index, /** @type {any} */ (content));
+      });
+    } else {
+      /** @type {Array<any>} */ (this._prelimContent).splice(index, 0, ...content);
+    }
+  }
+
+  /**
+   * Appends content to this YArray.
+   *
+   * @param {Array<T>} content Array of content to append.
+   *
+   * @todo Use the following implementation in all types.
+   */
+  push (content) {
+    if (this.doc !== null) {
+      transact(this.doc, transaction => {
+        typeListPushGenerics(transaction, this, /** @type {any} */ (content));
+      });
+    } else {
+      /** @type {Array<any>} */ (this._prelimContent).push(...content);
+    }
+  }
+
+  /**
+   * Prepends content to this YArray.
+   *
+   * @param {Array<T>} content Array of content to prepend.
+   */
+  unshift (content) {
+    this.insert(0, content);
+  }
+
+  /**
+   * Deletes elements starting from an index.
+   *
+   * @param {number} index Index at which to start deleting elements
+   * @param {number} length The number of elements to remove. Defaults to 1.
+   */
+  delete (index, length = 1) {
+    if (this.doc !== null) {
+      transact(this.doc, transaction => {
+        typeListDelete(transaction, this, index, length);
+      });
+    } else {
+      /** @type {Array<any>} */ (this._prelimContent).splice(index, length);
+    }
+  }
+
+  /**
+   * Returns the i-th element from a YArray.
+   *
+   * @param {number} index The index of the element to return from the YArray
+   * @return {T}
+   */
+  get (index) {
+    return typeListGet(this, index)
+  }
+
+  /**
+   * Transforms this YArray to a JavaScript Array.
+   *
+   * @return {Array<T>}
+   */
+  toArray () {
+    return typeListToArray(this)
+  }
+
+  /**
+   * Render the difference to another ydoc (which can be empty) and highlight the differences with
+   * attributions.
+   *
+   * Note that deleted content that was not deleted in prevYdoc is rendered as an insertion with the
+   * attribution `{ isDeleted: true, .. }`.
+   *
+   * @param {AbstractAttributionManager} am
+   * @return {delta.ArrayDelta<import('./AbstractType.js').TypeToDelta<T>>} The Delta representation of this type.
+   *
+   * @public
+   */
+  getContentDeep (am = noAttributionsManager) {
+    return super.getContentDeep(am)
+  }
+
+  /**
+   * Returns a portion of this YArray into a JavaScript Array selected
+   * from start to end (end not included).
+   *
+   * @param {number} [start]
+   * @param {number} [end]
+   * @return {Array<T>}
+   */
+  slice (start = 0, end = this.length) {
+    return typeListSlice(this, start, end)
+  }
+
+  /**
+   * Transforms this Shared Type to a JSON object.
+   *
+   * @return {Array<any>}
+   */
+  toJSON () {
+    return this.map(c => c instanceof AbstractType ? c.toJSON() : c)
+  }
+
+  /**
+   * Returns an Array with the result of calling a provided function on every
+   * element of this YArray.
+   *
+   * @template M
+   * @param {function(T,number,YArray<T>):M} f Function that produces an element of the new Array
+   * @return {Array<M>} A new array with each element being the result of the
+   *                 callback function
+   */
+  map (f) {
+    return typeListMap(this, /** @type {any} */ (f))
+  }
+
+  /**
+   * Executes a provided function once on every element of this YArray.
+   *
+   * @param {function(T,number,YArray<T>):void} f A function to execute on every element of this YArray.
+   */
+  forEach (f) {
+    typeListForEach(this, f);
+  }
+
+  /**
+   * @return {IterableIterator<T>}
+   */
+  [Symbol.iterator] () {
+    return typeListCreateIterator(this)
+  }
+
+  /**
+   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
+   */
+  _write (encoder) {
+    encoder.writeTypeRef(YArrayRefID);
+  }
+}
+
+/**
+ * @param {UpdateDecoderV1 | UpdateDecoderV2} _decoder
+ * @return {import('../utils/types.js').YType}
+ *
+ * @private
+ * @function
+ */
+const readYArray = _decoder => new YArray();
+
+/**
+ * @module YMap
+ */
+
+
+/**
+ * @template MapType
+ * A shared Map implementation.
+ *
+ * @extends AbstractType<delta.MapDelta<{[K in string]:MapType}>>
+ * @implements {Iterable<[string, MapType]>}
+ */
+class YMap extends AbstractType {
+  /**
+   *
+   * @param {Iterable<readonly [string, any]>=} entries - an optional iterable to initialize the YMap
+   */
+  constructor (entries) {
+    super();
+    /**
+     * @type {Map<string,any>?}
+     * @private
+     */
+    this._prelimContent = null;
+
+    if (entries === undefined) {
+      this._prelimContent = new Map();
+    } else {
+      this._prelimContent = new Map(entries);
+    }
+  }
+
+  /**
+   * Integrate this type into the Yjs instance.
+   *
+   * * Save this struct in the os
+   * * This type is sent to other client
+   * * Observer functions are fired
+   *
+   * @param {Doc} y The Yjs instance
+   * @param {Item?} item
+   */
+  _integrate (y, item) {
+    super._integrate(y, item)
+    ;/** @type {Map<string, any>} */ (this._prelimContent).forEach((value, key) => {
+      this.set(key, value);
+    });
+    this._prelimContent = null;
+  }
+
+  /**
+   * Makes a copy of this data type that can be included somewhere else.
+   *
+   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
+   *
+   * @return {this}
+   */
+  clone () {
+    const map = this._copy();
+    this.forEach((value, key) => {
+      map.set(key, value instanceof AbstractType ? /** @type {typeof value} */ (value.clone()) : value);
+    });
+    return map
+  }
+
+  /**
+   * Transforms this Shared Type to a JSON object.
+   *
+   * @return {Object<string,any>}
+   */
+  toJSON () {
+    this.doc ?? warnPrematureAccess();
+    /**
+     * @type {Object<string,MapType>}
+     */
+    const map = {};
+    this._map.forEach((item, key) => {
+      if (!item.deleted) {
+        const v = item.content.getContent()[item.length - 1];
+        map[key] = v instanceof AbstractType ? v.toJSON() : v;
+      }
+    });
+    return map
+  }
+
+  /**
+   * Returns the size of the YMap (count of key/value pairs)
+   *
+   * @return {number}
+   */
+  get size () {
+    return [...createMapIterator(this)].length
+  }
+
+  /**
+   * Returns the keys for each element in the YMap Type.
+   *
+   * @return {IterableIterator<string>}
+   */
+  keys () {
+    return iterator.iteratorMap(createMapIterator(this), /** @param {any} v */ v => v[0])
+  }
+
+  /**
+   * Returns the values for each element in the YMap Type.
+   *
+   * @return {IterableIterator<MapType>}
+   */
+  values () {
+    return iterator.iteratorMap(createMapIterator(this), /** @param {any} v */ v => v[1].content.getContent()[v[1].length - 1])
+  }
+
+  /**
+   * Returns an Iterator of [key, value] pairs
+   *
+   * @return {IterableIterator<[string, MapType]>}
+   */
+  entries () {
+    return iterator.iteratorMap(createMapIterator(this), /** @param {any} v */ v => /** @type {any} */ ([v[0], v[1].content.getContent()[v[1].length - 1]]))
+  }
+
+  /**
+   * Executes a provided function on once on every key-value pair.
+   *
+   * @param {function(MapType,string,YMap<MapType>):void} f A function to execute on every element of this YArray.
+   */
+  forEach (f) {
+    this.doc ?? warnPrematureAccess();
+    this._map.forEach((item, key) => {
+      if (!item.deleted) {
+        f(item.content.getContent()[item.length - 1], key, this);
+      }
+    });
+  }
+
+  /**
+   * Returns an Iterator of [key, value] pairs
+   *
+   * @return {IterableIterator<[string, MapType]>}
+   */
+  [Symbol.iterator] () {
+    return this.entries()
+  }
+
+  /**
+   * Remove a specified element from this YMap.
+   *
+   * @param {string} key The key of the element to remove.
+   */
+  delete (key) {
+    if (this.doc !== null) {
+      transact(this.doc, transaction => {
+        typeMapDelete(transaction, this, key);
+      });
+    } else {
+      /** @type {Map<string, any>} */ (this._prelimContent).delete(key);
+    }
+  }
+
+  /**
+   * Adds or updates an element with a specified key and value.
+   * @template {MapType} VAL
+   *
+   * @param {string} key The key of the element to add to this YMap
+   * @param {VAL} value The value of the element to add
+   * @return {VAL}
+   */
+  set (key, value) {
+    if (this.doc !== null) {
+      transact(this.doc, transaction => {
+        typeMapSet(transaction, this, key, /** @type {any} */ (value));
+      });
+    } else {
+      /** @type {Map<string, any>} */ (this._prelimContent).set(key, value);
+    }
+    return value
+  }
+
+  /**
+   * Returns a specified element from this YMap.
+   *
+   * @param {string} key
+   * @return {MapType|undefined}
+   */
+  get (key) {
+    return /** @type {any} */ (typeMapGet(this, key))
+  }
+
+  /**
+   * Returns a boolean indicating whether the specified key exists or not.
+   *
+   * @param {string} key The key to test.
+   * @return {boolean}
+   */
+  has (key) {
+    return typeMapHas(this, key)
+  }
+
+  /**
+   * Removes all elements from this YMap.
+   */
+  clear () {
+    if (this.doc !== null) {
+      transact(this.doc, transaction => {
+        this.forEach(function (_value, key, map) {
+          typeMapDelete(transaction, map, key);
+        });
+      });
+    } else {
+      /** @type {Map<string, any>} */ (this._prelimContent).clear();
+    }
+  }
+
+  /**
+   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
+   */
+  _write (encoder) {
+    encoder.writeTypeRef(YMapRefID);
+  }
+}
+
+/**
+ * @param {UpdateDecoderV1 | UpdateDecoderV2} _decoder
+ * @return {import('../utils/types.js').YType}
+ *
+ * @private
+ * @function
+ */
+const readYMap = _decoder => new YMap();
+
+/**
+ * @module YText
+ */
+
+
+class ItemTextListPosition {
+  /**
+   * @param {Item|null} left
+   * @param {Item|null} right
+   * @param {number} index
+   * @param {Map<string,any>} currentAttributes
+   * @param {AbstractAttributionManager} am
+   */
+  constructor (left, right, index, currentAttributes, am) {
+    this.left = left;
+    this.right = right;
+    this.index = index;
+    this.currentAttributes = currentAttributes;
+    this.am = am;
+  }
+
+  /**
+   * Only call this if you know that this.right is defined
+   */
+  forward () {
+    if (this.right === null) {
+      error.unexpectedCase();
+    }
+    switch (this.right.content.constructor) {
+      case ContentFormat:
+        if (!this.right.deleted) {
+          updateCurrentAttributes(this.currentAttributes, /** @type {ContentFormat} */ (this.right.content));
+        }
+        break
+      default:
+        this.index += this.am.contentLength(this.right);
+        break
+    }
+    this.left = this.right;
+    this.right = this.right.right;
+  }
+
+  /**
+   * @param {Transaction} transaction
+   * @param {import('../utils/types.js').YType} parent
+   * @param {number} length
+   * @param {Object<string,any>} attributes
+   *
+   * @function
+   */
+  formatText (transaction, parent, length, attributes) {
+    const doc = transaction.doc;
+    const ownClientId = doc.clientID;
+    minimizeAttributeChanges(this, attributes);
+    const negatedAttributes = insertAttributes(transaction, parent, this, attributes);
+    // iterate until first non-format or null is found
+    // delete all formats with attributes[format.key] != null
+    // also check the attributes after the first non-format as we do not want to insert redundant negated attributes there
+    // eslint-disable-next-line no-labels
+    iterationLoop: while (
+      this.right !== null &&
+      (length > 0 ||
+        (
+          negatedAttributes.size > 0 &&
+          ((this.right.deleted && this.am.contentLength(this.right) === 0) || this.right.content.constructor === ContentFormat)
+        )
+      )
+    ) {
+      switch (this.right.content.constructor) {
+        case ContentFormat: {
+          if (!this.right.deleted) {
+            const { key, value } = /** @type {ContentFormat} */ (this.right.content);
+            const attr = attributes[key];
+            if (attr !== undefined) {
+              if (equalAttrs(attr, value)) {
+                negatedAttributes.delete(key);
+              } else {
+                if (length === 0) {
+                  // no need to further extend negatedAttributes
+                  // eslint-disable-next-line no-labels
+                  break iterationLoop
+                }
+                negatedAttributes.set(key, value);
+              }
+              this.right.delete(transaction);
+            } else {
+              this.currentAttributes.set(key, value);
+            }
+          }
+          break
+        }
+        default: {
+          const item = this.right;
+          const rightLen = this.am.contentLength(item);
+          if (length < rightLen) {
+            /**
+             * @type {Array<import('../internals.js').AttributedContent<any>>}
+             */
+            const contents = [];
+            this.am.readContent(contents, item.id.client, item.id.clock, item.deleted, item.content, 0);
+            let i = 0;
+            for (; i < contents.length && length > 0; i++) {
+              const c = contents[i];
+              if ((!c.deleted || c.attrs != null) && c.content.isCountable()) {
+                length -= c.content.getLength();
+              }
+            }
+            if (length < 0 || (length === 0 && i !== contents.length)) {
+              const c = contents[--i];
+              getItemCleanStart(transaction, createID(item.id.client, c.clock + c.content.getLength() + length));
+            }
+          } else {
+            length -= rightLen;
+          }
+          break
+        }
+      }
+      this.forward();
+    }
+    // Quill just assumes that the editor starts with a newline and that it always
+    // ends with a newline. We only insert that newline when a new newline is
+    // inserted - i.e when length is bigger than type.length
+    if (length > 0) {
+      let newlines = '';
+      for (; length > 0; length--) {
+        newlines += '\n';
+      }
+      this.right = new Item(createID(ownClientId, getState(doc.store, ownClientId)), this.left, this.left && this.left.lastId, this.right, this.right && this.right.id, parent, null, new ContentString(newlines));
+      this.right.integrate(transaction, 0);
+      this.forward();
+    }
+    insertNegatedAttributes(transaction, parent, this, negatedAttributes);
+  }
+}
+
+/**
+ * @param {Transaction} transaction
+ * @param {ItemTextListPosition} pos
+ * @param {number} count steps to move forward
+ * @return {ItemTextListPosition}
+ *
+ * @private
+ * @function
+ */
+const findNextPosition = (transaction, pos, count) => {
+  while (pos.right !== null && count > 0) {
+    switch (pos.right.content.constructor) {
+      case ContentFormat:
+        if (!pos.right.deleted) {
+          updateCurrentAttributes(pos.currentAttributes, /** @type {ContentFormat} */ (pos.right.content));
+        }
+        break
+      default:
+        if (!pos.right.deleted) {
+          if (count < pos.right.length) {
+            // split right
+            getItemCleanStart(transaction, createID(pos.right.id.client, pos.right.id.clock + count));
+          }
+          pos.index += pos.right.length;
+          count -= pos.right.length;
+        }
+        break
+    }
+    pos.left = pos.right;
+    pos.right = pos.right.right;
+    // pos.forward() - we don't forward because that would halve the performance because we already do the checks above
+  }
+  return pos
+};
+
+/**
+ * @param {Transaction} transaction
+ * @param {import('../utils/types.js').YType} parent
+ * @param {number} index
+ * @param {boolean} useSearchMarker
+ * @return {ItemTextListPosition}
+ *
+ * @private
+ * @function
+ */
+const findPosition = (transaction, parent, index, useSearchMarker) => {
+  const currentAttributes = new Map();
+  const marker = useSearchMarker ? findMarker(parent, index) : null;
+  if (marker) {
+    const pos = new ItemTextListPosition(marker.p.left, marker.p, marker.index, currentAttributes, noAttributionsManager);
+    return findNextPosition(transaction, pos, index - marker.index)
+  } else {
+    const pos = new ItemTextListPosition(null, parent._start, 0, currentAttributes, noAttributionsManager);
+    return findNextPosition(transaction, pos, index)
+  }
+};
+
+/**
+ * Negate applied formats
+ *
+ * @param {Transaction} transaction
+ * @param {import('../utils/types.js').YType} parent
+ * @param {ItemTextListPosition} currPos
+ * @param {Map<string,any>} negatedAttributes
+ *
+ * @private
+ * @function
+ */
+const insertNegatedAttributes = (transaction, parent, currPos, negatedAttributes) => {
+  // check if we really need to remove attributes
+  while (
+    currPos.right !== null && (
+      (currPos.right.deleted && (currPos.am === noAttributionsManager || currPos.am.contentLength(currPos.right) === 0)) || (
+        currPos.right.content.constructor === ContentFormat &&
+        equalAttrs(negatedAttributes.get(/** @type {ContentFormat} */ (currPos.right.content).key), /** @type {ContentFormat} */ (currPos.right.content).value)
+      )
+    )
+  ) {
+    if (!currPos.right.deleted) {
+      negatedAttributes.delete(/** @type {ContentFormat} */ (currPos.right.content).key);
+    }
+    currPos.forward();
+  }
+  const doc = transaction.doc;
+  const ownClientId = doc.clientID;
+  negatedAttributes.forEach((val, key) => {
+    const left = currPos.left;
+    const right = currPos.right;
+    const nextFormat = new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key, val));
+    nextFormat.integrate(transaction, 0);
+    currPos.right = nextFormat;
+    currPos.forward();
+  });
+};
+
+/**
+ * @param {Map<string,any>} currentAttributes
+ * @param {ContentFormat} format
+ *
+ * @private
+ * @function
+ */
+const updateCurrentAttributes = (currentAttributes, format) => {
+  const { key, value } = format;
+  if (value === null) {
+    currentAttributes.delete(key);
+  } else {
+    currentAttributes.set(key, value);
+  }
+};
+
+/**
+ * @param {ItemTextListPosition} currPos
+ * @param {Object<string,any>} attributes
+ *
+ * @private
+ * @function
+ */
+const minimizeAttributeChanges = (currPos, attributes) => {
+  // go right while attributes[right.key] === right.value (or right is deleted)
+  while (true) {
+    if (currPos.right === null) {
+      break
+    } else if (currPos.right.deleted ? (currPos.am.contentLength(currPos.right) === 0) : (!currPos.right.deleted && currPos.right.content.constructor === ContentFormat && equalAttrs(attributes[(/** @type {ContentFormat} */ (currPos.right.content)).key] ?? null, /** @type {ContentFormat} */ (currPos.right.content).value))) ; else {
+      break
+    }
+    currPos.forward();
+  }
+};
+
+/**
+ * @param {Transaction} transaction
+ * @param {import('../utils/types.js').YType} parent
+ * @param {ItemTextListPosition} currPos
+ * @param {Object<string,any>} attributes
+ * @return {Map<string,any>}
+ *
+ * @private
+ * @function
+ **/
+const insertAttributes = (transaction, parent, currPos, attributes) => {
+  const doc = transaction.doc;
+  const ownClientId = doc.clientID;
+  const negatedAttributes = new Map();
+  // insert format-start items
+  for (const key in attributes) {
+    const val = attributes[key];
+    const currentVal = currPos.currentAttributes.get(key) ?? null;
+    if (!equalAttrs(currentVal, val)) {
+      // save negated attribute (set null if currentVal undefined)
+      negatedAttributes.set(key, currentVal);
+      const { left, right } = currPos;
+      currPos.right = new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key, val));
+      currPos.right.integrate(transaction, 0);
+      currPos.forward();
+    }
+  }
+  return negatedAttributes
+};
+
+/**
+ * @param {Transaction} transaction
+ * @param {import('../utils/types.js').YType} parent
+ * @param {ItemTextListPosition} currPos
+ * @param {string|object|import('../utils/types.js').YType} text
+ * @param {Object<string,any>} attributes
+ *
+ * @private
+ * @function
+ **/
+const insertText = (transaction, parent, currPos, text, attributes) => {
+  currPos.currentAttributes.forEach((_val, key) => {
+    if (attributes[key] === undefined) {
+      attributes[key] = null;
+    }
+  });
+  const doc = transaction.doc;
+  const ownClientId = doc.clientID;
+  minimizeAttributeChanges(currPos, attributes);
+  const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);
+  // insert content
+  const content = text.constructor === String ? new ContentString(/** @type {string} */ (text)) : (text instanceof AbstractType ? new ContentType(text) : new ContentEmbed(text));
+  let { left, right, index } = currPos;
+  if (parent._searchMarker) {
+    updateMarkerChanges(parent._searchMarker, currPos.index, content.getLength());
+  }
+  right = new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, content);
+  right.integrate(transaction, 0);
+  currPos.right = right;
+  currPos.index = index;
+  currPos.forward();
+  insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);
+};
+
+/**
+ * Call this function after string content has been deleted in order to
+ * clean up formatting Items.
+ *
+ * @param {Transaction} transaction
+ * @param {Item} start
+ * @param {Item|null} curr exclusive end, automatically iterates to the next Content Item
+ * @param {Map<string,any>} startAttributes
+ * @param {Map<string,any>} currAttributes
+ * @return {number} The amount of formatting Items deleted.
+ *
+ * @function
+ */
+const cleanupFormattingGap = (transaction, start, curr, startAttributes, currAttributes) => {
+  if (!transaction.doc.cleanupFormatting) return 0
+  /**
+   * @type {Item|null}
+   */
+  let end = start;
+  /**
+   * @type {Map<string,ContentFormat>}
+   */
+  const endFormats = map.create();
+  while (end && (!end.countable || end.deleted)) {
+    if (!end.deleted && end.content.constructor === ContentFormat) {
+      const cf = /** @type {ContentFormat} */ (end.content);
+      endFormats.set(cf.key, cf);
+    }
+    end = end.right;
+  }
+  let cleanups = 0;
+  let reachedCurr = false;
+  while (start !== end) {
+    if (curr === start) {
+      reachedCurr = true;
+    }
+    if (!start.deleted) {
+      const content = start.content;
+      switch (content.constructor) {
+        case ContentFormat: {
+          const { key, value } = /** @type {ContentFormat} */ (content);
+          const startAttrValue = startAttributes.get(key) ?? null;
+          if (endFormats.get(key) !== content || startAttrValue === value) {
+            // Either this format is overwritten or it is not necessary because the attribute already existed.
+            start.delete(transaction);
+            transaction.cleanUps.add(start.id.client, start.id.clock, start.length);
+            cleanups++;
+            if (!reachedCurr && (currAttributes.get(key) ?? null) === value && startAttrValue !== value) {
+              if (startAttrValue === null) {
+                currAttributes.delete(key);
+              } else {
+                currAttributes.set(key, startAttrValue);
+              }
+            }
+          }
+          if (!reachedCurr && !start.deleted) {
+            updateCurrentAttributes(currAttributes, /** @type {ContentFormat} */ (content));
+          }
+          break
+        }
+      }
+    }
+    start = /** @type {Item} */ (start.right);
+  }
+  return cleanups
+};
+
+/**
+ * @param {Transaction} transaction
+ * @param {Item | null} item
+ */
+const cleanupContextlessFormattingGap = (transaction, item) => {
+  if (!transaction.doc.cleanupFormatting) return 0
+  // iterate until item.right is null or content
+  while (item && item.right && (item.right.deleted || !item.right.countable)) {
+    item = item.right;
+  }
+  const attrs = new Set();
+  // iterate back until a content item is found
+  while (item && (item.deleted || !item.countable)) {
+    if (!item.deleted && item.content.constructor === ContentFormat) {
+      const key = /** @type {ContentFormat} */ (item.content).key;
+      if (attrs.has(key)) {
+        item.delete(transaction);
+        transaction.cleanUps.add(item.id.client, item.id.clock, item.length);
+      } else {
+        attrs.add(key);
+      }
+    }
+    item = item.left;
+  }
+};
+
+/**
+ * This function is experimental and subject to change / be removed.
+ *
+ * Ideally, we don't need this function at all. Formatting attributes should be cleaned up
+ * automatically after each change. This function iterates twice over the complete YText type
+ * and removes unnecessary formatting attributes. This is also helpful for testing.
+ *
+ * This function won't be exported anymore as soon as there is confidence that the YText type works as intended.
+ *
+ * @param {YText<any>} type
+ * @return {number} How many formatting attributes have been cleaned up.
+ */
+const cleanupYTextFormatting = type => {
+  if (!type.doc?.cleanupFormatting) return 0
+  let res = 0;
+  transact(/** @type {Doc} */ (type.doc), transaction => {
+    let start = /** @type {Item} */ (type._start);
+    let end = type._start;
+    let startAttributes = map.create();
+    const currentAttributes = map.copy(startAttributes);
+    while (end) {
+      if (end.deleted === false) {
+        switch (end.content.constructor) {
+          case ContentFormat:
+            updateCurrentAttributes(currentAttributes, /** @type {ContentFormat} */ (end.content));
+            break
+          default:
+            res += cleanupFormattingGap(transaction, start, end, startAttributes, currentAttributes);
+            startAttributes = map.copy(currentAttributes);
+            start = end;
+            break
+        }
+      }
+      end = end.right;
+    }
+  });
+  return res
+};
+
+/**
+ * This will be called by the transaction once the event handlers are called to potentially cleanup
+ * formatting attributes.
+ *
+ * @param {Transaction} transaction
+ */
+const cleanupYTextAfterTransaction = transaction => {
+  /**
+   * @type {Set<YText<any>>}
+   */
+  const needFullCleanup = new Set();
+  // check if another formatting item was inserted
+  const doc = transaction.doc;
+  iterateStructsByIdSet(transaction, transaction.insertSet, (item) => {
+    if (
+      !item.deleted && /** @type {Item} */ (item).content.constructor === ContentFormat && item.constructor !== GC
+    ) {
+      needFullCleanup.add(/** @type {any} */ (item).parent);
+    }
+  });
+  // cleanup in a new transaction
+  transact(doc, (t) => {
+    iterateStructsByIdSet(transaction, transaction.deleteSet, item => {
+      if (item instanceof GC || !(/** @type {YText<any>} */ (item.parent)._hasFormatting) || needFullCleanup.has(/** @type {YText<any>} */ (item.parent))) {
+        return
+      }
+      const parent = /** @type {YText<any>} */ (item.parent);
+      if (item.content.constructor === ContentFormat) {
+        needFullCleanup.add(parent);
+      } else {
+        // If no formatting attribute was inserted or deleted, we can make due with contextless
+        // formatting cleanups.
+        // Contextless: it is not necessary to compute currentAttributes for the affected position.
+        cleanupContextlessFormattingGap(t, item);
+      }
+    });
+    // If a formatting item was inserted, we simply clean the whole type.
+    // We need to compute currentAttributes for the current position anyway.
+    for (const yText of needFullCleanup) {
+      cleanupYTextFormatting(yText);
+    }
+  });
+};
+
+/**
+ * @param {Transaction} transaction
+ * @param {ItemTextListPosition} currPos
+ * @param {number} length
+ * @return {ItemTextListPosition}
+ *
+ * @private
+ * @function
+ */
+const deleteText = (transaction, currPos, length) => {
+  const startLength = length;
+  const startAttrs = map.copy(currPos.currentAttributes);
+  const start = currPos.right;
+  while (length > 0 && currPos.right !== null) {
+    if (!currPos.right.deleted) {
+      switch (currPos.right.content.constructor) {
+        case ContentType:
+        case ContentEmbed:
+        case ContentString:
+          if (length < currPos.right.length) {
+            getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length));
+          }
+          length -= currPos.right.length;
+          currPos.right.delete(transaction);
+          break
+      }
+    } else if (currPos.am !== noAttributionsManager) {
+      const item = currPos.right;
+      /**
+       * @type {Array<import('../internals.js').AttributedContent<any>>}
+       */
+      const contents = [];
+      currPos.am.readContent(contents, item.id.client, item.id.clock, true, item.content, 0);
+      for (let i = 0; i < contents.length; i++) {
+        const c = contents[i];
+        if (c.content.isCountable() && c.attrs != null) {
+          // deleting already deleted content. store that information in a meta property, but do
+          // nothing
+          const contentLen = math.min(c.content.getLength(), length);
+          map.setIfUndefined(transaction.meta, 'attributedDeletes', createIdSet).add(item.id.client, c.clock, contentLen);
+          length -= contentLen;
+        }
+      }
+      const lastContent = contents.length > 0 ? contents[contents.length - 1] : null;
+      const nextItemClock = item.id.clock + item.length;
+      const nextContentClock = lastContent != null ? lastContent.clock + lastContent.content.getLength() : nextItemClock;
+      if (nextContentClock < nextItemClock) {
+        getItemCleanStart(transaction, createID(item.id.client, nextContentClock));
+      }
+    }
+    currPos.forward();
+  }
+  if (start) {
+    cleanupFormattingGap(transaction, start, currPos.right, startAttrs, currPos.currentAttributes);
+  }
+  const parent = /** @type {AbstractType<any>} */ (/** @type {Item} */ (currPos.left || currPos.right).parent);
+  if (parent._searchMarker) {
+    updateMarkerChanges(parent._searchMarker, currPos.index, -startLength + length);
+  }
+  return currPos
+};
+
+/**
+ * The Quill Delta format represents changes on a text document with
+ * formatting information. For more information visit {@link https://quilljs.com/docs/delta/|Quill Delta}
+ *
+ * @example
+ *   {
+ *     ops: [
+ *       { insert: 'Gandalf', attributes: { bold: true } },
+ *       { insert: ' the ' },
+ *       { insert: 'Grey', attributes: { color: '#cccccc' } }
+ *     ]
+ *   }
+ *
+ */
+
+/**
+  * Attributes that can be assigned to a selection of text.
+  *
+  * @example
+  *   {
+  *     bold: true,
+  *     font-size: '40px'
+  *   }
+  *
+  * @typedef {Object} TextAttributes
+  */
+
+/**
+ * Type that represents text with formatting information.
+ *
+ * This type replaces y-richtext as this implementation is able to handle
+ * block formats (format information on a paragraph), embeds (complex elements
+ * like pictures and videos), and text formats (**bold**, *italic*).
+ *
+ * @template {{ [key:string]:any } | import('../utils/types.js').YType} [Embeds={ [key:string]:any } | import('../utils/types.js').YType]
+ * @extends {AbstractType<import('lib0/delta').TextDelta<Embeds>>}
+ */
+class YText extends AbstractType {
+  /**
+   * @param {String} [string] The initial value of the YText.
+   */
+  constructor (string) {
+    super();
+    /**
+     * Array of pending operations on this type
+     * @type {Array<function():void>?}
+     */
+    this._pending = string !== undefined ? [() => this.insert(0, string)] : [];
+    /**
+     * @type {Array<ArraySearchMarker>|null}
+     */
+    this._searchMarker = [];
+    /**
+     * Whether this YText contains formatting attributes.
+     * This flag is updated when a formatting item is integrated (see ContentFormat.integrate)
+     */
+    this._hasFormatting = false;
+  }
+
+  /**
+   * Number of characters of this text type.
+   *
+   * @type {number}
+   */
+  get length () {
+    this.doc ?? warnPrematureAccess();
+    return this._length
+  }
+
+  /**
+   * @param {Doc} y
+   * @param {Item?} item
+   */
+  _integrate (y, item) {
+    super._integrate(y, item);
+    try {
+      /** @type {Array<function>} */ (this._pending).forEach(f => f());
+    } catch (e) {
+      console.error(e);
+    }
+    this._pending = null;
+  }
+
+  /**
+   * Makes a copy of this data type that can be included somewhere else.
+   *
+   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
+   *
+   * @return {YText<Embeds>}
+   */
+  clone () {
+    /**
+     * @type {YText<Embeds>}
+     */
+    const text = /** @type {any} */ (new YText());
+    text.applyDelta(this.getContent());
+    return text
+  }
+
+  /**
+   * Creates YTextEvent and calls observers.
+   *
+   * @param {Transaction} transaction
+   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
+   */
+  _callObserver (transaction, parentSubs) {
+    super._callObserver(transaction, parentSubs);
+    // If a remote change happened, we try to cleanup potential formatting duplicates.
+    if (!transaction.local && this._hasFormatting) {
+      transaction._needFormattingCleanup = true;
+    }
+  }
+
+  /**
+   * Returns the unformatted string representation of this YText type.
+   *
+   * @public
+   */
+  toString () {
+    this.doc ?? warnPrematureAccess();
+    let str = '';
+    /**
+     * @type {Item|null}
+     */
+    let n = this._start;
+    while (n !== null) {
+      if (!n.deleted && n.countable && n.content.constructor === ContentString) {
+        str += /** @type {ContentString} */ (n.content).str;
+      }
+      n = n.right;
+    }
+    return str
+  }
+
+  /**
+   * Returns the unformatted string representation of this YText type.
+   *
+   * @return {string}
+   * @public
+   */
+  toJSON () {
+    return this.toString()
+  }
+
+  /**
+   * Insert text at a given index.
+   *
+   * @param {number} index The index at which to start inserting.
+   * @param {String} text The text to insert at the specified position.
+   * @param {TextAttributes} [attributes] Optionally define some formatting
+   *                                    information to apply on the inserted
+   *                                    Text.
+   * @public
+   */
+  insert (index, text, attributes) {
+    if (text.length <= 0) {
+      return
+    }
+    const y = this.doc;
+    if (y !== null) {
+      transact(y, transaction => {
+        const pos = findPosition(transaction, this, index, !attributes);
+        if (!attributes) {
+          attributes = {};
+          // @ts-ignore
+          pos.currentAttributes.forEach((v, k) => { attributes[k] = v; });
+        }
+        insertText(transaction, this, pos, text, attributes);
+      });
+    } else {
+      /** @type {Array<function>} */ (this._pending).push(() => this.insert(index, text, attributes));
+    }
+  }
+
+  /**
+   * Inserts an embed at a index.
+   *
+   * @param {number} index The index to insert the embed at.
+   * @param {Object | AbstractType<any>} embed The Object that represents the embed.
+   * @param {TextAttributes} [attributes] Attribute information to apply on the
+   *                                    embed
+   *
+   * @public
+   */
+  insertEmbed (index, embed, attributes) {
+    const y = this.doc;
+    if (y !== null) {
+      transact(y, transaction => {
+        const pos = findPosition(transaction, this, index, !attributes);
+        insertText(transaction, this, pos, embed, attributes || {});
+      });
+    } else {
+      /** @type {Array<function>} */ (this._pending).push(() => this.insertEmbed(index, embed, attributes || {}));
+    }
+  }
+
+  /**
+   * Deletes text starting from an index.
+   *
+   * @param {number} index Index at which to start deleting.
+   * @param {number} length The number of characters to remove. Defaults to 1.
+   *
+   * @public
+   */
+  delete (index, length) {
+    if (length === 0) {
+      return
+    }
+    const y = this.doc;
+    if (y !== null) {
+      transact(y, transaction => {
+        deleteText(transaction, findPosition(transaction, this, index, true), length);
+      });
+    } else {
+      /** @type {Array<function>} */ (this._pending).push(() => this.delete(index, length));
+    }
+  }
+
+  /**
+   * Assigns properties to a range of text.
+   *
+   * @param {number} index The position where to start formatting.
+   * @param {number} length The amount of characters to assign properties to.
+   * @param {TextAttributes} attributes Attribute information to apply on the
+   *                                    text.
+   *
+   * @public
+   */
+  format (index, length, attributes) {
+    if (length === 0) {
+      return
+    }
+    const y = this.doc;
+    if (y !== null) {
+      transact(y, transaction => {
+        const pos = findPosition(transaction, this, index, false);
+        if (pos.right === null) {
+          return
+        }
+        pos.formatText(transaction, this, length, attributes);
+      });
+    } else {
+      /** @type {Array<function>} */ (this._pending).push(() => this.format(index, length, attributes));
+    }
+  }
+
+  /**
+   * Removes an attribute.
+   *
+   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
+   *
+   * @param {String} attributeName The attribute name that is to be removed.
+   *
+   * @public
+   */
+  removeAttribute (attributeName) {
+    if (this.doc !== null) {
+      transact(this.doc, transaction => {
+        typeMapDelete(transaction, this, attributeName);
+      });
+    } else {
+      /** @type {Array<function>} */ (this._pending).push(() => this.removeAttribute(attributeName));
+    }
+  }
+
+  /**
+   * Sets or updates an attribute.
+   *
+   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
+   *
+   * @param {String} attributeName The attribute name that is to be set.
+   * @param {any} attributeValue The attribute value that is to be set.
+   *
+   * @public
+   */
+  setAttribute (attributeName, attributeValue) {
+    if (this.doc !== null) {
+      transact(this.doc, transaction => {
+        typeMapSet(transaction, this, attributeName, attributeValue);
+      });
+    } else {
+      /** @type {Array<function>} */ (this._pending).push(() => this.setAttribute(attributeName, attributeValue));
+    }
+  }
+
+  /**
+   * Returns an attribute value that belongs to the attribute name.
+   *
+   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
+   *
+   * @param {String} attributeName The attribute name that identifies the
+   *                               queried value.
+   * @return {any} The queried attribute value.
+   *
+   * @public
+   */
+  getAttribute (attributeName) {
+    return /** @type {any} */ (typeMapGet(this, attributeName))
+  }
+
+  /**
+   * Returns all attribute name/value pairs in a JSON Object.
+   *
+   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
+   *
+   * @return {Object<string, any>} A JSON Object that describes the attributes.
+   *
+   * @public
+   */
+  getAttributes () {
+    return typeMapGetAll(this)
+  }
+
+  /**
+   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
+   */
+  _write (encoder) {
+    encoder.writeTypeRef(YTextRefID);
+  }
+
+  /**
+   * @param {this} other
+   */
+  [traits.EqualityTraitSymbol] (other) {
+    return this.getContent().equals(other.getContent())
+  }
+}
+
+/**
+ * @param {UpdateDecoderV1 | UpdateDecoderV2} _decoder
+ * @return {import('../utils/types.js').YType}
+ *
+ * @private
+ * @function
+ */
+const readYText = _decoder => new YText();
+
+/**
+ * @module YXml
+ */
+
+
+/**
+ * Define the elements to which a set of CSS queries apply.
+ * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors|CSS_Selectors}
+ *
+ * @example
+ *   query = '.classSelector'
+ *   query = 'nodeSelector'
+ *   query = '#idSelector'
+ *
+ * @typedef {string} CSS_Selector
+ */
+
+/**
+ * Dom filter function.
+ *
+ * @callback domFilter
+ * @param {string} nodeName The nodeName of the element
+ * @param {Map} attributes The map of attributes.
+ * @return {boolean} Whether to include the Dom node in the YXmlElement.
+ */
+
+/**
+ * Represents a list of {@link YXmlElement}.and {@link YXmlText} types.
+ * A YxmlFragment is similar to a {@link YXmlElement}, but it does not have a
+ * nodeName and it does not have attributes. Though it can be bound to a DOM
+ * element - in this case the attributes and the nodeName are not shared.
+ *
+ * @public
+ * @template {any} [Children=any]
+ * @template {{[K in string]:any}} [Attrs={}]
+ * @extends AbstractType<delta.Delta<any,Attrs,Children,any>>
+ */
+class YXmlFragment extends AbstractType {
+  constructor () {
+    super();
+    /**
+     * @todo remove _prelimContent
+     * @type {Array<any>|null}
+     */
+    this._prelimContent = [];
+  }
+
+  /**
+   * @type {YXmlElement|YXmlText|null}
+   */
+  get firstChild () {
+    const first = this._first;
+    return first ? first.content.getContent()[0] : null
+  }
+
+  /**
+   * Integrate this type into the Yjs instance.
+   *
+   * * Save this struct in the os
+   * * This type is sent to other client
+   * * Observer functions are fired
+   *
+   * @param {Doc} y The Yjs instance
+   * @param {Item?} item
+   */
+  _integrate (y, item) {
+    super._integrate(y, item);
+    this.insert(0, /** @type {Array<any>} */ (this._prelimContent));
+    this._prelimContent = null;
+  }
+
+  /**
+   * Makes a copy of this data type that can be included somewhere else.
+   *
+   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
+   *
+   * @return {this}
+   */
+  clone () {
+    const el = this._copy();
+    el.insert(0, this.toArray().map(item => item instanceof AbstractType ? item.clone() : item));
+    return el
+  }
+
+  get length () {
+    this.doc ?? warnPrematureAccess();
+    return this._prelimContent === null ? this._length : this._prelimContent.length
+  }
+
+  /**
+   * Get the string representation of all the children of this YXmlFragment.
+   *
+   * @return {string} The string representation of all children.
+   */
+  toString () {
+    return typeListMap(this, xml => xml.toString()).join('')
+  }
+
+  /**
+   * @return {string}
+   */
+  toJSON () {
+    return this.toString()
+  }
+
+  /**
+   * Inserts new content at an index.
+   *
+   * @example
+   *  // Insert character 'a' at position 0
+   *  xml.insert(0, [new Y.XmlText('text')])
+   *
+   * @param {number} index The index to insert content at
+   * @param {Array<YXmlElement|YXmlText|YXmlHook>} content The array of content
+   */
+  insert (index, content) {
+    if (this.doc !== null) {
+      transact(this.doc, transaction => {
+        typeListInsertGenerics(transaction, this, index, content);
+      });
+    } else {
+      // @ts-ignore _prelimContent is defined because this is not yet integrated
+      this._prelimContent.splice(index, 0, ...content);
+    }
+  }
+
+  /**
+   * Inserts new content at an index.
+   *
+   * @example
+   *  // Insert character 'a' at position 0
+   *  xml.insert(0, [new Y.XmlText('text')])
+   *
+   * @param {null|Item|YXmlElement|YXmlText} ref The index to insert content at
+   * @param {Array<YXmlElement|YXmlText>} content The array of content
+   */
+  insertAfter (ref, content) {
+    if (this.doc !== null) {
+      transact(this.doc, transaction => {
+        const refItem = (ref && ref instanceof AbstractType) ? ref._item : ref;
+        typeListInsertGenericsAfter(transaction, this, refItem, content);
+      });
+    } else {
+      const pc = /** @type {Array<any>} */ (this._prelimContent);
+      const index = ref === null ? 0 : pc.findIndex(el => el === ref) + 1;
+      if (index === 0 && ref !== null) {
+        throw error.create('Reference item not found')
+      }
+      pc.splice(index, 0, ...content);
+    }
+  }
+
+  /**
+   * Deletes elements starting from an index.
+   *
+   * @param {number} index Index at which to start deleting elements
+   * @param {number} [length=1] The number of elements to remove. Defaults to 1.
+   */
+  delete (index, length = 1) {
+    if (this.doc !== null) {
+      transact(this.doc, transaction => {
+        typeListDelete(transaction, this, index, length);
+      });
+    } else {
+      // @ts-ignore _prelimContent is defined because this is not yet integrated
+      this._prelimContent.splice(index, length);
+    }
+  }
+
+  /**
+   * Transforms this YArray to a JavaScript Array.
+   *
+   * @return {Array<YXmlElement|YXmlText|YXmlHook>}
+   */
+  toArray () {
+    return typeListToArray(this)
+  }
+
+  /**
+   * Appends content to this YArray.
+   *
+   * @param {Array<YXmlElement|YXmlText>} content Array of content to append.
+   */
+  push (content) {
+    this.insert(this.length, content);
+  }
+
+  /**
+   * Prepends content to this YArray.
+   *
+   * @param {Array<YXmlElement|YXmlText>} content Array of content to prepend.
+   */
+  unshift (content) {
+    this.insert(0, content);
+  }
+
+  /**
+   * Returns the i-th element from a YArray.
+   *
+   * @param {number} index The index of the element to return from the YArray
+   * @return {YXmlElement|YXmlText}
+   */
+  get (index) {
+    return typeListGet(this, index)
+  }
+
+  /**
+   * Returns a portion of this YXmlFragment into a JavaScript Array selected
+   * from start to end (end not included).
+   *
+   * @param {number} [start]
+   * @param {number} [end]
+   * @return {Array<YXmlElement|YXmlText>}
+   */
+  slice (start = 0, end = this.length) {
+    return typeListSlice(this, start, end)
+  }
+
+  /**
+   * Executes a provided function on once on every child element.
+   *
+   * @param {function(YXmlElement|YXmlText,number, typeof self):void} f A function to execute on every element of this YArray.
+   */
+  forEach (f) {
+    typeListForEach(this, f);
+  }
+
+  /**
+   * Transform the properties of this type to binary and write it to an
+   * BinaryEncoder.
+   *
+   * This is called when this Item is sent to a remote peer.
+   *
+   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
+   */
+  _write (encoder) {
+    encoder.writeTypeRef(YXmlFragmentRefID);
+  }
+}
+
+/**
+ * @param {UpdateDecoderV1 | UpdateDecoderV2} _decoder
+ * @return {import('../utils/types.js').YType}
+ *
+ * @private
+ * @function
+ */
+const readYXmlFragment = _decoder => new YXmlFragment();
+
+/**
+ * @typedef {Object|number|null|Array<any>|string|Uint8Array|AbstractType<any>} ValueTypes
+ */
+
+/**
+ * An YXmlElement imitates the behavior of a
+ * https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element
+ *
+ * * An YXmlElement has attributes (key value pairs)
+ * * An YXmlElement has childElements that must inherit from YXmlElement
+ *
+ * @template {{ [key: string]: any }} [Attrs={ [key: string]: string }]
+ * @template {any} [Children=any]
+ * @extends YXmlFragment<Children,Attrs>
+ */
+class YXmlElement extends YXmlFragment {
+  constructor (nodeName = 'UNDEFINED') {
+    super();
+    this.nodeName = nodeName;
+    /**
+     * @type {Map<string, any>|null}
+     */
+    this._prelimAttrs = new Map();
+  }
+
+  /**
+   * @type {YXmlElement|YXmlText|null}
+   */
+  get nextSibling () {
+    const n = this._item ? this._item.next : null;
+    return n ? /** @type {YXmlElement|YXmlText} */ (/** @type {ContentType} */ (n.content).type) : null
+  }
+
+  /**
+   * @type {YXmlElement|YXmlText|null}
+   */
+  get prevSibling () {
+    const n = this._item ? this._item.prev : null;
+    return n ? /** @type {YXmlElement|YXmlText} */ (/** @type {ContentType} */ (n.content).type) : null
+  }
+
+  /**
+   * Integrate this type into the Yjs instance.
+   *
+   * * Save this struct in the os
+   * * This type is sent to other client
+   * * Observer functions are fired
+   *
+   * @param {Doc} y The Yjs instance
+   * @param {Item?} item
+   */
+  _integrate (y, item) {
+    super._integrate(y, item)
+    ;(/** @type {Map<string, any>} */ (this._prelimAttrs)).forEach((value, key) => {
+      this.setAttribute(key, value);
+    });
+    this._prelimAttrs = null;
+  }
+
+  /**
+   * Creates an Item with the same effect as this Item (without position effect)
+   *
+   * @return {this}
+   */
+  _copy () {
+    return /** @type {any} */ (new YXmlElement(this.nodeName))
+  }
+
+  /**
+   * Makes a copy of this data type that can be included somewhere else.
+   *
+   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
+   *
+   * @return {this}
+   */
+  clone () {
+    const el = this._copy();
+    const attrs = this.getAttributes();
+    object.forEach(attrs, (value, key) => {
+      if (typeof value === 'string') {
+        el.setAttribute(key, value);
+      }
+    });
+    // @ts-ignore
+    el.insert(0, this.toArray().map(item => item instanceof AbstractType ? item.clone() : item));
+    return el
+  }
+
+  /**
+   * Returns the XML serialization of this YXmlElement.
+   * The attributes are ordered by attribute-name, so you can easily use this
+   * method to compare YXmlElements
+   *
+   * @return {string} The string representation of this type.
+   *
+   * @public
+   */
+  toString () {
+    const attrs = this.getAttributes();
+    const stringBuilder = [];
+    const keys = [];
+    for (const key in attrs) {
+      keys.push(key);
+    }
+    keys.sort();
+    const keysLen = keys.length;
+    for (let i = 0; i < keysLen; i++) {
+      const key = keys[i];
+      stringBuilder.push(key + '="' + attrs[key] + '"');
+    }
+    const nodeName = this.nodeName.toLocaleLowerCase();
+    const attrsString = stringBuilder.length > 0 ? ' ' + stringBuilder.join(' ') : '';
+    return `<${nodeName}${attrsString}>${super.toString()}</${nodeName}>`
+  }
+
+  /**
+   * Removes an attribute from this YXmlElement.
+   *
+   * @param {string} attributeName The attribute name that is to be removed.
+   *
+   * @public
+   */
+  removeAttribute (attributeName) {
+    if (this.doc !== null) {
+      transact(this.doc, transaction => {
+        typeMapDelete(transaction, this, attributeName);
+      });
+    } else {
+      /** @type {Map<string,any>} */ (this._prelimAttrs).delete(attributeName);
+    }
+  }
+
+  /**
+   * Sets or updates an attribute.
+   *
+   * @template {keyof Attrs & string} KEY
+   *
+   * @param {KEY} attributeName The attribute name that is to be set.
+   * @param {Attrs[KEY]} attributeValue The attribute value that is to be set.
+   *
+   * @public
+   */
+  setAttribute (attributeName, attributeValue) {
+    if (this.doc !== null) {
+      transact(this.doc, transaction => {
+        typeMapSet(transaction, this, attributeName, /** @type {any} */ (attributeValue));
+      });
+    } else {
+      /** @type {Map<string, any>} */ (this._prelimAttrs).set(attributeName, attributeValue);
+    }
+  }
+
+  /**
+   * Returns an attribute value that belongs to the attribute name.
+   *
+   * @template {keyof Attrs & string} KEY
+   *
+   * @param {KEY} attributeName The attribute name that identifies the
+   *                               queried value.
+   * @return {Attrs[KEY]|undefined} The queried attribute value.
+   *
+   * @public
+   */
+  getAttribute (attributeName) {
+    return /** @type {any} */ (typeMapGet(this, attributeName))
+  }
+
+  /**
+   * Returns whether an attribute exists
+   *
+   * @param {string} attributeName The attribute name to check for existence.
+   * @return {boolean} whether the attribute exists.
+   *
+   * @public
+   */
+  hasAttribute (attributeName) {
+    return /** @type {any} */ (typeMapHas(this, attributeName))
+  }
+
+  /**
+   * Returns all attribute name/value pairs in a JSON Object.
+   *
+   * @param {Snapshot} [snapshot]
+   * @return {{ [Key in Extract<keyof Attrs,string>]?: Attrs[Key]}} A JSON Object that describes the attributes.
+   *
+   * @public
+   */
+  getAttributes (snapshot) {
+    return /** @type {any} */ (snapshot ? typeMapGetAllSnapshot(this, snapshot) : typeMapGetAll(this))
+  }
+
+  /**
+   * Transform the properties of this type to binary and write it to an
+   * BinaryEncoder.
+   *
+   * This is called when this Item is sent to a remote peer.
+   *
+   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
+   */
+  _write (encoder) {
+    encoder.writeTypeRef(YXmlElementRefID);
+    encoder.writeKey(this.nodeName);
+  }
+}
+
+/**
+ * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
+ * @return {import('../utils/types.js').YType}
+ *
+ * @function
+ */
+const readYXmlElement = decoder => new YXmlElement(decoder.readKey());
+
+/**
+ * You can manage binding to a custom type with YXmlHook.
+ *
+ * @extends {YMap<any>}
+ */
+class YXmlHook extends YMap {
+  /**
+   * @param {string} hookName nodeName of the Dom Node.
+   */
+  constructor (hookName) {
+    super();
+    /**
+     * @type {string}
+     */
+    this.hookName = hookName;
+  }
+
+  /**
+   * @return {this}
+   */
+  _copy () {
+    return /** @type {this} */ (new YXmlHook(this.hookName))
+  }
+
+  /**
+   * Makes a copy of this data type that can be included somewhere else.
+   *
+   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
+   *
+   * @return {this}
+   */
+  clone () {
+    const el = this._copy();
+    this.forEach((value, key) => {
+      el.set(key, value);
+    });
+    return el
+  }
+
+  /**
+   * Transform the properties of this type to binary and write it to an
+   * BinaryEncoder.
+   *
+   * This is called when this Item is sent to a remote peer.
+   *
+   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
+   */
+  _write (encoder) {
+    encoder.writeTypeRef(YXmlHookRefID);
+    encoder.writeKey(this.hookName);
+  }
+}
+
+/**
+ * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
+ * @return {import('../utils/types.js').YType}
+ *
+ * @private
+ * @function
+ */
+const readYXmlHook = decoder =>
+  new YXmlHook(decoder.readKey());
+
+/**
+ * @todo can we deprecate this?
+ *
+ * Represents text in a Dom Element. In the future this type will also handle
+ * simple formatting information like bold and italic.
+ * @extends YText
+ */
+class YXmlText extends YText {
+  /**
+   * @type {YXmlElement|YXmlText|null}
+   */
+  get nextSibling () {
+    const n = this._item ? this._item.next : null;
+    return n ? /** @type {YXmlElement|YXmlText} */ (/** @type {ContentType} */ (n.content).type) : null
+  }
+
+  /**
+   * @type {YXmlElement|YXmlText|null}
+   */
+  get prevSibling () {
+    const n = this._item ? this._item.prev : null;
+    return n ? /** @type {YXmlElement|YXmlText} */ (/** @type {ContentType} */ (n.content).type) : null
+  }
+
+  /**
+   * Makes a copy of this data type that can be included somewhere else.
+   *
+   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
+   *
+   * @return {this}
+   */
+  clone () {
+    const text = /** @type {this} */ (this._copy());
+    text.applyDelta(this.getContent());
+    return text
+  }
+
+  /**
+   * @return {string}
+   */
+  toJSON () {
+    return this.toString()
+  }
+
+  /**
+   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
+   */
+  _write (encoder) {
+    encoder.writeTypeRef(YXmlTextRefID);
+  }
+}
+
+/**
+ * @param {UpdateDecoderV1 | UpdateDecoderV2} _decoder
+ * @return {import('../utils/types.js').YType}
+ *
+ * @private
+ * @function
+ */
+const readYXmlText = _decoder => new YXmlText();
+
+class AbstractStruct {
+  /**
+   * @param {ID} id
+   * @param {number} length
+   */
+  constructor (id, length) {
+    this.id = id;
+    this.length = length;
+  }
+
+  /**
+   * @type {boolean}
+   */
+  get deleted () {
+    throw error.methodUnimplemented()
+  }
+
+  /**
+   * Merge this struct with the item to the right.
+   * This method is already assuming that `this.id.clock + this.length === this.id.clock`.
+   * Also this method does *not* remove right from StructStore!
+   * @param {AbstractStruct} right
+   * @return {boolean} whether this merged with right
+   */
+  mergeWith (right) {
+    return false
+  }
+
+  /**
+   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
+   * @param {number} offset
+   * @param {number} encodingRef
+   */
+  write (encoder, offset, encodingRef) {
+    throw error.methodUnimplemented()
+  }
+
+  /**
+   * @param {Transaction} transaction
+   * @param {number} offset
+   */
+  integrate (transaction, offset) {
+    throw error.methodUnimplemented()
+  }
+
+  /**
+   * @param {number} diff
+   * @return {import('../internals.js').GC|import('../internals.js').Item}
+   */
+  splice (diff) {
+    throw error.methodUnimplemented()
+  }
+}
+
+const structGCRefNumber = 0;
+
+/**
+ * @private
+ */
+class GC extends AbstractStruct {
+  get deleted () {
+    return true
+  }
+
+  delete () {}
+
+  /**
+   * @param {GC} right
+   * @return {boolean}
+   */
+  mergeWith (right) {
+    if (this.constructor !== right.constructor) {
+      return false
+    }
+    this.length += right.length;
+    return true
+  }
+
+  /**
+   * @param {Transaction} transaction
+   * @param {number} offset - @todo remove offset parameter
+   */
+  integrate (transaction, offset) {
+    if (offset > 0) {
+      this.id.clock += offset;
+      this.length -= offset;
+    }
+    addToIdSet(transaction.deleteSet, this.id.client, this.id.clock, this.length);
+    addStructToIdSet(transaction.insertSet, this);
+    addStruct(transaction.doc.store, this);
+  }
+
+  /**
+   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
+   * @param {number} offset
+   * @param {number} offsetEnd
+   */
+  write (encoder, offset, offsetEnd) {
+    encoder.writeInfo(structGCRefNumber);
+    encoder.writeLen(this.length - offset - offsetEnd);
+  }
+
+  /**
+   * @param {Transaction} _transaction
+   * @param {StructStore} _store
+   * @return {null | number}
+   */
+  getMissing (_transaction, _store) {
+    return null
+  }
+
+  /**
+   * gc structs can't be spliced.
+   *
+   * If this feature is required in the future, then need to try to merge this struct after
+   * transaction.
+   *
+   * @param {number} diff
+   */
+  splice (diff) {
+    const other = new GC(createID(this.id.client, this.id.clock + diff), this.length - diff);
+    this.length = diff;
+    return other
+  }
+}
+
+class ContentBinary {
+  /**
+   * @param {Uint8Array} content
+   */
+  constructor (content) {
+    this.content = content;
+  }
+
+  /**
+   * @return {number}
+   */
+  getLength () {
+    return 1
+  }
+
+  /**
+   * @return {Array<any>}
+   */
+  getContent () {
+    return [this.content]
+  }
+
+  /**
+   * @return {boolean}
+   */
+  isCountable () {
+    return true
+  }
+
+  /**
+   * @return {ContentBinary}
+   */
+  copy () {
+    return new ContentBinary(this.content)
+  }
+
+  /**
+   * @param {number} offset
+   * @return {ContentBinary}
+   */
+  splice (offset) {
+    throw error.methodUnimplemented()
+  }
+
+  /**
+   * @param {ContentBinary} right
+   * @return {boolean}
+   */
+  mergeWith (right) {
+    return false
+  }
+
+  /**
+   * @param {Transaction} transaction
+   * @param {Item} item
+   */
+  integrate (transaction, item) {}
+  /**
+   * @param {Transaction} transaction
+   */
+  delete (transaction) {}
+  /**
+   * @param {Transaction} _tr
+   */
+  gc (_tr) {}
+  /**
+   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
+   * @param {number} _offset
+   * @param {number} _offsetEnd
+   */
+  write (encoder, _offset, _offsetEnd) {
+    encoder.writeBuf(this.content);
+  }
+
+  /**
+   * @return {number}
+   */
+  getRef () {
+    return 3
+  }
+}
+
+/**
+ * @param {UpdateDecoderV1 | UpdateDecoderV2 } decoder
+ * @return {ContentBinary}
+ */
+const readContentBinary = decoder => new ContentBinary(decoder.readBuf());
+
+class ContentDeleted {
+  /**
+   * @param {number} len
+   */
+  constructor (len) {
+    this.len = len;
+  }
+
+  /**
+   * @return {number}
+   */
+  getLength () {
+    return this.len
+  }
+
+  /**
+   * @return {Array<any>}
+   */
+  getContent () {
+    return []
+  }
+
+  /**
+   * @return {boolean}
+   */
+  isCountable () {
+    return false
+  }
+
+  /**
+   * @return {ContentDeleted}
+   */
+  copy () {
+    return new ContentDeleted(this.len)
+  }
+
+  /**
+   * @param {number} offset
+   * @return {ContentDeleted}
+   */
+  splice (offset) {
+    const right = new ContentDeleted(this.len - offset);
+    this.len = offset;
+    return right
+  }
+
+  /**
+   * @param {ContentDeleted} right
+   * @return {boolean}
+   */
+  mergeWith (right) {
+    this.len += right.len;
+    return true
+  }
+
+  /**
+   * @param {Transaction} transaction
+   * @param {Item} item
+   */
+  integrate (transaction, item) {
+    addToIdSet(transaction.deleteSet, item.id.client, item.id.clock, this.len);
+    item.markDeleted();
+  }
+
+  /**
+   * @param {Transaction} _transaction
+   */
+  delete (_transaction) {}
+  /**
+   * @param {Transaction} _tr
+   */
+  gc (_tr) {}
+  /**
+   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
+   * @param {number} offset
+   * @param {number} offsetEnd
+   */
+  write (encoder, offset, offsetEnd) {
+    encoder.writeLen(this.len - offset - offsetEnd);
+  }
+
+  /**
+   * @return {number}
+   */
+  getRef () {
+    return 1
+  }
+}
+
+/**
+ * @private
+ *
+ * @param {UpdateDecoderV1 | UpdateDecoderV2 } decoder
+ * @return {ContentDeleted}
+ */
+const readContentDeleted = decoder => new ContentDeleted(decoder.readLen());
+
+/**
+ * @param {string} guid
+ * @param {Object<string, any>} opts
+ */
+const createDocFromOpts = (guid, opts) => new Doc({ guid, ...opts, shouldLoad: opts.shouldLoad || opts.autoLoad || false });
+
+/**
+ * @private
+ */
+class ContentDoc {
+  /**
+   * @param {Doc} doc
+   */
+  constructor (doc) {
+    if (doc._item) {
+      console.error('This document was already integrated as a sub-document. You should create a second instance instead with the same guid.');
+    }
+    /**
+     * @type {Doc}
+     */
+    this.doc = doc;
+    /**
+     * @type {any}
+     */
+    const opts = {};
+    this.opts = opts;
+    if (!doc.gc) {
+      opts.gc = false;
+    }
+    if (doc.autoLoad) {
+      opts.autoLoad = true;
+    }
+    if (doc.meta !== null) {
+      opts.meta = doc.meta;
+    }
+  }
+
+  /**
+   * @return {number}
+   */
+  getLength () {
+    return 1
+  }
+
+  /**
+   * @return {Array<any>}
+   */
+  getContent () {
+    return [this.doc]
+  }
+
+  /**
+   * @return {boolean}
+   */
+  isCountable () {
+    return true
+  }
+
+  /**
+   * @return {ContentDoc}
+   */
+  copy () {
+    return new ContentDoc(createDocFromOpts(this.doc.guid, this.opts))
+  }
+
+  /**
+   * @param {number} offset
+   * @return {ContentDoc}
+   */
+  splice (offset) {
+    throw error.methodUnimplemented()
+  }
+
+  /**
+   * @param {ContentDoc} right
+   * @return {boolean}
+   */
+  mergeWith (right) {
+    return false
+  }
+
+  /**
+   * @param {Transaction} transaction
+   * @param {Item} item
+   */
+  integrate (transaction, item) {
+    // this needs to be reflected in doc.destroy as well
+    this.doc._item = item;
+    transaction.subdocsAdded.add(this.doc);
+    if (this.doc.shouldLoad) {
+      transaction.subdocsLoaded.add(this.doc);
+    }
+  }
+
+  /**
+   * @param {Transaction} transaction
+   */
+  delete (transaction) {
+    if (transaction.subdocsAdded.has(this.doc)) {
+      transaction.subdocsAdded.delete(this.doc);
+    } else {
+      transaction.subdocsRemoved.add(this.doc);
+    }
+  }
+
+  /**
+   * @param {Transaction} _tr
+   */
+  gc (_tr) {}
+
+  /**
+   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
+   * @param {number} _offset
+   * @param {number} _offsetEnd
+   */
+  write (encoder, _offset, _offsetEnd) {
+    encoder.writeString(this.doc.guid);
+    encoder.writeAny(this.opts);
+  }
+
+  /**
+   * @return {number}
+   */
+  getRef () {
+    return 9
+  }
+}
+
+/**
+ * @private
+ *
+ * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
+ * @return {ContentDoc}
+ */
+const readContentDoc = decoder => new ContentDoc(createDocFromOpts(decoder.readString(), decoder.readAny()));
+
+/**
+ * @private
+ */
+class ContentEmbed {
+  /**
+   * @param {Object} embed
+   */
+  constructor (embed) {
+    this.embed = embed;
+  }
+
+  /**
+   * @return {number}
+   */
+  getLength () {
+    return 1
+  }
+
+  /**
+   * @return {Array<any>}
+   */
+  getContent () {
+    return [this.embed]
+  }
+
+  /**
+   * @return {boolean}
+   */
+  isCountable () {
+    return true
+  }
+
+  /**
+   * @return {ContentEmbed}
+   */
+  copy () {
+    return new ContentEmbed(this.embed)
+  }
+
+  /**
+   * @param {number} offset
+   * @return {ContentEmbed}
+   */
+  splice (offset) {
+    throw error.methodUnimplemented()
+  }
+
+  /**
+   * @param {ContentEmbed} right
+   * @return {boolean}
+   */
+  mergeWith (right) {
+    return false
+  }
+
+  /**
+   * @param {Transaction} transaction
+   * @param {Item} item
+   */
+  integrate (transaction, item) {}
+  /**
+   * @param {Transaction} transaction
+   */
+  delete (transaction) {}
+  /**
+   * @param {Transaction} _tr
+   */
+  gc (_tr) {}
+  /**
+   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
+   * @param {number} _offset
+   * @param {number} _offsetEnd
+   */
+  write (encoder, _offset, _offsetEnd) {
+    encoder.writeJSON(this.embed);
+  }
+
+  /**
+   * @return {number}
+   */
+  getRef () {
+    return 5
+  }
+}
+
+/**
+ * @private
+ *
+ * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
+ * @return {ContentEmbed}
+ */
+const readContentEmbed = decoder => new ContentEmbed(decoder.readJSON());
+
+/**
+ * @private
+ */
+class ContentFormat {
+  /**
+   * @param {string} key
+   * @param {Object} value
+   */
+  constructor (key, value) {
+    this.key = key;
+    this.value = value;
+  }
+
+  /**
+   * @return {number}
+   */
+  getLength () {
+    return 1
+  }
+
+  /**
+   * @return {Array<any>}
+   */
+  getContent () {
+    return []
+  }
+
+  /**
+   * @return {boolean}
+   */
+  isCountable () {
+    return false
+  }
+
+  /**
+   * @return {ContentFormat}
+   */
+  copy () {
+    return new ContentFormat(this.key, this.value)
+  }
+
+  /**
+   * @param {number} _offset
+   * @return {ContentFormat}
+   */
+  splice (_offset) {
+    throw error.methodUnimplemented()
+  }
+
+  /**
+   * @param {ContentFormat} _right
+   * @return {boolean}
+   */
+  mergeWith (_right) {
+    return false
+  }
+
+  /**
+   * @param {Transaction} _transaction
+   * @param {Item} item
+   */
+  integrate (_transaction, item) {
+    // @todo searchmarker are currently unsupported for rich text documents
+    const p = /** @type {YText<any>} */ (item.parent);
+    p._searchMarker = null;
+    p._hasFormatting = true;
+  }
+
+  /**
+   * @param {Transaction} _transaction
+   */
+  delete (_transaction) {}
+  /**
+   * @param {Transaction} _tr
+   */
+  gc (_tr) {}
+  /**
+   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
+   * @param {number} _offset
+   * @param {number} _offsetEnd
+   */
+  write (encoder, _offset, _offsetEnd) {
+    encoder.writeKey(this.key);
+    encoder.writeJSON(this.value);
+  }
+
+  /**
+   * @return {number}
+   */
+  getRef () {
+    return 6
+  }
+}
+
+/**
+ * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
+ * @return {ContentFormat}
+ */
+const readContentFormat = decoder => new ContentFormat(decoder.readKey(), decoder.readJSON());
+
+/**
+ * @private
+ */
+class ContentJSON {
+  /**
+   * @param {Array<any>} arr
+   */
+  constructor (arr) {
+    /**
+     * @type {Array<any>}
+     */
+    this.arr = arr;
+  }
+
+  /**
+   * @return {number}
+   */
+  getLength () {
+    return this.arr.length
+  }
+
+  /**
+   * @return {Array<any>}
+   */
+  getContent () {
+    return this.arr
+  }
+
+  /**
+   * @return {boolean}
+   */
+  isCountable () {
+    return true
+  }
+
+  /**
+   * @return {ContentJSON}
+   */
+  copy () {
+    return new ContentJSON(this.arr)
+  }
+
+  /**
+   * @param {number} offset
+   * @return {ContentJSON}
+   */
+  splice (offset) {
+    const right = new ContentJSON(this.arr.slice(offset));
+    this.arr = this.arr.slice(0, offset);
+    return right
+  }
+
+  /**
+   * @param {ContentJSON} right
+   * @return {boolean}
+   */
+  mergeWith (right) {
+    this.arr = this.arr.concat(right.arr);
+    return true
+  }
+
+  /**
+   * @param {Transaction} transaction
+   * @param {Item} item
+   */
+  integrate (transaction, item) {}
+  /**
+   * @param {Transaction} transaction
+   */
+  delete (transaction) {}
+  /**
+   * @param {Transaction} _tr
+   */
+  gc (_tr) {}
+  /**
+   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
+   * @param {number} offset
+   * @param {number} offsetEnd
+   */
+  write (encoder, offset, offsetEnd) {
+    const end = this.arr.length - offsetEnd;
+    encoder.writeLen(end - offset);
+    for (let i = offset; i < end; i++) {
+      const c = this.arr[i];
+      encoder.writeString(c === undefined ? 'undefined' : JSON.stringify(c));
+    }
+  }
+
+  /**
+   * @return {number}
+   */
+  getRef () {
+    return 2
+  }
+}
+
+/**
+ * @private
+ *
+ * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
+ * @return {ContentJSON}
+ */
+const readContentJSON = decoder => {
+  const len = decoder.readLen();
+  const cs = [];
+  for (let i = 0; i < len; i++) {
+    const c = decoder.readString();
+    if (c === 'undefined') {
+      cs.push(undefined);
+    } else {
+      cs.push(JSON.parse(c));
+    }
+  }
+  return new ContentJSON(cs)
+};
+
+const isDevMode = env.getVariable('node_env') === 'development';
+
+class ContentAny {
+  /**
+   * @param {Array<any>} arr
+   */
+  constructor (arr) {
+    /**
+     * @type {Array<any>}
+     */
+    this.arr = arr;
+    isDevMode && object.deepFreeze(arr);
+  }
+
+  /**
+   * @return {number}
+   */
+  getLength () {
+    return this.arr.length
+  }
+
+  /**
+   * @return {Array<any>}
+   */
+  getContent () {
+    return this.arr
+  }
+
+  /**
+   * @return {boolean}
+   */
+  isCountable () {
+    return true
+  }
+
+  /**
+   * @return {ContentAny}
+   */
+  copy () {
+    return new ContentAny(this.arr)
+  }
+
+  /**
+   * @param {number} offset
+   * @return {ContentAny}
+   */
+  splice (offset) {
+    const right = new ContentAny(this.arr.slice(offset));
+    this.arr = this.arr.slice(0, offset);
+    return right
+  }
+
+  /**
+   * @param {ContentAny} right
+   * @return {boolean}
+   */
+  mergeWith (right) {
+    this.arr = this.arr.concat(right.arr);
+    return true
+  }
+
+  /**
+   * @param {Transaction} transaction
+   * @param {Item} item
+   */
+  integrate (transaction, item) {}
+  /**
+   * @param {Transaction} transaction
+   */
+  delete (transaction) {}
+  /**
+   * @param {Transaction} _tr
+   */
+  gc (_tr) {}
+  /**
+   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
+   * @param {number} offset
+   * @param {number} offsetEnd
+   */
+  write (encoder, offset, offsetEnd) {
+    const end = this.arr.length - offsetEnd;
+    encoder.writeLen(end - offset);
+    for (let i = offset; i < end; i++) {
+      const c = this.arr[i];
+      encoder.writeAny(c);
+    }
+  }
+
+  /**
+   * @return {number}
+   */
+  getRef () {
+    return 8
+  }
+}
+
+/**
+ * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
+ * @return {ContentAny}
+ */
+const readContentAny = decoder => {
+  const len = decoder.readLen();
+  const cs = [];
+  for (let i = 0; i < len; i++) {
+    cs.push(decoder.readAny());
+  }
+  return new ContentAny(cs)
+};
+
+/**
+ * @private
+ */
+class ContentString {
+  /**
+   * @param {string} str
+   */
+  constructor (str) {
+    /**
+     * @type {string}
+     */
+    this.str = str;
+  }
+
+  /**
+   * @return {number}
+   */
+  getLength () {
+    return this.str.length
+  }
+
+  /**
+   * @return {Array<any>}
+   */
+  getContent () {
+    return this.str.split('')
+  }
+
+  /**
+   * @return {boolean}
+   */
+  isCountable () {
+    return true
+  }
+
+  /**
+   * @return {ContentString}
+   */
+  copy () {
+    return new ContentString(this.str)
+  }
+
+  /**
+   * @param {number} offset
+   * @return {ContentString}
+   */
+  splice (offset) {
+    const right = new ContentString(this.str.slice(offset));
+    this.str = this.str.slice(0, offset);
+
+    // Prevent encoding invalid documents because of splitting of surrogate pairs: https://github.com/yjs/yjs/issues/248
+    const firstCharCode = this.str.charCodeAt(offset - 1);
+    if (firstCharCode >= 0xD800 && firstCharCode <= 0xDBFF) {
+      // Last character of the left split is the start of a surrogate utf16/ucs2 pair.
+      // We don't support splitting of surrogate pairs because this may lead to invalid documents.
+      // Replace the invalid character with a unicode replacement character ( / U+FFFD)
+      this.str = this.str.slice(0, offset - 1) + '';
+      // replace right as well
+      right.str = '' + right.str.slice(1);
+    }
+    return right
+  }
+
+  /**
+   * @param {ContentString} right
+   * @return {boolean}
+   */
+  mergeWith (right) {
+    this.str += right.str;
+    return true
+  }
+
+  /**
+   * @param {Transaction} transaction
+   * @param {Item} item
+   */
+  integrate (transaction, item) {}
+  /**
+   * @param {Transaction} transaction
+   */
+  delete (transaction) {}
+  /**
+   * @param {Transaction} _tr
+   */
+  gc (_tr) {}
+  /**
+   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
+   * @param {number} offset
+   * @param {number} offsetEnd
+   */
+  write (encoder, offset, offsetEnd) {
+    encoder.writeString((offset === 0 && offsetEnd === 0) ? this.str : this.str.slice(offset, this.str.length - offsetEnd));
+  }
+
+  /**
+   * @return {number}
+   */
+  getRef () {
+    return 4
+  }
+}
+
+/**
+ * @private
+ *
+ * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
+ * @return {ContentString}
+ */
+const readContentString = decoder => new ContentString(decoder.readString());
+
+/**
+ * @type {Array<(decoder: UpdateDecoderV1 | UpdateDecoderV2)=>(import('../utils/types.js').YType)>}
+ * @private
+ */
+const typeRefs = [
+  readYArray,
+  readYMap,
+  readYText,
+  readYXmlElement,
+  readYXmlFragment,
+  readYXmlHook,
+  readYXmlText
+];
+
+const YArrayRefID = 0;
+const YMapRefID = 1;
+const YTextRefID = 2;
+const YXmlElementRefID = 3;
+const YXmlFragmentRefID = 4;
+const YXmlHookRefID = 5;
+const YXmlTextRefID = 6;
+
+/**
+ * @private
+ */
+class ContentType {
+  /**
+   * @param {YType_CT} type
+   */
+  constructor (type) {
+    /**
+     * @type {YType_CT}
+     */
+    this.type = type;
+  }
+
+  /**
+   * @return {number}
+   */
+  getLength () {
+    return 1
+  }
+
+  /**
+   * @return {Array<any>}
+   */
+  getContent () {
+    return [this.type]
+  }
+
+  /**
+   * @return {boolean}
+   */
+  isCountable () {
+    return true
+  }
+
+  /**
+   * @return {ContentType}
+   */
+  copy () {
+    return new ContentType(this.type._copy())
+  }
+
+  /**
+   * @param {number} _offset
+   * @return {ContentType}
+   */
+  splice (_offset) {
+    throw error.methodUnimplemented()
+  }
+
+  /**
+   * @param {ContentType} _right
+   * @return {boolean}
+   */
+  mergeWith (_right) {
+    return false
+  }
+
+  /**
+   * @param {Transaction} transaction
+   * @param {Item} item
+   */
+  integrate (transaction, item) {
+    this.type._integrate(transaction.doc, item);
+  }
+
+  /**
+   * @param {Transaction} transaction
+   */
+  delete (transaction) {
+    let item = this.type._start;
+    while (item !== null) {
+      if (!item.deleted) {
+        item.delete(transaction);
+      } else if (!transaction.insertSet.hasId(item.id)) {
+        // This will be gc'd later and we want to merge it if possible
+        // We try to merge all deleted items after each transaction,
+        // but we have no knowledge about that this needs to be merged
+        // since it is not in transaction.ds. Hence we add it to transaction._mergeStructs
+        transaction._mergeStructs.push(item);
+      }
+      item = item.right;
+    }
+    this.type._map.forEach(item => {
+      if (!item.deleted) {
+        item.delete(transaction);
+      } else if (!transaction.insertSet.hasId(item.id)) {
+        // same as above
+        transaction._mergeStructs.push(item);
+      }
+    });
+    transaction.changed.delete(this.type);
+  }
+
+  /**
+   * @param {Transaction} tr
+   */
+  gc (tr) {
+    let item = this.type._start;
+    while (item !== null) {
+      item.gc(tr, true);
+      item = item.right;
+    }
+    this.type._start = null;
+    this.type._map.forEach(/** @param {Item | null} item */ (item) => {
+      while (item !== null) {
+        item.gc(tr, true);
+        item = item.left;
+      }
+    });
+    this.type._map = new Map();
+  }
+
+  /**
+   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
+   * @param {number} _offset
+   * @param {number} _offsetEnd
+   */
+  write (encoder, _offset, _offsetEnd) {
+    this.type._write(encoder);
+  }
+
+  /**
+   * @return {number}
+   */
+  getRef () {
+    return 7
+  }
+}
+
+/**
+ * @private
+ *
+ * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
+ * @return {ContentType}
+ */
+const readContentType = decoder => new ContentType(typeRefs[decoder.readTypeRef()](decoder));
+
+/**
+ * @typedef {import('../utils/types.js').YType} YType__
+ */
+
+/**
+ * @todo This should return several items
+ *
+ * @param {StructStore} store
+ * @param {ID} id
+ * @return {{item:Item, diff:number}}
+ */
+const followRedone = (store, id) => {
+  /**
+   * @type {ID|null}
+   */
+  let nextID = id;
+  let diff = 0;
+  let item;
+  do {
+    if (diff > 0) {
+      nextID = createID(nextID.client, nextID.clock + diff);
+    }
+    item = getItem(store, nextID);
+    diff = nextID.clock - item.id.clock;
+    nextID = item.redone;
+  } while (nextID !== null && item instanceof Item)
+  return {
+    item, diff
+  }
+};
+
+/**
+ * Make sure that neither item nor any of its parents is ever deleted.
+ *
+ * This property does not persist when storing it into a database or when
+ * sending it to other peers
+ *
+ * @param {Item|null} item
+ * @param {boolean} keep
+ */
+const keepItem = (item, keep) => {
+  while (item !== null && item.keep !== keep) {
+    item.keep = keep;
+    item = /** @type {YType__} */ (item.parent)._item;
+  }
+};
+
+/**
+ * Split leftItem into two items
+ * @param {Transaction?} transaction
+ * @param {Item} leftItem
+ * @param {number} diff
+ * @return {Item}
+ *
+ * @function
+ * @private
+ */
+const splitItem = (transaction, leftItem, diff) => {
+  // create rightItem
+  const { client, clock } = leftItem.id;
+  const rightItem = new Item(
+    createID(client, clock + diff),
+    leftItem,
+    createID(client, clock + diff - 1),
+    leftItem.right,
+    leftItem.rightOrigin,
+    leftItem.parent,
+    leftItem.parentSub,
+    leftItem.content.splice(diff)
+  );
+  if (leftItem.deleted) {
+    rightItem.markDeleted();
+  }
+  if (leftItem.keep) {
+    rightItem.keep = true;
+  }
+  if (leftItem.redone !== null) {
+    rightItem.redone = createID(leftItem.redone.client, leftItem.redone.clock + diff);
+  }
+  if (transaction != null) {
+    // update left (do not set leftItem.rightOrigin as it will lead to problems when syncing)
+    leftItem.right = rightItem;
+    // update right
+    if (rightItem.right !== null) {
+      rightItem.right.left = rightItem;
+    }
+    // right is more specific.
+    transaction._mergeStructs.push(rightItem);
+    // update parent._map
+    if (rightItem.parentSub !== null && rightItem.right === null) {
+      /** @type {YType__} */ (rightItem.parent)._map.set(rightItem.parentSub, rightItem);
+    }
+  } else {
+    rightItem.left = null;
+    rightItem.right = null;
+  }
+  leftItem.length = diff;
+  return rightItem
+};
+
+/**
+ * More generalized version of splitItem. Split leftStruct into two structs
+ * @param {Transaction?} transaction
+ * @param {AbstractStruct} leftStruct
+ * @param {number} diff
+ * @return {GC|Item}
+ *
+ * @function
+ * @private
+ */
+const splitStruct = (transaction, leftStruct, diff) => {
+  if (leftStruct instanceof Item) {
+    return splitItem(transaction, leftStruct, diff)
+  } else {
+    const rightItem = leftStruct.splice(diff);
+    transaction?._mergeStructs.push(rightItem);
+    return rightItem
+  }
+};
+
+/**
+ * @param {Array<StackItem>} stack
+ * @param {ID} id
+ */
+const isDeletedByUndoStack = (stack, id) => array.some(stack, /** @param {StackItem} s */ s => s.deletions.hasId(id));
+
+/**
+ * Redoes the effect of this operation.
+ *
+ * @param {Transaction} transaction The Yjs instance.
+ * @param {Item} item
+ * @param {Set<Item>} redoitems
+ * @param {IdSet} itemsToDelete
+ * @param {boolean} ignoreRemoteMapChanges
+ * @param {import('../utils/UndoManager.js').UndoManager} um
+ *
+ * @return {Item|null}
+ *
+ * @private
+ */
+const redoItem = (transaction, item, redoitems, itemsToDelete, ignoreRemoteMapChanges, um) => {
+  const doc = transaction.doc;
+  const store = doc.store;
+  const ownClientID = doc.clientID;
+  const redone = item.redone;
+  if (redone !== null) {
+    return getItemCleanStart(transaction, redone)
+  }
+  let parentItem = /** @type {YType__} */ (item.parent)._item;
+  /**
+   * @type {Item|null}
+   */
+  let left = null;
+  /**
+   * @type {Item|null}
+   */
+  let right;
+  // make sure that parent is redone
+  if (parentItem !== null && parentItem.deleted === true) {
+    // try to undo parent if it will be undone anyway
+    if (parentItem.redone === null && (!redoitems.has(parentItem) || redoItem(transaction, parentItem, redoitems, itemsToDelete, ignoreRemoteMapChanges, um) === null)) {
+      return null
+    }
+    while (parentItem.redone !== null) {
+      parentItem = getItemCleanStart(transaction, parentItem.redone);
+    }
+  }
+  /**
+   * @type {YType__}
+   */
+  const parentType = /** @type {YType__} */ (parentItem === null ? item.parent : /** @type {ContentType} */ (parentItem.content).type);
+
+  if (item.parentSub === null) {
+    // Is an array item. Insert at the old position
+    left = item.left;
+    right = item;
+    // find next cloned_redo items
+    while (left !== null) {
+      /**
+       * @type {Item|null}
+       */
+      let leftTrace = left;
+      // trace redone until parent matches
+      while (leftTrace !== null && /** @type {YType__} */ (leftTrace.parent)._item !== parentItem) {
+        leftTrace = leftTrace.redone === null ? null : getItemCleanStart(transaction, leftTrace.redone);
+      }
+      if (leftTrace !== null && /** @type {YType__} */ (leftTrace.parent)._item === parentItem) {
+        left = leftTrace;
+        break
+      }
+      left = left.left;
+    }
+    while (right !== null) {
+      /**
+       * @type {Item|null}
+       */
+      let rightTrace = right;
+      // trace redone until parent matches
+      while (rightTrace !== null && /** @type {YType__} */ (rightTrace.parent)._item !== parentItem) {
+        rightTrace = rightTrace.redone === null ? null : getItemCleanStart(transaction, rightTrace.redone);
+      }
+      if (rightTrace !== null && /** @type {YType__} */ (rightTrace.parent)._item === parentItem) {
+        right = rightTrace;
+        break
+      }
+      right = right.right;
+    }
+  } else {
+    right = null;
+    if (item.right && !ignoreRemoteMapChanges) {
+      left = item;
+      // Iterate right while right is in itemsToDelete
+      // If it is intended to delete right while item is redone, we can expect that item should replace right.
+      while (left !== null && left.right !== null && (left.right.redone || itemsToDelete.hasId(left.right.id) || isDeletedByUndoStack(um.undoStack, left.right.id) || isDeletedByUndoStack(um.redoStack, left.right.id))) {
+        left = left.right;
+        // follow redone
+        while (left.redone) left = getItemCleanStart(transaction, left.redone);
+      }
+      if (left && left.right !== null) {
+        // It is not possible to redo this item because it conflicts with a
+        // change from another client
+        return null
+      }
+    } else {
+      left = parentType._map.get(item.parentSub) || null;
+    }
+  }
+  const nextClock = getState(store, ownClientID);
+  const nextId = createID(ownClientID, nextClock);
+  const redoneItem = new Item(
+    nextId,
+    left, left && left.lastId,
+    right, right && right.id,
+    parentType,
+    item.parentSub,
+    item.content.copy()
+  );
+  item.redone = nextId;
+  keepItem(redoneItem, true);
+  redoneItem.integrate(transaction, 0);
+  return redoneItem
+};
+
+/**
+ * Abstract class that represents any content.
+ */
+class Item extends AbstractStruct {
+  /**
+   * @param {ID} id
+   * @param {Item | null} left
+   * @param {ID | null} origin
+   * @param {Item | null} right
+   * @param {ID | null} rightOrigin
+   * @param {AbstractType<any,any>|ID|null} parent Is a type if integrated, is null if it is possible to copy parent from left or right, is ID before integration to search for it.
+   * @param {string | null} parentSub
+   * @param {AbstractContent} content
+   */
+  constructor (id, left, origin, right, rightOrigin, parent, parentSub, content) {
+    super(id, content.getLength());
+    /**
+     * The item that was originally to the left of this item.
+     * @type {ID | null}
+     */
+    this.origin = origin;
+    /**
+     * The item that is currently to the left of this item.
+     * @type {Item | null}
+     */
+    this.left = left;
+    /**
+     * The item that is currently to the right of this item.
+     * @type {Item | null}
+     */
+    this.right = right;
+    /**
+     * The item that was originally to the right of this item.
+     * @type {ID | null}
+     */
+    this.rightOrigin = rightOrigin;
+    /**
+     * @type {AbstractType<any,any>|ID|null}
+     */
+    this.parent = parent;
+    /**
+     * If the parent refers to this item with some kind of key (e.g. YMap, the
+     * key is specified here. The key is then used to refer to the list in which
+     * to insert this item. If `parentSub = null` type._start is the list in
+     * which to insert to. Otherwise it is `parent._map`.
+     * @type {String | null}
+     */
+    this.parentSub = parentSub;
+    /**
+     * If this type's effect is redone this type refers to the type that undid
+     * this operation.
+     * @type {ID | null}
+     */
+    this.redone = null;
+    /**
+     * @type {AbstractContent}
+     */
+    this.content = content;
+    /**
+     * bit1: keep
+     * bit2: countable
+     * bit3: deleted
+     * bit4: mark - mark node as fast-search-marker
+     * @type {number} byte
+     */
+    this.info = this.content.isCountable() ? binary.BIT2 : 0;
+  }
+
+  /**
+   * This is used to mark the item as an indexed fast-search marker
+   *
+   * @type {boolean}
+   */
+  set marker (isMarked) {
+    if (((this.info & binary.BIT4) > 0) !== isMarked) {
+      this.info ^= binary.BIT4;
+    }
+  }
+
+  get marker () {
+    return (this.info & binary.BIT4) > 0
+  }
+
+  /**
+   * If true, do not garbage collect this Item.
+   */
+  get keep () {
+    return (this.info & binary.BIT1) > 0
+  }
+
+  set keep (doKeep) {
+    if (this.keep !== doKeep) {
+      this.info ^= binary.BIT1;
+    }
+  }
+
+  get countable () {
+    return (this.info & binary.BIT2) > 0
+  }
+
+  /**
+   * Whether this item was deleted or not.
+   * @type {Boolean}
+   */
+  get deleted () {
+    return (this.info & binary.BIT3) > 0
+  }
+
+  set deleted (doDelete) {
+    if (this.deleted !== doDelete) {
+      this.info ^= binary.BIT3;
+    }
+  }
+
+  markDeleted () {
+    this.info |= binary.BIT3;
+  }
+
+  /**
+   * Return the creator clientID of the missing op or define missing items and return null.
+   *
+   * @param {Transaction} transaction
+   * @param {StructStore} store
+   * @return {null | number}
+   */
+  getMissing (transaction, store) {
+    if (this.origin && (this.origin.clock >= getState(store, this.origin.client) || store.skips.hasId(this.origin))) {
+      return this.origin.client
+    }
+    if (this.rightOrigin && (this.rightOrigin.clock >= getState(store, this.rightOrigin.client) || store.skips.hasId(this.rightOrigin))) {
+      return this.rightOrigin.client
+    }
+    if (this.parent && this.parent.constructor === ID && (this.parent.clock >= getState(store, this.parent.client) || store.skips.hasId(this.parent))) {
+      return this.parent.client
+    }
+    // We have all missing ids, now find the items
+    if (this.origin) {
+      this.left = getItemCleanEnd(transaction, store, this.origin);
+      this.origin = this.left.lastId;
+    }
+    if (this.rightOrigin) {
+      this.right = getItemCleanStart(transaction, this.rightOrigin);
+      this.rightOrigin = this.right.id;
+    }
+    if ((this.left && this.left.constructor === GC) || (this.right && this.right.constructor === GC)) {
+      this.parent = null;
+    } else if (!this.parent) {
+      // only set parent if this shouldn't be garbage collected
+      if (this.left && this.left.constructor === Item) {
+        this.parent = this.left.parent;
+        this.parentSub = this.left.parentSub;
+      } else if (this.right && this.right.constructor === Item) {
+        this.parent = this.right.parent;
+        this.parentSub = this.right.parentSub;
+      }
+    } else if (this.parent.constructor === ID) {
+      const parentItem = getItem(store, this.parent);
+      if (parentItem.constructor === GC) {
+        this.parent = null;
+      } else {
+        this.parent = /** @type {ContentType} */ (parentItem.content).type;
+      }
+    }
+    return null
+  }
+
+  /**
+   * @param {Transaction} transaction
+   * @param {number} offset
+   */
+  integrate (transaction, offset) {
+    if (offset > 0) {
+      this.id.clock += offset;
+      this.left = getItemCleanEnd(transaction, transaction.doc.store, createID(this.id.client, this.id.clock - 1));
+      this.origin = this.left.lastId;
+      this.content = this.content.splice(offset);
+      this.length -= offset;
+    }
+
+    if (this.parent) {
+      if ((!this.left && (!this.right || this.right.left !== null)) || (this.left && this.left.right !== this.right)) {
+        /**
+         * @type {Item|null}
+         */
+        let left = this.left;
+
+        /**
+         * @type {Item|null}
+         */
+        let o;
+        // set o to the first conflicting item
+        if (left !== null) {
+          o = left.right;
+        } else if (this.parentSub !== null) {
+          o = /** @type {AbstractType<any>} */ (this.parent)._map.get(this.parentSub) || null;
+          while (o !== null && o.left !== null) {
+            o = o.left;
+          }
+        } else {
+          o = /** @type {AbstractType<any>} */ (this.parent)._start;
+        }
+        // TODO: use something like DeleteSet here (a tree implementation would be best)
+        // @todo use global set definitions
+        /**
+         * @type {Set<Item>}
+         */
+        const conflictingItems = new Set();
+        /**
+         * @type {Set<Item>}
+         */
+        const itemsBeforeOrigin = new Set();
+        // Let c in conflictingItems, b in itemsBeforeOrigin
+        // ***{origin}bbbb{this}{c,b}{c,b}{o}***
+        // Note that conflictingItems is a subset of itemsBeforeOrigin
+        while (o !== null && o !== this.right) {
+          itemsBeforeOrigin.add(o);
+          conflictingItems.add(o);
+          if (compareIDs(this.origin, o.origin)) {
+            // case 1
+            if (o.id.client < this.id.client) {
+              left = o;
+              conflictingItems.clear();
+            } else if (compareIDs(this.rightOrigin, o.rightOrigin)) {
+              // this and o are conflicting and point to the same integration points. The id decides which item comes first.
+              // Since this is to the left of o, we can break here
+              break
+            } // else, o might be integrated before an item that this conflicts with. If so, we will find it in the next iterations
+          } else if (o.origin !== null && itemsBeforeOrigin.has(getItem(transaction.doc.store, o.origin))) { // use getItem instead of getItemCleanEnd because we don't want / need to split items.
+            // case 2
+            if (!conflictingItems.has(getItem(transaction.doc.store, o.origin))) {
+              left = o;
+              conflictingItems.clear();
+            }
+          } else {
+            break
+          }
+          o = o.right;
+        }
+        this.left = left;
+      }
+      // reconnect left/right + update parent map/start if necessary
+      if (this.left !== null) {
+        const right = this.left.right;
+        this.right = right;
+        this.left.right = this;
+      } else {
+        let r;
+        if (this.parentSub !== null) {
+          r = /** @type {AbstractType<any>} */ (this.parent)._map.get(this.parentSub) || null;
+          while (r !== null && r.left !== null) {
+            r = r.left;
+          }
+        } else {
+          r = /** @type {AbstractType<any>} */ (this.parent)._start
+          ;/** @type {AbstractType<any>} */ (this.parent)._start = this;
+        }
+        this.right = r;
+      }
+      if (this.right !== null) {
+        this.right.left = this;
+      } else if (this.parentSub !== null) {
+        // set as current parent value if right === null and this is parentSub
+        /** @type {AbstractType<any>} */ (this.parent)._map.set(this.parentSub, this);
+        if (this.left !== null) {
+          // this is the current attribute value of parent. delete right
+          this.left.delete(transaction);
+        }
+      }
+      // adjust length of parent
+      if (this.parentSub === null && this.countable && !this.deleted) {
+        /** @type {AbstractType<any>} */ (this.parent)._length += this.length;
+      }
+      addStructToIdSet(transaction.insertSet, this);
+      addStruct(transaction.doc.store, this);
+      this.content.integrate(transaction, this);
+      // add parent to transaction.changed
+      addChangedTypeToTransaction(transaction, /** @type {import('../utils/types.js').YType} */ (this.parent), this.parentSub);
+      if ((/** @type {AbstractType<any>} */ (this.parent)._item !== null && /** @type {AbstractType<any>} */ (this.parent)._item.deleted) || (this.parentSub !== null && this.right !== null)) {
+        // delete if parent is deleted or if this is not the current attribute value of parent
+        this.delete(transaction);
+      }
+    } else {
+      // parent is not defined. Integrate GC struct instead
+      new GC(this.id, this.length).integrate(transaction, 0);
+    }
+  }
+
+  /**
+   * Returns the next non-deleted item
+   */
+  get next () {
+    let n = this.right;
+    while (n !== null && n.deleted) {
+      n = n.right;
+    }
+    return n
+  }
+
+  /**
+   * Returns the previous non-deleted item
+   */
+  get prev () {
+    let n = this.left;
+    while (n !== null && n.deleted) {
+      n = n.left;
+    }
+    return n
+  }
+
+  /**
+   * Computes the last content address of this Item.
+   */
+  get lastId () {
+    // allocating ids is pretty costly because of the amount of ids created, so we try to reuse whenever possible
+    return this.length === 1 ? this.id : createID(this.id.client, this.id.clock + this.length - 1)
+  }
+
+  /**
+   * Try to merge two items
+   *
+   * @param {Item} right
+   * @return {boolean}
+   */
+  mergeWith (right) {
+    if (
+      this.constructor === right.constructor &&
+      compareIDs(right.origin, this.lastId) &&
+      this.right === right &&
+      compareIDs(this.rightOrigin, right.rightOrigin) &&
+      this.id.client === right.id.client &&
+      this.id.clock + this.length === right.id.clock &&
+      this.deleted === right.deleted &&
+      this.redone === null &&
+      right.redone === null &&
+      this.content.constructor === right.content.constructor &&
+      this.content.mergeWith(right.content)
+    ) {
+      const searchMarker = /** @type {AbstractType<any>} */ (this.parent)._searchMarker;
+      if (searchMarker) {
+        searchMarker.forEach(marker => {
+          if (marker.p === right) {
+            // right is going to be "forgotten" so we need to update the marker
+            marker.p = this;
+            // adjust marker index
+            if (!this.deleted && this.countable) {
+              marker.index -= this.length;
+            }
+          }
+        });
+      }
+      if (right.keep) {
+        this.keep = true;
+      }
+      this.right = right.right;
+      if (this.right !== null) {
+        this.right.left = this;
+      }
+      this.length += right.length;
+      return true
+    }
+    return false
+  }
+
+  /**
+   * Mark this Item as deleted.
+   *
+   * @param {Transaction} transaction
+   */
+  delete (transaction) {
+    if (!this.deleted) {
+      const parent = /** @type {import('../utils/types.js').YType} */ (this.parent);
+      // adjust the length of parent
+      if (this.countable && this.parentSub === null) {
+        parent._length -= this.length;
+      }
+      this.markDeleted();
+      addToIdSet(transaction.deleteSet, this.id.client, this.id.clock, this.length);
+      addChangedTypeToTransaction(transaction, parent, this.parentSub);
+      this.content.delete(transaction);
+    }
+  }
+
+  /**
+   * @param {Transaction} tr
+   * @param {boolean} parentGCd
+   */
+  gc (tr, parentGCd) {
+    if (!this.deleted) {
+      throw error.unexpectedCase()
+    }
+    this.content.gc(tr);
+    if (parentGCd) {
+      replaceStruct(tr, this, new GC(this.id, this.length));
+    } else {
+      this.content = new ContentDeleted(this.length);
+    }
+  }
+
+  /**
+   * Transform the properties of this type to binary and write it to an
+   * BinaryEncoder.
+   *
+   * This is called when this Item is sent to a remote peer.
+   *
+   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
+   * @param {number} offset
+   * @param {number} offsetEnd
+   */
+  write (encoder, offset, offsetEnd) {
+    const origin = offset > 0 ? createID(this.id.client, this.id.clock + offset - 1) : this.origin;
+    const rightOrigin = this.rightOrigin;
+    const parentSub = this.parentSub;
+    const info = (this.content.getRef() & binary.BITS5) |
+      (origin === null ? 0 : binary.BIT8) | // origin is defined
+      (rightOrigin === null ? 0 : binary.BIT7) | // right origin is defined
+      (parentSub === null ? 0 : binary.BIT6); // parentSub is non-null
+    encoder.writeInfo(info);
+    if (origin !== null) {
+      encoder.writeLeftID(origin);
+    }
+    if (rightOrigin !== null) {
+      encoder.writeRightID(rightOrigin);
+    }
+    if (origin === null && rightOrigin === null) {
+      const parent = /** @type {AbstractType<any>} */ (this.parent);
+      if (parent._item !== undefined) {
+        const parentItem = parent._item;
+        if (parentItem === null) {
+          // parent type on y._map
+          // find the correct key
+          const ykey = findRootTypeKey(parent);
+          encoder.writeParentInfo(true); // write parentYKey
+          encoder.writeString(ykey);
+        } else {
+          encoder.writeParentInfo(false); // write parent id
+          encoder.writeLeftID(parentItem.id);
+        }
+      } else if (parent.constructor === String) { // this edge case was added by differential updates
+        encoder.writeParentInfo(true); // write parentYKey
+        encoder.writeString(parent);
+      } else if (parent.constructor === ID) {
+        encoder.writeParentInfo(false); // write parent id
+        encoder.writeLeftID(parent);
+      } else {
+        error.unexpectedCase();
+      }
+      if (parentSub !== null) {
+        encoder.writeString(parentSub);
+      }
+    }
+    this.content.write(encoder, offset, offsetEnd);
+  }
+}
+
+/**
+ * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
+ * @param {number} info
+ */
+const readItemContent = (decoder, info) => contentRefs[info & binary.BITS5](decoder);
+
+/**
+ * A lookup map for reading Item content.
+ *
+ * @type {Array<function(UpdateDecoderV1 | UpdateDecoderV2):AbstractContent>}
+ */
+const contentRefs = [
+  () => { error.unexpectedCase(); }, // GC is not ItemContent
+  readContentDeleted, // 1
+  readContentJSON, // 2
+  readContentBinary, // 3
+  readContentString, // 4
+  readContentEmbed, // 5
+  readContentFormat, // 6
+  readContentType, // 7
+  readContentAny, // 8
+  readContentDoc, // 9
+  () => { error.unexpectedCase(); } // 10 - Skip is not ItemContent
+];
+
+/**
+ * Do not implement this class!
+ */
+class AbstractContent {
+  /**
+   * @return {number}
+   */
+  getLength () {
+    throw error.methodUnimplemented()
+  }
+
+  /**
+   * @return {Array<any>}
+   */
+  getContent () {
+    throw error.methodUnimplemented()
+  }
+
+  /**
+   * Should return false if this Item is some kind of meta information
+   * (e.g. format information).
+   *
+   * * Whether this Item should be addressable via `yarray.get(i)`
+   * * Whether this Item should be counted when computing yarray.length
+   *
+   * @return {boolean}
+   */
+  isCountable () {
+    throw error.methodUnimplemented()
+  }
+
+  /**
+   * @return {AbstractContent}
+   */
+  copy () {
+    throw error.methodUnimplemented()
+  }
+
+  /**
+   * @param {number} _offset
+   * @return {AbstractContent}
+   */
+  splice (_offset) {
+    throw error.methodUnimplemented()
+  }
+
+  /**
+   * @param {AbstractContent} _right
+   * @return {boolean}
+   */
+  mergeWith (_right) {
+    throw error.methodUnimplemented()
+  }
+
+  /**
+   * @param {Transaction} _transaction
+   * @param {Item} _item
+   */
+  integrate (_transaction, _item) {
+    throw error.methodUnimplemented()
+  }
+
+  /**
+   * @param {Transaction} _transaction
+   */
+  delete (_transaction) {
+    throw error.methodUnimplemented()
+  }
+
+  /**
+   * @param {Transaction} _transaction
+   */
+  gc (_transaction) {
+    throw error.methodUnimplemented()
+  }
+
+  /**
+   * @param {UpdateEncoderV1 | UpdateEncoderV2} _encoder
+   * @param {number} _offset
+   * @param {number} _offsetEnd
+   */
+  write (_encoder, _offset, _offsetEnd) {
+    throw error.methodUnimplemented()
+  }
+
+  /**
+   * @return {number}
+   */
+  getRef () {
+    throw error.methodUnimplemented()
+  }
+}
+
+const structSkipRefNumber = 10;
+
+/**
+ * @private
+ */
+class Skip extends AbstractStruct {
+  get deleted () {
+    return false
+  }
+
+  delete () {}
+
+  /**
+   * @param {Skip} right
+   * @return {boolean}
+   */
+  mergeWith (right) {
+    if (this.constructor !== right.constructor) {
+      return false
+    }
+    this.length += right.length;
+    return true
+  }
+
+  /**
+   * @param {Transaction} transaction
+   * @param {number} offset
+   */
+  integrate (transaction, offset) {
+    if (offset > 0) {
+      this.id.clock += offset;
+      this.length -= offset;
+    }
+    addToIdSet(transaction.doc.store.skips, this.id.client, this.id.clock, this.length);
+    addStruct(transaction.doc.store, this);
+  }
+
+  /**
+   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
+   * @param {number} offset
+   */
+  write (encoder, offset) {
+    encoder.writeInfo(structSkipRefNumber);
+    // write as VarUint because Skips can't make use of predictable length-encoding
+    encoding.writeVarUint(encoder.restEncoder, this.length - offset);
+  }
+
+  /**
+   * @param {Transaction} _transaction
+   * @param {StructStore} _store
+   * @return {null | number}
+   */
+  getMissing (_transaction, _store) {
+    return null
+  }
+
+  /**
+   * @param {number} diff
+   */
+  splice (diff) {
+    const other = new Skip(createID(this.id.client, this.id.clock + diff), this.length - diff);
+    this.length = diff;
+    return other
+  }
+}
+
+export { encodeStateVector as $, AbstractConnector as A, DSDecoderV2 as B, UpdateDecoderV2 as C, Doc as D, IdSetEncoderV1 as E, UpdateEncoderV1 as F, IdSetEncoderV2 as G, UpdateEncoderV2 as H, IdRange as I, writeClientsStructs as J, writeStructsFromIdSet as K, writeStructsFromTransaction as L, MaybeIdRange as M, readUpdateV2 as N, readUpdate as O, applyUpdateV2 as P, applyUpdate as Q, writeStateAsUpdate as R, encodeStateAsUpdateV2 as S, encodeStateAsUpdate as T, UpdateDecoderV1 as U, readStateVector as V, decodeStateVector as W, writeStateVector as X, writeDocumentStateVector as Y, encodeStateVectorV2 as Z, _deleteRangeFromIdSet as _, IdRanges as a, logUpdate as a$, EventHandler as a0, createEventHandler as a1, addEventHandlerListener as a2, removeEventHandlerListener as a3, removeAllEventHandlerListeners as a4, callEventHandlerListeners as a5, ID as a6, compareIDs as a7, createID as a8, writeID as a9, isVisible as aA, splitSnapshotAffectedStructs as aB, createDocFromSnapshot as aC, snapshotContainsUpdateV2 as aD, snapshotContainsUpdate as aE, StructStore as aF, getStateVector as aG, getState as aH, integrityCheck as aI, addStruct as aJ, findIndexSS as aK, find as aL, getItem as aM, findIndexCleanStart as aN, getItemCleanStart as aO, getItemCleanEnd as aP, replaceStruct as aQ, iterateStructs as aR, Transaction as aS, writeUpdateMessageFromTransaction as aT, nextID as aU, addChangedTypeToTransaction as aV, tryGc as aW, transact as aX, StackItem as aY, UndoManager as aZ, LazyStructReader as a_, readID as aa, findRootTypeKey as ab, isParentOf as ac, logType as ad, RelativePosition as ae, relativePositionToJSON as af, createRelativePositionFromJSON as ag, AbsolutePosition as ah, createAbsolutePosition as ai, createRelativePosition as aj, createRelativePositionFromTypeIndex as ak, writeRelativePosition as al, encodeRelativePosition as am, readRelativePosition as an, decodeRelativePosition as ao, createAbsolutePositionFromRelativePosition as ap, compareRelativePositions as aq, Snapshot as ar, equalSnapshots as as, encodeSnapshotV2 as at, encodeSnapshot as au, decodeSnapshotV2 as av, decodeSnapshot as aw, createSnapshot as ax, emptySnapshot as ay, snapshot as az, IdSet as b, typeListMap as b$, logUpdateV2 as b0, decodeUpdate as b1, decodeUpdateV2 as b2, LazyStructWriter as b3, mergeUpdates as b4, encodeStateVectorFromUpdateV2 as b5, encodeStateVectorFromUpdate as b6, readUpdateIdRangesV2 as b7, readUpdateIdRanges as b8, mergeUpdatesV2 as b9, insertIntoIdMap as bA, diffIdMap as bB, intersectMaps as bC, attributionJsonSchema as bD, createAttributionFromAttributionItems as bE, AttributedContent as bF, AbstractAttributionManager as bG, TwosetAttributionManager as bH, NoAttributionsManager as bI, noAttributionsManager as bJ, DiffAttributionManager as bK, createAttributionManagerFromDiff as bL, SnapshotAttributionManager as bM, createAttributionManagerFromSnapshots as bN, diffDocsToDelta as bO, warnPrematureAccess as bP, ArraySearchMarker as bQ, findMarker as bR, updateMarkerChanges as bS, getTypeChildren as bT, callTypeObservers as bU, AbstractType as bV, equalAttrs as bW, typeListSlice as bX, typeListToArray as bY, typeListToArraySnapshot as bZ, typeListForEach as b_, diffUpdateV2 as ba, diffUpdate as bb, convertUpdateFormat as bc, obfuscateUpdate as bd, obfuscateUpdateV2 as be, convertUpdateFormatV1ToV2 as bf, convertUpdateFormatV2ToV1 as bg, YEvent as bh, getPathTo as bi, readStructSet as bj, removeRangesFromStructSet as bk, StructSet as bl, AttributionItem as bm, createAttributionItem as bn, idmapAttrsEqual as bo, AttrRange as bp, createMaybeAttrRange as bq, AttrRanges as br, mergeIdMaps as bs, createIdMapFromIdSet as bt, IdMap as bu, writeIdMap as bv, encodeIdMap as bw, readIdMap as bx, decodeIdMap as by, createIdMap as bz, createMaybeIdRange as c, readContentType as c$, typeListCreateIterator as c0, typeListForEachSnapshot as c1, typeListGet as c2, typeListInsertGenericsAfter as c3, typeListInsertGenerics as c4, typeListPushGenerics as c5, typeListDelete as c6, typeMapDelete as c7, typeMapSet as c8, typeMapGet as c9, structGCRefNumber as cA, GC as cB, ContentBinary as cC, readContentBinary as cD, ContentDeleted as cE, readContentDeleted as cF, ContentDoc as cG, readContentDoc as cH, ContentEmbed as cI, readContentEmbed as cJ, ContentFormat as cK, readContentFormat as cL, ContentJSON as cM, readContentJSON as cN, ContentAny as cO, readContentAny as cP, ContentString as cQ, readContentString as cR, typeRefs as cS, YArrayRefID as cT, YMapRefID as cU, YTextRefID as cV, YXmlElementRefID as cW, YXmlFragmentRefID as cX, YXmlHookRefID as cY, YXmlTextRefID as cZ, ContentType as c_, typeMapGetAll as ca, typeMapGetDelta as cb, typeMapHas as cc, typeMapGetSnapshot as cd, typeMapGetAllSnapshot as ce, createMapIterator as cf, YArray as cg, readYArray as ch, YMap as ci, readYMap as cj, ItemTextListPosition as ck, insertText as cl, cleanupYTextFormatting as cm, cleanupYTextAfterTransaction as cn, deleteText as co, YText as cp, readYText as cq, YXmlFragment as cr, readYXmlFragment as cs, YXmlElement as ct, readYXmlElement as cu, YXmlHook as cv, readYXmlHook as cw, YXmlText as cx, readYXmlText as cy, AbstractStruct as cz, findRangeStartInIdRanges as d, followRedone as d0, keepItem as d1, splitItem as d2, splitStruct as d3, redoItem as d4, Item as d5, readItemContent as d6, contentRefs as d7, AbstractContent as d8, structSkipRefNumber as d9, Skip as da, _insertIntoIdSet as e, findIndexInIdRanges as f, insertIntoIdSet as g, _diffSet as h, iterateStructsByIdSet as i, diffIdSet as j, _intersectSets as k, intersectSets as l, mergeIdSets as m, addToIdSet as n, addStructToIdSet as o, createIdSet as p, createDeleteSetFromStructStore as q, _createInsertSliceFromStructs as r, createInsertSetFromStructStore as s, readIdSet as t, readAndApplyDeleteSet as u, equalIdSets as v, writeIdSet as w, generateNewClientId as x, cloneDoc as y, DSDecoderV1 as z };
+//# sourceMappingURL=Skip-gsWxt5h3.js.map
diff --git a/dist/Skip-gsWxt5h3.js.map b/dist/Skip-gsWxt5h3.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..40b0658fdf8c20f6df02b743ecc5ebd0b3aeed70
--- /dev/null
+++ b/dist/Skip-gsWxt5h3.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"Skip-gsWxt5h3.js","sources":["../src/utils/AbstractConnector.js","../src/utils/IdSet.js","../src/utils/Doc.js","../src/utils/UpdateDecoder.js","../src/utils/UpdateEncoder.js","../src/utils/encoding.js","../src/utils/EventHandler.js","../src/utils/ID.js","../src/utils/isParentOf.js","../src/utils/logging.js","../src/utils/RelativePosition.js","../src/utils/Snapshot.js","../src/utils/StructStore.js","../src/utils/Transaction.js","../src/utils/UndoManager.js","../src/utils/updates.js","../src/utils/YEvent.js","../src/utils/StructSet.js","../src/utils/IdMap.js","../src/utils/AttributionManager.js","../src/utils/delta-helpers.js","../src/types/AbstractType.js","../src/types/YArray.js","../src/types/YMap.js","../src/types/YText.js","../src/types/YXmlFragment.js","../src/types/YXmlElement.js","../src/types/YXmlHook.js","../src/types/YXmlText.js","../src/structs/AbstractStruct.js","../src/structs/GC.js","../src/structs/ContentBinary.js","../src/structs/ContentDeleted.js","../src/structs/ContentDoc.js","../src/structs/ContentEmbed.js","../src/structs/ContentFormat.js","../src/structs/ContentJSON.js","../src/structs/ContentAny.js","../src/structs/ContentString.js","../src/structs/ContentType.js","../src/structs/Item.js","../src/structs/Skip.js"],"sourcesContent":["import { ObservableV2 } from 'lib0/observable'\n\nimport {\n  Doc // eslint-disable-line\n} from '../internals.js'\n\n/**\n * This is an abstract interface that all Connectors should implement to keep them interchangeable.\n *\n * @note This interface is experimental and it is not advised to actually inherit this class.\n *       It just serves as typing information.\n *\n * @extends {ObservableV2<any>}\n */\nexport class AbstractConnector extends ObservableV2 {\n  /**\n   * @param {Doc} ydoc\n   * @param {any} awareness\n   */\n  constructor (ydoc, awareness) {\n    super()\n    this.doc = ydoc\n    this.awareness = awareness\n  }\n}\n","import {\n  findIndexSS,\n  getState,\n  splitItem,\n  iterateStructs,\n  UpdateEncoderV2,\n  IdMap,\n  AttrRanges,\n  AttrRange,\n  Skip, AbstractStruct, DSDecoderV1, IdSetEncoderV1, DSDecoderV2, IdSetEncoderV2, Item, GC, StructStore, Transaction, ID, AttributionItem, // eslint-disable-line\n} from '../internals.js'\n\nimport * as array from 'lib0/array'\nimport * as math from 'lib0/math'\nimport * as encoding from 'lib0/encoding'\nimport * as decoding from 'lib0/decoding'\nimport * as traits from 'lib0/traits'\n\nexport class IdRange {\n  /**\n   * @param {number} clock\n   * @param {number} len\n   */\n  constructor (clock, len) {\n    /**\n     * @type {number}\n     */\n    this.clock = clock\n    /**\n     * @type {number}\n     */\n    this.len = len\n  }\n\n  /**\n   * @param {number} clock\n   * @param {number} len\n   */\n  copyWith (clock, len) {\n    return new IdRange(clock, len)\n  }\n\n  /**\n   * Helper method making this compatible with IdMap.\n   *\n   * @return {Array<import('./IdMap.js').AttributionItem<any>>}\n   */\n  get attrs () {\n    return []\n  }\n}\n\nexport class MaybeIdRange {\n  /**\n   * @param {number} clock\n   * @param {number} len\n   * @param {boolean} exists\n   */\n  constructor (clock, len, exists) {\n    /**\n     * @type {number}\n     */\n    this.clock = clock\n    /**\n     * @type {number}\n     */\n    this.len = len\n    /**\n     * @type {boolean}\n     */\n    this.exists = exists\n  }\n}\n\n/**\n * @param {number} clock\n * @param {number} len\n * @param {boolean} exists\n * @return {MaybeIdRange}\n */\nexport const createMaybeIdRange = (clock, len, exists) => new MaybeIdRange(clock, len, exists)\n\nexport class IdRanges {\n  /**\n   * @param {Array<IdRange>} ids\n   */\n  constructor (ids) {\n    this.sorted = false\n    /**\n     * A typical use-case for IdSet is to append data. We heavily optimize this case by allowing the\n     * last item to be mutated ef it isn't used currently.\n     * This flag is true if the last item was exposed to the outside.\n     */\n    this._lastIsUsed = false\n    /**\n     * @private\n     */\n    this._ids = ids\n  }\n\n  copy () {\n    return new IdRanges(this._ids.slice())\n  }\n\n  /**\n   * @param {number} clock\n   * @param {number} length\n   */\n  add (clock, length) {\n    const last = this._ids[this._ids.length - 1]\n    if (last.clock + last.len === clock) {\n      if (this._lastIsUsed) {\n        this._ids[this._ids.length - 1] = new IdRange(last.clock, last.len + length)\n        this._lastIsUsed = false\n      } else {\n        this._ids[this._ids.length - 1].len += length\n      }\n    } else {\n      this.sorted = false\n      this._ids.push(new IdRange(clock, length))\n    }\n  }\n\n  /**\n   * Return the list of immutable id ranges, sorted and merged.\n   */\n  getIds () {\n    const ids = this._ids\n    this._lastIsUsed = true\n    if (!this.sorted) {\n      this.sorted = true\n      ids.sort((a, b) => a.clock - b.clock)\n      // merge items without filtering or splicing the array\n      // i is the current pointer\n      // j refers to the current insert position for the pointed item\n      // try to merge dels[i] into dels[j-1] or set dels[j]=dels[i]\n      let i, j\n      for (i = 1, j = 1; i < ids.length; i++) {\n        const left = ids[j - 1]\n        const right = ids[i]\n        if (left.clock + left.len >= right.clock) {\n          const r = right.clock + right.len - left.clock\n          if (left.len < r) {\n            ids[j - 1] = new IdRange(left.clock, r)\n          }\n        } else if (left.len === 0) {\n          ids[j - 1] = right\n        } else {\n          if (j < i) {\n            ids[j] = right\n          }\n          j++\n        }\n      }\n      ids.length = ids[j - 1].len === 0 ? j - 1 : j\n    }\n    return ids\n  }\n}\n\n/**\n * @implements {traits.EqualityTrait}\n */\nexport class IdSet {\n  constructor () {\n    /**\n     * @type {Map<number,IdRanges>}\n     */\n    this.clients = new Map()\n  }\n\n  isEmpty () {\n    return this.clients.size === 0\n  }\n\n  /**\n   * @param {(idrange:IdRange, client:number) => void} f\n   */\n  forEach (f) {\n    this.clients.forEach((ranges, client) => {\n      ranges.getIds().forEach((range) => {\n        f(range, client)\n      })\n    })\n  }\n\n  /**\n   * @param {ID} id\n   * @return {boolean}\n   */\n  hasId (id) {\n    return this.has(id.client, id.clock)\n  }\n\n  /**\n   * @param {number} client\n   * @param {number} clock\n   */\n  has (client, clock) {\n    const dr = this.clients.get(client)\n    if (dr) {\n      return findIndexInIdRanges(dr.getIds(), clock) !== null\n    }\n    return false\n  }\n\n  /**\n   * Return slices of ids that exist in this idset.\n   *\n   * @param {number} client\n   * @param {number} clock\n   * @param {number} len\n   * @return {Array<MaybeIdRange>}\n   */\n  slice (client, clock, len) {\n    const dr = this.clients.get(client)\n    /**\n     * @type {Array<MaybeIdRange>}\n     */\n    const res = []\n    if (dr) {\n      /**\n       * @type {Array<IdRange>}\n       */\n      const ranges = dr.getIds()\n      let index = findRangeStartInIdRanges(ranges, clock)\n      if (index !== null) {\n        let prev = null\n        while (index < ranges.length) {\n          let r = ranges[index]\n          if (r.clock < clock) {\n            r = new IdRange(clock, r.len - (clock - r.clock))\n          }\n          if (r.clock + r.len > clock + len) {\n            r = new IdRange(r.clock, clock + len - r.clock)\n          }\n          if (r.len <= 0) break\n          const prevEnd = prev != null ? prev.clock + prev.len : clock\n          if (prevEnd < r.clock) {\n            res.push(createMaybeIdRange(prevEnd, r.clock - prevEnd, false))\n          }\n          prev = r\n          res.push(createMaybeIdRange(r.clock, r.len, true))\n          index++\n        }\n      }\n    }\n    if (res.length > 0) {\n      const last = res[res.length - 1]\n      const end = last.clock + last.len\n      if (end < clock + len) {\n        res.push(createMaybeIdRange(end, clock + len - end, false))\n      }\n    } else {\n      res.push(createMaybeIdRange(clock, len, false))\n    }\n    return res\n  }\n\n  /**\n   * @param {number} client\n   * @param {number} clock\n   * @param {number} len\n   */\n  add (client, clock, len) {\n    addToIdSet(this, client, clock, len)\n  }\n\n  /**\n   * @param {number} client\n   * @param {number} clock\n   * @param {number} len\n   */\n  delete (client, clock, len) {\n    _deleteRangeFromIdSet(this, client, clock, len)\n  }\n\n  /**\n   * @param {any} other\n   */\n  [traits.EqualityTraitSymbol] (other) {\n    return equalIdSets(this, other)\n  }\n}\n\n/**\n * @param {IdSet | IdMap<any>} set\n * @param {number} client\n * @param {number} clock\n * @param {number} len\n */\nexport const _deleteRangeFromIdSet = (set, client, clock, len) => {\n  const dr = set.clients.get(client)\n  if (dr && len > 0) {\n    const ids = dr.getIds()\n    let index = findRangeStartInIdRanges(ids, clock)\n    if (index != null) {\n      for (let r = ids[index]; index < ids.length && r.clock < clock + len; r = ids[++index]) {\n        if (r.clock < clock) {\n          ids[index] = r.copyWith(r.clock, clock - r.clock)\n          if (clock + len < r.clock + r.len) {\n            ids.splice(index + 1, 0, r.copyWith(clock + len, r.clock + r.len - clock - len))\n          }\n        } else if (clock + len < r.clock + r.len) {\n          // need to retain end\n          ids[index] = r.copyWith(clock + len, r.clock + r.len - clock - len)\n        } else if (ids.length === 1) {\n          set.clients.delete(client)\n          return\n        } else {\n          ids.splice(index--, 1)\n        }\n      }\n    }\n  }\n}\n\n/**\n * Iterate over all structs that are mentioned by the IdSet.\n *\n * @param {Transaction} transaction\n * @param {IdSet} ds\n * @param {function(GC|Item):void} f\n *\n * @function\n */\nexport const iterateStructsByIdSet = (transaction, ds, f) =>\n  ds.clients.forEach((idRanges, clientid) => {\n    const ranges = idRanges.getIds()\n    const structs = /** @type {Array<GC|Item>} */ (transaction.doc.store.clients.get(clientid))\n    if (structs != null) {\n      for (let i = 0; i < ranges.length; i++) {\n        const del = ranges[i]\n        iterateStructs(transaction, structs, del.clock, del.len, f)\n      }\n    }\n  })\n\n/**\n * @param {Array<IdRange>} dis\n * @param {number} clock\n * @return {number|null}\n *\n * @private\n * @function\n */\nexport const findIndexInIdRanges = (dis, clock) => {\n  let left = 0\n  let right = dis.length - 1\n  while (left <= right) {\n    const midindex = math.floor((left + right) / 2)\n    const mid = dis[midindex]\n    const midclock = mid.clock\n    if (midclock <= clock) {\n      if (clock < midclock + mid.len) {\n        return midindex\n      }\n      left = midindex + 1\n    } else {\n      right = midindex - 1\n    }\n  }\n  return null\n}\n\n/**\n * Find the first range that contains clock or comes after clock.\n *\n * @param {Array<IdRange>} dis\n * @param {number} clock\n * @return {number|null}\n *\n * @private\n * @function\n */\nexport const findRangeStartInIdRanges = (dis, clock) => {\n  let left = 0\n  let right = dis.length - 1\n  while (left <= right) {\n    const midindex = math.floor((left + right) / 2)\n    const mid = dis[midindex]\n    const midclock = mid.clock\n    if (midclock <= clock) {\n      if (clock < midclock + mid.len) {\n        return midindex\n      }\n      left = midindex + 1\n    } else {\n      right = midindex - 1\n    }\n  }\n  return left < dis.length ? left : null\n}\n\n/**\n * @param {Array<IdSet>} idSets\n * @return {IdSet} A fresh IdSet\n */\nexport const mergeIdSets = idSets => {\n  const merged = new IdSet()\n  for (let dssI = 0; dssI < idSets.length; dssI++) {\n    idSets[dssI].clients.forEach((rangesLeft, client) => {\n      if (!merged.clients.has(client)) {\n        // Write all missing keys from current ds and all following.\n        // If merged already contains `client` current ds has already been added.\n        const ids = rangesLeft.getIds().slice()\n        for (let i = dssI + 1; i < idSets.length; i++) {\n          const nextIds = idSets[i].clients.get(client)\n          if (nextIds) {\n            array.appendTo(ids, nextIds.getIds())\n          }\n        }\n        merged.clients.set(client, new IdRanges(ids))\n      }\n    })\n  }\n  return merged\n}\n\n/**\n * @template {IdSet | IdMap<any>} S\n * @param {S} dest\n * @param {S} src\n */\nexport const _insertIntoIdSet = (dest, src) => {\n  src.clients.forEach((srcRanges, client) => {\n    const targetRanges = dest.clients.get(client)\n    if (targetRanges) {\n      array.appendTo(targetRanges.getIds(), srcRanges.getIds())\n      targetRanges.sorted = false\n    } else {\n      const res = srcRanges.copy()\n      res.sorted = true\n      dest.clients.set(client, /** @type {any} */ (res))\n    }\n  })\n}\n\n/**\n * @param {IdSet} dest\n * @param {IdSet} src\n */\nexport const insertIntoIdSet = _insertIntoIdSet\n\n/**\n * Remove all ranges from `exclude` from `ds`. The result is a fresh IdSet containing all ranges from `idSet` that are not\n * in `exclude`.\n *\n * @template {IdSet | IdMap<any>} Set\n * @param {Set} set\n * @param {IdSet | IdMap<any>} exclude\n * @return {Set}\n */\nexport const _diffSet = (set, exclude) => {\n  /**\n   * @type {Set}\n   */\n  const res = /** @type {any } */ (set instanceof IdSet ? new IdSet() : new IdMap())\n  const Ranges = set instanceof IdSet ? IdRanges : AttrRanges\n  set.clients.forEach((_setRanges, client) => {\n    /**\n     * @type {Array<IdRange>}\n     */\n    let resRanges = []\n    const _excludedRanges = exclude.clients.get(client)\n    const setRanges = _setRanges.getIds()\n    if (_excludedRanges == null) {\n      resRanges = setRanges.slice()\n    } else {\n      const excludedRanges = _excludedRanges.getIds()\n      let i = 0; let j = 0\n      let currRange = setRanges[0]\n      while (i < setRanges.length && j < excludedRanges.length) {\n        const e = excludedRanges[j]\n        if (currRange.clock + currRange.len <= e.clock) { // no overlapping, use next range item\n          if (currRange.len > 0) resRanges.push(currRange)\n          currRange = setRanges[++i]\n        } else if (e.clock + e.len <= currRange.clock) { // no overlapping, use next excluded item\n          j++\n        } else if (e.clock <= currRange.clock) { // exclude laps into range (we already know that the ranges somehow collide)\n          const newClock = e.clock + e.len\n          const newLen = currRange.clock + currRange.len - newClock\n          if (newLen > 0) {\n            currRange = currRange.copyWith(newClock, newLen)\n            j++\n          } else {\n            // this item is completely overwritten. len=0. We can jump to the next range\n            currRange = setRanges[++i]\n          }\n        } else { // currRange.clock < e.clock -- range laps into exclude => adjust len\n          // beginning can't be empty, add it to the result\n          const nextLen = e.clock - currRange.clock\n          resRanges.push(currRange.copyWith(currRange.clock, nextLen))\n          // retain the remaining length after exclude in currRange\n          currRange = currRange.copyWith(currRange.clock + e.len + nextLen, math.max(currRange.len - e.len - nextLen, 0))\n          if (currRange.len === 0) currRange = setRanges[++i]\n          else j++\n        }\n      }\n      if (currRange != null) {\n        resRanges.push(currRange)\n      }\n      i++\n      while (i < setRanges.length) {\n        resRanges.push(setRanges[i++])\n      }\n    }\n    // @ts-ignore\n    if (resRanges.length > 0) res.clients.set(client, /** @type {any} */ (new Ranges(resRanges)))\n  })\n  return res\n}\n\n/**\n * Remove all ranges from `exclude` from `idSet`. The result is a fresh IdSet containing all ranges from `idSet` that are not\n * in `exclude`.\n *\n * @type {(idSet: IdSet, exclude: IdSet|IdMap<any>) => IdSet}\n */\nexport const diffIdSet = _diffSet\n\n/**\n * @template {IdSet | IdMap<any>} SetA\n * @template {IdSet | IdMap<any>} SetB\n * @param {SetA} setA\n * @param {SetB} setB\n * @return {SetA extends IdMap<infer A> ? (SetB extends IdMap<infer B> ? IdMap<A | B> : IdMap<A>) : IdSet}\n */\nexport const _intersectSets = (setA, setB) => {\n  /**\n   * @type {IdMap<any> | IdSet}\n   */\n  const res = /** @type {any } */ (setA instanceof IdSet ? new IdSet() : new IdMap())\n  const Ranges = setA instanceof IdSet ? IdRanges : AttrRanges\n  setA.clients.forEach((_aRanges, client) => {\n    /**\n     * @type {Array<IdRange>}\n     */\n    const resRanges = []\n    const _bRanges = setB.clients.get(client)\n    const aRanges = _aRanges.getIds()\n    if (_bRanges != null) {\n      const bRanges = _bRanges.getIds()\n      for (let a = 0, b = 0; a < aRanges.length && b < bRanges.length;) {\n        const aRange = aRanges[a]\n        const bRange = bRanges[b]\n        // construct overlap\n        const clock = math.max(aRange.clock, bRange.clock)\n        const len = math.min(aRange.len - (clock - aRange.clock), bRange.len - (clock - bRange.clock))\n        if (len > 0) {\n          resRanges.push(aRange instanceof AttrRange\n            ? new AttrRange(clock, len, /** @type {Array<AttributionItem<any>>} */ (aRange.attrs).concat(bRange.attrs))\n            : new IdRange(clock, len)\n          )\n        }\n        if (aRange.clock + aRange.len < bRange.clock + bRange.len) {\n          a++\n        } else {\n          b++\n        }\n      }\n    }\n    // @ts-ignore\n    if (resRanges.length > 0) res.clients.set(client, /** @type {any} */ (new Ranges(resRanges)))\n  })\n  return /** @type {any} */ (res)\n}\n\nexport const intersectSets = _intersectSets\n\n/**\n * @param {IdSet} idSet\n * @param {number} client\n * @param {number} clock\n * @param {number} length\n *\n * @private\n * @function\n */\nexport const addToIdSet = (idSet, client, clock, length) => {\n  if (length === 0) return\n  const idRanges = idSet.clients.get(client)\n  if (idRanges) {\n    idRanges.add(clock, length)\n  } else {\n    idSet.clients.set(client, new IdRanges([new IdRange(clock, length)]))\n  }\n}\n\n/**\n * @param {IdSet} idSet\n * @param {AbstractStruct} struct\n *\n * @private\n * @function\n */\nexport const addStructToIdSet = (idSet, struct) => addToIdSet(idSet, struct.id.client, struct.id.clock, struct.length)\n\nexport const createIdSet = () => new IdSet()\n\n/**\n * @param {StructStore} ss\n * @return {IdSet}\n *\n * @private\n * @function\n */\nexport const createDeleteSetFromStructStore = ss => {\n  const ds = createIdSet()\n  ss.clients.forEach((structs, client) => {\n    /**\n     * @type {Array<IdRange>}\n     */\n    const dsitems = []\n    for (let i = 0; i < structs.length; i++) {\n      const struct = structs[i]\n      if (struct.deleted) {\n        const clock = struct.id.clock\n        let len = struct.length\n        if (i + 1 < structs.length) {\n          for (let next = structs[i + 1]; i + 1 < structs.length && next.deleted; next = structs[++i + 1]) {\n            len += next.length\n          }\n        }\n        dsitems.push(new IdRange(clock, len))\n      }\n    }\n    if (dsitems.length > 0) {\n      ds.clients.set(client, new IdRanges(dsitems))\n    }\n  })\n  return ds\n}\n\n/**\n * @param {Array<GC | Item>} structs\n * @param {boolean} filterDeleted\n *\n */\nexport const _createInsertSliceFromStructs = (structs, filterDeleted) => {\n  /**\n   * @type {Array<IdRange>}\n   */\n  const iditems = []\n  for (let i = 0; i < structs.length; i++) {\n    const struct = structs[i]\n    if (!(filterDeleted && struct.deleted)) {\n      const clock = struct.id.clock\n      let len = struct.length\n      if (i + 1 < structs.length) {\n        // eslint-disable-next-line\n        for (let next = structs[i + 1]; i + 1 < structs.length && !(filterDeleted && next.deleted); next = structs[++i + 1]) {\n          len += next.length\n        }\n      }\n      iditems.push(new IdRange(clock, len))\n    }\n  }\n  return iditems\n}\n\n/**\n * @param {import('../internals.js').StructStore} ss\n * @param {boolean} filterDeleted\n */\nexport const createInsertSetFromStructStore = (ss, filterDeleted) => {\n  const idset = createIdSet()\n  ss.clients.forEach((structs, client) => {\n    const iditems = _createInsertSliceFromStructs(structs, filterDeleted)\n    if (iditems.length !== 0) {\n      idset.clients.set(client, new IdRanges(iditems))\n    }\n  })\n  return idset\n}\n\n/**\n * @param {IdSetEncoderV1 | IdSetEncoderV2} encoder\n * @param {IdSet} idSet\n *\n * @private\n * @function\n */\nexport const writeIdSet = (encoder, idSet) => {\n  encoding.writeVarUint(encoder.restEncoder, idSet.clients.size)\n  // Ensure that the delete set is written in a deterministic order\n  array.from(idSet.clients.entries())\n    .sort((a, b) => b[0] - a[0])\n    .forEach(([client, _idRanges]) => {\n      const idRanges = _idRanges.getIds()\n      encoder.resetIdSetCurVal()\n      encoding.writeVarUint(encoder.restEncoder, client)\n      const len = idRanges.length\n      encoding.writeVarUint(encoder.restEncoder, len)\n      for (let i = 0; i < len; i++) {\n        const item = idRanges[i]\n        encoder.writeIdSetClock(item.clock)\n        encoder.writeIdSetLen(item.len)\n      }\n    })\n}\n\n/**\n * @param {DSDecoderV1 | DSDecoderV2} decoder\n * @return {IdSet}\n *\n * @private\n * @function\n */\nexport const readIdSet = decoder => {\n  const ds = new IdSet()\n  const numClients = decoding.readVarUint(decoder.restDecoder)\n  for (let i = 0; i < numClients; i++) {\n    decoder.resetDsCurVal()\n    const client = decoding.readVarUint(decoder.restDecoder)\n    const numberOfDeletes = decoding.readVarUint(decoder.restDecoder)\n    if (numberOfDeletes > 0) {\n      /**\n       * @type {Array<IdRange>}\n       */\n      const dsRanges = []\n      for (let i = 0; i < numberOfDeletes; i++) {\n        dsRanges.push(new IdRange(decoder.readDsClock(), decoder.readDsLen()))\n      }\n      ds.clients.set(client, new IdRanges(dsRanges))\n    }\n  }\n  return ds\n}\n\n/**\n * @todo YDecoder also contains references to String and other Decoders. Would make sense to exchange YDecoder.toUint8Array for YDecoder.DsToUint8Array()..\n */\n\n/**\n * @param {DSDecoderV1 | DSDecoderV2} decoder\n * @param {Transaction} transaction\n * @param {StructStore} store\n * @return {Uint8Array<ArrayBuffer>|null} Returns a v2 update containing all deletes that couldn't be applied yet; or null if all deletes were applied successfully.\n *\n * @private\n * @function\n */\nexport const readAndApplyDeleteSet = (decoder, transaction, store) => {\n  const unappliedDS = new IdSet()\n  const numClients = decoding.readVarUint(decoder.restDecoder)\n  for (let i = 0; i < numClients; i++) {\n    decoder.resetDsCurVal()\n    const client = decoding.readVarUint(decoder.restDecoder)\n    const numberOfDeletes = decoding.readVarUint(decoder.restDecoder)\n    const structs = store.clients.get(client) || []\n    const state = getState(store, client)\n    for (let i = 0; i < numberOfDeletes; i++) {\n      const clock = decoder.readDsClock()\n      const clockEnd = clock + decoder.readDsLen()\n      if (clock < state) {\n        if (state < clockEnd) {\n          addToIdSet(unappliedDS, client, state, clockEnd - state)\n        }\n        let index = findIndexSS(structs, clock)\n        /**\n         * We can ignore the case of GC and Delete structs, because we are going to skip them\n         * @type {Item | GC | Skip}\n         */\n        let struct = structs[index]\n        // split the first item if necessary\n        if (!struct.deleted && struct.id.clock < clock && struct instanceof Item) {\n          // increment index, we now want to use the next struct\n          structs.splice(++index, 0, splitItem(transaction, struct, clock - struct.id.clock))\n        }\n        while (index < structs.length) {\n          // @ts-ignore\n          struct = structs[index++]\n          if (struct.id.clock < clockEnd) {\n            if (!struct.deleted) {\n              if (struct instanceof Item) {\n                if (clockEnd < struct.id.clock + struct.length) {\n                  structs.splice(index, 0, splitItem(transaction, struct, clockEnd - struct.id.clock))\n                }\n                struct.delete(transaction)\n              } else { // is a Skip - add range to unappliedDS\n                const c = math.max(struct.id.clock, clock)\n                unappliedDS.add(client, c, math.min(struct.length, clockEnd - c))\n              }\n            }\n          } else {\n            break\n          }\n        }\n      } else {\n        addToIdSet(unappliedDS, client, clock, clockEnd - clock)\n      }\n    }\n  }\n  if (unappliedDS.clients.size > 0) {\n    const ds = new UpdateEncoderV2()\n    encoding.writeVarUint(ds.restEncoder, 0) // encode 0 structs\n    writeIdSet(ds, unappliedDS)\n    return ds.toUint8Array()\n  }\n  return null\n}\n\n/**\n * @param {IdSet} ds1\n * @param {IdSet} ds2\n */\nexport const equalIdSets = (ds1, ds2) => {\n  if (ds1.clients.size !== ds2.clients.size) return false\n  for (const [client, _deleteItems1] of ds1.clients.entries()) {\n    const deleteItems1 = _deleteItems1.getIds()\n    const deleteItems2 = ds2.clients.get(client)?.getIds()\n    if (deleteItems2 === undefined || deleteItems1.length !== deleteItems2.length) return false\n    for (let i = 0; i < deleteItems1.length; i++) {\n      const di1 = deleteItems1[i]\n      const di2 = deleteItems2[i]\n      if (di1.clock !== di2.clock || di1.len !== di2.len) {\n        return false\n      }\n    }\n  }\n  return true\n}\n","/**\n * @module Y\n */\n\nimport {\n  StructStore,\n  AbstractType,\n  YArray,\n  YText,\n  YMap,\n  YXmlElement,\n  YXmlFragment,\n  transact,\n  applyUpdate,\n  ContentDoc, Item, Transaction, // eslint-disable-line\n  encodeStateAsUpdate\n} from '../internals.js'\n\nimport { ObservableV2 } from 'lib0/observable'\nimport * as random from 'lib0/random'\nimport * as map from 'lib0/map'\nimport * as array from 'lib0/array'\nimport * as promise from 'lib0/promise'\n\nexport const generateNewClientId = random.uint32\n\n/**\n * @typedef {import('../utils/types.js').YTypeConstructors} YTypeConstructors\n */\n/**\n * @typedef {import('../utils/types.js').YType} YType\n */\n\n/**\n * @typedef {Object} DocOpts\n * @property {boolean} [DocOpts.gc=true] Disable garbage collection (default: gc=true)\n * @property {function(Item):boolean} [DocOpts.gcFilter] Will be called before an Item is garbage collected. Return false to keep the Item.\n * @property {string} [DocOpts.guid] Define a globally unique identifier for this document\n * @property {string | null} [DocOpts.collectionid] Associate this document with a collection. This only plays a role if your provider has a concept of collection.\n * @property {any} [DocOpts.meta] Any kind of meta information you want to associate with this document. If this is a subdocument, remote peers will store the meta information as well.\n * @property {boolean} [DocOpts.autoLoad] If a subdocument, automatically load document. If this is a subdocument, remote peers will load the document as well automatically.\n * @property {boolean} [DocOpts.shouldLoad] Whether the document should be synced by the provider now. This is toggled to true when you call ydoc.load()\n * @property {boolean} [DocOpts.isSuggestionDoc] Set to true if this document merely suggests\n * changes. If this flag is not set in a suggestion document, automatic formatting changes will be\n * displayed as suggestions, which might not be intended.\n */\n\n/**\n * @typedef {Object} DocEvents\n * @property {function(Doc):void} DocEvents.destroy\n * @property {function(Doc):void} DocEvents.load\n * @property {function(boolean, Doc):void} DocEvents.sync\n * @property {function(Uint8Array<ArrayBuffer>, any, Doc, Transaction):void} DocEvents.update\n * @property {function(Uint8Array<ArrayBuffer>, any, Doc, Transaction):void} DocEvents.updateV2\n * @property {function(Doc):void} DocEvents.beforeAllTransactions\n * @property {function(Transaction, Doc):void} DocEvents.beforeTransaction\n * @property {function(Transaction, Doc):void} DocEvents.beforeObserverCalls\n * @property {function(Transaction, Doc):void} DocEvents.afterTransaction\n * @property {function(Transaction, Doc):void} DocEvents.afterTransactionCleanup\n * @property {function(Doc, Array<Transaction>):void} DocEvents.afterAllTransactions\n * @property {function({ loaded: Set<Doc>, added: Set<Doc>, removed: Set<Doc> }, Doc, Transaction):void} DocEvents.subdocs\n */\n\n/**\n * A Yjs instance handles the state of shared data.\n * @extends ObservableV2<DocEvents>\n */\nexport class Doc extends ObservableV2 {\n  /**\n   * @param {DocOpts} opts configuration\n   */\n  constructor ({ guid = random.uuidv4(), collectionid = null, gc = true, gcFilter = () => true, meta = null, autoLoad = false, shouldLoad = true, isSuggestionDoc = false } = {}) {\n    super()\n    this.gc = gc\n    this.gcFilter = gcFilter\n    this.clientID = generateNewClientId()\n    this.guid = guid\n    this.collectionid = collectionid\n    this.isSuggestionDoc = isSuggestionDoc\n    this.cleanupFormatting = !isSuggestionDoc\n    /**\n     * @type {Map<string, YType>}\n     */\n    this.share = new Map()\n    this.store = new StructStore()\n    /**\n     * @type {Transaction | null}\n     */\n    this._transaction = null\n    /**\n     * @type {Array<Transaction>}\n     */\n    this._transactionCleanups = []\n    /**\n     * @type {Set<Doc>}\n     */\n    this.subdocs = new Set()\n    /**\n     * If this document is a subdocument - a document integrated into another document - then _item is defined.\n     * @type {Item?}\n     */\n    this._item = null\n    this.shouldLoad = shouldLoad\n    this.autoLoad = autoLoad\n    this.meta = meta\n    /**\n     * This is set to true when the persistence provider loaded the document from the database or when the `sync` event fires.\n     * Note that not all providers implement this feature. Provider authors are encouraged to fire the `load` event when the doc content is loaded from the database.\n     *\n     * @type {boolean}\n     */\n    this.isLoaded = false\n    /**\n     * This is set to true when the connection provider has successfully synced with a backend.\n     * Note that when using peer-to-peer providers this event may not provide very useful.\n     * Also note that not all providers implement this feature. Provider authors are encouraged to fire\n     * the `sync` event when the doc has been synced (with `true` as a parameter) or if connection is\n     * lost (with false as a parameter).\n     */\n    this.isSynced = false\n    this.isDestroyed = false\n    /**\n     * Promise that resolves once the document has been loaded from a persistence provider.\n     */\n    this.whenLoaded = promise.create(resolve => {\n      this.on('load', () => {\n        this.isLoaded = true\n        resolve(this)\n      })\n    })\n    const provideSyncedPromise = () => promise.create(resolve => {\n      /**\n       * @param {boolean} isSynced\n       */\n      const eventHandler = (isSynced) => {\n        if (isSynced === undefined || isSynced === true) {\n          this.off('sync', eventHandler)\n          resolve()\n        }\n      }\n      this.on('sync', eventHandler)\n    })\n    this.on('sync', isSynced => {\n      if (isSynced === false && this.isSynced) {\n        this.whenSynced = provideSyncedPromise()\n      }\n      this.isSynced = isSynced === undefined || isSynced === true\n      if (this.isSynced && !this.isLoaded) {\n        this.emit('load', [this])\n      }\n    })\n    /**\n     * Promise that resolves once the document has been synced with a backend.\n     * This promise is recreated when the connection is lost.\n     * Note the documentation about the `isSynced` property.\n     */\n    this.whenSynced = provideSyncedPromise()\n  }\n\n  /**\n   * Notify the parent document that you request to load data into this subdocument (if it is a subdocument).\n   *\n   * `load()` might be used in the future to request any provider to load the most current data.\n   *\n   * It is safe to call `load()` multiple times.\n   */\n  load () {\n    const item = this._item\n    if (item !== null && !this.shouldLoad) {\n      transact(/** @type {any} */ (item.parent).doc, transaction => {\n        transaction.subdocsLoaded.add(this)\n      }, null, true)\n    }\n    this.shouldLoad = true\n  }\n\n  getSubdocs () {\n    return this.subdocs\n  }\n\n  getSubdocGuids () {\n    return new Set(array.from(this.subdocs).map(doc => doc.guid))\n  }\n\n  /**\n   * Changes that happen inside of a transaction are bundled. This means that\n   * the observer fires _after_ the transaction is finished and that all changes\n   * that happened inside of the transaction are sent as one message to the\n   * other peers.\n   *\n   * @template T\n   * @param {function(Transaction):T} f The function that should be executed as a transaction\n   * @param {any} [origin] Origin of who started the transaction. Will be stored on transaction.origin\n   * @return T\n   *\n   * @public\n   */\n  transact (f, origin = null) {\n    return transact(this, f, origin)\n  }\n\n  /**\n   * Define a shared data type.\n   *\n   * Multiple calls of `ydoc.get(name, TypeConstructor)` yield the same result\n   * and do not overwrite each other. I.e.\n   * `ydoc.get(name, Y.Array) === ydoc.get(name, Y.Array)`\n   *\n   * After this method is called, the type is also available on `ydoc.share.get(name)`.\n   *\n   * *Best Practices:*\n   * Define all types right after the Y.Doc instance is created and store them in a separate object.\n   * Also use the typed methods `getText(name)`, `getArray(name)`, ..\n   *\n   * @template {YTypeConstructors} [TypeC=typeof AbstractType]\n   * @example\n   *   const ydoc = new Y.Doc(..)\n   *   const appState = {\n   *     document: ydoc.getText('document')\n   *     comments: ydoc.getArray('comments')\n   *   }\n   *\n   * @param {string} name\n   * @param {TypeC} TypeConstructor The constructor of the type definition. E.g. Y.Text, Y.Array, Y.Map, ...\n   * @return {AbstractType} The created type. Constructed with TypeConstructor\n   *\n   * @public\n   */\n  get (name, TypeConstructor = /** @type {any} */ (AbstractType)) {\n    const type = map.setIfUndefined(this.share, name, () => {\n      // @ts-ignore\n      const t = new TypeConstructor()\n      t._integrate(this, null)\n      return t\n    })\n    const Constr = type.constructor\n    // @ts-ignore\n    if (TypeConstructor !== AbstractType && Constr !== TypeConstructor) {\n      if (Constr === AbstractType) {\n        // @ts-ignore\n        const t = new TypeConstructor()\n        t._map = type._map\n        type._map.forEach(/** @param {Item?} n */ n => {\n          for (; n !== null; n = n.left) {\n            // @ts-ignore\n            n.parent = t\n          }\n        })\n        t._start = type._start\n        for (let n = t._start; n !== null; n = n.right) {\n          n.parent = t\n        }\n        t._length = type._length\n        this.share.set(name, t)\n        t._integrate(this, null)\n        return /** @type {InstanceType<TypeC>} */ (t)\n      } else {\n        throw new Error(`Type with the name ${name} has already been defined with a different constructor`)\n      }\n    }\n    return /** @type {InstanceType<TypeC>} */ (type)\n  }\n\n  /**\n   * @template T\n   * @param {string} [name]\n   * @return {YArray<T>}\n   *\n   * @public\n   */\n  getArray (name = '') {\n    return /** @type {YArray<any>} */ (this.get(name, YArray))\n  }\n\n  /**\n   * @param {string} [name]\n   * @return {YText}\n   *\n   * @public\n   */\n  getText (name = '') {\n    return /** @type {YText} */ (this.get(name, YText))\n  }\n\n  /**\n   * @template T\n   * @param {string} [name]\n   * @return {YMap<T>}\n   *\n   * @public\n   */\n  getMap (name = '') {\n    return /** @type {YMap<T>} */ (this.get(name, YMap))\n  }\n\n  /**\n   * @param {string} [name]\n   * @return {YXmlElement}\n   *\n   * @public\n   */\n  getXmlElement (name = '') {\n    return /** @type {YXmlElement<{[key:string]:string}>} */ (this.get(name, YXmlElement))\n  }\n\n  /**\n   * @param {string} [name]\n   * @return {YXmlFragment}\n   *\n   * @public\n   */\n  getXmlFragment (name = '') {\n    return /** @type {YXmlFragment} */ (this.get(name, YXmlFragment))\n  }\n\n  /**\n   * Converts the entire document into a js object, recursively traversing each yjs type\n   * Doesn't log types that have not been defined (using ydoc.getType(..)).\n   *\n   * @deprecated Do not use this method and rather call toJSON directly on the shared types.\n   *\n   * @return {Object<string, any>}\n   */\n  toJSON () {\n    /**\n     * @type {Object<string, any>}\n     */\n    const doc = {}\n\n    this.share.forEach((value, key) => {\n      doc[key] = value.toJSON()\n    })\n\n    return doc\n  }\n\n  /**\n   * Emit `destroy` event and unregister all event handlers.\n   */\n  destroy () {\n    this.isDestroyed = true\n    array.from(this.subdocs).forEach(subdoc => subdoc.destroy())\n    const item = this._item\n    if (item !== null) {\n      this._item = null\n      const content = /** @type {ContentDoc} */ (item.content)\n      content.doc = new Doc({ guid: this.guid, ...content.opts, shouldLoad: false })\n      content.doc._item = item\n      transact(/** @type {any} */ (item).parent.doc, transaction => {\n        const doc = content.doc\n        if (!item.deleted) {\n          transaction.subdocsAdded.add(doc)\n        }\n        transaction.subdocsRemoved.add(this)\n      }, null, true)\n    }\n    // @ts-ignore\n    this.emit('destroyed', [true]) // DEPRECATED!\n    this.emit('destroy', [this])\n    super.destroy()\n  }\n}\n\n/**\n * @param {Doc} ydoc\n * @param {DocOpts} [opts]\n */\nexport const cloneDoc = (ydoc, opts) => {\n  const clone = new Doc(opts)\n  applyUpdate(clone, encodeStateAsUpdate(ydoc))\n  return clone\n}\n","import * as buffer from 'lib0/buffer'\nimport * as decoding from 'lib0/decoding'\nimport {\n  ID, createID\n} from '../internals.js'\n\nexport class DSDecoderV1 {\n  /**\n   * @param {decoding.Decoder} decoder\n   */\n  constructor (decoder) {\n    this.restDecoder = decoder\n  }\n\n  resetDsCurVal () {\n    // nop\n  }\n\n  /**\n   * @return {number}\n   */\n  readDsClock () {\n    return decoding.readVarUint(this.restDecoder)\n  }\n\n  /**\n   * @return {number}\n   */\n  readDsLen () {\n    return decoding.readVarUint(this.restDecoder)\n  }\n}\n\nexport class UpdateDecoderV1 extends DSDecoderV1 {\n  /**\n   * @return {ID}\n   */\n  readLeftID () {\n    return createID(decoding.readVarUint(this.restDecoder), decoding.readVarUint(this.restDecoder))\n  }\n\n  /**\n   * @return {ID}\n   */\n  readRightID () {\n    return createID(decoding.readVarUint(this.restDecoder), decoding.readVarUint(this.restDecoder))\n  }\n\n  /**\n   * Read the next client id.\n   * Use this in favor of readID whenever possible to reduce the number of objects created.\n   */\n  readClient () {\n    return decoding.readVarUint(this.restDecoder)\n  }\n\n  /**\n   * @return {number} info An unsigned 8-bit integer\n   */\n  readInfo () {\n    return decoding.readUint8(this.restDecoder)\n  }\n\n  /**\n   * @return {string}\n   */\n  readString () {\n    return decoding.readVarString(this.restDecoder)\n  }\n\n  /**\n   * @return {boolean} isKey\n   */\n  readParentInfo () {\n    return decoding.readVarUint(this.restDecoder) === 1\n  }\n\n  /**\n   * @return {number} info An unsigned 8-bit integer\n   */\n  readTypeRef () {\n    return decoding.readVarUint(this.restDecoder)\n  }\n\n  /**\n   * Write len of a struct - well suited for Opt RLE encoder.\n   *\n   * @return {number} len\n   */\n  readLen () {\n    return decoding.readVarUint(this.restDecoder)\n  }\n\n  /**\n   * @return {any}\n   */\n  readAny () {\n    return decoding.readAny(this.restDecoder)\n  }\n\n  /**\n   * @return {Uint8Array}\n   */\n  readBuf () {\n    return buffer.copyUint8Array(decoding.readVarUint8Array(this.restDecoder))\n  }\n\n  /**\n   * Legacy implementation uses JSON parse. We use any-decoding in v2.\n   *\n   * @return {any}\n   */\n  readJSON () {\n    return JSON.parse(decoding.readVarString(this.restDecoder))\n  }\n\n  /**\n   * @return {string}\n   */\n  readKey () {\n    return decoding.readVarString(this.restDecoder)\n  }\n}\n\nexport class DSDecoderV2 {\n  /**\n   * @param {decoding.Decoder} decoder\n   */\n  constructor (decoder) {\n    /**\n     * @private\n     */\n    this.dsCurrVal = 0\n    this.restDecoder = decoder\n  }\n\n  resetDsCurVal () {\n    this.dsCurrVal = 0\n  }\n\n  /**\n   * @return {number}\n   */\n  readDsClock () {\n    this.dsCurrVal += decoding.readVarUint(this.restDecoder)\n    return this.dsCurrVal\n  }\n\n  /**\n   * @return {number}\n   */\n  readDsLen () {\n    const diff = decoding.readVarUint(this.restDecoder) + 1\n    this.dsCurrVal += diff\n    return diff\n  }\n}\n\nexport class UpdateDecoderV2 extends DSDecoderV2 {\n  /**\n   * @param {decoding.Decoder} decoder\n   */\n  constructor (decoder) {\n    super(decoder)\n    /**\n     * List of cached keys. If the keys[id] does not exist, we read a new key\n     * from stringEncoder and push it to keys.\n     *\n     * @type {Array<string>}\n     */\n    this.keys = []\n    decoding.readVarUint(decoder) // read feature flag - currently unused\n    this.keyClockDecoder = new decoding.IntDiffOptRleDecoder(decoding.readVarUint8Array(decoder))\n    this.clientDecoder = new decoding.UintOptRleDecoder(decoding.readVarUint8Array(decoder))\n    this.leftClockDecoder = new decoding.IntDiffOptRleDecoder(decoding.readVarUint8Array(decoder))\n    this.rightClockDecoder = new decoding.IntDiffOptRleDecoder(decoding.readVarUint8Array(decoder))\n    this.infoDecoder = new decoding.RleDecoder(decoding.readVarUint8Array(decoder), decoding.readUint8)\n    this.stringDecoder = new decoding.StringDecoder(decoding.readVarUint8Array(decoder))\n    this.parentInfoDecoder = new decoding.RleDecoder(decoding.readVarUint8Array(decoder), decoding.readUint8)\n    this.typeRefDecoder = new decoding.UintOptRleDecoder(decoding.readVarUint8Array(decoder))\n    this.lenDecoder = new decoding.UintOptRleDecoder(decoding.readVarUint8Array(decoder))\n  }\n\n  /**\n   * @return {ID}\n   */\n  readLeftID () {\n    return new ID(this.clientDecoder.read(), this.leftClockDecoder.read())\n  }\n\n  /**\n   * @return {ID}\n   */\n  readRightID () {\n    return new ID(this.clientDecoder.read(), this.rightClockDecoder.read())\n  }\n\n  /**\n   * Read the next client id.\n   * Use this in favor of readID whenever possible to reduce the number of objects created.\n   */\n  readClient () {\n    return this.clientDecoder.read()\n  }\n\n  /**\n   * @return {number} info An unsigned 8-bit integer\n   */\n  readInfo () {\n    return /** @type {number} */ (this.infoDecoder.read())\n  }\n\n  /**\n   * @return {string}\n   */\n  readString () {\n    return this.stringDecoder.read()\n  }\n\n  /**\n   * @return {boolean}\n   */\n  readParentInfo () {\n    return this.parentInfoDecoder.read() === 1\n  }\n\n  /**\n   * @return {number} An unsigned 8-bit integer\n   */\n  readTypeRef () {\n    return this.typeRefDecoder.read()\n  }\n\n  /**\n   * Write len of a struct - well suited for Opt RLE encoder.\n   *\n   * @return {number}\n   */\n  readLen () {\n    return this.lenDecoder.read()\n  }\n\n  /**\n   * @return {any}\n   */\n  readAny () {\n    return decoding.readAny(this.restDecoder)\n  }\n\n  /**\n   * @return {Uint8Array}\n   */\n  readBuf () {\n    return decoding.readVarUint8Array(this.restDecoder)\n  }\n\n  /**\n   * This is mainly here for legacy purposes.\n   *\n   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.\n   *\n   * @return {any}\n   */\n  readJSON () {\n    return decoding.readAny(this.restDecoder)\n  }\n\n  /**\n   * @return {string}\n   */\n  readKey () {\n    const keyClock = this.keyClockDecoder.read()\n    if (keyClock < this.keys.length) {\n      return this.keys[keyClock]\n    } else {\n      const key = this.stringDecoder.read()\n      this.keys.push(key)\n      return key\n    }\n  }\n}\n","import * as error from 'lib0/error'\nimport * as encoding from 'lib0/encoding'\n\nimport {\n  ID // eslint-disable-line\n} from '../internals.js'\n\nexport class IdSetEncoderV1 {\n  constructor () {\n    this.restEncoder = encoding.createEncoder()\n  }\n\n  toUint8Array () {\n    return encoding.toUint8Array(this.restEncoder)\n  }\n\n  resetIdSetCurVal () {\n    // nop\n  }\n\n  /**\n   * @param {number} clock\n   */\n  writeIdSetClock (clock) {\n    encoding.writeVarUint(this.restEncoder, clock)\n  }\n\n  /**\n   * @param {number} len\n   */\n  writeIdSetLen (len) {\n    encoding.writeVarUint(this.restEncoder, len)\n  }\n}\n\nexport class UpdateEncoderV1 extends IdSetEncoderV1 {\n  /**\n   * @param {ID} id\n   */\n  writeLeftID (id) {\n    encoding.writeVarUint(this.restEncoder, id.client)\n    encoding.writeVarUint(this.restEncoder, id.clock)\n  }\n\n  /**\n   * @param {ID} id\n   */\n  writeRightID (id) {\n    encoding.writeVarUint(this.restEncoder, id.client)\n    encoding.writeVarUint(this.restEncoder, id.clock)\n  }\n\n  /**\n   * Use writeClient and writeClock instead of writeID if possible.\n   * @param {number} client\n   */\n  writeClient (client) {\n    encoding.writeVarUint(this.restEncoder, client)\n  }\n\n  /**\n   * @param {number} info An unsigned 8-bit integer\n   */\n  writeInfo (info) {\n    encoding.writeUint8(this.restEncoder, info)\n  }\n\n  /**\n   * @param {string} s\n   */\n  writeString (s) {\n    encoding.writeVarString(this.restEncoder, s)\n  }\n\n  /**\n   * @param {boolean} isYKey\n   */\n  writeParentInfo (isYKey) {\n    encoding.writeVarUint(this.restEncoder, isYKey ? 1 : 0)\n  }\n\n  /**\n   * @param {number} info An unsigned 8-bit integer\n   */\n  writeTypeRef (info) {\n    encoding.writeVarUint(this.restEncoder, info)\n  }\n\n  /**\n   * Write len of a struct - well suited for Opt RLE encoder.\n   *\n   * @param {number} len\n   */\n  writeLen (len) {\n    encoding.writeVarUint(this.restEncoder, len)\n  }\n\n  /**\n   * @param {any} any\n   */\n  writeAny (any) {\n    encoding.writeAny(this.restEncoder, any)\n  }\n\n  /**\n   * @param {Uint8Array} buf\n   */\n  writeBuf (buf) {\n    encoding.writeVarUint8Array(this.restEncoder, buf)\n  }\n\n  /**\n   * @param {any} embed\n   */\n  writeJSON (embed) {\n    encoding.writeVarString(this.restEncoder, JSON.stringify(embed))\n  }\n\n  /**\n   * @param {string} key\n   */\n  writeKey (key) {\n    encoding.writeVarString(this.restEncoder, key)\n  }\n}\n\nexport class IdSetEncoderV2 {\n  constructor () {\n    this.restEncoder = encoding.createEncoder() // encodes all the rest / non-optimized\n    this.dsCurrVal = 0\n  }\n\n  toUint8Array () {\n    return encoding.toUint8Array(this.restEncoder)\n  }\n\n  resetIdSetCurVal () {\n    this.dsCurrVal = 0\n  }\n\n  /**\n   * @param {number} clock\n   */\n  writeIdSetClock (clock) {\n    const diff = clock - this.dsCurrVal\n    this.dsCurrVal = clock\n    encoding.writeVarUint(this.restEncoder, diff)\n  }\n\n  /**\n   * @param {number} len\n   */\n  writeIdSetLen (len) {\n    if (len === 0) {\n      error.unexpectedCase()\n    }\n    encoding.writeVarUint(this.restEncoder, len - 1)\n    this.dsCurrVal += len\n  }\n}\n\nexport class UpdateEncoderV2 extends IdSetEncoderV2 {\n  constructor () {\n    super()\n    /**\n     * @type {Map<string,number>}\n     */\n    this.keyMap = new Map()\n    /**\n     * Refers to the next unique key-identifier to me used.\n     * See writeKey method for more information.\n     *\n     * @type {number}\n     */\n    this.keyClock = 0\n    this.keyClockEncoder = new encoding.IntDiffOptRleEncoder()\n    this.clientEncoder = new encoding.UintOptRleEncoder()\n    this.leftClockEncoder = new encoding.IntDiffOptRleEncoder()\n    this.rightClockEncoder = new encoding.IntDiffOptRleEncoder()\n    this.infoEncoder = new encoding.RleEncoder(encoding.writeUint8)\n    this.stringEncoder = new encoding.StringEncoder()\n    this.parentInfoEncoder = new encoding.RleEncoder(encoding.writeUint8)\n    this.typeRefEncoder = new encoding.UintOptRleEncoder()\n    this.lenEncoder = new encoding.UintOptRleEncoder()\n  }\n\n  toUint8Array () {\n    const encoder = encoding.createEncoder()\n    encoding.writeVarUint(encoder, 0) // this is a feature flag that we might use in the future\n    encoding.writeVarUint8Array(encoder, this.keyClockEncoder.toUint8Array())\n    encoding.writeVarUint8Array(encoder, this.clientEncoder.toUint8Array())\n    encoding.writeVarUint8Array(encoder, this.leftClockEncoder.toUint8Array())\n    encoding.writeVarUint8Array(encoder, this.rightClockEncoder.toUint8Array())\n    encoding.writeVarUint8Array(encoder, encoding.toUint8Array(this.infoEncoder))\n    encoding.writeVarUint8Array(encoder, this.stringEncoder.toUint8Array())\n    encoding.writeVarUint8Array(encoder, encoding.toUint8Array(this.parentInfoEncoder))\n    encoding.writeVarUint8Array(encoder, this.typeRefEncoder.toUint8Array())\n    encoding.writeVarUint8Array(encoder, this.lenEncoder.toUint8Array())\n    // @note The rest encoder is appended! (note the missing var)\n    encoding.writeUint8Array(encoder, encoding.toUint8Array(this.restEncoder))\n    return encoding.toUint8Array(encoder)\n  }\n\n  /**\n   * @param {ID} id\n   */\n  writeLeftID (id) {\n    this.clientEncoder.write(id.client)\n    this.leftClockEncoder.write(id.clock)\n  }\n\n  /**\n   * @param {ID} id\n   */\n  writeRightID (id) {\n    this.clientEncoder.write(id.client)\n    this.rightClockEncoder.write(id.clock)\n  }\n\n  /**\n   * @param {number} client\n   */\n  writeClient (client) {\n    this.clientEncoder.write(client)\n  }\n\n  /**\n   * @param {number} info An unsigned 8-bit integer\n   */\n  writeInfo (info) {\n    this.infoEncoder.write(info)\n  }\n\n  /**\n   * @param {string} s\n   */\n  writeString (s) {\n    this.stringEncoder.write(s)\n  }\n\n  /**\n   * @param {boolean} isYKey\n   */\n  writeParentInfo (isYKey) {\n    this.parentInfoEncoder.write(isYKey ? 1 : 0)\n  }\n\n  /**\n   * @param {number} info An unsigned 8-bit integer\n   */\n  writeTypeRef (info) {\n    this.typeRefEncoder.write(info)\n  }\n\n  /**\n   * Write len of a struct - well suited for Opt RLE encoder.\n   *\n   * @param {number} len\n   */\n  writeLen (len) {\n    this.lenEncoder.write(len)\n  }\n\n  /**\n   * @param {any} any\n   */\n  writeAny (any) {\n    encoding.writeAny(this.restEncoder, any)\n  }\n\n  /**\n   * @param {Uint8Array} buf\n   */\n  writeBuf (buf) {\n    encoding.writeVarUint8Array(this.restEncoder, buf)\n  }\n\n  /**\n   * This is mainly here for legacy purposes.\n   *\n   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.\n   *\n   * @param {any} embed\n   */\n  writeJSON (embed) {\n    encoding.writeAny(this.restEncoder, embed)\n  }\n\n  /**\n   * Property keys are often reused. For example, in y-prosemirror the key `bold` might\n   * occur very often. For a 3d application, the key `position` might occur very often.\n   *\n   * We cache these keys in a Map and refer to them via a unique number.\n   *\n   * @param {string} key\n   */\n  writeKey (key) {\n    const clock = this.keyMap.get(key)\n    if (clock === undefined) {\n      /**\n       * @todo uncomment to introduce this feature finally\n       *\n       * Background. The ContentFormat object was always encoded using writeKey, but the decoder used to use readString.\n       * Furthermore, I forgot to set the keyclock. So everything was working fine.\n       *\n       * However, this feature here is basically useless as it is not being used (it actually only consumes extra memory).\n       *\n       * I don't know yet how to reintroduce this feature..\n       *\n       * Older clients won't be able to read updates when we reintroduce this feature. So this should probably be done using a flag.\n       *\n       */\n      // this.keyMap.set(key, this.keyClock)\n      this.keyClockEncoder.write(this.keyClock++)\n      this.stringEncoder.write(key)\n    } else {\n      this.keyClockEncoder.write(clock)\n    }\n  }\n}\n","/**\n * @module encoding\n */\n/*\n * We use the first five bits in the info flag for determining the type of the struct.\n *\n * 0: GC\n * 1: Item with Deleted content\n * 2: Item with JSON content\n * 3: Item with Binary content\n * 4: Item with String content\n * 5: Item with Embed content (for richtext content)\n * 6: Item with Format content (a formatting marker for richtext content)\n * 7: Item with Type\n */\n\nimport {\n  findIndexSS,\n  getState,\n  getStateVector,\n  readAndApplyDeleteSet,\n  writeIdSet,\n  transact,\n  UpdateDecoderV1,\n  UpdateDecoderV2,\n  UpdateEncoderV1,\n  UpdateEncoderV2,\n  IdSetEncoderV2,\n  DSDecoderV1,\n  IdSetEncoderV1,\n  mergeUpdates,\n  mergeUpdatesV2,\n  Skip,\n  diffUpdateV2,\n  convertUpdateFormatV2ToV1,\n  readStructSet,\n  removeRangesFromStructSet,\n  createIdSet,\n  StructSet, IdSet, DSDecoderV2, Doc, Transaction, GC, Item, StructStore, // eslint-disable-line\n  createID,\n  IdRange\n} from '../internals.js'\n\nimport * as encoding from 'lib0/encoding'\nimport * as decoding from 'lib0/decoding'\nimport * as map from 'lib0/map'\nimport * as math from 'lib0/math'\nimport * as array from 'lib0/array'\n\n/**\n * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n * @param {Array<GC|Item>} structs All structs by `client`\n * @param {number} client\n * @param {Array<IdRange>} idranges\n *\n * @function\n */\nconst writeStructs = (encoder, structs, client, idranges) => {\n  let structsToWrite = 0 // this accounts for the skips\n  /**\n   * @type {Array<{ start: number, end: number, startClock: number, endClock: number }>}\n   */\n  const indexRanges = []\n  const firstPossibleClock = structs[0].id.clock\n  const lastStruct = array.last(structs)\n  const lastPossibleClock = lastStruct.id.clock + lastStruct.length\n  idranges.forEach(idrange => {\n    const startClock = math.max(idrange.clock, firstPossibleClock)\n    const endClock = math.min(idrange.clock + idrange.len, lastPossibleClock)\n    if (startClock >= endClock) return // structs for this range do not exist\n    // inclusive start\n    const start = findIndexSS(structs, startClock)\n    // exclusive end\n    const end = findIndexSS(structs, endClock - 1) + 1\n    structsToWrite += end - start\n    indexRanges.push({\n      start,\n      end,\n      startClock,\n      endClock\n    })\n  })\n  structsToWrite += idranges.length - 1\n  // start writing with this clock. this is updated to the next clock that we expect to write\n  let clock = indexRanges[0].startClock\n  // write # encoded structs\n  encoding.writeVarUint(encoder.restEncoder, structsToWrite)\n  encoder.writeClient(client)\n  // write clock\n  encoding.writeVarUint(encoder.restEncoder, clock)\n  indexRanges.forEach(indexRange => {\n    const skipLen = indexRange.startClock - clock\n    if (skipLen > 0) {\n      new Skip(createID(client, clock), skipLen).write(encoder, 0)\n      clock += skipLen\n    }\n    for (let i = indexRange.start; i < indexRange.end; i++) {\n      const struct = structs[i]\n      const structEnd = struct.id.clock + struct.length\n      const offsetEnd = math.max(structEnd - indexRange.endClock, 0)\n      struct.write(encoder, clock - struct.id.clock, offsetEnd)\n      clock = structEnd - offsetEnd\n    }\n  })\n}\n\n/**\n * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n * @param {StructStore} store\n * @param {Map<number,number>} _sm\n *\n * @private\n * @function\n */\nexport const writeClientsStructs = (encoder, store, _sm) => {\n  // we filter all valid _sm entries into sm\n  const sm = new Map()\n  _sm.forEach((clock, client) => {\n    // only write if new structs are available\n    if (getState(store, client) > clock) {\n      sm.set(client, clock)\n    }\n  })\n  getStateVector(store).forEach((_clock, client) => {\n    if (!_sm.has(client)) {\n      sm.set(client, 0)\n    }\n  })\n  // write # states that were updated\n  encoding.writeVarUint(encoder.restEncoder, sm.size)\n  // Write items with higher client ids first\n  // This heavily improves the conflict algorithm.\n  array.from(sm.entries()).sort((a, b) => b[0] - a[0]).forEach(([client, clock]) => {\n    const structs = /** @type {Array<GC|Item>} */ (store.clients.get(client))\n    const lastStruct = structs[structs.length - 1]\n    writeStructs(encoder, structs, client, [new IdRange(clock, lastStruct.id.clock + lastStruct.length - clock)])\n  })\n}\n\n/**\n * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n * @param {StructStore} store\n * @param {IdSet} idset\n *\n * @todo at the moment this writes the full deleteset range\n *\n * @private\n * @function\n */\nexport const writeStructsFromIdSet = (encoder, store, idset) => {\n  // write # states that were updated\n  encoding.writeVarUint(encoder.restEncoder, idset.clients.size)\n  // Write items with higher client ids first\n  // This heavily improves the conflict algorithm.\n  array.from(idset.clients.entries()).sort((a, b) => b[0] - a[0]).forEach(([client, ids]) => {\n    const idRanges = ids.getIds()\n    const structs = /** @type {Array<GC|Item>} */ (store.clients.get(client))\n    writeStructs(encoder, structs, client, idRanges)\n  })\n}\n\n/**\n * Resume computing structs generated by struct readers.\n *\n * While there is something to do, we integrate structs in this order\n * 1. top element on stack, if stack is not empty\n * 2. next element from current struct reader (if empty, use next struct reader)\n *\n * If struct causally depends on another struct (ref.missing), we put next reader of\n * `ref.id.client` on top of stack.\n *\n * At some point we find a struct that has no causal dependencies,\n * then we start emptying the stack.\n *\n * It is not possible to have circles: i.e. struct1 (from client1) depends on struct2 (from client2)\n * depends on struct3 (from client1). Therefore the max stack size is equal to `structReaders.length`.\n *\n * This method is implemented in a way so that we can resume computation if this update\n * causally depends on another update.\n *\n * @param {Transaction} transaction\n * @param {StructStore} store\n * @param {StructSet} clientsStructRefs\n * @return { null | { update: Uint8Array<ArrayBuffer>, missing: Map<number,number> } }\n *\n * @private\n * @function\n */\nconst integrateStructs = (transaction, store, clientsStructRefs) => {\n  /**\n   * @type {Array<Item | GC>}\n   */\n  const stack = []\n  // sort them so that we take the higher id first, in case of conflicts the lower id will probably not conflict with the id from the higher user.\n  let clientsStructRefsIds = array.from(clientsStructRefs.clients.keys()).sort((a, b) => a - b)\n  if (clientsStructRefsIds.length === 0) {\n    return null\n  }\n  const getNextStructTarget = () => {\n    if (clientsStructRefsIds.length === 0) {\n      return null\n    }\n    let nextStructsTarget = /** @type {{i:number,refs:Array<GC|Item>}} */ (clientsStructRefs.clients.get(clientsStructRefsIds[clientsStructRefsIds.length - 1]))\n    while (nextStructsTarget.refs.length === nextStructsTarget.i) {\n      clientsStructRefsIds.pop()\n      if (clientsStructRefsIds.length > 0) {\n        nextStructsTarget = /** @type {{i:number,refs:Array<GC|Item>}} */ (clientsStructRefs.clients.get(clientsStructRefsIds[clientsStructRefsIds.length - 1]))\n      } else {\n        return null\n      }\n    }\n    return nextStructsTarget\n  }\n  let curStructsTarget = getNextStructTarget()\n  if (curStructsTarget === null) {\n    return null\n  }\n\n  /**\n   * @type {StructStore}\n   */\n  const restStructs = new StructStore()\n  const missingSV = new Map()\n  /**\n   * @param {number} client\n   * @param {number} clock\n   */\n  const updateMissingSv = (client, clock) => {\n    const mclock = missingSV.get(client)\n    if (mclock == null || mclock > clock) {\n      missingSV.set(client, clock)\n    }\n  }\n  /**\n   * @type {GC|Item}\n   */\n  let stackHead = /** @type {any} */ (curStructsTarget).refs[/** @type {any} */ (curStructsTarget).i++]\n  // caching the state because it is used very often\n  const state = new Map()\n\n  // // caching the state because it is used very often\n  // const currentInsertSet = createIdSet()\n  // clientsStructRefsIds.forEach(clientId => {\n  //   currentInsertSet.clients.set(clientid, new IdRanges(_createInsertSliceFromStructs(store.clients.get(clientId) ?? [], false)))\n  // })\n\n  const addStackToRestSS = () => {\n    for (const item of stack) {\n      const client = item.id.client\n      const inapplicableItems = clientsStructRefs.clients.get(client)\n      if (inapplicableItems) {\n        // decrement because we weren't able to apply previous operation\n        inapplicableItems.i--\n        restStructs.clients.set(client, inapplicableItems.refs.slice(inapplicableItems.i))\n        clientsStructRefs.clients.delete(client)\n        inapplicableItems.i = 0\n        inapplicableItems.refs = []\n      } else {\n        // item was the last item on clientsStructRefs and the field was already cleared. Add item to restStructs and continue\n        restStructs.clients.set(client, [item])\n      }\n      // remove client from clientsStructRefsIds to prevent users from applying the same update again\n      clientsStructRefsIds = clientsStructRefsIds.filter(c => c !== client)\n    }\n    stack.length = 0\n  }\n\n  // iterate over all struct readers until we are done\n  while (true) {\n    if (stackHead.constructor !== Skip) {\n      const localClock = map.setIfUndefined(state, stackHead.id.client, () => getState(store, stackHead.id.client))\n      const offset = localClock - stackHead.id.clock\n      const missing = stackHead.getMissing(transaction, store)\n      if (missing !== null) {\n        stack.push(stackHead)\n        // get the struct reader that has the missing struct\n        /**\n         * @type {{ refs: Array<GC|Item>, i: number }}\n         */\n        const structRefs = clientsStructRefs.clients.get(/** @type {number} */ (missing)) || { refs: [], i: 0 }\n        if (structRefs.refs.length === structRefs.i || missing === stackHead.id.client || stack.some(s => s.id.client === missing)) { // @todo this could be optimized!\n          // This update message causally depends on another update message that doesn't exist yet\n          updateMissingSv(/** @type {number} */ (missing), getState(store, missing))\n          addStackToRestSS()\n        } else {\n          stackHead = structRefs.refs[structRefs.i++]\n          continue\n        }\n      } else {\n        // all fine, apply the stackhead\n        // but first add a skip to structs if necessary\n        if (offset < 0) {\n          const skip = new Skip(createID(stackHead.id.client, localClock), -offset)\n          skip.integrate(transaction, 0)\n        }\n        stackHead.integrate(transaction, 0)\n        state.set(stackHead.id.client, math.max(stackHead.id.clock + stackHead.length, localClock))\n      }\n    }\n    // iterate to next stackHead\n    if (stack.length > 0) {\n      stackHead = /** @type {GC|Item} */ (stack.pop())\n    } else if (curStructsTarget !== null && curStructsTarget.i < curStructsTarget.refs.length) {\n      stackHead = /** @type {GC|Item} */ (curStructsTarget.refs[curStructsTarget.i++])\n    } else {\n      curStructsTarget = getNextStructTarget()\n      if (curStructsTarget === null) {\n        // we are done!\n        break\n      } else {\n        stackHead = /** @type {GC|Item} */ (curStructsTarget.refs[curStructsTarget.i++])\n      }\n    }\n  }\n  if (restStructs.clients.size > 0) {\n    const encoder = new UpdateEncoderV2()\n    writeClientsStructs(encoder, restStructs, new Map())\n    // write empty deleteset\n    // writeDeleteSet(encoder, new DeleteSet())\n    encoding.writeVarUint(encoder.restEncoder, 0) // => no need for an extra function call, just write 0 deletes\n    return { missing: missingSV, update: encoder.toUint8Array() }\n  }\n  return null\n}\n\n/**\n * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n * @param {Transaction} transaction\n *\n * @private\n * @function\n */\nexport const writeStructsFromTransaction = (encoder, transaction) => writeStructsFromIdSet(encoder, transaction.doc.store, transaction.insertSet)\n\n/**\n * Read and apply a document update.\n *\n * This function has the same effect as `applyUpdate` but accepts a decoder.\n *\n * @param {decoding.Decoder} decoder\n * @param {Doc} ydoc\n * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`\n * @param {UpdateDecoderV1 | UpdateDecoderV2} [structDecoder]\n *\n * @function\n */\nexport const readUpdateV2 = (decoder, ydoc, transactionOrigin, structDecoder = new UpdateDecoderV2(decoder)) =>\n  transact(ydoc, transaction => {\n    // force that transaction.local is set to non-local\n    transaction.local = false\n    let retry = false\n    const doc = transaction.doc\n    const store = doc.store\n    // let start = performance.now()\n    const ss = readStructSet(structDecoder, doc)\n    const knownState = createIdSet()\n    ss.clients.forEach((_, client) => {\n      const storeStructs = store.clients.get(client)\n      if (storeStructs) {\n        const last = storeStructs[storeStructs.length - 1]\n        knownState.add(client, 0, last.id.clock + last.length)\n        // remove known items from ss\n        store.skips.clients.get(client)?.getIds().forEach(idrange => {\n          knownState.delete(client, idrange.clock, idrange.len)\n        })\n      }\n    })\n    // remove known items from ss\n    removeRangesFromStructSet(ss, knownState)\n    // console.log('time to read structs: ', performance.now() - start) // @todo remove\n    // start = performance.now()\n    // console.log('time to merge: ', performance.now() - start) // @todo remove\n    // start = performance.now()\n    const restStructs = integrateStructs(transaction, store, ss)\n    const pending = store.pendingStructs\n    if (pending) {\n      // check if we can apply something\n      for (const [client, clock] of pending.missing) {\n        if (ss.clients.has(client) || clock < getState(store, client)) {\n          retry = true\n          break\n        }\n      }\n      if (restStructs) {\n        // merge restStructs into store.pending\n        for (const [client, clock] of restStructs.missing) {\n          const mclock = pending.missing.get(client)\n          if (mclock == null || mclock > clock) {\n            pending.missing.set(client, clock)\n          }\n        }\n        pending.update = mergeUpdatesV2([pending.update, restStructs.update])\n      }\n    } else {\n      store.pendingStructs = restStructs\n    }\n    // console.log('time to integrate: ', performance.now() - start) // @todo remove\n    // start = performance.now()\n    const dsRest = readAndApplyDeleteSet(structDecoder, transaction, store)\n    if (store.pendingDs) {\n      // @todo we could make a lower-bound state-vector check as we do above\n      const pendingDSUpdate = new UpdateDecoderV2(decoding.createDecoder(store.pendingDs))\n      decoding.readVarUint(pendingDSUpdate.restDecoder) // read 0 structs, because we only encode deletes in pendingdsupdate\n      const dsRest2 = readAndApplyDeleteSet(pendingDSUpdate, transaction, store)\n      if (dsRest && dsRest2) {\n        // case 1: ds1 != null && ds2 != null\n        store.pendingDs = mergeUpdatesV2([dsRest, dsRest2])\n      } else {\n        // case 2: ds1 != null\n        // case 3: ds2 != null\n        // case 4: ds1 == null && ds2 == null\n        store.pendingDs = dsRest || dsRest2\n      }\n    } else {\n      // Either dsRest == null && pendingDs == null OR dsRest != null\n      store.pendingDs = dsRest\n    }\n    // console.log('time to cleanup: ', performance.now() - start) // @todo remove\n    // start = performance.now()\n\n    // console.log('time to resume delete readers: ', performance.now() - start) // @todo remove\n    // start = performance.now()\n    if (retry) {\n      const update = /** @type {{update: Uint8Array}} */ (store.pendingStructs).update\n      store.pendingStructs = null\n      applyUpdateV2(transaction.doc, update)\n    }\n  }, transactionOrigin, false)\n\n/**\n * Read and apply a document update.\n *\n * This function has the same effect as `applyUpdate` but accepts a decoder.\n *\n * @param {decoding.Decoder} decoder\n * @param {Doc} ydoc\n * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`\n *\n * @function\n */\nexport const readUpdate = (decoder, ydoc, transactionOrigin) => readUpdateV2(decoder, ydoc, transactionOrigin, new UpdateDecoderV1(decoder))\n\n/**\n * Apply a document update created by, for example, `y.on('update', update => ..)` or `update = encodeStateAsUpdate()`.\n *\n * This function has the same effect as `readUpdate` but accepts an Uint8Array instead of a Decoder.\n *\n * @param {Doc} ydoc\n * @param {Uint8Array} update\n * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`\n * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} [YDecoder]\n *\n * @function\n */\nexport const applyUpdateV2 = (ydoc, update, transactionOrigin, YDecoder = UpdateDecoderV2) => {\n  const decoder = decoding.createDecoder(update)\n  readUpdateV2(decoder, ydoc, transactionOrigin, new YDecoder(decoder))\n}\n\n/**\n * Apply a document update created by, for example, `y.on('update', update => ..)` or `update = encodeStateAsUpdate()`.\n *\n * This function has the same effect as `readUpdate` but accepts an Uint8Array instead of a Decoder.\n *\n * @param {Doc} ydoc\n * @param {Uint8Array} update\n * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`\n *\n * @function\n */\nexport const applyUpdate = (ydoc, update, transactionOrigin) => applyUpdateV2(ydoc, update, transactionOrigin, UpdateDecoderV1)\n\n/**\n * Write all the document as a single update message. If you specify the state of the remote client (`targetStateVector`) it will\n * only write the operations that are missing.\n *\n * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n * @param {Doc} doc\n * @param {Map<number,number>} [targetStateVector] The state of the target that receives the update. Leave empty to write all known structs\n *\n * @function\n */\nexport const writeStateAsUpdate = (encoder, doc, targetStateVector = new Map()) => {\n  writeClientsStructs(encoder, doc.store, targetStateVector)\n  writeIdSet(encoder, doc.store.ds)\n}\n\n/**\n * Write all the document as a single update message that can be applied on the remote document. If you specify the state of the remote client (`targetState`) it will\n * only write the operations that are missing.\n *\n * Use `writeStateAsUpdate` instead if you are working with lib0/encoding.js#Encoder\n *\n * @param {Doc} doc\n * @param {Uint8Array} [encodedTargetStateVector] The state of the target that receives the update. Leave empty to write all known structs\n * @param {UpdateEncoderV1 | UpdateEncoderV2} [encoder]\n * @return {Uint8Array<ArrayBuffer>}\n *\n * @function\n */\nexport const encodeStateAsUpdateV2 = (doc, encodedTargetStateVector = new Uint8Array([0]), encoder = new UpdateEncoderV2()) => {\n  const targetStateVector = decodeStateVector(encodedTargetStateVector)\n  writeStateAsUpdate(encoder, doc, targetStateVector)\n  const updates = [encoder.toUint8Array()]\n  // also add the pending updates (if there are any)\n  if (doc.store.pendingDs) {\n    updates.push(doc.store.pendingDs)\n  }\n  if (doc.store.pendingStructs) {\n    updates.push(diffUpdateV2(doc.store.pendingStructs.update, encodedTargetStateVector))\n  }\n  if (updates.length > 1) {\n    if (encoder.constructor === UpdateEncoderV1) {\n      return mergeUpdates(updates.map((update, i) => i === 0 ? update : convertUpdateFormatV2ToV1(update)))\n    } else if (encoder.constructor === UpdateEncoderV2) {\n      return mergeUpdatesV2(updates)\n    }\n  }\n  return updates[0]\n}\n\n/**\n * Write all the document as a single update message that can be applied on the remote document. If you specify the state of the remote client (`targetState`) it will\n * only write the operations that are missing.\n *\n * Use `writeStateAsUpdate` instead if you are working with lib0/encoding.js#Encoder\n *\n * @param {Doc} doc\n * @param {Uint8Array} [encodedTargetStateVector] The state of the target that receives the update. Leave empty to write all known structs\n * @return {Uint8Array<ArrayBuffer>}\n *\n * @function\n */\nexport const encodeStateAsUpdate = (doc, encodedTargetStateVector) => encodeStateAsUpdateV2(doc, encodedTargetStateVector, new UpdateEncoderV1())\n\n/**\n * Read state vector from Decoder and return as Map\n *\n * @param {DSDecoderV1 | DSDecoderV2} decoder\n * @return {Map<number,number>} Maps `client` to the number next expected `clock` from that client.\n *\n * @function\n */\nexport const readStateVector = decoder => {\n  const ss = new Map()\n  const ssLength = decoding.readVarUint(decoder.restDecoder)\n  for (let i = 0; i < ssLength; i++) {\n    const client = decoding.readVarUint(decoder.restDecoder)\n    const clock = decoding.readVarUint(decoder.restDecoder)\n    ss.set(client, clock)\n  }\n  return ss\n}\n\n/**\n * Read decodedState and return State as Map.\n *\n * @param {Uint8Array} decodedState\n * @return {Map<number,number>} Maps `client` to the number next expected `clock` from that client.\n *\n * @function\n */\n// export const decodeStateVectorV2 = decodedState => readStateVector(new DSDecoderV2(decoding.createDecoder(decodedState)))\n\n/**\n * Read decodedState and return State as Map.\n *\n * @param {Uint8Array} decodedState\n * @return {Map<number,number>} Maps `client` to the number next expected `clock` from that client.\n *\n * @function\n */\nexport const decodeStateVector = decodedState => readStateVector(new DSDecoderV1(decoding.createDecoder(decodedState)))\n\n/**\n * @param {IdSetEncoderV1 | IdSetEncoderV2} encoder\n * @param {Map<number,number>} sv\n * @function\n */\nexport const writeStateVector = (encoder, sv) => {\n  encoding.writeVarUint(encoder.restEncoder, sv.size)\n  array.from(sv.entries()).sort((a, b) => b[0] - a[0]).forEach(([client, clock]) => {\n    encoding.writeVarUint(encoder.restEncoder, client) // @todo use a special client decoder that is based on mapping\n    encoding.writeVarUint(encoder.restEncoder, clock)\n  })\n  return encoder\n}\n\n/**\n * @param {IdSetEncoderV1 | IdSetEncoderV2} encoder\n * @param {Doc} doc\n *\n * @function\n */\nexport const writeDocumentStateVector = (encoder, doc) => writeStateVector(encoder, getStateVector(doc.store))\n\n/**\n * Encode State as Uint8Array.\n *\n * @param {Doc|Map<number,number>} doc\n * @param {IdSetEncoderV1 | IdSetEncoderV2} [encoder]\n * @return {Uint8Array}\n *\n * @function\n */\nexport const encodeStateVectorV2 = (doc, encoder = new IdSetEncoderV2()) => {\n  if (doc instanceof Map) {\n    writeStateVector(encoder, doc)\n  } else {\n    writeDocumentStateVector(encoder, doc)\n  }\n  return encoder.toUint8Array()\n}\n\n/**\n * Encode State as Uint8Array.\n *\n * @param {Doc|Map<number,number>} doc\n * @return {Uint8Array}\n *\n * @function\n */\nexport const encodeStateVector = doc => encodeStateVectorV2(doc, new IdSetEncoderV1())\n","import * as f from 'lib0/function'\n\n/**\n * General event handler implementation.\n *\n * @template ARG0, ARG1\n *\n * @private\n */\nexport class EventHandler {\n  constructor () {\n    /**\n     * @type {Array<function(ARG0, ARG1):void>}\n     */\n    this.l = []\n  }\n}\n\n/**\n * @template ARG0,ARG1\n * @returns {EventHandler<ARG0,ARG1>}\n *\n * @private\n * @function\n */\nexport const createEventHandler = () => new EventHandler()\n\n/**\n * Adds an event listener that is called when\n * {@link EventHandler#callEventListeners} is called.\n *\n * @template ARG0,ARG1\n * @param {EventHandler<ARG0,ARG1>} eventHandler\n * @param {function(ARG0,ARG1):void} f The event handler.\n *\n * @private\n * @function\n */\nexport const addEventHandlerListener = (eventHandler, f) =>\n  eventHandler.l.push(f)\n\n/**\n * Removes an event listener.\n *\n * @template ARG0,ARG1\n * @param {EventHandler<ARG0,ARG1>} eventHandler\n * @param {function(ARG0,ARG1):void} f The event handler that was added with\n *                     {@link EventHandler#addEventListener}\n *\n * @private\n * @function\n */\nexport const removeEventHandlerListener = (eventHandler, f) => {\n  const l = eventHandler.l\n  const len = l.length\n  eventHandler.l = l.filter(g => f !== g)\n  if (len === eventHandler.l.length) {\n    console.error('[yjs] Tried to remove event handler that doesn\\'t exist.')\n  }\n}\n\n/**\n * Removes all event listeners.\n * @template ARG0,ARG1\n * @param {EventHandler<ARG0,ARG1>} eventHandler\n *\n * @private\n * @function\n */\nexport const removeAllEventHandlerListeners = eventHandler => {\n  eventHandler.l.length = 0\n}\n\n/**\n * Call all event listeners that were added via\n * {@link EventHandler#addEventListener}.\n *\n * @template ARG0,ARG1\n * @param {EventHandler<ARG0,ARG1>} eventHandler\n * @param {ARG0} arg0\n * @param {ARG1} arg1\n *\n * @private\n * @function\n */\nexport const callEventHandlerListeners = (eventHandler, arg0, arg1) =>\n  f.callAll(eventHandler.l, [arg0, arg1])\n","import { AbstractType } from '../internals.js' // eslint-disable-line\n\nimport * as decoding from 'lib0/decoding'\nimport * as encoding from 'lib0/encoding'\nimport * as error from 'lib0/error'\n\nexport class ID {\n  /**\n   * @param {number} client client id\n   * @param {number} clock unique per client id, continuous number\n   */\n  constructor (client, clock) {\n    /**\n     * Client id\n     * @type {number}\n     */\n    this.client = client\n    /**\n     * unique per client id, continuous number\n     * @type {number}\n     */\n    this.clock = clock\n  }\n}\n\n/**\n * @param {ID | null} a\n * @param {ID | null} b\n * @return {boolean}\n *\n * @function\n */\nexport const compareIDs = (a, b) => a === b || (a !== null && b !== null && a.client === b.client && a.clock === b.clock)\n\n/**\n * @param {number} client\n * @param {number} clock\n *\n * @private\n * @function\n */\nexport const createID = (client, clock) => new ID(client, clock)\n\n/**\n * @param {encoding.Encoder} encoder\n * @param {ID} id\n *\n * @private\n * @function\n */\nexport const writeID = (encoder, id) => {\n  encoding.writeVarUint(encoder, id.client)\n  encoding.writeVarUint(encoder, id.clock)\n}\n\n/**\n * Read ID.\n * * If first varUint read is 0xFFFFFF a RootID is returned.\n * * Otherwise an ID is returned\n *\n * @param {decoding.Decoder} decoder\n * @return {ID}\n *\n * @private\n * @function\n */\nexport const readID = decoder =>\n  createID(decoding.readVarUint(decoder), decoding.readVarUint(decoder))\n\n/**\n * The top types are mapped from y.share.get(keyname) => type.\n * `type` does not store any information about the `keyname`.\n * This function finds the correct `keyname` for `type` and throws otherwise.\n *\n * @param {AbstractType<any>} type\n * @return {string}\n *\n * @private\n * @function\n */\nexport const findRootTypeKey = type => {\n  // @ts-ignore _y must be defined, otherwise unexpected case\n  for (const [key, value] of type.doc.share.entries()) {\n    if (value === type) {\n      return key\n    }\n  }\n  throw error.unexpectedCase()\n}\n","import { AbstractType, Item } from '../internals.js' // eslint-disable-line\n\n/**\n * Check if `parent` is a parent of `child`.\n *\n * @param {import('../utils/types.js').YType} parent\n * @param {Item|null} child\n * @return {Boolean} Whether `parent` is a parent of `child`.\n *\n * @private\n * @function\n */\nexport const isParentOf = (parent, child) => {\n  while (child !== null) {\n    if (child.parent === parent) {\n      return true\n    }\n    child = /** @type {AbstractType<any>} */ (child.parent)._item\n  }\n  return false\n}\n","import {\n  AbstractType // eslint-disable-line\n} from '../internals.js'\n\n/**\n * Convenient helper to log type information.\n *\n * Do not use in productive systems as the output can be immense!\n *\n * @param {AbstractType<any>} type\n */\nexport const logType = type => {\n  const res = []\n  let n = type._start\n  while (n) {\n    res.push(n)\n    n = n.right\n  }\n  console.log('Children: ', res)\n  console.log('Children content: ', res.filter(m => !m.deleted).map(m => m.content))\n}\n","import {\n  writeID,\n  readID,\n  compareIDs,\n  getState,\n  findRootTypeKey,\n  Item,\n  createID,\n  ContentType,\n  followRedone,\n  getItem,\n  StructStore, ID, Doc, AbstractType, noAttributionsManager, // eslint-disable-line\n} from '../internals.js'\n\nimport * as encoding from 'lib0/encoding'\nimport * as decoding from 'lib0/decoding'\nimport * as error from 'lib0/error'\n\n/**\n * A relative position is based on the Yjs model and is not affected by document changes.\n * E.g. If you place a relative position before a certain character, it will always point to this character.\n * If you place a relative position at the end of a type, it will always point to the end of the type.\n *\n * A numeric position is often unsuited for user selections, because it does not change when content is inserted\n * before or after.\n *\n * ```Insert(0, 'x')('a|bc') = 'xa|bc'``` Where | is the relative position.\n *\n * One of the properties must be defined.\n *\n * @example\n *   // Current cursor position is at position 10\n *   const relativePosition = createRelativePositionFromIndex(yText, 10)\n *   // modify yText\n *   yText.insert(0, 'abc')\n *   yText.delete(3, 10)\n *   // Compute the cursor position\n *   const absolutePosition = createAbsolutePositionFromRelativePosition(y, relativePosition)\n *   absolutePosition.type === yText // => true\n *   console.log('cursor location is ' + absolutePosition.index) // => cursor location is 3\n *\n */\nexport class RelativePosition {\n  /**\n   * @param {ID|null} type\n   * @param {string|null} tname\n   * @param {ID|null} item\n   * @param {number} assoc\n   */\n  constructor (type, tname, item, assoc = 0) {\n    /**\n     * @type {ID|null}\n     */\n    this.type = type\n    /**\n     * @type {string|null}\n     */\n    this.tname = tname\n    /**\n     * @type {ID | null}\n     */\n    this.item = item\n    /**\n     * A relative position is associated to a specific character. By default\n     * assoc >= 0, the relative position is associated to the character\n     * after the meant position.\n     * I.e. position 1 in 'ab' is associated to character 'b'.\n     *\n     * If assoc < 0, then the relative position is associated to the character\n     * before the meant position.\n     *\n     * @type {number}\n     */\n    this.assoc = assoc\n  }\n}\n\n/**\n * @param {RelativePosition} rpos\n * @return {any}\n */\nexport const relativePositionToJSON = rpos => {\n  const json = {}\n  if (rpos.type) {\n    json.type = rpos.type\n  }\n  if (rpos.tname) {\n    json.tname = rpos.tname\n  }\n  if (rpos.item) {\n    json.item = rpos.item\n  }\n  if (rpos.assoc != null) {\n    json.assoc = rpos.assoc\n  }\n  return json\n}\n\n/**\n * @param {any} json\n * @return {RelativePosition}\n *\n * @function\n */\nexport const createRelativePositionFromJSON = json => new RelativePosition(json.type == null ? null : createID(json.type.client, json.type.clock), json.tname ?? null, json.item == null ? null : createID(json.item.client, json.item.clock), json.assoc == null ? 0 : json.assoc)\n\nexport class AbsolutePosition {\n  /**\n   * @param {AbstractType<any>} type\n   * @param {number} index\n   * @param {number} [assoc]\n   */\n  constructor (type, index, assoc = 0) {\n    /**\n     * @type {AbstractType<any>}\n     */\n    this.type = type\n    /**\n     * @type {number}\n     */\n    this.index = index\n    this.assoc = assoc\n  }\n}\n\n/**\n * @param {AbstractType<any>} type\n * @param {number} index\n * @param {number} [assoc]\n *\n * @function\n */\nexport const createAbsolutePosition = (type, index, assoc = 0) => new AbsolutePosition(type, index, assoc)\n\n/**\n * @param {AbstractType<any>} type\n * @param {ID|null} item\n * @param {number} [assoc]\n *\n * @function\n */\nexport const createRelativePosition = (type, item, assoc) => {\n  let typeid = null\n  let tname = null\n  if (type._item === null) {\n    tname = findRootTypeKey(type)\n  } else {\n    typeid = createID(type._item.id.client, type._item.id.clock)\n  }\n  return new RelativePosition(typeid, tname, item, assoc)\n}\n\n/**\n * Create a relativePosition based on a absolute position.\n *\n * @param {AbstractType} type The base type (e.g. YText or YArray).\n * @param {number} index The absolute position.\n * @param {number} [assoc]\n * @param {import('../utils/AttributionManager.js').AbstractAttributionManager} attributionManager\n * @return {RelativePosition}\n *\n * @function\n */\nexport const createRelativePositionFromTypeIndex = (type, index, assoc = 0, attributionManager = noAttributionsManager) => {\n  let t = type._start\n  if (assoc < 0) {\n    // associated to the left character or the beginning of a type, increment index if possible.\n    if (index === 0) {\n      return createRelativePosition(type, null, assoc)\n    }\n    index--\n  }\n  while (t !== null) {\n    const len = attributionManager.contentLength(t)\n    if (len > index) {\n      // case 1: found position somewhere in the linked list\n      return createRelativePosition(type, createID(t.id.client, t.id.clock + index), assoc)\n    }\n    index -= len\n    if (t.right === null && assoc < 0) {\n      // left-associated position, return last available id\n      return createRelativePosition(type, t.lastId, assoc)\n    }\n    t = t.right\n  }\n  return createRelativePosition(type, null, assoc)\n}\n\n/**\n * @param {encoding.Encoder} encoder\n * @param {RelativePosition} rpos\n *\n * @function\n */\nexport const writeRelativePosition = (encoder, rpos) => {\n  const { type, tname, item, assoc } = rpos\n  if (item !== null) {\n    encoding.writeVarUint(encoder, 0)\n    writeID(encoder, item)\n  } else if (tname !== null) {\n    // case 2: found position at the end of the list and type is stored in y.share\n    encoding.writeUint8(encoder, 1)\n    encoding.writeVarString(encoder, tname)\n  } else if (type !== null) {\n    // case 3: found position at the end of the list and type is attached to an item\n    encoding.writeUint8(encoder, 2)\n    writeID(encoder, type)\n  } else {\n    throw error.unexpectedCase()\n  }\n  encoding.writeVarInt(encoder, assoc)\n  return encoder\n}\n\n/**\n * @param {RelativePosition} rpos\n * @return {Uint8Array}\n */\nexport const encodeRelativePosition = rpos => {\n  const encoder = encoding.createEncoder()\n  writeRelativePosition(encoder, rpos)\n  return encoding.toUint8Array(encoder)\n}\n\n/**\n * @param {decoding.Decoder} decoder\n * @return {RelativePosition}\n *\n * @function\n */\nexport const readRelativePosition = decoder => {\n  let type = null\n  let tname = null\n  let itemID = null\n  switch (decoding.readVarUint(decoder)) {\n    case 0:\n      // case 1: found position somewhere in the linked list\n      itemID = readID(decoder)\n      break\n    case 1:\n      // case 2: found position at the end of the list and type is stored in y.share\n      tname = decoding.readVarString(decoder)\n      break\n    case 2: {\n      // case 3: found position at the end of the list and type is attached to an item\n      type = readID(decoder)\n    }\n  }\n  const assoc = decoding.hasContent(decoder) ? decoding.readVarInt(decoder) : 0\n  return new RelativePosition(type, tname, itemID, assoc)\n}\n\n/**\n * @param {Uint8Array} uint8Array\n * @return {RelativePosition}\n */\nexport const decodeRelativePosition = uint8Array => readRelativePosition(decoding.createDecoder(uint8Array))\n\n/**\n * @param {StructStore} store\n * @param {ID} id\n */\nconst getItemWithOffset = (store, id) => {\n  const item = getItem(store, id)\n  const diff = id.clock - item.id.clock\n  return {\n    item, diff\n  }\n}\n\n/**\n * Transform a relative position to an absolute position.\n *\n * If you want to share the relative position with other users, you should set\n * `followUndoneDeletions` to false to get consistent results across all clients.\n *\n * When calculating the absolute position, we try to follow the \"undone deletions\". This yields\n * better results for the user who performed undo. However, only the user who performed the undo\n * will get the better results, the other users don't know which operations recreated a deleted\n * range of content. There is more information in this ticket: https://github.com/yjs/yjs/issues/638\n *\n * @param {RelativePosition} rpos\n * @param {Doc} doc\n * @param {boolean} followUndoneDeletions - whether to follow undone deletions - see https://github.com/yjs/yjs/issues/638\n * @param {import('../utils/AttributionManager.js').AbstractAttributionManager} attributionManager\n * @return {AbsolutePosition|null}\n *\n * @function\n */\nexport const createAbsolutePositionFromRelativePosition = (rpos, doc, followUndoneDeletions = true, attributionManager = noAttributionsManager) => {\n  const store = doc.store\n  const rightID = rpos.item\n  const typeID = rpos.type\n  const tname = rpos.tname\n  const assoc = rpos.assoc\n  let type = null\n  let index = 0\n  if (rightID !== null) {\n    if (getState(store, rightID.client) <= rightID.clock) {\n      return null\n    }\n    const res = followUndoneDeletions ? followRedone(store, rightID) : getItemWithOffset(store, rightID)\n    const right = res.item\n    if (!(right instanceof Item)) {\n      return null\n    }\n    type = /** @type {AbstractType<any>} */ (right.parent)\n    if (type._item === null || !type._item.deleted) {\n      index = attributionManager.contentLength(right) === 0 ? 0 : (res.diff + (assoc >= 0 ? 0 : 1)) // adjust position based on left association if necessary\n      let n = right.left\n      while (n !== null) {\n        index += attributionManager.contentLength(n)\n        n = n.left\n      }\n    }\n  } else {\n    if (tname !== null) {\n      type = doc.get(tname)\n    } else if (typeID !== null) {\n      if (getState(store, typeID.client) <= typeID.clock) {\n        // type does not exist yet\n        return null\n      }\n      const { item } = followUndoneDeletions ? followRedone(store, typeID) : { item: getItem(store, typeID) }\n      if (item instanceof Item && item.content instanceof ContentType) {\n        type = item.content.type\n      } else {\n        // struct is garbage collected\n        return null\n      }\n    } else {\n      throw error.unexpectedCase()\n    }\n    if (assoc >= 0) {\n      index = type._length\n    } else {\n      index = 0\n    }\n  }\n  return createAbsolutePosition(type, index, rpos.assoc)\n}\n\n/**\n * @param {RelativePosition|null} a\n * @param {RelativePosition|null} b\n * @return {boolean}\n *\n * @function\n */\nexport const compareRelativePositions = (a, b) => a === b || (\n  a !== null && b !== null && a.tname === b.tname && compareIDs(a.item, b.item) && compareIDs(a.type, b.type) && a.assoc === b.assoc\n)\n","import {\n  createDeleteSetFromStructStore,\n  getStateVector,\n  getItemCleanStart,\n  iterateStructsByIdSet,\n  writeIdSet,\n  writeStateVector,\n  readIdSet,\n  readStateVector,\n  createIdSet,\n  createID,\n  getState,\n  findIndexSS,\n  UpdateEncoderV2,\n  applyUpdateV2,\n  LazyStructReader,\n  equalIdSets,\n  UpdateDecoderV1, UpdateDecoderV2, IdSetEncoderV1, IdSetEncoderV2, DSDecoderV1, DSDecoderV2, Transaction, Doc, IdSet, Item, // eslint-disable-line\n  mergeIdSets\n} from '../internals.js'\n\nimport * as map from 'lib0/map'\nimport * as set from 'lib0/set'\nimport * as decoding from 'lib0/decoding'\nimport * as encoding from 'lib0/encoding'\n\nexport class Snapshot {\n  /**\n   * @param {IdSet} ds\n   * @param {Map<number,number>} sv state map\n   */\n  constructor (ds, sv) {\n    /**\n     * @type {IdSet}\n     */\n    this.ds = ds\n    /**\n     * State Map\n     * @type {Map<number,number>}\n     */\n    this.sv = sv\n  }\n}\n\n/**\n * @param {Snapshot} snap1\n * @param {Snapshot} snap2\n * @return {boolean}\n */\nexport const equalSnapshots = (snap1, snap2) => {\n  const sv1 = snap1.sv\n  const sv2 = snap2.sv\n  if (sv1.size !== sv2.size) {\n    return false\n  }\n  for (const [key, value] of sv1.entries()) {\n    if (sv2.get(key) !== value) {\n      return false\n    }\n  }\n  return equalIdSets(snap1.ds, snap2.ds)\n}\n\n/**\n * @param {Snapshot} snapshot\n * @param {IdSetEncoderV1 | IdSetEncoderV2} [encoder]\n * @return {Uint8Array}\n */\nexport const encodeSnapshotV2 = (snapshot, encoder = new IdSetEncoderV2()) => {\n  writeIdSet(encoder, snapshot.ds)\n  writeStateVector(encoder, snapshot.sv)\n  return encoder.toUint8Array()\n}\n\n/**\n * @param {Snapshot} snapshot\n * @return {Uint8Array}\n */\nexport const encodeSnapshot = snapshot => encodeSnapshotV2(snapshot, new IdSetEncoderV1())\n\n/**\n * @param {Uint8Array} buf\n * @param {DSDecoderV1 | DSDecoderV2} [decoder]\n * @return {Snapshot}\n */\nexport const decodeSnapshotV2 = (buf, decoder = new DSDecoderV2(decoding.createDecoder(buf))) => {\n  return new Snapshot(readIdSet(decoder), readStateVector(decoder))\n}\n\n/**\n * @param {Uint8Array} buf\n * @return {Snapshot}\n */\nexport const decodeSnapshot = buf => decodeSnapshotV2(buf, new DSDecoderV1(decoding.createDecoder(buf)))\n\n/**\n * @param {IdSet} ds\n * @param {Map<number,number>} sm\n * @return {Snapshot}\n */\nexport const createSnapshot = (ds, sm) => new Snapshot(ds, sm)\n\nexport const emptySnapshot = createSnapshot(createIdSet(), new Map())\n\n/**\n * @param {Doc} doc\n * @return {Snapshot}\n */\nexport const snapshot = doc => createSnapshot(createDeleteSetFromStructStore(doc.store), getStateVector(doc.store))\n\n/**\n * @param {Item} item\n * @param {Snapshot|undefined} snapshot\n *\n * @protected\n * @function\n */\nexport const isVisible = (item, snapshot) => snapshot === undefined\n  ? !item.deleted\n  : snapshot.sv.has(item.id.client) && (snapshot.sv.get(item.id.client) || 0) > item.id.clock && !snapshot.ds.hasId(item.id)\n\n/**\n * @param {Transaction} transaction\n * @param {Snapshot} snapshot\n */\nexport const splitSnapshotAffectedStructs = (transaction, snapshot) => {\n  const meta = map.setIfUndefined(transaction.meta, splitSnapshotAffectedStructs, set.create)\n  const store = transaction.doc.store\n  // check if we already split for this snapshot\n  if (!meta.has(snapshot)) {\n    snapshot.sv.forEach((clock, client) => {\n      if (clock < getState(store, client)) {\n        getItemCleanStart(transaction, createID(client, clock))\n      }\n    })\n    iterateStructsByIdSet(transaction, snapshot.ds, _item => {})\n    meta.add(snapshot)\n  }\n}\n\n/**\n * @example\n *  const ydoc = new Y.Doc({ gc: false })\n *  ydoc.getText().insert(0, 'world!')\n *  const snapshot = Y.snapshot(ydoc)\n *  ydoc.getText().insert(0, 'hello ')\n *  const restored = Y.createDocFromSnapshot(ydoc, snapshot)\n *  assert(restored.getText().toString() === 'world!')\n *\n * @param {Doc} originDoc\n * @param {Snapshot} snapshot\n * @param {Doc} [newDoc] Optionally, you may define the Yjs document that receives the data from originDoc\n * @return {Doc}\n */\nexport const createDocFromSnapshot = (originDoc, snapshot, newDoc = new Doc()) => {\n  if (originDoc.gc) {\n    // we should not try to restore a GC-ed document, because some of the restored items might have their content deleted\n    throw new Error('Garbage-collection must be disabled in `originDoc`!')\n  }\n  const { sv, ds } = snapshot\n\n  const encoder = new UpdateEncoderV2()\n  originDoc.transact(transaction => {\n    let size = 0\n    sv.forEach(clock => {\n      if (clock > 0) {\n        size++\n      }\n    })\n    encoding.writeVarUint(encoder.restEncoder, size)\n    // splitting the structs before writing them to the encoder\n    for (const [client, clock] of sv) {\n      if (clock === 0) {\n        continue\n      }\n      if (clock < getState(originDoc.store, client)) {\n        getItemCleanStart(transaction, createID(client, clock))\n      }\n      const structs = originDoc.store.clients.get(client) || []\n      const lastStructIndex = findIndexSS(structs, clock - 1)\n      // write # encoded structs\n      encoding.writeVarUint(encoder.restEncoder, lastStructIndex + 1)\n      encoder.writeClient(client)\n      // first clock written is 0\n      encoding.writeVarUint(encoder.restEncoder, 0)\n      for (let i = 0; i <= lastStructIndex; i++) {\n        structs[i].write(encoder, 0, 0)\n      }\n    }\n    writeIdSet(encoder, ds)\n  })\n\n  applyUpdateV2(newDoc, encoder.toUint8Array(), 'snapshot')\n  return newDoc\n}\n\n/**\n * @param {Snapshot} snapshot\n * @param {Uint8Array} update\n * @param {typeof UpdateDecoderV2 | typeof UpdateDecoderV1} [YDecoder]\n */\nexport const snapshotContainsUpdateV2 = (snapshot, update, YDecoder = UpdateDecoderV2) => {\n  const structs = []\n  const updateDecoder = new YDecoder(decoding.createDecoder(update))\n  const lazyDecoder = new LazyStructReader(updateDecoder, false)\n  for (let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()) {\n    structs.push(curr)\n    if ((snapshot.sv.get(curr.id.client) || 0) < curr.id.clock + curr.length) {\n      return false\n    }\n  }\n  const mergedDS = mergeIdSets([snapshot.ds, readIdSet(updateDecoder)])\n  return equalIdSets(snapshot.ds, mergedDS)\n}\n\n/**\n * @param {Snapshot} snapshot\n * @param {Uint8Array} update\n */\nexport const snapshotContainsUpdate = (snapshot, update) => snapshotContainsUpdateV2(snapshot, update, UpdateDecoderV1)\n","import {\n  GC,\n  splitItem,\n  createDeleteSetFromStructStore,\n  createIdSet,\n  Transaction, ID, Item, // eslint-disable-line\n  Skip,\n  createID,\n  splitStruct\n} from '../internals.js'\n\nimport * as math from 'lib0/math'\nimport * as error from 'lib0/error'\n\nexport class StructStore {\n  constructor () {\n    /**\n     * @type {Map<number,Array<GC|Item>>}\n     */\n    this.clients = new Map()\n    // this.ds = new IdSet()\n    /**\n     * @type {null | { missing: Map<number, number>, update: Uint8Array<ArrayBuffer> }}\n     */\n    this.pendingStructs = null\n    /**\n     * @type {null | Uint8Array<ArrayBuffer>}\n     */\n    this.pendingDs = null\n    this.skips = createIdSet()\n  }\n\n  get ds () {\n    return createDeleteSetFromStructStore(this)\n  }\n}\n\n/**\n * Return the states as a Map<client,clock>.\n * Note that clock refers to the next expected clock id.\n *\n * @param {StructStore} store\n * @return {Map<number,number>}\n *\n * @public\n * @function\n */\nexport const getStateVector = store => {\n  const sm = new Map()\n  store.clients.forEach((structs, client) => {\n    const struct = structs[structs.length - 1]\n    sm.set(client, struct.id.clock + struct.length)\n  })\n  store.skips.clients.forEach((range, client) => {\n    sm.set(client, range.getIds()[0].clock)\n  })\n  return sm\n}\n\n/**\n * @param {StructStore} store\n * @param {number} client\n * @return {number}\n *\n * @public\n * @function\n */\nexport const getState = (store, client) => {\n  const structs = store.clients.get(client)\n  if (structs === undefined) {\n    return 0\n  }\n  const lastStruct = structs[structs.length - 1]\n  return lastStruct.id.clock + lastStruct.length\n}\n\n/**\n * @param {StructStore} store\n *\n * @private\n * @function\n */\nexport const integrityCheck = store => {\n  store.clients.forEach(structs => {\n    for (let i = 1; i < structs.length; i++) {\n      const l = structs[i - 1]\n      const r = structs[i]\n      if (l.id.clock + l.length !== r.id.clock) {\n        throw new Error('StructStore failed integrity check')\n      }\n    }\n  })\n}\n\n/**\n * @param {StructStore} store\n * @param {GC|Item} struct\n *\n * @private\n * @function\n */\nexport const addStruct = (store, struct) => {\n  let structs = store.clients.get(struct.id.client)\n  if (structs === undefined) {\n    structs = []\n    store.clients.set(struct.id.client, structs)\n  } else {\n    const lastStruct = structs[structs.length - 1]\n    if (lastStruct.id.clock + lastStruct.length !== struct.id.clock) {\n      // this replaces an integrated skip\n      let index = findIndexSS(structs, struct.id.clock)\n      const skip = structs[index]\n      const diffStart = struct.id.clock - skip.id.clock\n      const diffEnd = skip.id.clock + skip.length - struct.id.clock - struct.length\n      if (diffStart > 0) {\n        structs.splice(index++, 0, new Skip(createID(struct.id.client, skip.id.clock), diffStart))\n      }\n      if (diffEnd > 0) {\n        structs.splice(index + 1, 0, new Skip(createID(struct.id.client, struct.id.clock + struct.length), diffEnd))\n      }\n      structs[index] = struct\n      store.skips.delete(struct.id.client, struct.id.clock, struct.length)\n      return\n    }\n  }\n  structs.push(struct)\n}\n\n/**\n * Perform a binary search on a sorted array\n * @param {Array<Item|GC>} structs\n * @param {number} clock\n * @return {number}\n *\n * @private\n * @function\n */\nexport const findIndexSS = (structs, clock) => {\n  let left = 0\n  let right = structs.length - 1\n  let mid = structs[right]\n  let midclock = mid.id.clock\n  if (midclock === clock) {\n    return right\n  }\n  // @todo does it even make sense to pivot the search?\n  // If a good split misses, it might actually increase the time to find the correct item.\n  // Currently, the only advantage is that search with pivoting might find the item on the first try.\n  let midindex = math.floor((clock / (midclock + mid.length - 1)) * right) // pivoting the search\n  while (left <= right) {\n    mid = structs[midindex]\n    midclock = mid.id.clock\n    if (midclock <= clock) {\n      if (clock < midclock + mid.length) {\n        return midindex\n      }\n      left = midindex + 1\n    } else {\n      right = midindex - 1\n    }\n    midindex = math.floor((left + right) / 2)\n  }\n  // Always check state before looking for a struct in StructStore\n  // Therefore the case of not finding a struct is unexpected\n  throw error.unexpectedCase()\n}\n\n/**\n * Expects that id is actually in store. This function throws or is an infinite loop otherwise.\n *\n * @param {StructStore} store\n * @param {ID} id\n * @return {GC|Item}\n *\n * @private\n * @function\n */\nexport const find = (store, id) => {\n  /**\n   * @type {Array<GC|Item>}\n   */\n  // @ts-ignore\n  const structs = store.clients.get(id.client)\n  return structs[findIndexSS(structs, id.clock)]\n}\n\n/**\n * Expects that id is actually in store. This function throws or is an infinite loop otherwise.\n * @private\n * @function\n */\nexport const getItem = /** @type {function(StructStore,ID):Item} */ (find)\n\n/**\n * @param {Transaction?} transaction\n * @param {Array<Item|GC>} structs\n * @param {number} clock\n */\nexport const findIndexCleanStart = (transaction, structs, clock) => {\n  const index = findIndexSS(structs, clock)\n  const struct = structs[index]\n  if (struct.id.clock < clock) {\n    structs.splice(index + 1, 0, splitStruct(transaction, struct, clock - struct.id.clock))\n    return index + 1\n  }\n  return index\n}\n\n/**\n * Expects that id is actually in store. This function throws or is an infinite loop otherwise.\n *\n * @param {Transaction} transaction\n * @param {ID} id\n * @return {Item}\n *\n * @private\n * @function\n */\nexport const getItemCleanStart = (transaction, id) => {\n  const structs = /** @type {Array<Item>} */ (transaction.doc.store.clients.get(id.client))\n  return structs[findIndexCleanStart(transaction, structs, id.clock)]\n}\n\n/**\n * Expects that id is actually in store. This function throws or is an infinite loop otherwise.\n *\n * @param {Transaction} transaction\n * @param {StructStore} store\n * @param {ID} id\n * @return {Item}\n *\n * @private\n * @function\n */\nexport const getItemCleanEnd = (transaction, store, id) => {\n  /**\n   * @type {Array<Item>}\n   */\n  // @ts-ignore\n  const structs = store.clients.get(id.client)\n  const index = findIndexSS(structs, id.clock)\n  const struct = structs[index]\n  if (id.clock !== struct.id.clock + struct.length - 1 && struct.constructor !== GC) {\n    structs.splice(index + 1, 0, splitItem(transaction, struct, id.clock - struct.id.clock + 1))\n  }\n  return struct\n}\n\n/**\n * Replace `item` with `newitem` in store\n * @param {Transaction} tr\n * @param {GC|Item} struct\n * @param {GC|Item} newStruct\n *\n * @private\n * @function\n */\nexport const replaceStruct = (tr, struct, newStruct) => {\n  const structs = /** @type {Array<GC|Item>} */ (tr.doc.store.clients.get(struct.id.client))\n  structs[findIndexSS(structs, struct.id.clock)] = newStruct\n  tr._mergeStructs.push(newStruct)\n}\n\n/**\n * Iterate over a range of structs\n *\n * @param {Transaction} transaction\n * @param {Array<Item|GC>} structs\n * @param {number} clockStart Inclusive start\n * @param {number} len\n * @param {function(GC|Item):void} f\n *\n * @function\n */\nexport const iterateStructs = (transaction, structs, clockStart, len, f) => {\n  if (len === 0) {\n    return\n  }\n  const clockEnd = clockStart + len\n  let index = findIndexCleanStart(transaction, structs, clockStart)\n  let struct\n  do {\n    struct = structs[index++]\n    if (clockEnd < struct.id.clock + struct.length) {\n      findIndexCleanStart(transaction, structs, clockEnd)\n    }\n    f(struct)\n  } while (index < structs.length && structs[index].id.clock < clockEnd)\n}\n","import {\n  getState,\n  writeStructsFromTransaction,\n  writeIdSet,\n  getStateVector,\n  findIndexSS,\n  callEventHandlerListeners,\n  createIdSet,\n  Item,\n  generateNewClientId,\n  createID,\n  cleanupYTextAfterTransaction,\n  IdSet, UpdateEncoderV1, UpdateEncoderV2, GC, StructStore, AbstractType, AbstractStruct, YEvent, Doc // eslint-disable-line\n} from '../internals.js'\n\nimport * as error from 'lib0/error'\nimport * as map from 'lib0/map'\nimport * as math from 'lib0/math'\nimport * as set from 'lib0/set'\nimport * as logging from 'lib0/logging'\nimport { callAll } from 'lib0/function'\n\n/**\n * A transaction is created for every change on the Yjs model. It is possible\n * to bundle changes on the Yjs model in a single transaction to\n * minimize the number on messages sent and the number of observer calls.\n * If possible the user of this library should bundle as many changes as\n * possible. Here is an example to illustrate the advantages of bundling:\n *\n * @example\n * const ydoc = new Y.Doc()\n * const map = ydoc.getMap('map')\n * // Log content when change is triggered\n * map.observe(() => {\n *   console.log('change triggered')\n * })\n * // Each change on the map type triggers a log message:\n * map.set('a', 0) // => \"change triggered\"\n * map.set('b', 0) // => \"change triggered\"\n * // When put in a transaction, it will trigger the log after the transaction:\n * ydoc.transact(() => {\n *   map.set('a', 1)\n *   map.set('b', 1)\n * }) // => \"change triggered\"\n *\n * @public\n */\nexport class Transaction {\n  /**\n   * @param {Doc} doc\n   * @param {any} origin\n   * @param {boolean} local\n   */\n  constructor (doc, origin, local) {\n    /**\n     * The Yjs instance.\n     * @type {Doc}\n     */\n    this.doc = doc\n    /**\n     * Describes the set of deleted items by ids\n     */\n    this.deleteSet = createIdSet()\n    /**\n     * Describes the set of items that are cleaned up / deleted by ids. It is a subset of\n     * this.deleteSet\n     */\n    this.cleanUps = createIdSet()\n    /**\n     * Describes the set of inserted items by ids\n     */\n    this.insertSet = createIdSet()\n    /**\n     * Holds the state before the transaction started.\n     * @type {Map<Number,Number>?}\n     */\n    this._beforeState = null\n    /**\n     * Holds the state after the transaction.\n     * @type {Map<Number,Number>?}\n     */\n    this._afterState = null\n    /**\n     * All types that were directly modified (property added or child\n     * inserted/deleted). New types are not included in this Set.\n     * Maps from type to parentSubs (`item.parentSub = null` for YArray)\n     * @type {Map<import('../utils/types.js').YType,Set<String|null>>}\n     */\n    this.changed = new Map()\n    /**\n     * Stores the events for the types that observe also child elements.\n     * It is mainly used by `observeDeep`.\n     * @type {Map<import('../utils/types.js').YType,Array<YEvent<any>>>}\n     */\n    this.changedParentTypes = new Map()\n    /**\n     * @type {Array<AbstractStruct>}\n     */\n    this._mergeStructs = []\n    /**\n     * @type {any}\n     */\n    this.origin = origin\n    /**\n     * Stores meta information on the transaction\n     * @type {Map<any,any>}\n     */\n    this.meta = new Map()\n    /**\n     * Whether this change originates from this doc.\n     * @type {boolean}\n     */\n    this.local = local\n    /**\n     * @type {Set<Doc>}\n     */\n    this.subdocsAdded = new Set()\n    /**\n     * @type {Set<Doc>}\n     */\n    this.subdocsRemoved = new Set()\n    /**\n     * @type {Set<Doc>}\n     */\n    this.subdocsLoaded = new Set()\n    /**\n     * @type {boolean}\n     */\n    this._needFormattingCleanup = false\n    this._done = false\n  }\n\n  /**\n   * Holds the state before the transaction started.\n   *\n   * @deprecated\n   * @type {Map<Number,Number>}\n   */\n  get beforeState () {\n    if (this._beforeState == null) {\n      const sv = getStateVector(this.doc.store)\n      this.insertSet.clients.forEach((ranges, client) => {\n        sv.set(client, ranges.getIds()[0].clock)\n      })\n      this._beforeState = sv\n    }\n    return this._beforeState\n  }\n\n  /**\n   * Holds the state after the transaction.\n   *\n   * @deprecated\n   * @type {Map<Number,Number>}\n   */\n  get afterState () {\n    if (!this._done) error.unexpectedCase()\n    if (this._afterState == null) {\n      const sv = getStateVector(this.doc.store)\n      this.insertSet.clients.forEach((_ranges, client) => {\n        const ranges = _ranges.getIds()\n        const d = ranges[ranges.length - 1]\n        sv.set(client, d.clock + d.len)\n      })\n      this._afterState = sv\n    }\n    return this._afterState\n  }\n}\n\n/**\n * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n * @param {Transaction} transaction\n * @return {boolean} Whether data was written.\n */\nexport const writeUpdateMessageFromTransaction = (encoder, transaction) => {\n  if (transaction.deleteSet.clients.size === 0 && transaction.insertSet.clients.size === 0) {\n    return false\n  }\n  writeStructsFromTransaction(encoder, transaction)\n  writeIdSet(encoder, transaction.deleteSet)\n  return true\n}\n\n/**\n * @param {Transaction} transaction\n *\n * @private\n * @function\n */\nexport const nextID = transaction => {\n  const y = transaction.doc\n  return createID(y.clientID, getState(y.store, y.clientID))\n}\n\n/**\n * If `type.parent` was added in current transaction, `type` technically\n * did not change, it was just added and we should not fire events for `type`.\n *\n * @param {Transaction} transaction\n * @param {import('../utils/types.js').YType} type\n * @param {string|null} parentSub\n */\nexport const addChangedTypeToTransaction = (transaction, type, parentSub) => {\n  const item = type._item\n  if (item === null || (!item.deleted && !transaction.insertSet.hasId(item.id))) {\n    map.setIfUndefined(transaction.changed, type, set.create).add(parentSub)\n  }\n}\n\n/**\n * @param {Array<AbstractStruct>} structs\n * @param {number} pos\n * @return {number} # of merged structs\n */\nconst tryToMergeWithLefts = (structs, pos) => {\n  let right = structs[pos]\n  let left = structs[pos - 1]\n  let i = pos\n  for (; i > 0; right = left, left = structs[--i - 1]) {\n    if (left.deleted === right.deleted && left.constructor === right.constructor) {\n      if (left.mergeWith(right)) {\n        if (right instanceof Item && right.parentSub !== null && /** @type {AbstractType<any>} */ (right.parent)._map.get(right.parentSub) === right) {\n          /** @type {AbstractType<any>} */ (right.parent)._map.set(right.parentSub, /** @type {Item} */ (left))\n        }\n        continue\n      }\n    }\n    break\n  }\n  const merged = pos - i\n  if (merged) {\n    // remove all merged structs from the array\n    structs.splice(pos + 1 - merged, merged)\n  }\n  return merged\n}\n\n/**\n * @param {Transaction} tr\n * @param {IdSet} ds\n * @param {function(Item):boolean} gcFilter\n */\nconst tryGcDeleteSet = (tr, ds, gcFilter) => {\n  for (const [client, _deleteItems] of ds.clients.entries()) {\n    const deleteItems = _deleteItems.getIds()\n    const structs = /** @type {Array<GC|Item>} */ (tr.doc.store.clients.get(client))\n    for (let di = deleteItems.length - 1; di >= 0; di--) {\n      const deleteItem = deleteItems[di]\n      const endDeleteItemClock = deleteItem.clock + deleteItem.len\n      for (\n        let si = findIndexSS(structs, deleteItem.clock), struct = structs[si];\n        si < structs.length && struct.id.clock < endDeleteItemClock;\n        struct = structs[++si]\n      ) {\n        const struct = structs[si]\n        if (deleteItem.clock + deleteItem.len <= struct.id.clock) {\n          break\n        }\n        if (struct instanceof Item && struct.deleted && !struct.keep && gcFilter(struct)) {\n          struct.gc(tr, false)\n        }\n      }\n    }\n  }\n}\n\n/**\n * @param {IdSet} ds\n * @param {StructStore} store\n */\nconst tryMerge = (ds, store) => {\n  // try to merge deleted / gc'd items\n  // merge from right to left for better efficiency and so we don't miss any merge targets\n  ds.clients.forEach((_deleteItems, client) => {\n    const deleteItems = _deleteItems.getIds()\n    const structs = /** @type {Array<GC|Item>} */ (store.clients.get(client))\n    for (let di = deleteItems.length - 1; di >= 0; di--) {\n      const deleteItem = deleteItems[di]\n      // start with merging the item next to the last deleted item\n      const mostRightIndexToCheck = math.min(structs.length - 1, 1 + findIndexSS(structs, deleteItem.clock + deleteItem.len - 1))\n      for (\n        let si = mostRightIndexToCheck, struct = structs[si];\n        si > 0 && struct.id.clock >= deleteItem.clock;\n        struct = structs[si]\n      ) {\n        si -= 1 + tryToMergeWithLefts(structs, si)\n      }\n    }\n  })\n}\n\n/**\n * @param {Transaction} tr\n * @param {IdSet} idset\n * @param {function(Item):boolean} gcFilter\n */\nexport const tryGc = (tr, idset, gcFilter) => {\n  tryGcDeleteSet(tr, idset, gcFilter)\n  tryMerge(idset, tr.doc.store)\n}\n\n/**\n * @param {Array<Transaction>} transactionCleanups\n * @param {number} i\n */\nconst cleanupTransactions = (transactionCleanups, i) => {\n  if (i < transactionCleanups.length) {\n    const transaction = transactionCleanups[i]\n    transaction._done = true\n    const doc = transaction.doc\n    const store = doc.store\n    const ds = transaction.deleteSet\n    const mergeStructs = transaction._mergeStructs\n    // insertIntoIdSet(store.ds, ds)\n    try {\n      doc.emit('beforeObserverCalls', [transaction, doc])\n      /**\n       * An array of event callbacks.\n       *\n       * Each callback is called even if the other ones throw errors.\n       *\n       * @type {Array<function():void>}\n       */\n      const fs = []\n      // observe events on changed types\n      transaction.changed.forEach((subs, itemtype) =>\n        fs.push(() => {\n          if (itemtype._item === null || !itemtype._item.deleted) {\n            itemtype._callObserver(transaction, subs)\n          }\n        })\n      )\n      fs.push(() => {\n        // deep observe events\n        transaction.changedParentTypes.forEach((events, type) => {\n          // We need to think about the possibility that the user transforms the\n          // Y.Doc in the event.\n          if (type._dEH.l.length > 0 && (type._item === null || !type._item.deleted)) {\n            events = events\n              .filter(event =>\n                event.target._item === null || !event.target._item.deleted\n              )\n            events\n              .forEach(event => {\n                event.currentTarget = type\n                // path is relative to the current target\n                event._path = null\n              })\n            // sort events by path length so that top-level events are fired first.\n            events\n              .sort((event1, event2) => event1.path.length - event2.path.length)\n            // We don't need to check for events.length\n            // because we know it has at least one element\n            callEventHandlerListeners(type._dEH, events, transaction)\n          }\n        })\n      })\n      fs.push(() => doc.emit('afterTransaction', [transaction, doc]))\n      callAll(fs, [])\n      if (transaction._needFormattingCleanup && doc.cleanupFormatting) {\n        cleanupYTextAfterTransaction(transaction)\n      }\n    } finally {\n      // Replace deleted items with ItemDeleted / GC.\n      // This is where content is actually remove from the Yjs Doc.\n      if (doc.gc) {\n        tryGcDeleteSet(transaction, ds, doc.gcFilter)\n      }\n      tryMerge(ds, store)\n\n      // on all affected store.clients props, try to merge\n      transaction.insertSet.clients.forEach((ids, client) => {\n        const firstClock = ids.getIds()[0].clock\n        const structs = /** @type {Array<GC|Item>} */ (store.clients.get(client))\n        // we iterate from right to left so we can safely remove entries\n        const firstChangePos = math.max(findIndexSS(structs, firstClock), 1)\n        for (let i = structs.length - 1; i >= firstChangePos;) {\n          i -= 1 + tryToMergeWithLefts(structs, i)\n        }\n      })\n      // try to merge mergeStructs\n      // @todo: it makes more sense to transform mergeStructs to a DS, sort it, and merge from right to left\n      //        but at the moment DS does not handle duplicates\n      for (let i = mergeStructs.length - 1; i >= 0; i--) {\n        const { client, clock } = mergeStructs[i].id\n        const structs = /** @type {Array<GC|Item>} */ (store.clients.get(client))\n        const replacedStructPos = findIndexSS(structs, clock)\n        if (replacedStructPos + 1 < structs.length) {\n          if (tryToMergeWithLefts(structs, replacedStructPos + 1) > 1) {\n            continue // no need to perform next check, both are already merged\n          }\n        }\n        if (replacedStructPos > 0) {\n          tryToMergeWithLefts(structs, replacedStructPos)\n        }\n      }\n      if (!transaction.local && transaction.insertSet.clients.has(doc.clientID)) {\n        logging.print(logging.ORANGE, logging.BOLD, '[yjs] ', logging.UNBOLD, logging.RED, 'Changed the client-id because another client seems to be using it.')\n        doc.clientID = generateNewClientId()\n      }\n      // @todo Merge all the transactions into one and provide send the data as a single update message\n      doc.emit('afterTransactionCleanup', [transaction, doc])\n      if (doc._observers.has('update')) {\n        const encoder = new UpdateEncoderV1()\n        const hasContent = writeUpdateMessageFromTransaction(encoder, transaction)\n        if (hasContent) {\n          doc.emit('update', [encoder.toUint8Array(), transaction.origin, doc, transaction])\n        }\n      }\n      if (doc._observers.has('updateV2')) {\n        const encoder = new UpdateEncoderV2()\n        const hasContent = writeUpdateMessageFromTransaction(encoder, transaction)\n        if (hasContent) {\n          doc.emit('updateV2', [encoder.toUint8Array(), transaction.origin, doc, transaction])\n        }\n      }\n      const { subdocsAdded, subdocsLoaded, subdocsRemoved } = transaction\n      if (subdocsAdded.size > 0 || subdocsRemoved.size > 0 || subdocsLoaded.size > 0) {\n        subdocsAdded.forEach(subdoc => {\n          subdoc.clientID = doc.clientID\n          if (subdoc.collectionid == null) {\n            subdoc.collectionid = doc.collectionid\n          }\n          doc.subdocs.add(subdoc)\n        })\n        subdocsRemoved.forEach(subdoc => doc.subdocs.delete(subdoc))\n        doc.emit('subdocs', [{ loaded: subdocsLoaded, added: subdocsAdded, removed: subdocsRemoved }, doc, transaction])\n        subdocsRemoved.forEach(subdoc => subdoc.destroy())\n      }\n\n      if (transactionCleanups.length <= i + 1) {\n        doc._transactionCleanups = []\n        doc.emit('afterAllTransactions', [doc, transactionCleanups])\n      } else {\n        cleanupTransactions(transactionCleanups, i + 1)\n      }\n    }\n  }\n}\n\n/**\n * Implements the functionality of `y.transact(()=>{..})`\n *\n * @template T\n * @param {Doc} doc\n * @param {function(Transaction):T} f\n * @param {any} [origin=true]\n * @return {T}\n *\n * @function\n */\nexport const transact = (doc, f, origin = null, local = true) => {\n  const transactionCleanups = doc._transactionCleanups\n  let initialCall = false\n  /**\n   * @type {any}\n   */\n  let result = null\n  if (doc._transaction === null) {\n    initialCall = true\n    doc._transaction = new Transaction(doc, origin, local)\n    transactionCleanups.push(doc._transaction)\n    if (transactionCleanups.length === 1) {\n      doc.emit('beforeAllTransactions', [doc])\n    }\n    doc.emit('beforeTransaction', [doc._transaction, doc])\n  }\n  try {\n    result = f(doc._transaction)\n  } finally {\n    if (initialCall) {\n      const finishCleanup = doc._transaction === transactionCleanups[0]\n      doc._transaction = null\n      if (finishCleanup) {\n        // The first transaction ended, now process observer calls.\n        // Observer call may create new transactions for which we need to call the observers and do cleanup.\n        // We don't want to nest these calls, so we execute these calls one after\n        // another.\n        // Also we need to ensure that all cleanups are called, even if the\n        // observes throw errors.\n        // This file is full of hacky try {} finally {} blocks to ensure that an\n        // event can throw errors and also that the cleanup is called.\n        cleanupTransactions(transactionCleanups, 0)\n      }\n    }\n  }\n  return result\n}\n","import {\n  mergeIdSets,\n  iterateStructsByIdSet,\n  keepItem,\n  transact,\n  createID,\n  redoItem,\n  isParentOf,\n  followRedone,\n  getItemCleanStart,\n  YEvent, Transaction, Doc, Item, GC, IdSet, AbstractType // eslint-disable-line\n} from '../internals.js'\n\nimport * as time from 'lib0/time'\nimport * as array from 'lib0/array'\nimport * as logging from 'lib0/logging'\nimport { ObservableV2 } from 'lib0/observable'\n\nexport class StackItem {\n  /**\n   * @param {IdSet} deletions\n   * @param {IdSet} insertions\n   */\n  constructor (deletions, insertions) {\n    this.insertions = insertions\n    this.deletions = deletions\n    /**\n     * Use this to save and restore metadata like selection range\n     */\n    this.meta = new Map()\n  }\n}\n/**\n * @param {Transaction} tr\n * @param {UndoManager} um\n * @param {StackItem} stackItem\n */\nconst clearUndoManagerStackItem = (tr, um, stackItem) => {\n  iterateStructsByIdSet(tr, stackItem.deletions, item => {\n    if (item instanceof Item && um.scope.some(type => type === tr.doc || isParentOf(/** @type {import('../utils/types.js').YType} */ (type), item))) {\n      keepItem(item, false)\n    }\n  })\n}\n\n/**\n * @param {UndoManager} undoManager\n * @param {Array<StackItem>} stack\n * @param {'undo'|'redo'} eventType\n * @return {StackItem?}\n */\nconst popStackItem = (undoManager, stack, eventType) => {\n  /**\n   * Keep a reference to the transaction so we can fire the event with the changedParentTypes\n   * @type {any}\n   */\n  let _tr = null\n  const doc = undoManager.doc\n  const scope = undoManager.scope\n  transact(doc, transaction => {\n    while (stack.length > 0 && undoManager.currStackItem === null) {\n      const store = doc.store\n      const stackItem = /** @type {StackItem} */ (stack.pop())\n      /**\n       * @type {Set<Item>}\n       */\n      const itemsToRedo = new Set()\n      /**\n       * @type {Array<Item>}\n       */\n      const itemsToDelete = []\n      let performedChange = false\n      iterateStructsByIdSet(transaction, stackItem.insertions, struct => {\n        if (struct instanceof Item) {\n          if (struct.redone !== null) {\n            let { item, diff } = followRedone(store, struct.id)\n            if (diff > 0) {\n              item = getItemCleanStart(transaction, createID(item.id.client, item.id.clock + diff))\n            }\n            struct = item\n          }\n          if (!struct.deleted && scope.some(type => type === transaction.doc || isParentOf(/** @type {import('../utils/types.js').YType} */ (type), /** @type {Item} */ (struct)))) {\n            itemsToDelete.push(struct)\n          }\n        }\n      })\n      iterateStructsByIdSet(transaction, stackItem.deletions, struct => {\n        if (\n          struct instanceof Item &&\n          scope.some(type => type === transaction.doc || isParentOf(/** @type {import('../utils/types.js').YType} */ (type), struct)) &&\n          // Never redo structs in stackItem.insertions because they were created and deleted in the same capture interval.\n          !stackItem.insertions.hasId(struct.id)\n        ) {\n          itemsToRedo.add(struct)\n        }\n      })\n      itemsToRedo.forEach(struct => {\n        performedChange = redoItem(transaction, struct, itemsToRedo, stackItem.insertions, undoManager.ignoreRemoteMapChanges, undoManager) !== null || performedChange\n      })\n      // We want to delete in reverse order so that children are deleted before\n      // parents, so we have more information available when items are filtered.\n      for (let i = itemsToDelete.length - 1; i >= 0; i--) {\n        const item = itemsToDelete[i]\n        if (undoManager.deleteFilter(item)) {\n          item.delete(transaction)\n          performedChange = true\n        }\n      }\n      undoManager.currStackItem = performedChange ? stackItem : null\n    }\n    transaction.changed.forEach((subProps, type) => {\n      // destroy search marker if necessary\n      if (subProps.has(null) && type._searchMarker) {\n        type._searchMarker.length = 0\n      }\n    })\n    _tr = transaction\n  }, undoManager)\n  const res = undoManager.currStackItem\n  if (res != null) {\n    const changedParentTypes = _tr.changedParentTypes\n    undoManager.emit('stack-item-popped', [{ stackItem: res, type: eventType, changedParentTypes, origin: undoManager }, undoManager])\n    undoManager.currStackItem = null\n  }\n  return res\n}\n\n/**\n * @typedef {Object} UndoManagerOptions\n * @property {number} [UndoManagerOptions.captureTimeout=500]\n * @property {function(Transaction):boolean} [UndoManagerOptions.captureTransaction] Do not capture changes of a Transaction if result false.\n * @property {function(Item):boolean} [UndoManagerOptions.deleteFilter=()=>true] Sometimes\n * it is necessary to filter what an Undo/Redo operation can delete. If this\n * filter returns false, the type/item won't be deleted even it is in the\n * undo/redo scope.\n * @property {Set<any>} [UndoManagerOptions.trackedOrigins=new Set([null])]\n * @property {boolean} [ignoreRemoteMapChanges] Experimental. By default, the UndoManager will never overwrite remote changes. Enable this property to enable overwriting remote changes on key-value changes (Y.Map, properties on Y.Xml, etc..).\n * @property {Doc} [doc] The document that this UndoManager operates on. Only needed if typeScope is empty.\n */\n\n/**\n * @typedef {Object} StackItemEvent\n * @property {StackItem} StackItemEvent.stackItem\n * @property {any} StackItemEvent.origin\n * @property {'undo'|'redo'} StackItemEvent.type\n * @property {Map<import('../utils/types.js').YType,Array<YEvent<any>>>} StackItemEvent.changedParentTypes\n */\n\n/**\n * Fires 'stack-item-added' event when a stack item was added to either the undo- or\n * the redo-stack. You may store additional stack information via the\n * metadata property on `event.stackItem.meta` (it is a `Map` of metadata properties).\n * Fires 'stack-item-popped' event when a stack item was popped from either the\n * undo- or the redo-stack. You may restore the saved stack information from `event.stackItem.meta`.\n *\n * @extends {ObservableV2<{'stack-item-added':function(StackItemEvent, UndoManager):void, 'stack-item-popped': function(StackItemEvent, UndoManager):void, 'stack-cleared': function({ undoStackCleared: boolean, redoStackCleared: boolean }):void, 'stack-item-updated': function(StackItemEvent, UndoManager):void }>}\n */\nexport class UndoManager extends ObservableV2 {\n  /**\n   * @param {Doc|import('../utils/types.js').YType|Array<import('../utils/types.js').YType>} typeScope Limits the scope of the UndoManager. If this is set to a ydoc instance, all changes on that ydoc will be undone. If set to a specific type, only changes on that type or its children will be undone. Also accepts an array of types.\n   * @param {UndoManagerOptions} options\n   */\n  constructor (typeScope, {\n    captureTimeout = 500,\n    captureTransaction = _tr => true,\n    deleteFilter = () => true,\n    trackedOrigins = new Set([null]),\n    ignoreRemoteMapChanges = false,\n    doc = /** @type {Doc} */ (array.isArray(typeScope) ? typeScope[0].doc : typeScope instanceof Doc ? typeScope : typeScope.doc)\n  } = {}) {\n    super()\n    /**\n     * @type {Array<import('../utils/types.js').YType | Doc>}\n     */\n    this.scope = []\n    this.doc = doc\n    this.addToScope(typeScope)\n    this.deleteFilter = deleteFilter\n    trackedOrigins.add(this)\n    this.trackedOrigins = trackedOrigins\n    this.captureTransaction = captureTransaction\n    /**\n     * @type {Array<StackItem>}\n     */\n    this.undoStack = []\n    /**\n     * @type {Array<StackItem>}\n     */\n    this.redoStack = []\n    /**\n     * Whether the client is currently undoing (calling UndoManager.undo)\n     *\n     * @type {boolean}\n     */\n    this.undoing = false\n    this.redoing = false\n    /**\n     * The currently popped stack item if UndoManager.undoing or UndoManager.redoing\n     *\n     * @type {StackItem|null}\n     */\n    this.currStackItem = null\n    this.lastChange = 0\n    this.ignoreRemoteMapChanges = ignoreRemoteMapChanges\n    this.captureTimeout = captureTimeout\n    /**\n     * @param {Transaction} transaction\n     */\n    this.afterTransactionHandler = transaction => {\n      // Only track certain transactions\n      if (\n        !this.captureTransaction(transaction) ||\n        !this.scope.some(type => transaction.changedParentTypes.has(/** @type {import('../utils/types.js').YType} */ (type)) || type === this.doc) ||\n        (!this.trackedOrigins.has(transaction.origin) && (!transaction.origin || !this.trackedOrigins.has(transaction.origin.constructor)))\n      ) {\n        return\n      }\n      const undoing = this.undoing\n      const redoing = this.redoing\n      const stack = undoing ? this.redoStack : this.undoStack\n      if (undoing) {\n        this.stopCapturing() // next undo should not be appended to last stack item\n      } else if (!redoing) {\n        // neither undoing nor redoing: delete redoStack\n        this.clear(false, true)\n      }\n      const insertions = transaction.insertSet\n      const now = time.getUnixTime()\n      let didAdd = false\n      if (this.lastChange > 0 && now - this.lastChange < this.captureTimeout && stack.length > 0 && !undoing && !redoing) {\n        // append change to last stack op\n        const lastOp = stack[stack.length - 1]\n        lastOp.deletions = mergeIdSets([lastOp.deletions, transaction.deleteSet])\n        lastOp.insertions = mergeIdSets([lastOp.insertions, insertions])\n      } else {\n        // create a new stack op\n        stack.push(new StackItem(transaction.deleteSet, insertions))\n        didAdd = true\n      }\n      if (!undoing && !redoing) {\n        this.lastChange = now\n      }\n      // make sure that deleted structs are not gc'd\n      iterateStructsByIdSet(transaction, transaction.deleteSet, /** @param {Item|GC} item */ item => {\n        if (item instanceof Item && this.scope.some(type => type === transaction.doc || isParentOf(/** @type {import('../utils/types.js').YType} */ (type), item))) {\n          keepItem(item, true)\n        }\n      })\n      /**\n       * @type {[StackItemEvent, UndoManager]}\n       */\n      const changeEvent = [{ stackItem: stack[stack.length - 1], origin: transaction.origin, type: undoing ? 'redo' : 'undo', changedParentTypes: transaction.changedParentTypes }, this]\n      if (didAdd) {\n        this.emit('stack-item-added', changeEvent)\n      } else {\n        this.emit('stack-item-updated', changeEvent)\n      }\n    }\n    this.doc.on('afterTransaction', this.afterTransactionHandler)\n    this.doc.on('destroy', () => {\n      this.destroy()\n    })\n  }\n\n  /**\n   * Extend the scope.\n   *\n   * @param {Array<import('../utils/types.js').YType | Doc> | import('../utils/types.js').YType | Doc} ytypes\n   */\n  addToScope (ytypes) {\n    const tmpSet = new Set(this.scope)\n    ytypes = array.isArray(ytypes) ? ytypes : [ytypes]\n    ytypes.forEach(ytype => {\n      if (!tmpSet.has(ytype)) {\n        tmpSet.add(ytype)\n        if (ytype instanceof AbstractType ? ytype.doc !== this.doc : ytype !== this.doc) logging.warn('[yjs#509] Not same Y.Doc') // use MultiDocUndoManager instead. also see https://github.com/yjs/yjs/issues/509\n        this.scope.push(ytype)\n      }\n    })\n  }\n\n  /**\n   * @param {any} origin\n   */\n  addTrackedOrigin (origin) {\n    this.trackedOrigins.add(origin)\n  }\n\n  /**\n   * @param {any} origin\n   */\n  removeTrackedOrigin (origin) {\n    this.trackedOrigins.delete(origin)\n  }\n\n  clear (clearUndoStack = true, clearRedoStack = true) {\n    if ((clearUndoStack && this.canUndo()) || (clearRedoStack && this.canRedo())) {\n      this.doc.transact(tr => {\n        if (clearUndoStack) {\n          this.undoStack.forEach(item => clearUndoManagerStackItem(tr, this, item))\n          this.undoStack = []\n        }\n        if (clearRedoStack) {\n          this.redoStack.forEach(item => clearUndoManagerStackItem(tr, this, item))\n          this.redoStack = []\n        }\n        this.emit('stack-cleared', [{ undoStackCleared: clearUndoStack, redoStackCleared: clearRedoStack }])\n      })\n    }\n  }\n\n  /**\n   * UndoManager merges Undo-StackItem if they are created within time-gap\n   * smaller than `options.captureTimeout`. Call `um.stopCapturing()` so that the next\n   * StackItem won't be merged.\n   *\n   *\n   * @example\n   *     // without stopCapturing\n   *     ytext.insert(0, 'a')\n   *     ytext.insert(1, 'b')\n   *     um.undo()\n   *     ytext.toString() // => '' (note that 'ab' was removed)\n   *     // with stopCapturing\n   *     ytext.insert(0, 'a')\n   *     um.stopCapturing()\n   *     ytext.insert(0, 'b')\n   *     um.undo()\n   *     ytext.toString() // => 'a' (note that only 'b' was removed)\n   *\n   */\n  stopCapturing () {\n    this.lastChange = 0\n  }\n\n  /**\n   * Undo last changes on type.\n   *\n   * @return {StackItem?} Returns StackItem if a change was applied\n   */\n  undo () {\n    this.undoing = true\n    let res\n    try {\n      res = popStackItem(this, this.undoStack, 'undo')\n    } finally {\n      this.undoing = false\n    }\n    return res\n  }\n\n  /**\n   * Redo last undo operation.\n   *\n   * @return {StackItem?} Returns StackItem if a change was applied\n   */\n  redo () {\n    this.redoing = true\n    let res\n    try {\n      res = popStackItem(this, this.redoStack, 'redo')\n    } finally {\n      this.redoing = false\n    }\n    return res\n  }\n\n  /**\n   * Are undo steps available?\n   *\n   * @return {boolean} `true` if undo is possible\n   */\n  canUndo () {\n    return this.undoStack.length > 0\n  }\n\n  /**\n   * Are redo steps available?\n   *\n   * @return {boolean} `true` if redo is possible\n   */\n  canRedo () {\n    return this.redoStack.length > 0\n  }\n\n  destroy () {\n    this.trackedOrigins.delete(this)\n    this.doc.off('afterTransaction', this.afterTransactionHandler)\n    super.destroy()\n  }\n}\n","import * as binary from 'lib0/binary'\nimport * as decoding from 'lib0/decoding'\nimport * as encoding from 'lib0/encoding'\nimport * as error from 'lib0/error'\nimport * as f from 'lib0/function'\nimport * as logging from 'lib0/logging'\nimport * as map from 'lib0/map'\nimport * as math from 'lib0/math'\nimport * as string from 'lib0/string'\n\nimport {\n  ContentAny,\n  ContentBinary,\n  ContentDeleted,\n  ContentDoc,\n  ContentEmbed,\n  ContentFormat,\n  ContentJSON,\n  ContentString,\n  ContentType,\n  createID,\n  decodeStateVector,\n  IdSetEncoderV1,\n  IdSetEncoderV2,\n  GC,\n  Item,\n  mergeIdSets,\n  readIdSet,\n  readItemContent,\n  Skip,\n  UpdateDecoderV1,\n  UpdateDecoderV2,\n  UpdateEncoderV1,\n  UpdateEncoderV2,\n  writeIdSet,\n  YXmlElement,\n  YXmlHook,\n  createIdSet\n} from '../internals.js'\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n */\nfunction * lazyStructReaderGenerator (decoder) {\n  const numOfStateUpdates = decoding.readVarUint(decoder.restDecoder)\n  for (let i = 0; i < numOfStateUpdates; i++) {\n    const numberOfStructs = decoding.readVarUint(decoder.restDecoder)\n    const client = decoder.readClient()\n    let clock = decoding.readVarUint(decoder.restDecoder)\n    for (let i = 0; i < numberOfStructs; i++) {\n      const info = decoder.readInfo()\n      // @todo use switch instead of ifs\n      if (info === 10) {\n        const len = decoding.readVarUint(decoder.restDecoder)\n        yield new Skip(createID(client, clock), len)\n        clock += len\n      } else if ((binary.BITS5 & info) !== 0) {\n        const cantCopyParentInfo = (info & (binary.BIT7 | binary.BIT8)) === 0\n        // If parent = null and neither left nor right are defined, then we know that `parent` is child of `y`\n        // and we read the next string as parentYKey.\n        // It indicates how we store/retrieve parent from `y.share`\n        // @type {string|null}\n        const struct = new Item(\n          createID(client, clock),\n          null, // left\n          (info & binary.BIT8) === binary.BIT8 ? decoder.readLeftID() : null, // origin\n          null, // right\n          (info & binary.BIT7) === binary.BIT7 ? decoder.readRightID() : null, // right origin\n          // @ts-ignore Force writing a string here.\n          cantCopyParentInfo ? (decoder.readParentInfo() ? decoder.readString() : decoder.readLeftID()) : null, // parent\n          cantCopyParentInfo && (info & binary.BIT6) === binary.BIT6 ? decoder.readString() : null, // parentSub\n          readItemContent(decoder, info) // item content\n        )\n        yield struct\n        clock += struct.length\n      } else {\n        const len = decoder.readLen()\n        yield new GC(createID(client, clock), len)\n        clock += len\n      }\n    }\n  }\n}\n\nexport class LazyStructReader {\n  /**\n   * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n   * @param {boolean} filterSkips\n   */\n  constructor (decoder, filterSkips) {\n    this.gen = lazyStructReaderGenerator(decoder)\n    /**\n     * @type {null | Item | Skip | GC}\n     */\n    this.curr = null\n    this.done = false\n    this.filterSkips = filterSkips\n    this.next()\n  }\n\n  /**\n   * @return {Item | GC | Skip |null}\n   */\n  next () {\n    // ignore \"Skip\" structs\n    do {\n      this.curr = this.gen.next().value || null\n    } while (this.filterSkips && this.curr !== null && this.curr.constructor === Skip)\n    return this.curr\n  }\n}\n\n/**\n * @param {Uint8Array} update\n *\n */\nexport const logUpdate = update => logUpdateV2(update, UpdateDecoderV1)\n\n/**\n * @param {Uint8Array} update\n * @param {typeof UpdateDecoderV2 | typeof UpdateDecoderV1} [YDecoder]\n */\nexport const logUpdateV2 = (update, YDecoder = UpdateDecoderV2) => {\n  const structs = []\n  const updateDecoder = new YDecoder(decoding.createDecoder(update))\n  const lazyDecoder = new LazyStructReader(updateDecoder, false)\n  for (let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()) {\n    structs.push(curr)\n  }\n  logging.print('Structs: ', structs)\n  const ds = readIdSet(updateDecoder)\n  logging.print('DeleteSet: ', ds)\n}\n\n/**\n * @param {Uint8Array} update\n *\n */\nexport const decodeUpdate = (update) => decodeUpdateV2(update, UpdateDecoderV1)\n\n/**\n * @param {Uint8Array} update\n * @param {typeof UpdateDecoderV2 | typeof UpdateDecoderV1} [YDecoder]\n *\n */\nexport const decodeUpdateV2 = (update, YDecoder = UpdateDecoderV2) => {\n  const structs = []\n  const updateDecoder = new YDecoder(decoding.createDecoder(update))\n  const lazyDecoder = new LazyStructReader(updateDecoder, false)\n  for (let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()) {\n    structs.push(curr)\n  }\n  return {\n    structs,\n    ds: readIdSet(updateDecoder)\n  }\n}\n\nexport class LazyStructWriter {\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */\n  constructor (encoder) {\n    this.currClient = 0\n    this.startClock = 0\n    this.written = 0\n    this.encoder = encoder\n    /**\n     * We want to write operations lazily, but also we need to know beforehand how many operations we want to write for each client.\n     *\n     * This kind of meta-information (#clients, #structs-per-client-written) is written to the restEncoder.\n     *\n     * We fragment the restEncoder and store a slice of it per-client until we know how many clients there are.\n     * When we flush (toUint8Array) we write the restEncoder using the fragments and the meta-information.\n     *\n     * @type {Array<{ written: number, restEncoder: Uint8Array }>}\n     */\n    this.clientStructs = []\n  }\n}\n\n/**\n * @param {Array<Uint8Array<ArrayBuffer>>} updates\n * @return {Uint8Array<ArrayBuffer>}\n */\nexport const mergeUpdates = updates => mergeUpdatesV2(updates, UpdateDecoderV1, UpdateEncoderV1)\n\n/**\n * @param {Uint8Array} update\n * @param {typeof IdSetEncoderV1 | typeof IdSetEncoderV2} YEncoder\n * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} YDecoder\n * @return {Uint8Array}\n */\nexport const encodeStateVectorFromUpdateV2 = (update, YEncoder = IdSetEncoderV2, YDecoder = UpdateDecoderV2) => {\n  const encoder = new YEncoder()\n  const updateDecoder = new LazyStructReader(new YDecoder(decoding.createDecoder(update)), false)\n  let curr = updateDecoder.curr\n  if (curr !== null) {\n    let size = 0\n    let currClient = curr.id.client\n    let stopCounting = curr.id.clock !== 0 // must start at 0\n    let currClock = stopCounting ? 0 : curr.id.clock + curr.length\n    for (; curr !== null; curr = updateDecoder.next()) {\n      if (currClient !== curr.id.client) {\n        if (currClock !== 0) {\n          size++\n          // We found a new client\n          // write what we have to the encoder\n          encoding.writeVarUint(encoder.restEncoder, currClient)\n          encoding.writeVarUint(encoder.restEncoder, currClock)\n        }\n        currClient = curr.id.client\n        currClock = 0\n        stopCounting = curr.id.clock !== 0\n      }\n      // we ignore skips\n      if (curr.constructor === Skip) {\n        stopCounting = true\n      }\n      if (!stopCounting) {\n        currClock = curr.id.clock + curr.length\n      }\n    }\n    // write what we have\n    if (currClock !== 0) {\n      size++\n      encoding.writeVarUint(encoder.restEncoder, currClient)\n      encoding.writeVarUint(encoder.restEncoder, currClock)\n    }\n    // prepend the size of the state vector\n    const enc = encoding.createEncoder()\n    encoding.writeVarUint(enc, size)\n    encoding.writeBinaryEncoder(enc, encoder.restEncoder)\n    encoder.restEncoder = enc\n    return encoder.toUint8Array()\n  } else {\n    encoding.writeVarUint(encoder.restEncoder, 0)\n    return encoder.toUint8Array()\n  }\n}\n\n/**\n * @param {Uint8Array} update\n * @return {Uint8Array}\n */\nexport const encodeStateVectorFromUpdate = update => encodeStateVectorFromUpdateV2(update, IdSetEncoderV1, UpdateDecoderV1)\n\n/**\n * @param {Uint8Array} update\n * @param {typeof UpdateDecoderV2 | typeof UpdateDecoderV1} [YDecoder]\n */\nexport const readUpdateIdRangesV2 = (update, YDecoder = UpdateDecoderV2) => {\n  const updateDecoder = new YDecoder(decoding.createDecoder(update))\n  const lazyDecoder = new LazyStructReader(updateDecoder, true)\n  const inserts = createIdSet()\n  let lastClientId = -1\n  let lastClock = 0\n  let lastLen = 0\n  for (let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()) {\n    const currId = curr.id\n    if (lastClientId === currId.client && lastClock + lastLen === currId.clock) {\n      // default case: extend prev entry\n      lastLen += curr.length\n    } else {\n      if (lastClientId >= 0) {\n        inserts.add(lastClientId, lastClock, lastLen)\n      }\n      lastClientId = currId.client\n      lastClock = currId.clock\n      lastLen = curr.length\n    }\n  }\n  if (lastClientId >= 0) {\n    inserts.add(lastClientId, lastClock, lastLen)\n  }\n  const deletes = readIdSet(updateDecoder)\n  return { inserts, deletes }\n}\n\n/**\n * @param {Uint8Array} update\n */\nexport const readUpdateIdRanges = update => readUpdateIdRangesV2(update, UpdateDecoderV1)\n\n/**\n * This method is intended to slice any kind of struct and retrieve the right part.\n * It does not handle side-effects, so it should only be used by the lazy-encoder.\n *\n * @param {Item | GC | Skip} left\n * @param {number} diff\n * @return {Item | GC}\n */\nconst sliceStruct = (left, diff) => {\n  if (left.constructor === GC) {\n    const { client, clock } = left.id\n    return new GC(createID(client, clock + diff), left.length - diff)\n  } else if (left.constructor === Skip) {\n    const { client, clock } = left.id\n    return new Skip(createID(client, clock + diff), left.length - diff)\n  } else {\n    const leftItem = /** @type {Item} */ (left)\n    const { client, clock } = leftItem.id\n    return new Item(\n      createID(client, clock + diff),\n      null,\n      createID(client, clock + diff - 1),\n      null,\n      leftItem.rightOrigin,\n      leftItem.parent,\n      leftItem.parentSub,\n      leftItem.content.splice(diff)\n    )\n  }\n}\n\n/**\n *\n * This function works similarly to `readUpdateV2`.\n *\n * @param {Array<Uint8Array<ArrayBuffer>>} updates\n * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} [YDecoder]\n * @param {typeof UpdateEncoderV1 | typeof UpdateEncoderV2} [YEncoder]\n * @return {Uint8Array<ArrayBuffer>}\n */\nexport const mergeUpdatesV2 = (updates, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2) => {\n  if (updates.length === 1) {\n    return updates[0]\n  }\n  const updateDecoders = updates.map(update => new YDecoder(decoding.createDecoder(update)))\n  let lazyStructDecoders = updateDecoders.map(decoder => new LazyStructReader(decoder, true))\n\n  /**\n   * @todo we don't need offset because we always slice before\n   * @type {null | { struct: Item | GC | Skip, offset: number }}\n   */\n  let currWrite = null\n\n  const updateEncoder = new YEncoder()\n  // write structs lazily\n  const lazyStructEncoder = new LazyStructWriter(updateEncoder)\n\n  // Note: We need to ensure that all lazyStructDecoders are fully consumed\n  // Note: Should merge document updates whenever possible - even from different updates\n  // Note: Should handle that some operations cannot be applied yet ()\n\n  while (true) {\n    // Write higher clients first  sort by clientID & clock and remove decoders without content\n    lazyStructDecoders = lazyStructDecoders.filter(dec => dec.curr !== null)\n    lazyStructDecoders.sort(\n      /** @type {function(any,any):number} */ (dec1, dec2) => {\n        if (dec1.curr.id.client === dec2.curr.id.client) {\n          const clockDiff = dec1.curr.id.clock - dec2.curr.id.clock\n          if (clockDiff === 0) {\n            // @todo remove references to skip since the structDecoders must filter Skips.\n            return dec1.curr.constructor === dec2.curr.constructor\n              ? 0\n              : dec1.curr.constructor === Skip ? 1 : -1 // we are filtering skips anyway.\n          } else {\n            return clockDiff\n          }\n        } else {\n          return dec2.curr.id.client - dec1.curr.id.client\n        }\n      }\n    )\n    if (lazyStructDecoders.length === 0) {\n      break\n    }\n    const currDecoder = lazyStructDecoders[0]\n    // write from currDecoder until the next operation is from another client or if filler-struct\n    // then we need to reorder the decoders and find the next operation to write\n    const firstClient = /** @type {Item | GC} */ (currDecoder.curr).id.client\n\n    if (currWrite !== null) {\n      let curr = /** @type {Item | GC | null} */ (currDecoder.curr)\n      let iterated = false\n\n      // iterate until we find something that we haven't written already\n      // remember: first the high client-ids are written\n      while (curr !== null && curr.id.clock + curr.length <= currWrite.struct.id.clock + currWrite.struct.length && curr.id.client >= currWrite.struct.id.client) {\n        curr = currDecoder.next()\n        iterated = true\n      }\n      if (\n        curr === null || // current decoder is empty\n        curr.id.client !== firstClient || // check whether there is another decoder that has has updates from `firstClient`\n        (iterated && curr.id.clock > currWrite.struct.id.clock + currWrite.struct.length) // the above while loop was used and we are potentially missing updates\n      ) {\n        continue\n      }\n\n      if (firstClient !== currWrite.struct.id.client) {\n        writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset)\n        currWrite = { struct: curr, offset: 0 }\n        currDecoder.next()\n      } else {\n        if (currWrite.struct.id.clock + currWrite.struct.length < curr.id.clock) {\n          // @todo write currStruct & set currStruct = Skip(clock = currStruct.id.clock + currStruct.length, length = curr.id.clock - self.clock)\n          if (currWrite.struct.constructor === Skip) {\n            // extend existing skip\n            currWrite.struct.length = curr.id.clock + curr.length - currWrite.struct.id.clock\n          } else {\n            writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset)\n            const diff = curr.id.clock - currWrite.struct.id.clock - currWrite.struct.length\n            /**\n             * @type {Skip}\n             */\n            const struct = new Skip(createID(firstClient, currWrite.struct.id.clock + currWrite.struct.length), diff)\n            currWrite = { struct, offset: 0 }\n          }\n        } else { // if (currWrite.struct.id.clock + currWrite.struct.length >= curr.id.clock) {\n          const diff = currWrite.struct.id.clock + currWrite.struct.length - curr.id.clock\n          if (diff > 0) {\n            if (currWrite.struct.constructor === Skip) {\n              // prefer to slice Skip because the other struct might contain more information\n              currWrite.struct.length -= diff\n            } else {\n              curr = sliceStruct(curr, diff)\n            }\n          }\n          if (!currWrite.struct.mergeWith(/** @type {any} */ (curr))) {\n            writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset)\n            currWrite = { struct: curr, offset: 0 }\n            currDecoder.next()\n          }\n        }\n      }\n    } else {\n      currWrite = { struct: /** @type {Item | GC} */ (currDecoder.curr), offset: 0 }\n      currDecoder.next()\n    }\n    for (\n      let next = currDecoder.curr;\n      next !== null && next.id.client === firstClient && next.id.clock === currWrite.struct.id.clock + currWrite.struct.length && next.constructor !== Skip;\n      next = currDecoder.next()\n    ) {\n      writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset)\n      currWrite = { struct: next, offset: 0 }\n    }\n  }\n  if (currWrite !== null) {\n    writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset)\n    currWrite = null\n  }\n  finishLazyStructWriting(lazyStructEncoder)\n\n  const dss = updateDecoders.map(decoder => readIdSet(decoder))\n  const ds = mergeIdSets(dss)\n  writeIdSet(updateEncoder, ds)\n  return updateEncoder.toUint8Array()\n}\n\n/**\n * @param {Uint8Array} update\n * @param {Uint8Array} sv\n * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} [YDecoder]\n * @param {typeof UpdateEncoderV1 | typeof UpdateEncoderV2} [YEncoder]\n */\nexport const diffUpdateV2 = (update, sv, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2) => {\n  const state = decodeStateVector(sv)\n  const encoder = new YEncoder()\n  const lazyStructWriter = new LazyStructWriter(encoder)\n  const decoder = new YDecoder(decoding.createDecoder(update))\n  const reader = new LazyStructReader(decoder, false)\n  while (reader.curr) {\n    const curr = reader.curr\n    const currClient = curr.id.client\n    const svClock = state.get(currClient) || 0\n    if (reader.curr.constructor === Skip) {\n      // the first written struct shouldn't be a skip\n      reader.next()\n      continue\n    }\n    if (curr.id.clock + curr.length > svClock) {\n      writeStructToLazyStructWriter(lazyStructWriter, curr, math.max(svClock - curr.id.clock, 0))\n      reader.next()\n      while (reader.curr && reader.curr.id.client === currClient) {\n        writeStructToLazyStructWriter(lazyStructWriter, reader.curr, 0)\n        reader.next()\n      }\n    } else {\n      // read until something new comes up\n      while (reader.curr && reader.curr.id.client === currClient && reader.curr.id.clock + reader.curr.length <= svClock) {\n        reader.next()\n      }\n    }\n  }\n  finishLazyStructWriting(lazyStructWriter)\n  // write ds\n  const ds = readIdSet(decoder)\n  writeIdSet(encoder, ds)\n  return encoder.toUint8Array()\n}\n\n/**\n * @param {Uint8Array} update\n * @param {Uint8Array} sv\n */\nexport const diffUpdate = (update, sv) => diffUpdateV2(update, sv, UpdateDecoderV1, UpdateEncoderV1)\n\n/**\n * @param {LazyStructWriter} lazyWriter\n */\nconst flushLazyStructWriter = lazyWriter => {\n  if (lazyWriter.written > 0) {\n    lazyWriter.clientStructs.push({ written: lazyWriter.written, restEncoder: encoding.toUint8Array(lazyWriter.encoder.restEncoder) })\n    lazyWriter.encoder.restEncoder = encoding.createEncoder()\n    lazyWriter.written = 0\n  }\n}\n\n/**\n * @param {LazyStructWriter} lazyWriter\n * @param {Item | GC} struct\n * @param {number} offset\n */\nconst writeStructToLazyStructWriter = (lazyWriter, struct, offset) => {\n  // flush curr if we start another client\n  if (lazyWriter.written > 0 && lazyWriter.currClient !== struct.id.client) {\n    flushLazyStructWriter(lazyWriter)\n  }\n  if (lazyWriter.written === 0) {\n    lazyWriter.currClient = struct.id.client\n    // write next client\n    lazyWriter.encoder.writeClient(struct.id.client)\n    // write startClock\n    encoding.writeVarUint(lazyWriter.encoder.restEncoder, struct.id.clock + offset)\n  }\n  struct.write(lazyWriter.encoder, offset, 0)\n  lazyWriter.written++\n}\n/**\n * Call this function when we collected all parts and want to\n * put all the parts together. After calling this method,\n * you can continue using the UpdateEncoder.\n *\n * @param {LazyStructWriter} lazyWriter\n */\nconst finishLazyStructWriting = (lazyWriter) => {\n  flushLazyStructWriter(lazyWriter)\n\n  // this is a fresh encoder because we called flushCurr\n  const restEncoder = lazyWriter.encoder.restEncoder\n\n  /**\n   * Now we put all the fragments together.\n   * This works similarly to `writeClientsStructs`\n   */\n\n  // write # states that were updated - i.e. the clients\n  encoding.writeVarUint(restEncoder, lazyWriter.clientStructs.length)\n\n  for (let i = 0; i < lazyWriter.clientStructs.length; i++) {\n    const partStructs = lazyWriter.clientStructs[i]\n    /**\n     * Works similarly to `writeStructs`\n     */\n    // write # encoded structs\n    encoding.writeVarUint(restEncoder, partStructs.written)\n    // write the rest of the fragment\n    encoding.writeUint8Array(restEncoder, partStructs.restEncoder)\n  }\n}\n\n/**\n * @param {Uint8Array} update\n * @param {function(Item|GC|Skip):Item|GC|Skip} blockTransformer\n * @param {typeof UpdateDecoderV2 | typeof UpdateDecoderV1} YDecoder\n * @param {typeof UpdateEncoderV2 | typeof UpdateEncoderV1 } YEncoder\n */\nexport const convertUpdateFormat = (update, blockTransformer, YDecoder, YEncoder) => {\n  const updateDecoder = new YDecoder(decoding.createDecoder(update))\n  const lazyDecoder = new LazyStructReader(updateDecoder, false)\n  const updateEncoder = new YEncoder()\n  const lazyWriter = new LazyStructWriter(updateEncoder)\n  for (let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()) {\n    writeStructToLazyStructWriter(lazyWriter, blockTransformer(curr), 0)\n  }\n  finishLazyStructWriting(lazyWriter)\n  const ds = readIdSet(updateDecoder)\n  writeIdSet(updateEncoder, ds)\n  return updateEncoder.toUint8Array()\n}\n\n/**\n * @typedef {Object} ObfuscatorOptions\n * @property {boolean} [ObfuscatorOptions.formatting=true]\n * @property {boolean} [ObfuscatorOptions.subdocs=true]\n * @property {boolean} [ObfuscatorOptions.yxml=true] Whether to obfuscate nodeName / hookName\n */\n\n/**\n * @param {ObfuscatorOptions} obfuscator\n */\nconst createObfuscator = ({ formatting = true, subdocs = true, yxml = true } = {}) => {\n  let i = 0\n  const mapKeyCache = map.create()\n  const nodeNameCache = map.create()\n  const formattingKeyCache = map.create()\n  const formattingValueCache = map.create()\n  formattingValueCache.set(null, null) // end of a formatting range should always be the end of a formatting range\n  /**\n   * @param {Item|GC|Skip} block\n   * @return {Item|GC|Skip}\n   */\n  return block => {\n    switch (block.constructor) {\n      case GC:\n      case Skip:\n        return block\n      case Item: {\n        const item = /** @type {Item} */ (block)\n        const content = item.content\n        switch (content.constructor) {\n          case ContentDeleted:\n            break\n          case ContentType: {\n            if (yxml) {\n              const type = /** @type {ContentType} */ (content).type\n              if (type instanceof YXmlElement) {\n                type.nodeName = map.setIfUndefined(nodeNameCache, type.nodeName, () => 'node-' + i)\n              }\n              // @ts-ignore\n              if (type instanceof YXmlHook) {\n                type.hookName = map.setIfUndefined(nodeNameCache, type.hookName, () => 'hook-' + i)\n              }\n            }\n            break\n          }\n          case ContentAny: {\n            const c = /** @type {ContentAny} */ (content)\n            c.arr = c.arr.map(() => i)\n            break\n          }\n          case ContentBinary: {\n            const c = /** @type {ContentBinary} */ (content)\n            c.content = new Uint8Array([i])\n            break\n          }\n          case ContentDoc: {\n            const c = /** @type {ContentDoc} */ (content)\n            if (subdocs) {\n              c.opts = {}\n              c.doc.guid = i + ''\n            }\n            break\n          }\n          case ContentEmbed: {\n            const c = /** @type {ContentEmbed} */ (content)\n            c.embed = {}\n            break\n          }\n          case ContentFormat: {\n            const c = /** @type {ContentFormat} */ (content)\n            if (formatting) {\n              c.key = map.setIfUndefined(formattingKeyCache, c.key, () => i + '')\n              c.value = map.setIfUndefined(formattingValueCache, c.value, () => ({ i }))\n            }\n            break\n          }\n          case ContentJSON: {\n            const c = /** @type {ContentJSON} */ (content)\n            c.arr = c.arr.map(() => i)\n            break\n          }\n          case ContentString: {\n            const c = /** @type {ContentString} */ (content)\n            c.str = string.repeat((i % 10) + '', c.str.length)\n            break\n          }\n          default:\n            // unknown content type\n            error.unexpectedCase()\n        }\n        if (item.parentSub) {\n          item.parentSub = map.setIfUndefined(mapKeyCache, item.parentSub, () => i + '')\n        }\n        i++\n        return block\n      }\n      default:\n        // unknown block-type\n        error.unexpectedCase()\n    }\n  }\n}\n\n/**\n * This function obfuscates the content of a Yjs update. This is useful to share\n * buggy Yjs documents while significantly limiting the possibility that a\n * developer can on the user. Note that it might still be possible to deduce\n * some information by analyzing the \"structure\" of the document or by analyzing\n * the typing behavior using the CRDT-related metadata that is still kept fully\n * intact.\n *\n * @param {Uint8Array} update\n * @param {ObfuscatorOptions} [opts]\n */\nexport const obfuscateUpdate = (update, opts) => convertUpdateFormat(update, createObfuscator(opts), UpdateDecoderV1, UpdateEncoderV1)\n\n/**\n * @param {Uint8Array} update\n * @param {ObfuscatorOptions} [opts]\n */\nexport const obfuscateUpdateV2 = (update, opts) => convertUpdateFormat(update, createObfuscator(opts), UpdateDecoderV2, UpdateEncoderV2)\n\n/**\n * @param {Uint8Array} update\n */\nexport const convertUpdateFormatV1ToV2 = update => convertUpdateFormat(update, f.id, UpdateDecoderV1, UpdateEncoderV2)\n\n/**\n * @param {Uint8Array} update\n */\nexport const convertUpdateFormatV2ToV1 = update => convertUpdateFormat(update, f.id, UpdateDecoderV2, UpdateEncoderV1)\n","import {\n  diffIdSet,\n  mergeIdSets,\n  noAttributionsManager,\n  Doc, AbstractAttributionManager, Item, AbstractType, Transaction, AbstractStruct, // eslint-disable-line\n  createAbsolutePositionFromRelativePosition,\n  createRelativePosition,\n  AbsolutePosition\n} from '../internals.js'\n\nimport * as map from 'lib0/map'\nimport * as delta from 'lib0/delta' // eslint-disable-line\nimport * as set from 'lib0/set'\n\n/**\n * @typedef {import('./types.js').YType} _YType\n */\n\n/**\n * @template {AbstractType<any,any>} Target\n * YEvent describes the changes on a YType.\n */\nexport class YEvent {\n  /**\n   * @param {Target} target The changed type.\n   * @param {Transaction} transaction\n   * @param {Set<any>?} subs The keys that changed\n   */\n  constructor (target, transaction, subs) {\n    /**\n     * The type on which this event was created on.\n     * @type {Target}\n     */\n    this.target = target\n    /**\n     * The current target on which the observe callback is called.\n     * @type {_YType}\n     */\n    this.currentTarget = target\n    /**\n     * The transaction that triggered this event.\n     * @type {Transaction}\n     */\n    this.transaction = transaction\n    /**\n     * @type {(Target extends AbstractType<infer D,any> ? D : delta.Delta<any,any,any,any,any>)|null}\n     */\n    this._delta = null\n    /**\n     * @type {(Target extends AbstractType<infer D,any> ? import('../internals.js').ToDeepEventDelta<D> : delta.Delta<any,any,any,any,any>)|null}\n     */\n    this._deltaDeep = null\n    /**\n     * @type {Array<string|number>|null}\n     */\n    this._path = null\n    /**\n     * Whether the children changed.\n     * @type {Boolean}\n     * @private\n     */\n    this.childListChanged = false\n    /**\n     * Set of all changed attributes.\n     * @type {Set<string>}\n     */\n    this.keysChanged = new Set()\n    subs?.forEach((sub) => {\n      if (sub === null) {\n        this.childListChanged = true\n      } else {\n        this.keysChanged.add(sub)\n      }\n    })\n  }\n\n  /**\n   * Computes the path from `y` to the changed type.\n   *\n   * @todo v14 should standardize on path: Array<{parent, index}> because that is easier to work with.\n   *\n   * The following property holds:\n   * @example\n   *   let type = y\n   *   event.path.forEach(dir => {\n   *     type = type.get(dir)\n   *   })\n   *   type === event.target // => true\n   */\n  get path () {\n    return this._path || (this._path = getPathTo(this.currentTarget, this.target))\n  }\n\n  /**\n   * Check if a struct is deleted by this event.\n   *\n   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.\n   *\n   * @param {AbstractStruct} struct\n   * @return {boolean}\n   */\n  deletes (struct) {\n    return this.transaction.deleteSet.hasId(struct.id)\n  }\n\n  /**\n   * Check if a struct is added by this event.\n   *\n   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.\n   *\n   * @param {AbstractStruct} struct\n   * @return {boolean}\n   */\n  adds (struct) {\n    return this.transaction.insertSet.hasId(struct.id)\n  }\n\n  /**\n   * @template {boolean} [Deep=false]\n   * @param {AbstractAttributionManager} am\n   * @param {object} [opts]\n   * @param {Deep} [opts.deep]\n   * @return {Target extends AbstractType<infer D,any> ? (Deep extends true ? import('../internals.js').ToDeepEventDelta<D> : D) : delta.Delta<any,any,any,any>} The Delta representation of this type.\n   *\n   * @public\n   */\n  getDelta (am = noAttributionsManager, { deep } = {}) {\n    const itemsToRender = mergeIdSets([diffIdSet(this.transaction.insertSet, this.transaction.deleteSet), diffIdSet(this.transaction.deleteSet, this.transaction.insertSet)])\n    /**\n     * @todo this should be done only one in the transaction step\n     *\n     * @type {Map<import('./types.js').YType,Set<string|null>>|null}\n     */\n    let modified = this.transaction.changed\n    if (deep) {\n      // need to add deep changes to copy of modified\n      const dchanged = new Map()\n      modified.forEach((attrs, type) => {\n        dchanged.set(type, new Set(attrs))\n      })\n      for (let m of modified.keys()) {\n        while (m._item != null) {\n          const item = m._item\n          const ms = map.setIfUndefined(dchanged, item?.parent, set.create)\n          if (item && !ms.has(item.parentSub)) {\n            ms.add(item.parentSub)\n            m = /** @type {any} */ (item.parent)\n          } else {\n            break\n          }\n        }\n      }\n      modified = dchanged\n    }\n    return /** @type {any} */ (this.target.getContent(am, { itemsToRender, retainDeletes: true, deletedItems: this.transaction.deleteSet, deep: !!deep, modified }))\n  }\n\n  /**\n   * Compute the changes in the delta format.\n   * A {@link https://quilljs.com/docs/delta/|Quill Delta}) that represents the changes on the document.\n   *\n   * @type {Target extends AbstractType<infer D,any> ? D : delta.Delta<any,any,any,any,any>} The Delta representation of this type.\n   * @public\n   */\n  get delta () {\n    return /** @type {any} */ (this._delta ?? (this._delta = this.getDelta().done()))\n  }\n\n  /**\n   * Compute the changes in the delta format.\n   * A {@link https://quilljs.com/docs/delta/|Quill Delta}) that represents the changes on the document.\n   *\n   * @type {Target extends AbstractType<infer D,any> ? D : delta.Delta<any,any,any,any,any>} The Delta representation of this type.\n   * @public\n   */\n  get deltaDeep () {\n    return /** @type {any} */ (this._deltaDeep ?? (this._deltaDeep = this.getDelta(noAttributionsManager, { deep: true })))\n  }\n}\n\n/**\n * Compute the path from this type to the specified target.\n *\n * @example\n *   // `child` should be accessible via `type.get(path[0]).get(path[1])..`\n *   const path = type.getPathTo(child)\n *   // assuming `type instanceof YArray`\n *   console.log(path) // might look like => [2, 'key1']\n *   child === type.get(path[0]).get(path[1])\n *\n * @param {_YType} parent\n * @param {_YType} child target\n * @param {AbstractAttributionManager} am\n * @return {Array<string|number>} Path to the target\n *\n * @private\n * @function\n */\nexport const getPathTo = (parent, child, am = noAttributionsManager) => {\n  const path = []\n  const doc = /** @type {Doc} */ (parent.doc)\n  while (child._item !== null && child !== parent) {\n    if (child._item.parentSub !== null) {\n      // parent is map-ish\n      path.unshift(child._item.parentSub)\n    } else {\n      const parent = /** @type {import('../utils/types.js').YType} */ (child._item.parent)\n      // parent is array-ish\n      const apos = /** @type {AbsolutePosition} */ (createAbsolutePositionFromRelativePosition(createRelativePosition(parent, child._item.id), doc, false, am))\n      path.unshift(apos.index)\n    }\n    child = /** @type {_YType} */ (child._item.parent)\n  }\n  return path\n}\n","import {\n  createID,\n  readItemContent,\n  findIndexCleanStart,\n  Skip,\n  UpdateDecoderV1, UpdateDecoderV2, IdSet, Doc, GC, Item, ID, // eslint-disable-line\n} from '../internals.js'\n\nimport * as decoding from 'lib0/decoding'\nimport * as binary from 'lib0/binary'\nimport * as map from 'lib0/map'\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder The decoder object to read data from.\n * @param {Doc} doc\n * @return {StructSet}\n *\n * @private\n * @function\n */\nexport const readStructSet = (decoder, doc) => {\n  const clientRefs = new StructSet()\n  const numOfStateUpdates = decoding.readVarUint(decoder.restDecoder)\n  for (let i = 0; i < numOfStateUpdates; i++) {\n    const numberOfStructs = decoding.readVarUint(decoder.restDecoder)\n    /**\n     * @type {Array<GC|Item>}\n     */\n    const refs = new Array(numberOfStructs)\n    const client = decoder.readClient()\n    let clock = decoding.readVarUint(decoder.restDecoder)\n    clientRefs.clients.set(client, new StructRange(refs))\n    for (let i = 0; i < numberOfStructs; i++) {\n      const info = decoder.readInfo()\n      switch (binary.BITS5 & info) {\n        case 0: { // GC\n          const len = decoder.readLen()\n          refs[i] = new GC(createID(client, clock), len)\n          clock += len\n          break\n        }\n        case 10: { // Skip Struct (nothing to apply)\n          // @todo we could reduce the amount of checks by adding Skip struct to clientRefs so we know that something is missing.\n          const len = decoding.readVarUint(decoder.restDecoder)\n          refs[i] = new Skip(createID(client, clock), len)\n          clock += len\n          break\n        }\n        default: { // Item with content\n          /**\n           * The optimized implementation doesn't use any variables because inlining variables is faster.\n           * Below a non-optimized version is shown that implements the basic algorithm with\n           * a few comments\n           */\n          const cantCopyParentInfo = (info & (binary.BIT7 | binary.BIT8)) === 0\n          // If parent = null and neither left nor right are defined, then we know that `parent` is child of `y`\n          // and we read the next string as parentYKey.\n          // It indicates how we store/retrieve parent from `y.share`\n          // @type {string|null}\n          const struct = new Item(\n            createID(client, clock),\n            null, // left\n            (info & binary.BIT8) === binary.BIT8 ? decoder.readLeftID() : null, // origin\n            null, // right\n            (info & binary.BIT7) === binary.BIT7 ? decoder.readRightID() : null, // right origin\n            cantCopyParentInfo ? (decoder.readParentInfo() ? doc.get(decoder.readString()) : decoder.readLeftID()) : null, // parent\n            cantCopyParentInfo && (info & binary.BIT6) === binary.BIT6 ? decoder.readString() : null, // parentSub\n            readItemContent(decoder, info) // item content\n          )\n          refs[i] = struct\n          clock += struct.length\n        }\n      }\n    }\n  }\n  return clientRefs\n}\n\n/**\n * Remove item-ranges from the StructSet.\n *\n * @param {StructSet} ss\n * @param {IdSet} exclude\n */\nexport const removeRangesFromStructSet = (ss, exclude) => {\n  // @todo walk through ss instead to reduce iterations\n  exclude.clients.forEach((range, client) => {\n    const structs = /** @type {StructRange} */ (ss.clients.get(client))?.refs\n    if (structs != null) {\n      const firstStruct = structs[0]\n      const lastStruct = structs[structs.length - 1]\n      const idranges = range.getIds()\n      for (let i = 0; i < idranges.length; i++) {\n        const range = idranges[i]\n        let startIndex = 0\n        if (range.clock >= lastStruct.id.clock + lastStruct.length) continue\n        if (range.clock > firstStruct.id.clock) {\n          startIndex = findIndexCleanStart(null, structs, range.clock)\n        }\n        let endIndex = structs.length // must be set here, after structs is modified\n        if (range.clock + range.len <= firstStruct.id.clock) continue\n        if (range.clock + range.len < lastStruct.id.clock + lastStruct.length) {\n          endIndex = findIndexCleanStart(null, structs, range.clock + range.len)\n        }\n        if (startIndex < endIndex) {\n          structs[startIndex] = new Skip(new ID(client, range.clock), range.len)\n          const d = endIndex - startIndex\n          if (d > 1) {\n            structs.splice(startIndex + 1, d - 1)\n          }\n        }\n      }\n    }\n  })\n}\n\nclass StructRange {\n  /**\n   * @param {Array<Item|GC>} refs\n   */\n  constructor (refs) {\n    this.i = 0\n    /**\n     * @type {Array<Item | GC>}\n     */\n    this.refs = refs\n  }\n}\n\nexport class StructSet {\n  constructor () {\n    /**\n     * @type {Map<number, StructRange>}\n     */\n    this.clients = map.create()\n  }\n}\n","import {\n  _diffSet,\n  findIndexInIdRanges,\n  findRangeStartInIdRanges,\n  _deleteRangeFromIdSet,\n  DSDecoderV1, DSDecoderV2,  IdSetEncoderV1, IdSetEncoderV2, IdSet, ID, // eslint-disable-line\n  _insertIntoIdSet,\n  _intersectSets\n} from '../internals.js'\n\nimport * as array from 'lib0/array'\nimport * as map from 'lib0/map'\nimport * as encoding from 'lib0/encoding'\nimport * as decoding from 'lib0/decoding'\nimport * as buf from 'lib0/buffer'\nimport * as rabin from 'lib0/hash/rabin'\n\n/**\n * @todo rename this to `Attribute`\n * @template V\n */\nexport class AttributionItem {\n  /**\n   * @param {string} name\n   * @param {V} val\n   */\n  constructor (name, val) {\n    this.name = name\n    this.val = val\n  }\n\n  hash () {\n    const encoder = encoding.createEncoder()\n    encoding.writeVarString(encoder, this.name)\n    encoding.writeAny(encoder, /** @type {any} */ (this.val))\n    return buf.toBase64(rabin.fingerprint(rabin.StandardIrreducible128, encoding.toUint8Array(encoder)))\n  }\n}\n\n/**\n * @todo rename this to `createAttribute`\n * @template V\n * @param {string} name\n * @param {V} val\n * @return {AttributionItem<V>}\n */\nexport const createAttributionItem = (name, val) => new AttributionItem(name, val)\n\n/**\n * @template T\n * @param {Array<T>} attrs\n * @param {T} attr\n *\n */\nconst idmapAttrsHas = (attrs, attr) => attrs.find(a => a === attr)\n\n/**\n * @template T\n * @param {Array<T>} a\n * @param {Array<T>} b\n */\nexport const idmapAttrsEqual = (a, b) => a.length === b.length && a.every(v => idmapAttrsHas(b, v))\n\n/**\n * @template T\n * @param {Array<T>} a\n * @param {Array<T>} b\n */\nconst idmapAttrRangeJoin = (a, b) => a.concat(b.filter(attr => !idmapAttrsHas(a, attr)))\n\n/**\n * @template Attrs\n */\nexport class AttrRange {\n  /**\n   * @param {number} clock\n   * @param {number} len\n   * @param {Array<AttributionItem<Attrs>>} attrs\n   */\n  constructor (clock, len, attrs) {\n    /**\n     * @readonly\n     */\n    this.clock = clock\n    /**\n     * @readonly\n     */\n    this.len = len\n    /**\n     * @readonly\n     */\n    this.attrs = attrs\n  }\n\n  /**\n   * @param {number} clock\n   * @param {number} len\n   */\n  copyWith (clock, len) {\n    return new AttrRange(clock, len, this.attrs)\n  }\n}\n\n/**\n * @template Attrs\n * @typedef {{ clock: number, len: number, attrs: Array<AttributionItem<Attrs>>? }} MaybeAttrRange\n */\n\n/**\n * @template Attrs\n *\n * @param {number} clock\n * @param {number} len\n * @param {Array<AttributionItem<Attrs>>?} attrs\n * @return {MaybeAttrRange<Attrs>}\n */\nexport const createMaybeAttrRange = (clock, len, attrs) => new AttrRange(clock, len, /** @type {any} */ (attrs))\n\n/**\n * Whenever this is instantiated, it must receive a fresh array of ops, not something copied.\n *\n * @template Attrs\n */\nexport class AttrRanges {\n  /**\n   * @param {Array<AttrRange<Attrs>>} ids\n   */\n  constructor (ids) {\n    this.sorted = false\n    /**\n     * @private\n     */\n    this._ids = ids\n  }\n\n  copy () {\n    return new AttrRanges(this._ids.slice())\n  }\n\n  /**\n   * @param {number} clock\n   * @param {number} length\n   * @param {Array<AttributionItem<Attrs>>} attrs\n   */\n  add (clock, length, attrs) {\n    if (length === 0) return\n    this.sorted = false\n    this._ids.push(new AttrRange(clock, length, attrs))\n  }\n\n  /**\n   * Return the list of id ranges, sorted and merged.\n   */\n  getIds () {\n    const ids = this._ids\n    if (!this.sorted) {\n      this.sorted = true\n      ids.sort((a, b) => a.clock - b.clock)\n      /**\n       * algorithm thoughts:\n       * - sort (by clock AND by length), bigger length is to the right (or not, we can't make\n       *   assumptions abouth length after long length has been split)\n       * -- maybe better: sort by clock+length. Then split items from right to left. This way, items are always\n       *   in the right order. But I also need to swap if left items is smaller after split\n       *   --- thought: there is no way to go around swapping. Unless, for each item from left to\n       *   right, when I have to split because one of the look-ahead items is overlapping, i split\n       *   it and merge the attributes into the following ones (that I also need to split). Best is\n       *   probably left to right with lookahead.\n       * - left to right, split overlapping items so that we can make the assumption that either an\n       *   item is overlapping with the next 1-on-1 or it is not overlapping at all (when splitting,\n       *   we can already incorporate the attributes)\n       *   -- better: for each item, go left to right and add own attributes to overlapping items.\n       *   Split them if necessary. After split, i must insert the retainer at a valid position.\n       * - merge items if neighbor has same attributes\n       */\n      for (let i = 0; i < ids.length - 1;) {\n        const range = ids[i]\n        const nextRange = ids[i + 1]\n        // find out how to split range. it must match with next range.\n        // 1) we have space. Split if necessary.\n        // 2) concat attributes in range to the next range. Split range and splice the remainder at\n        // the correct position.\n        if (range.clock < nextRange.clock) { // might need to split range\n          if (range.clock + range.len > nextRange.clock) {\n            // is overlapping\n            const diff = nextRange.clock - range.clock\n            ids[i] = new AttrRange(range.clock, diff, range.attrs)\n            ids.splice(i + 1, 0, new AttrRange(nextRange.clock, range.len - diff, range.attrs))\n          }\n          i++\n          continue\n        }\n        // now we know that range.clock === nextRange.clock\n        // merge range with nextRange\n        const largerRange = range.len > nextRange.len ? range : nextRange\n        const smallerLen = range.len < nextRange.len ? range.len : nextRange.len\n        ids[i] = new AttrRange(range.clock, smallerLen, idmapAttrRangeJoin(range.attrs, nextRange.attrs))\n        if (range.len === nextRange.len) {\n          ids.splice(i + 1, 1)\n        } else {\n          ids[i + 1] = new AttrRange(range.clock + smallerLen, largerRange.len - smallerLen, largerRange.attrs)\n          array.bubblesortItem(ids, i + 1, (a, b) => a.clock - b.clock)\n        }\n        if (smallerLen === 0) i++\n      }\n      while (ids.length > 0 && ids[0].len === 0) {\n        ids.splice(0, 1)\n      }\n      // merge items without filtering or splicing the array.\n      // i is the current pointer\n      // j refers to the current insert position for the pointed item\n      // try to merge dels[i] into dels[j-1] or set dels[j]=dels[i]\n      let i, j\n      for (i = 1, j = 1; i < ids.length; i++) {\n        const left = ids[j - 1]\n        const right = ids[i]\n        if (left.clock + left.len === right.clock && idmapAttrsEqual(left.attrs, right.attrs)) {\n          ids[j - 1] = new AttrRange(left.clock, left.len + right.len, left.attrs)\n        } else if (right.len !== 0) {\n          if (j < i) {\n            ids[j] = right\n          }\n          j++\n        }\n      }\n      ids.length = ids.length === 0 ? 0 : (ids[j - 1].len === 0 ? j - 1 : j)\n    }\n    return ids\n  }\n}\n\n/**\n * Merge multiple idmaps. Ensures that there are no redundant attribution definitions (two\n * Attributions that describe the same thing).\n *\n * @template T\n * @param {Array<IdMap<T>>} ams\n * @return {IdMap<T>} A fresh IdSet\n */\nexport const mergeIdMaps = ams => {\n  /**\n   * Maps attribution to the attribution of the merged idmap.\n   *\n   * @type {Map<AttributionItem<any>,AttributionItem<any>>}\n   */\n  const attrMapper = new Map()\n  const merged = createIdMap()\n  for (let amsI = 0; amsI < ams.length; amsI++) {\n    ams[amsI].clients.forEach((rangesLeft, client) => {\n      if (!merged.clients.has(client)) {\n        // Write all missing keys from current set and all following.\n        // If merged already contains `client` current ds has already been added.\n        let ids = rangesLeft.getIds().slice()\n        for (let i = amsI + 1; i < ams.length; i++) {\n          const nextIds = ams[i].clients.get(client)\n          if (nextIds) {\n            array.appendTo(ids, nextIds.getIds())\n          }\n        }\n        ids = ids.map(id => new AttrRange(id.clock, id.len, id.attrs.map(attr =>\n          map.setIfUndefined(attrMapper, attr, () =>\n            _ensureAttrs(merged, [attr])[0]\n          )\n        )))\n        merged.clients.set(client, new AttrRanges(ids))\n      }\n    })\n  }\n  return merged\n}\n\n/**\n * @param {IdSet} idset\n * @param {Array<AttributionItem<any>>} attrs\n */\nexport const createIdMapFromIdSet = (idset, attrs) => {\n  const idmap = createIdMap()\n  // map attrs to idmap\n  attrs = _ensureAttrs(idmap, attrs)\n  // filter out duplicates\n  /**\n   * @type {Array<AttributionItem<any>>}\n   */\n  const checkedAttrs = []\n  attrs.forEach(attr => {\n    if (!idmapAttrsHas(checkedAttrs, attr)) {\n      checkedAttrs.push(attr)\n    }\n  })\n  idset.clients.forEach((ranges, client) => {\n    const attrRanges = new AttrRanges(ranges.getIds().map(range => new AttrRange(range.clock, range.len, checkedAttrs)))\n    attrRanges.sorted = true // is sorted because idset is sorted\n    idmap.clients.set(client, attrRanges)\n  })\n  return idmap\n}\n\n/**\n * @template Attrs\n */\nexport class IdMap {\n  constructor () {\n    /**\n     * @type {Map<number,AttrRanges<Attrs>>}\n     */\n    this.clients = new Map()\n    /**\n     * @type {Map<string, AttributionItem<Attrs>>}\n     */\n    this.attrsH = new Map()\n    /**\n     * @type {Set<AttributionItem<Attrs>>}\n     */\n    this.attrs = new Set()\n  }\n\n  /**\n   * @param {(attrRange:AttrRange<Attrs>, client:number) => void} f\n   */\n  forEach (f) {\n    this.clients.forEach((ranges, client) => {\n      ranges.getIds().forEach((range) => {\n        f(range, client)\n      })\n    })\n  }\n\n  /**\n   * @param {ID} id\n   * @return {boolean}\n   */\n  hasId (id) {\n    return this.has(id.client, id.clock)\n  }\n\n  /**\n   * @param {number} client\n   * @param {number} clock\n   * @return {boolean}\n   */\n  has (client, clock) {\n    const dr = this.clients.get(client)\n    if (dr) {\n      return findIndexInIdRanges(dr.getIds(), clock) !== null\n    }\n    return false\n  }\n\n  /**\n   * Return attributions for a slice of ids.\n   *\n   * @param {ID} id\n   * @param {number} len\n   * @return {Array<MaybeAttrRange<Attrs>>}\n   */\n  sliceId (id, len) {\n    return this.slice(id.client, id.clock, len)\n  }\n\n  /**\n   * Return attributions for a slice of ids.\n   *\n   * @param {number} client\n   * @param {number} clock\n   * @param {number} len\n   * @return {Array<MaybeAttrRange<Attrs>>}\n   */\n  slice (client, clock, len) {\n    const dr = this.clients.get(client)\n    /**\n     * @type {Array<MaybeAttrRange<Attrs>>}\n     */\n    const res = []\n    if (dr) {\n      /**\n       * @type {Array<AttrRange<Attrs>>}\n       */\n      const ranges = dr.getIds()\n      let index = findRangeStartInIdRanges(ranges, clock)\n      if (index !== null) {\n        let prev = null\n        while (index < ranges.length) {\n          let r = ranges[index]\n          if (r.clock < clock) {\n            r = new AttrRange(clock, r.len - (clock - r.clock), r.attrs)\n          }\n          if (r.clock + r.len > clock + len) {\n            r = new AttrRange(r.clock, clock + len - r.clock, r.attrs)\n          }\n          if (r.len <= 0) break\n          const prevEnd = prev != null ? prev.clock + prev.len : clock\n          if (prevEnd < r.clock) {\n            res.push(createMaybeAttrRange(prevEnd, r.clock - prevEnd, null))\n          }\n          prev = r\n          res.push(r)\n          index++\n        }\n      }\n    }\n    if (res.length > 0) {\n      const last = res[res.length - 1]\n      const end = last.clock + last.len\n      if (end < clock + len) {\n        res.push(createMaybeAttrRange(end, clock + len - end, null))\n      }\n    } else {\n      res.push(createMaybeAttrRange(clock, len, null))\n    }\n    return res\n  }\n\n  /**\n   * @param {number} client\n   * @param {number} clock\n   * @param {number} len\n   * @param {Array<AttributionItem<Attrs>>} attrs\n   */\n  add (client, clock, len, attrs) {\n    if (len === 0) return\n    attrs = _ensureAttrs(this, attrs)\n    const ranges = this.clients.get(client)\n    if (ranges == null) {\n      this.clients.set(client, new AttrRanges([new AttrRange(clock, len, attrs)]))\n    } else {\n      ranges.add(clock, len, attrs)\n    }\n  }\n\n  /**\n   * @param {number} client\n   * @param {number} clock\n   * @param {number} len\n   */\n  delete (client, clock, len) {\n    _deleteRangeFromIdSet(this, client, clock, len)\n  }\n}\n\n/**\n * Efficiently encodes IdMap to a binary form. Ensures that information is de-duplicated when\n * written. Attribute.names are referenced by id. Attributes themselfs are also referenced by id.\n *\n * @template Attr\n * @param {IdSetEncoderV1 | IdSetEncoderV2} encoder\n * @param {IdMap<Attr>} idmap\n *\n * @private\n * @function\n */\nexport const writeIdMap = (encoder, idmap) => {\n  encoding.writeVarUint(encoder.restEncoder, idmap.clients.size)\n  let lastWrittenClientId = 0\n  /**\n   * @type {Map<AttributionItem<Attr>, number>}\n   */\n  const visitedAttributions = map.create()\n  /**\n   * @type {Map<string, number>}\n   */\n  const visitedAttrNames = map.create()\n  // Ensure that the ids are written in a deterministic order (smaller clientids first)\n  array.from(idmap.clients.entries())\n    .sort((a, b) => a[0] - b[0])\n    .forEach(([client, _idRanges]) => {\n      const attrRanges = _idRanges.getIds()\n      encoder.resetIdSetCurVal()\n      const diff = client - lastWrittenClientId\n      encoding.writeVarUint(encoder.restEncoder, diff)\n      lastWrittenClientId = client\n      const len = attrRanges.length\n      encoding.writeVarUint(encoder.restEncoder, len)\n      for (let i = 0; i < len; i++) {\n        const item = attrRanges[i]\n        const attrs = item.attrs\n        const attrLen = attrs.length\n        encoder.writeIdSetClock(item.clock)\n        encoder.writeIdSetLen(item.len)\n        encoding.writeVarUint(encoder.restEncoder, attrLen)\n        for (let j = 0; j < attrLen; j++) {\n          const attr = attrs[j]\n          const attrId = visitedAttributions.get(attr)\n          if (attrId != null) {\n            encoding.writeVarUint(encoder.restEncoder, attrId)\n          } else {\n            const newAttrId = visitedAttributions.size\n            visitedAttributions.set(attr, newAttrId)\n            encoding.writeVarUint(encoder.restEncoder, newAttrId)\n            const attrNameId = visitedAttrNames.get(attr.name)\n            // write attr.name\n            if (attrNameId != null) {\n              encoding.writeVarUint(encoder.restEncoder, attrNameId)\n            } else {\n              const newAttrNameId = visitedAttrNames.size\n              encoding.writeVarUint(encoder.restEncoder, newAttrNameId)\n              encoding.writeVarString(encoder.restEncoder, attr.name)\n              visitedAttrNames.set(attr.name, newAttrNameId)\n            }\n            encoding.writeAny(encoder.restEncoder, /** @type {any} */ (attr.val))\n          }\n        }\n      }\n    })\n}\n\n/**\n * @param {IdMap<any>} idmap\n */\nexport const encodeIdMap = idmap => {\n  const encoder = new IdSetEncoderV2()\n  writeIdMap(encoder, idmap)\n  return encoder.toUint8Array()\n}\n\n/**\n * @param {DSDecoderV1 | DSDecoderV2} decoder\n * @return {IdMap<any>}\n *\n * @private\n * @function\n */\nexport const readIdMap = decoder => {\n  const idmap = new IdMap()\n  const numClients = decoding.readVarUint(decoder.restDecoder)\n  /**\n   * @type {Array<AttributionItem<any>>}\n   */\n  const visitedAttributions = []\n  /**\n   * @type {Array<string>}\n   */\n  const visitedAttrNames = []\n  let lastClientId = 0\n  for (let i = 0; i < numClients; i++) {\n    decoder.resetDsCurVal()\n    const client = lastClientId + decoding.readVarUint(decoder.restDecoder)\n    lastClientId = client\n    const numberOfDeletes = decoding.readVarUint(decoder.restDecoder)\n    /**\n     * @type {Array<AttrRange<any>>}\n     */\n    const attrRanges = []\n    for (let i = 0; i < numberOfDeletes; i++) {\n      const rangeClock = decoder.readDsClock()\n      const rangeLen = decoder.readDsLen()\n      /**\n       * @type {Array<AttributionItem<any>>}\n       */\n      const attrs = []\n      const attrsLen = decoding.readVarUint(decoder.restDecoder)\n      for (let j = 0; j < attrsLen; j++) {\n        const attrId = decoding.readVarUint(decoder.restDecoder)\n        if (attrId >= visitedAttributions.length) {\n          // attrId not known yet\n          const attrNameId = decoding.readVarUint(decoder.restDecoder)\n          if (attrNameId >= visitedAttrNames.length) {\n            visitedAttrNames.push(decoding.readVarString(decoder.restDecoder))\n          }\n          visitedAttributions.push(new AttributionItem(visitedAttrNames[attrNameId], decoding.readAny(decoder.restDecoder)))\n        }\n        attrs.push(visitedAttributions[attrId])\n      }\n      attrRanges.push(new AttrRange(rangeClock, rangeLen, attrs))\n    }\n    idmap.clients.set(client, new AttrRanges(attrRanges))\n  }\n  visitedAttributions.forEach(attr => {\n    idmap.attrs.add(attr)\n    idmap.attrsH.set(attr.hash(), attr)\n  })\n  return idmap\n}\n\n/**\n * @param {Uint8Array} data\n * @return {IdMap<any>}\n */\nexport const decodeIdMap = data => readIdMap(new DSDecoderV2(decoding.createDecoder(data)))\n\n/**\n * @template Attrs\n * @param {IdMap<Attrs>} idmap\n * @param {Array<AttributionItem<Attrs>>} attrs\n * @return {Array<AttributionItem<Attrs>>}\n */\nconst _ensureAttrs = (idmap, attrs) => attrs.map(attr =>\n  idmap.attrs.has(attr)\n    ? attr\n    : map.setIfUndefined(idmap.attrsH, attr.hash(), () => {\n      idmap.attrs.add(attr)\n      return attr\n    }))\n\nexport const createIdMap = () => new IdMap()\n\n/**\n * @template T\n * @param {IdMap<T>} dest\n * @param {IdMap<T>} src\n */\nexport const insertIntoIdMap = _insertIntoIdSet\n\n/**\n * Remove all ranges from `exclude` from `ds`. The result is a fresh IdMap containing all ranges from `idSet` that are not\n * in `exclude`.\n *\n * @template {IdMap<any>} ISet\n * @param {ISet} set\n * @param {IdSet | IdMap<any>} exclude\n * @return {ISet}\n */\nexport const diffIdMap = (set, exclude) => {\n  const diffed = _diffSet(set, exclude)\n  diffed.attrs = set.attrs\n  diffed.attrsH = set.attrsH\n  return diffed\n}\n\nexport const intersectMaps = _intersectSets\n","import {\n  getItem,\n  diffIdSet,\n  createInsertSetFromStructStore,\n  createDeleteSetFromStructStore,\n  createIdMapFromIdSet,\n  ContentDeleted,\n  insertIntoIdMap,\n  insertIntoIdSet,\n  diffIdMap,\n  createIdMap,\n  mergeIdMaps,\n  createID,\n  mergeIdSets,\n  applyUpdate,\n  writeIdSet,\n  UpdateEncoderV1,\n  transact,\n  createMaybeAttrRange,\n  createIdSet,\n  writeStructsFromIdSet,\n  UndoManager,\n  StackItem,\n  getItemCleanStart,\n  intersectSets,\n  ContentFormat,\n  StructStore, Transaction, ID, IdSet, Item, Snapshot, Doc, AbstractContent, IdMap, // eslint-disable-line\n  encodeStateAsUpdate\n} from '../internals.js'\n\nimport * as error from 'lib0/error'\nimport { ObservableV2 } from 'lib0/observable'\nimport * as encoding from 'lib0/encoding'\nimport * as s from 'lib0/schema'\n\nexport const attributionJsonSchema = s.$object({\n  insert: s.$array(s.$string).optional,\n  insertedAt: s.$number.optional,\n  delete: s.$array(s.$string).optional,\n  deletedAt: s.$number.optional,\n  format: s.$record(s.$string, s.$array(s.$string)).optional,\n  formatAt: s.$number.optional\n})\n\n/**\n * @todo rename this to `insertBy`, `insertAt`, ..\n *\n * @typedef {s.Unwrap<typeof attributionJsonSchema>} Attribution\n */\n\n/**\n * @todo SHOULD NOT RETURN AN OBJECT!\n * @param {Array<import('./IdMap.js').AttributionItem<any>>?} attrs\n * @param {boolean} deleted - whether the attributed item is deleted\n * @return {Attribution?}\n */\nexport const createAttributionFromAttributionItems = (attrs, deleted) => {\n  if (attrs == null) {\n    return null\n  }\n  /**\n   * @type {Attribution}\n   */\n  const attribution = {}\n  if (deleted) {\n    attribution.delete = s.$array(s.$string).cast([])\n  } else {\n    attribution.insert = []\n  }\n  attrs.forEach(attr => {\n    switch (attr.name) {\n      // eslint-disable-next-line no-fallthrough\n      case 'insert':\n      case 'delete': {\n        const as = /** @type {import('lib0/delta').Attribution} */ (attribution)\n        const ls = as[attr.name] = as[attr.name] ?? []\n        ls.push(attr.val)\n        break\n      }\n      default: {\n        if (attr.name[0] !== '_') {\n          /** @type {any} */ (attribution)[attr.name] = attr.val\n        }\n      }\n    }\n  })\n  return attribution\n}\n\n/**\n * @template T\n */\nexport class AttributedContent {\n  /**\n   * @param {AbstractContent} content\n   * @param {number} clock\n   * @param {boolean} deleted\n   * @param {Array<import('./IdMap.js').AttributionItem<T>> | null} attrs\n   * @param {0|1|2} renderBehavior\n   */\n  constructor (content, clock, deleted, attrs, renderBehavior) {\n    this.content = content\n    this.clock = clock\n    this.deleted = deleted\n    this.attrs = attrs\n    this.render = renderBehavior === 0 ? false : (renderBehavior === 1 ? (!deleted || attrs != null) : true)\n  }\n}\n\n/**\n * Abstract class for associating Attributions to content / changes\n *\n * Should fire an event when the attributions changed _after_ the original change happens. This\n * Event will be used to update the attribution on the current content.\n *\n * @extends {ObservableV2<{change:(idset:IdSet,origin:any,local:boolean)=>void}>}\n */\nexport class AbstractAttributionManager extends ObservableV2 {\n  /**\n   * @param {Array<AttributedContent<any>>} _contents - where to write the result\n   * @param {number} _client\n   * @param {number} _clock\n   * @param {boolean} _deleted\n   * @param {AbstractContent} _content\n   * @param {0|1|2} _shouldRender - 0: if undeleted or attributed, render as a retain operation. 1: render only if undeleted or attributed. 2: render as insert operation (if unattributed and deleted, render as delete).\n   */\n  readContent (_contents, _client, _clock, _deleted, _content, _shouldRender) {\n    error.methodUnimplemented()\n  }\n\n  /**\n   * Calculate the length of the attributed content. This is used by iterators that walk through the\n   * content.\n   *\n   * If the content is not countable, it should return 0.\n   *\n   * @param {Item} _item\n   * @return {number}\n   */\n  contentLength (_item) {\n    error.methodUnimplemented()\n  }\n}\n\n/**\n * @implements AbstractAttributionManager\n *\n * @extends {ObservableV2<{change:(idset:IdSet,origin:any,local:boolean)=>void}>}\n */\nexport class TwosetAttributionManager extends ObservableV2 {\n  /**\n   * @param {IdMap<any>} inserts\n   * @param {IdMap<any>} deletes\n   */\n  constructor (inserts, deletes) {\n    super()\n    this.inserts = inserts\n    this.deletes = deletes\n  }\n\n  /**\n   * @param {Array<AttributedContent<any>>} contents - where to write the result\n   * @param {number} client\n   * @param {number} clock\n   * @param {boolean} deleted\n   * @param {AbstractContent} content\n   * @param {0|1|2} shouldRender - whether this should render or just result in a `retain` operation\n   */\n  readContent (contents, client, clock, deleted, content, shouldRender) {\n    const slice = (deleted ? this.deletes : this.inserts).slice(client, clock, content.getLength())\n    content = slice.length === 1 ? content : content.copy()\n    slice.forEach(s => {\n      const c = content\n      if (s.len < c.getLength()) {\n        content = c.splice(s.len)\n      }\n      if (!deleted || s.attrs != null || shouldRender) {\n        contents.push(new AttributedContent(c, s.clock, deleted, s.attrs, shouldRender))\n      }\n    })\n  }\n\n  /**\n   * @param {Item} item\n   * @return {number}\n   */\n  contentLength (item) {\n    if (!item.content.isCountable()) {\n      return 0\n    } else if (!item.deleted) {\n      return item.length\n    } else {\n      return this.deletes.sliceId(item.id, item.length).reduce((len, s) => s.attrs != null ? len + s.len : len, 0)\n    }\n  }\n}\n\n/**\n * Abstract class for associating Attributions to content / changes\n *\n * @implements AbstractAttributionManager\n *\n * @extends {ObservableV2<{change:(idset:IdSet,origin:any,local:boolean)=>void}>}\n */\nexport class NoAttributionsManager extends ObservableV2 {\n  /**\n   * @param {Array<AttributedContent<any>>} contents - where to write the result\n   * @param {number} _client\n   * @param {number} clock\n   * @param {boolean} deleted\n   * @param {AbstractContent} content\n   * @param {0|1|2} shouldRender - whether this should render or just result in a `retain` operation\n   */\n  readContent (contents, _client, clock, deleted, content, shouldRender) {\n    if (!deleted || shouldRender) {\n      contents.push(new AttributedContent(content, clock, deleted, null, shouldRender))\n    }\n  }\n\n  /**\n   * @param {Item} item\n   * @return {number}\n   */\n  contentLength (item) {\n    return (item.deleted || !item.content.isCountable()) ? 0 : item.length\n  }\n}\n\nexport const noAttributionsManager = new NoAttributionsManager()\n\n/**\n * @param {StructStore} store\n * @param {number} client\n * @param {number} clock\n * @param {number} len\n */\nconst getItemContent = (store, client, clock, len) => {\n  // Retrieved item is never more fragmented than the newer item.\n  const prevItem = getItem(store, createID(client, clock))\n  const diffStart = clock - prevItem.id.clock\n  let content = prevItem.length > 1 ? prevItem.content.copy() : prevItem.content\n  // trim itemContent to the correct size.\n  if (diffStart > 0) {\n    content = content.splice(diffStart)\n  }\n  if (len < content.getLength()) {\n    content.splice(len)\n  }\n  return content\n}\n\n/**\n * @param {Transaction?} tr - only specify this if you want to fill the content of deleted content\n * @param {DiffAttributionManager} am\n * @param {ID} start\n * @param {ID} end\n * @param {boolean} collectAll - collect as many items as possible. Accept adding redundant changes.\n */\nconst collectSuggestedChanges = (tr, am, start, end, collectAll) => {\n  const inserts = createIdSet()\n  const deletes = createIdSet()\n  const store = am._nextDoc.store\n  /**\n   * make sure to collect suggestions until all formats are closed\n   * @type {Set<string>}\n   */\n  const openedCollectedFormats = new Set()\n  /**\n   * @type {Item?}\n   */\n  let item = getItem(store, start)\n  const endItem = start === end ? item : (end == null ? null : getItem(store, end))\n\n  // walk to the left and find first un-attributed change that is rendered\n  while (item.left != null) {\n    item = item.left\n    if (item.content instanceof ContentFormat && item.content.value == null) {\n      item = item.right\n      break\n    }\n    if (!item.deleted) {\n      const slice = am.inserts.slice(item.id.client, item.id.clock, item.length)\n      if (slice.some(s => s.attrs === null)) {\n        for (let i = slice.length - 1; i >= 0; i--) {\n          const s = slice[i]\n          if (s.attrs == null) break\n          inserts.add(item.id.client, s.clock, s.len)\n        }\n        item = item.right\n        break\n      }\n    }\n  }\n  let foundEndItem = false\n  // eslint-disable-next-line\n  itemLoop: while (item != null) {\n    const itemClient = item.id.client\n    const slice = (item.deleted ? am.deletes : am.inserts).slice(itemClient, item.id.clock, item.length)\n    foundEndItem ||= item === endItem\n    if (item.deleted) {\n      // item probably gc'd content. Need to split item and fill with content again\n      for (let i = slice.length - 1; i >= 0; i--) {\n        const s = slice[i]\n        if (s.attrs != null || collectAll) {\n          deletes.add(itemClient, s.clock, s.len)\n          if (collectAll) {\n            // in case item has been added and deleted this might be necessary. the forked document\n            // will automatically filter this if it doesn't have it already.\n            inserts.add(itemClient, s.clock, s.len)\n          }\n        }\n        if (tr != null) {\n          const splicedItem = getItemCleanStart(tr, createID(itemClient, s.clock))\n          if (s.attrs != null) {\n            splicedItem.content = getItemContent(am._prevDocStore, itemClient, s.clock, s.len)\n          }\n        }\n      }\n    } else {\n      if (item.content instanceof ContentFormat) {\n        const { key, value } = item.content\n        if (value == null) {\n          openedCollectedFormats.delete(key)\n        } else {\n          openedCollectedFormats.add(key)\n        }\n      }\n      for (let i = 0; i < slice.length; i++) {\n        const s = slice[i]\n        if (s.attrs != null) {\n          inserts.add(itemClient, s.clock, s.len)\n        } else if (foundEndItem && openedCollectedFormats.size === 0) {\n          // eslint-disable-next-line\n          break itemLoop\n        }\n      }\n    }\n    item = item.right\n  }\n  return { inserts, deletes }\n}\n\n/**\n * @implements AbstractAttributionManager\n *\n * @extends {ObservableV2<{change:(idset:IdSet,origin:any,local:boolean)=>void}>}\n */\nexport class DiffAttributionManager extends ObservableV2 {\n  /**\n   * @param {Doc} prevDoc\n   * @param {Doc} nextDoc\n   * @param {Object} [options] - options for the attribution manager\n   * @param {Array<import('./IdMap.js').AttributionItem<any>>} [options.attrs] - the attributes to apply to the diff\n   */\n  constructor (prevDoc, nextDoc, { attrs = [] } = {}) {\n    super()\n    const _nextDocInserts = createInsertSetFromStructStore(nextDoc.store, false) // unmaintained\n    const _prevDocInserts = createInsertSetFromStructStore(prevDoc.store, false) // unmaintained\n    const nextDocDeletes = createDeleteSetFromStructStore(nextDoc.store) // maintained\n    const prevDocDeletes = createDeleteSetFromStructStore(prevDoc.store) // maintained\n    this.inserts = createIdMapFromIdSet(diffIdSet(_nextDocInserts, _prevDocInserts), attrs)\n    this.deletes = createIdMapFromIdSet(diffIdSet(nextDocDeletes, prevDocDeletes), attrs)\n    this._prevDoc = prevDoc\n    this._prevDocStore = prevDoc.store\n    this._nextDoc = nextDoc\n    // update before observer calls fired\n    this._nextBOH = nextDoc.on('beforeObserverCalls', tr => {\n      // update inserts\n      const diffInserts = diffIdSet(tr.insertSet, _prevDocInserts)\n      insertIntoIdMap(this.inserts, createIdMapFromIdSet(diffInserts, attrs))\n      // update deletes\n      const diffDeletes = diffIdSet(diffIdSet(tr.deleteSet, prevDocDeletes), this.inserts)\n      insertIntoIdMap(this.deletes, createIdMapFromIdSet(diffDeletes, attrs))\n      // @todo fire update ranges on `diffInserts` and `diffDeletes`\n    })\n    this._prevBOH = prevDoc.on('beforeObserverCalls', tr => {\n      insertIntoIdSet(_prevDocInserts, tr.insertSet)\n      insertIntoIdSet(prevDocDeletes, tr.deleteSet)\n      // insertIntoIdMap(this.inserts, createIdMapFromIdSet(intersectSets(tr.insertSet, this.inserts), [createAttributionItem('acceptInsert', 'unknown')]))\n      if (tr.insertSet.clients.size < 2) {\n        tr.insertSet.forEach((attrRange, client) => {\n          this.inserts.delete(client, attrRange.clock, attrRange.len)\n        })\n      } else {\n        this.inserts = diffIdMap(this.inserts, tr.insertSet)\n      }\n      // insertIntoIdMap(this.deletes, createIdMapFromIdSet(intersectSets(tr.deleteSet, this.deletes), [createAttributionItem('acceptDelete', 'unknown')]))\n      if (tr.deleteSet.clients.size < 2) {\n        tr.deleteSet.forEach((attrRange, client) => {\n          this.deletes.delete(client, attrRange.clock, attrRange.len)\n        })\n      } else {\n        this.deletes = diffIdMap(this.deletes, tr.deleteSet)\n      }\n      // fire event of \"changed\" attributions. exclude items that were added & deleted in the same\n      // transaction\n      this.emit('change', [diffIdSet(mergeIdSets([tr.insertSet, tr.deleteSet]), intersectSets(tr.insertSet, tr.deleteSet)), tr.origin, tr.local])\n    })\n    // changes from prevDoc should always flow into suggestionDoc\n    // changes from suggestionDoc only flow into ydoc if suggestion-mode is disabled\n    this._prevUpdateListener = prevDoc.on('update', (update, origin) => {\n      origin !== this && applyUpdate(nextDoc, update)\n    })\n    this._ndUpdateListener = nextDoc.on('update', (update, origin, _doc, tr) => {\n      // only if event is local and suggestion mode is enabled\n      if (!this.suggestionMode && tr.local && (this.suggestionOrigins == null || this.suggestionOrigins.some(o => o === origin))) {\n        applyUpdate(prevDoc, update, this)\n      }\n    })\n    this._afterTrListener = nextDoc.on('afterTransaction', (tr) => {\n      // apply deletes on attributed deletes (content that is already deleted, but is rendered by\n      // the attribution manager)\n      if (!this.suggestionMode && tr.local && (this.suggestionOrigins == null || this.suggestionOrigins.some(o => o === tr.origin))) {\n        const attributedDeletes = tr.meta.get('attributedDeletes')\n        if (attributedDeletes != null) {\n          transact(prevDoc, () => {\n            // apply attributed deletes if there are any\n            const ds = new UpdateEncoderV1()\n            encoding.writeVarUint(ds.restEncoder, 0) // encode 0 structs\n            writeIdSet(ds, attributedDeletes)\n            applyUpdate(prevDoc, ds.toUint8Array())\n          }, this)\n        }\n      }\n    })\n    this.suggestionMode = true\n    /**\n     * Optionally limit origins that may sync changes to the main doc if suggestion-mode is\n     * disabled.\n     *\n     * @type {Array<any>?}\n     */\n    this.suggestionOrigins = null\n    this._destroyHandler = nextDoc.on('destroy', this.destroy.bind(this))\n    prevDoc.on('destroy', this._destroyHandler)\n  }\n\n  destroy () {\n    super.destroy()\n    this._nextDoc.off('destroy', this._destroyHandler)\n    this._prevDoc.off('destroy', this._destroyHandler)\n    this._nextDoc.off('beforeObserverCalls', this._nextBOH)\n    this._prevDoc.off('beforeObserverCalls', this._prevBOH)\n    this._prevDoc.off('update', this._prevUpdateListener)\n    this._nextDoc.off('update', this._ndUpdateListener)\n    this._nextDoc.off('afterTransaction', this._afterTrListener)\n  }\n\n  acceptAllChanges () {\n    applyUpdate(this._prevDoc, encodeStateAsUpdate(this._nextDoc))\n  }\n\n  rejectAllChanges () {\n    this._prevDoc.transact(tr => {\n      applyUpdate(this._prevDoc, encodeStateAsUpdate(this._nextDoc))\n      const um = new UndoManager(this._prevDoc)\n      um.undoStack.push(new StackItem(tr.deleteSet, tr.insertSet))\n      um.undo()\n      um.destroy()\n    })\n  }\n\n  /**\n   * @param {ID} start\n   * @param {ID} end\n   */\n  acceptChanges (start, end = start) {\n    const { inserts, deletes } = collectSuggestedChanges(null, this, start, end, true)\n    const encoder = new UpdateEncoderV1()\n    writeStructsFromIdSet(encoder, this._nextDoc.store, inserts)\n    writeIdSet(encoder, deletes)\n    applyUpdate(this._prevDoc, encoder.toUint8Array())\n  }\n\n  /**\n   * @param {ID} start\n   * @param {ID} end\n   */\n  rejectChanges (start, end = start) {\n    this._nextDoc.transact(tr => {\n      const { inserts, deletes } = collectSuggestedChanges(tr, this, start, end, false)\n      const encoder = new UpdateEncoderV1()\n      writeStructsFromIdSet(encoder, this._nextDoc.store, inserts)\n      writeIdSet(encoder, deletes)\n      const um = new UndoManager(this._nextDoc)\n      um.undoStack.push(new StackItem(deletes, inserts))\n      um.undo()\n      um.destroy()\n    })\n    this.acceptChanges(start, end)\n  }\n\n  /**\n   * @param {Array<AttributedContent<any>>} contents - where to write the result\n   * @param {number} client\n   * @param {number} clock\n   * @param {boolean} deleted\n   * @param {AbstractContent} _content\n   * @param {0|1|2} shouldRender - whether this should render or just result in a `retain` operation\n   */\n  readContent (contents, client, clock, deleted, _content, shouldRender) {\n    const slice = (deleted ? this.deletes : this.inserts).slice(client, clock, _content.getLength())\n    /**\n     * @type {AbstractContent?}\n     */\n    let content = slice.length === 1 ? _content : _content.copy()\n    for (let i = 0; i < slice.length; i++) {\n      const s = slice[i]\n      if (content == null || content instanceof ContentDeleted) {\n        if ((!shouldRender && s.attrs == null) || this.inserts.has(client, s.clock)) {\n          continue\n        }\n        // Retrieved item is never more fragmented than the newer item.\n        const prevItem = getItem(this._prevDocStore, createID(client, s.clock))\n        const diffStart = s.clock - prevItem.id.clock\n        content = prevItem.length > 1 ? prevItem.content.copy() : prevItem.content\n        // trim itemContent to the correct size.\n        if (diffStart > 0) {\n          content = content.splice(diffStart)\n        }\n      }\n      const c = /** @type {AbstractContent} */ (content)\n      const clen = c.getLength()\n      if (clen < s.len) {\n        slice.splice(i + 1, 0, createMaybeAttrRange(s.clock + clen, s.len - clen, s.attrs))\n        s.len = clen\n      }\n      content = s.len < clen ? c.splice(s.len) : null\n      if (shouldRender || !deleted || s.attrs != null) {\n        contents.push(new AttributedContent(c, s.clock, deleted, s.attrs, shouldRender))\n      }\n    }\n  }\n\n  /**\n   * @param {Item} item\n   * @return {number}\n   */\n  contentLength (item) {\n    if (!item.deleted) {\n      return item.content.isCountable() ? item.length : 0\n    }\n    /**\n     * @type {Array<AttributedContent<any>>}\n     */\n    const cs = []\n    this.readContent(cs, item.id.client, item.id.clock, true, item.content, 0)\n    return cs.reduce((cnt, c) => cnt + ((c.attrs != null && c.content.isCountable()) ? c.content.getLength() : 0), 0)\n  }\n}\n\n/**\n * Attribute changes from ydoc1 to ydoc2.\n *\n * @param {Doc} prevDoc\n * @param {Doc} nextDoc\n * @param {Object} [options] - options for the attribution manager\n * @param {Array<import('./IdMap.js').AttributionItem<any>>} [options.attrs] - the attributes to apply to the diff\n */\nexport const createAttributionManagerFromDiff = (prevDoc, nextDoc, options) => new DiffAttributionManager(prevDoc, nextDoc, options)\n\n/**\n * Intended for projects that used the v13 snapshot feature. With this AttributionManager you can\n * read content similar to the previous snapshot api. Requires that `ydoc.gc` is turned off.\n *\n * @implements AbstractAttributionManager\n *\n * @extends {ObservableV2<{change:(idset:IdSet,origin:any,local:boolean)=>void}>}\n */\nexport class SnapshotAttributionManager extends ObservableV2 {\n  /**\n   * @param {Snapshot} prevSnapshot\n   * @param {Snapshot} nextSnapshot\n   * @param {Object} [options] - options for the attribution manager\n   * @param {Array<import('./IdMap.js').AttributionItem<any>>} [options.attrs] - the attributes to apply to the diff\n   */\n  constructor (prevSnapshot, nextSnapshot, { attrs = [] } = {}) {\n    super()\n    this.prevSnapshot = prevSnapshot\n    this.nextSnapshot = nextSnapshot\n    const inserts = createIdMap()\n    const deletes = createIdMapFromIdSet(diffIdSet(nextSnapshot.ds, prevSnapshot.ds), attrs)\n    nextSnapshot.sv.forEach((clock, client) => {\n      const prevClock = prevSnapshot.sv.get(client) || 0\n      inserts.add(client, 0, prevClock, []) // content is included in prevSnapshot is rendered without attributes\n      inserts.add(client, prevClock, clock - prevClock, attrs) // content is rendered as \"inserted\"\n    })\n    this.attrs = mergeIdMaps([diffIdMap(inserts, prevSnapshot.ds), deletes])\n  }\n\n  /**\n   * @param {Array<AttributedContent<any>>} contents - where to write the result\n   * @param {number} client\n   * @param {number} clock\n   * @param {boolean} _deleted\n   * @param {AbstractContent} content\n   * @param {0|1|2} shouldRender - whether this should render or just result in a `retain` operation\n   */\n  readContent (contents, client, clock, _deleted, content, shouldRender) {\n    if ((this.nextSnapshot.sv.get(client) ?? 0) <= clock) return // future item that should not be displayed\n    const slice = this.attrs.slice(client, clock, content.getLength())\n    content = slice.length === 1 ? content : content.copy()\n    slice.forEach(s => {\n      const deleted = this.nextSnapshot.ds.has(client, s.clock)\n      const nonExistend = (this.nextSnapshot.sv.get(client) ?? 0) <= s.clock\n      const c = content\n      if (s.len < c.getLength()) {\n        content = c.splice(s.len)\n      }\n      if (nonExistend) return\n      if (shouldRender || !deleted || (s.attrs != null && s.attrs.length > 0)) {\n        let attrsWithoutChange = s.attrs?.filter(attr => attr.name !== 'change') ?? null\n        if (s.attrs?.length === 0) {\n          attrsWithoutChange = null\n        }\n        contents.push(new AttributedContent(c, s.clock, deleted, attrsWithoutChange, shouldRender))\n      }\n    })\n  }\n\n  /**\n   * @param {Item} item\n   * @return {number}\n   */\n  contentLength (item) {\n    return item.content.isCountable()\n      ? (item.deleted\n          ? this.attrs.sliceId(item.id, item.length).reduce((len, s) => s.attrs != null ? len + s.len : len, 0)\n          : item.length\n        )\n      : 0\n  }\n}\n\n/**\n * @param {Snapshot} prevSnapshot\n * @param {Snapshot} nextSnapshot\n * @param {Object} [options] - options for the attribution manager\n * @param {Array<import('./IdMap.js').AttributionItem<any>>} [options.attrs] - the attributes to apply to the diff\n */\nexport const createAttributionManagerFromSnapshots = (prevSnapshot, nextSnapshot = prevSnapshot, options) => new SnapshotAttributionManager(prevSnapshot, nextSnapshot, options)\n","import {\n  createInsertSetFromStructStore,\n  createDeleteSetFromStructStore,\n  createAttributionManagerFromDiff,\n  diffIdSet,\n  mergeIdSets,\n  Item,\n  AbstractType, Doc, // eslint-disable-line\n  iterateStructsByIdSet\n} from '../internals.js'\nimport * as delta from 'lib0/delta'\nimport * as map from 'lib0/map'\nimport * as set from 'lib0/set'\n\n/**\n * @param {Doc} v1\n * @param {Doc} v2\n * @return {delta.DeltaBuilderAny}\n */\nexport const diffDocsToDelta = (v1, v2, { am = createAttributionManagerFromDiff(v1, v2) } = {}) => {\n  const d = delta.create()\n  v2.transact(tr => {\n    v2.share.forEach((type, typename) => {\n      const insertDiff = diffIdSet(createInsertSetFromStructStore(v2.store, false), createInsertSetFromStructStore(v1.store, false))\n      const deleteDiff = diffIdSet(createDeleteSetFromStructStore(v2.store), createDeleteSetFromStructStore(v1.store))\n      // don't render items that have been inserted and then deleted\n      const insertsOnly = diffIdSet(insertDiff, deleteDiff)\n      const deletesOnly = diffIdSet(deleteDiff, insertDiff)\n      const itemsToRender = mergeIdSets([insertsOnly, deleteDiff])\n      /**\n       * @type {Map<AbstractType, Set<string|null>>}\n       */\n      const changedTypes = new Map()\n      iterateStructsByIdSet(tr, itemsToRender, /** @param {any} item */ item => {\n        while (item instanceof Item) {\n          const parent = /** @type {AbstractType} */ (item.parent)\n          const conf = map.setIfUndefined(changedTypes, parent, set.create)\n          if (conf.has(item.parentSub)) break // has already been marked as modified\n          conf.add(item.parentSub)\n          item = parent._item\n        }\n      })\n      const typeConf = changedTypes.get(type)\n      if (typeConf) {\n        // @ts-ignore\n        const shareDelta = type.getContent(am, {\n          itemsToRender, retainDeletes: true, deletedItems: deletesOnly, modified: changedTypes, deep: true\n        })\n        d.update(typename, shareDelta)\n      }\n    })\n  })\n  return d\n}\n","import {\n  removeEventHandlerListener,\n  callEventHandlerListeners,\n  addEventHandlerListener,\n  createEventHandler,\n  getState,\n  isVisible,\n  ContentType,\n  createID,\n  ContentAny,\n  ContentFormat,\n  ContentBinary,\n  ContentJSON,\n  ContentDeleted,\n  ContentString,\n  ContentEmbed,\n  getItemCleanStart,\n  noAttributionsManager,\n  transact,\n  ItemTextListPosition,\n  insertText,\n  deleteText,\n  ContentDoc, UpdateEncoderV1, UpdateEncoderV2, Doc, Snapshot, Transaction, EventHandler, YEvent, Item, createAttributionFromAttributionItems, AbstractAttributionManager, YXmlElement, // eslint-disable-line\n} from '../internals.js'\n\nimport * as delta from 'lib0/delta'\nimport * as array from 'lib0/array'\nimport * as map from 'lib0/map'\nimport * as iterator from 'lib0/iterator'\nimport * as error from 'lib0/error'\nimport * as math from 'lib0/math'\nimport * as log from 'lib0/logging'\nimport * as object from 'lib0/object'\n\n/**\n * @typedef {import('../utils/types.js').YType} YType_\n */\n/**\n * @typedef {import('../utils/types.js').YValue} _YValue\n */\n\n/**\n * https://docs.yjs.dev/getting-started/working-with-shared-types#caveats\n */\nexport const warnPrematureAccess = () => { log.warn('Invalid access: Add Yjs type to a document before reading data.') }\n\nconst maxSearchMarker = 80\n\n/**\n * A unique timestamp that identifies each marker.\n *\n * Time is relative,.. this is more like an ever-increasing clock.\n *\n * @type {number}\n */\nlet globalSearchMarkerTimestamp = 0\n\nexport class ArraySearchMarker {\n  /**\n   * @param {Item} p\n   * @param {number} index\n   */\n  constructor (p, index) {\n    p.marker = true\n    this.p = p\n    this.index = index\n    this.timestamp = globalSearchMarkerTimestamp++\n  }\n}\n\n/**\n * @param {ArraySearchMarker} marker\n */\nconst refreshMarkerTimestamp = marker => { marker.timestamp = globalSearchMarkerTimestamp++ }\n\n/**\n * This is rather complex so this function is the only thing that should overwrite a marker\n *\n * @param {ArraySearchMarker} marker\n * @param {Item} p\n * @param {number} index\n */\nconst overwriteMarker = (marker, p, index) => {\n  marker.p.marker = false\n  marker.p = p\n  p.marker = true\n  marker.index = index\n  marker.timestamp = globalSearchMarkerTimestamp++\n}\n\n/**\n * @param {Array<ArraySearchMarker>} searchMarker\n * @param {Item} p\n * @param {number} index\n */\nconst markPosition = (searchMarker, p, index) => {\n  if (searchMarker.length >= maxSearchMarker) {\n    // override oldest marker (we don't want to create more objects)\n    const marker = searchMarker.reduce((a, b) => a.timestamp < b.timestamp ? a : b)\n    overwriteMarker(marker, p, index)\n    return marker\n  } else {\n    // create new marker\n    const pm = new ArraySearchMarker(p, index)\n    searchMarker.push(pm)\n    return pm\n  }\n}\n\n/**\n * Search marker help us to find positions in the associative array faster.\n *\n * They speed up the process of finding a position without much bookkeeping.\n *\n * A maximum of `maxSearchMarker` objects are created.\n *\n * This function always returns a refreshed marker (updated timestamp)\n *\n * @param {import('../utils/types.js').YType} yarray\n * @param {number} index\n */\nexport const findMarker = (yarray, index) => {\n  if (yarray._start === null || index === 0 || yarray._searchMarker === null) {\n    return null\n  }\n  const marker = yarray._searchMarker.length === 0 ? null : yarray._searchMarker.reduce((a, b) => math.abs(index - a.index) < math.abs(index - b.index) ? a : b)\n  let p = yarray._start\n  let pindex = 0\n  if (marker !== null) {\n    p = marker.p\n    pindex = marker.index\n    refreshMarkerTimestamp(marker) // we used it, we might need to use it again\n  }\n  // iterate to right if possible\n  while (p.right !== null && pindex < index) {\n    if (!p.deleted && p.countable) {\n      if (index < pindex + p.length) {\n        break\n      }\n      pindex += p.length\n    }\n    p = p.right\n  }\n  // iterate to left if necessary (might be that pindex > index)\n  while (p.left !== null && pindex > index) {\n    p = p.left\n    if (!p.deleted && p.countable) {\n      pindex -= p.length\n    }\n  }\n  // we want to make sure that p can't be merged with left, because that would screw up everything\n  // in that cas just return what we have (it is most likely the best marker anyway)\n  // iterate to left until p can't be merged with left\n  while (p.left !== null && p.left.id.client === p.id.client && p.left.id.clock + p.left.length === p.id.clock) {\n    p = p.left\n    if (!p.deleted && p.countable) {\n      pindex -= p.length\n    }\n  }\n\n  // @todo remove!\n  // assure position\n  // {\n  //   let start = yarray._start\n  //   let pos = 0\n  //   while (start !== p) {\n  //     if (!start.deleted && start.countable) {\n  //       pos += start.length\n  //     }\n  //     start = /** @type {Item} */ (start.right)\n  //   }\n  //   if (pos !== pindex) {\n  //     debugger\n  //     throw new Error('Gotcha position fail!')\n  //   }\n  // }\n  // if (marker) {\n  //   if (window.lengths == null) {\n  //     window.lengths = []\n  //     window.getLengths = () => window.lengths.sort((a, b) => a - b)\n  //   }\n  //   window.lengths.push(marker.index - pindex)\n  //   console.log('distance', marker.index - pindex, 'len', p && p.parent.length)\n  // }\n  if (marker !== null && math.abs(marker.index - pindex) < /** @type {any} */ (p.parent).length / maxSearchMarker) {\n    // adjust existing marker\n    overwriteMarker(marker, p, pindex)\n    return marker\n  } else {\n    // create new marker\n    return markPosition(yarray._searchMarker, p, pindex)\n  }\n}\n\n/**\n * Update markers when a change happened.\n *\n * This should be called before doing a deletion!\n *\n * @param {Array<ArraySearchMarker>} searchMarker\n * @param {number} index\n * @param {number} len If insertion, len is positive. If deletion, len is negative.\n */\nexport const updateMarkerChanges = (searchMarker, index, len) => {\n  for (let i = searchMarker.length - 1; i >= 0; i--) {\n    const m = searchMarker[i]\n    if (len > 0) {\n      /**\n       * @type {Item|null}\n       */\n      let p = m.p\n      p.marker = false\n      // Ideally we just want to do a simple position comparison, but this will only work if\n      // search markers don't point to deleted items for formats.\n      // Iterate marker to prev undeleted countable position so we know what to do when updating a position\n      while (p && (p.deleted || !p.countable)) {\n        p = p.left\n        if (p && !p.deleted && p.countable) {\n          // adjust position. the loop should break now\n          m.index -= p.length\n        }\n      }\n      if (p === null || p.marker === true) {\n        // remove search marker if updated position is null or if position is already marked\n        searchMarker.splice(i, 1)\n        continue\n      }\n      m.p = p\n      p.marker = true\n    }\n    if (index < m.index || (len > 0 && index === m.index)) { // a simple index <= m.index check would actually suffice\n      m.index = math.max(index, m.index + len)\n    }\n  }\n}\n\n/**\n * Accumulate all (list) children of a type and return them as an Array.\n *\n * @param {import('../utils/types.js').YType} t\n * @return {Array<Item>}\n */\nexport const getTypeChildren = t => {\n  t.doc ?? warnPrematureAccess()\n  let s = t._start\n  const arr = []\n  while (s) {\n    arr.push(s)\n    s = s.right\n  }\n  return arr\n}\n\n/**\n * Call event listeners with an event. This will also add an event to all\n * parents (for `.observeDeep` handlers).\n *\n * @param {import('../utils/types.js').YType} type\n * @param {Transaction} transaction\n  * @param {YEvent<any>} event\n */\nexport const callTypeObservers = (type, transaction, event) => {\n  const changedType = type\n  const changedParentTypes = transaction.changedParentTypes\n  while (true) {\n    // @ts-ignore\n    map.setIfUndefined(changedParentTypes, type, () => []).push(event)\n    if (type._item === null) {\n      break\n    }\n    type = /** @type {import('../utils/types.js').YType} */ (type._item.parent)\n  }\n  callEventHandlerListeners(/** @type {any} */ (changedType._eH), event, transaction)\n}\n\n/**\n * Abstract Yjs Type class\n * @template {delta.Delta<any,any,any,any,any>} [EventDelta=any]\n * @template {AbstractType<any,any>} [Self=any]\n */\nexport class AbstractType {\n  constructor () {\n    /**\n     * @type {Item|null}\n     */\n    this._item = null\n    /**\n     * @type {Map<string,Item>}\n     */\n    this._map = new Map()\n    /**\n     * @type {Item|null}\n     */\n    this._start = null\n    /**\n     * @type {Doc|null}\n     */\n    this.doc = null\n    this._length = 0\n    /**\n     * Event handlers\n     * @type {EventHandler<YEvent<Self>,Transaction>}\n     */\n    this._eH = createEventHandler()\n    /**\n     * Deep event handlers\n     * @type {EventHandler<Array<YEvent<any>>,Transaction>}\n     */\n    this._dEH = createEventHandler()\n    /**\n     * @type {null | Array<ArraySearchMarker>}\n     */\n    this._searchMarker = null\n    /**\n     * @type {EventDelta?}\n     */\n    this._prelim = null\n  }\n\n  /**\n   * Returns a fresh delta that can be used to change this YType.\n   * @type {EventDelta}\n   */\n  get change () {\n    return /** @type {any} */ (delta.create())\n  }\n\n  /**\n   * @return {import('../utils/types.js').YType|null}\n   */\n  get parent () {\n    return /** @type {import('../utils/types.js').YType} */ (this._item ? this._item.parent : null)\n  }\n\n  /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item|null} item\n   */\n  _integrate (y, item) {\n    this.doc = y\n    this._item = item\n    if (this._prelim) {\n      this.applyDelta(this._prelim)\n      this._prelim = null\n    }\n  }\n\n  /**\n   * @return {Self}\n   */\n  _copy () {\n    // @ts-ignore\n    return new this.constructor()\n  }\n\n  /**\n   * Makes a copy of this data type that can be included somewhere else.\n   *\n   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.\n   *\n   * @return {Self}\n   */\n  clone () {\n    // @todo remove this method from othern types by doing `_copy().apply(this.getContent())`\n    throw error.methodUnimplemented()\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} _encoder\n   */\n  _write (_encoder) { }\n\n  /**\n   * The first non-deleted item\n   */\n  get _first () {\n    let n = this._start\n    while (n !== null && n.deleted) {\n      n = n.right\n    }\n    return n\n  }\n\n  /**\n   * Creates YEvent and calls all type observers.\n   * Must be implemented by each type.\n   *\n   * @param {Transaction} transaction\n   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.\n   */\n  _callObserver (transaction, parentSubs) {\n    const event = new YEvent(/** @type {any} */ (this), transaction, parentSubs)\n    callTypeObservers(/** @type {any} */ (this), transaction, event)\n    if (!transaction.local && this._searchMarker) {\n      this._searchMarker.length = 0\n    }\n  }\n\n  /**\n   * Observe all events that are created on this type.\n   *\n   * @template {(target: YEvent<Self>, tr: Transaction) => void} F\n   * @param {F} f Observer function\n   * @return {F}\n   */\n  observe (f) {\n    addEventHandlerListener(this._eH, f)\n    return f\n  }\n\n  /**\n   * Observe all events that are created by this type and its children.\n   *\n   * @template {function(Array<YEvent<any>>,Transaction):void} F\n   * @param {F} f Observer function\n   * @return {F}\n   */\n  observeDeep (f) {\n    addEventHandlerListener(this._dEH, f)\n    return f\n  }\n\n  /**\n   * Unregister an observer function.\n   *\n   * @param {(type:YEvent<Self>,tr:Transaction)=>void} f Observer function\n   */\n  unobserve (f) {\n    removeEventHandlerListener(this._eH, f)\n  }\n\n  /**\n   * Unregister an observer function.\n   *\n   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function\n   */\n  unobserveDeep (f) {\n    removeEventHandlerListener(this._dEH, f)\n  }\n\n  /**\n   * @abstract\n   * @return {any}\n   */\n  toJSON () {}\n\n  /**\n   * Render the difference to another ydoc (which can be empty) and highlight the differences with\n   * attributions.\n   *\n   * Note that deleted content that was not deleted in prevYdoc is rendered as an insertion with the\n   * attribution `{ isDeleted: true, .. }`.\n   *\n   * @template {boolean} [Deep=false]\n   *\n   * @param {AbstractAttributionManager} am\n   * @param {Object} [opts]\n   * @param {import('../utils/IdSet.js').IdSet?} [opts.itemsToRender]\n   * @param {boolean} [opts.retainInserts] - if true, retain rendered inserts with attributions\n   * @param {boolean} [opts.retainDeletes] - if true, retain rendered+attributed deletes only\n   * @param {import('../utils/IdSet.js').IdSet?} [opts.deletedItems] - used for computing prevItem in attributes\n   * @param {Map<import('../utils/types.js').YType,Set<string|null>>|null} [opts.modified] - set of types that should be rendered as modified children\n   * @param {Deep} [opts.deep] - render child types as delta\n   * @return {Deep extends true ? ToDeepEventDelta<EventDelta> : EventDelta} The Delta representation of this type.\n   *\n   * @public\n   */\n  getContent (am = noAttributionsManager, opts = {}) {\n    const { itemsToRender = null, retainInserts = false, retainDeletes = false, deletedItems = null, modified = null, deep = false } = opts\n    const renderAttrs = modified?.get(this) || null\n    const renderChildren = (modified == null || opts.modified.get(this)?.has(null))\n    /**\n     * @type {EventDelta extends delta.Delta<infer N,infer Attrs,infer Children,infer Text,any> ? delta.DeltaBuilder<N,Attrs,Children,Text,any> : never}\n     */\n    const d = /** @type {any} */ (delta.create(/** @type {any} */ (this).nodeName || null))\n    const optsAll = modified == null ? opts : object.assign({}, opts, { modified: null })\n    typeMapGetDelta(d, /** @type {any} */ (this), renderAttrs, am, deep, modified, deletedItems, itemsToRender, opts, optsAll)\n    if (renderChildren) {\n      /**\n       * @type {delta.FormattingAttributes}\n       */\n      let currentAttributes = {} // saves all current attributes for insert\n      let usingCurrentAttributes = false\n      /**\n       * @type {delta.FormattingAttributes}\n       */\n      let changedAttributes = {} // saves changed attributes for retain\n      let usingChangedAttributes = false\n      /**\n       * Logic for formatting attribute attribution\n       * Everything that comes after an formatting attribute is formatted by the user that created it.\n       * Two exceptions:\n       * - the user resets formatting to the previously known formatting that is not attributed\n       * - the user deletes a formatting attribute and hence restores the previously known formatting\n       *   that is not attributed.\n       * @type {delta.FormattingAttributes}\n       */\n      const previousUnattributedAttributes = {} // contains previously known unattributed formatting\n      /**\n       * @type {delta.FormattingAttributes}\n       */\n      const previousAttributes = {} // The value before changes\n      /**\n       * @type {Array<import('../internals.js').AttributedContent<any>>}\n       */\n      const cs = []\n      for (let item = this._start; item !== null; cs.length = 0) {\n        if (itemsToRender != null) {\n          for (; item !== null && cs.length < 50; item = item.right) {\n            const rslice = itemsToRender.slice(item.id.client, item.id.clock, item.length)\n            let itemContent = rslice.length > 1 ? item.content.copy() : item.content\n            for (let ir = 0; ir < rslice.length; ir++) {\n              const idrange = rslice[ir]\n              const content = itemContent\n              if (ir !== rslice.length - 1) {\n                itemContent = itemContent.splice(idrange.len)\n              }\n              am.readContent(cs, item.id.client, idrange.clock, item.deleted, content, idrange.exists ? 2 : 0)\n            }\n          }\n        } else {\n          for (; item !== null && cs.length < 50; item = item.right) {\n            am.readContent(cs, item.id.client, item.id.clock, item.deleted, item.content, 1)\n          }\n        }\n        for (let i = 0; i < cs.length; i++) {\n          const c = cs[i]\n          // render (attributed) content even if it was deleted\n          const renderContent = c.render && (!c.deleted || c.attrs != null)\n          // content that was just deleted. It is not rendered as an insertion, because it doesn't\n          // have any attributes.\n          const renderDelete = c.render && c.deleted\n          // existing content that should be retained, only adding changed attributes\n          const retainContent = !c.render && (!c.deleted || c.attrs != null)\n          const attribution = (renderContent || c.content.constructor === ContentFormat) ? createAttributionFromAttributionItems(c.attrs, c.deleted) : null\n          switch (c.content.constructor) {\n            case ContentDeleted: {\n              if (renderDelete) d.delete(c.content.getLength())\n              break\n            }\n            case ContentString:\n              if (renderContent) {\n                d.usedAttributes = currentAttributes\n                usingCurrentAttributes = true\n                if (c.deleted ? retainDeletes : retainInserts) {\n                  d.retain(/** @type {ContentString} */ (c.content).str.length, null, attribution ?? {})\n                } else {\n                  d.insert(/** @type {ContentString} */ (c.content).str, null, attribution)\n                }\n              } else if (renderDelete) {\n                d.delete(c.content.getLength())\n              } else if (retainContent) {\n                d.usedAttributes = changedAttributes\n                usingChangedAttributes = true\n                d.retain(c.content.getLength())\n              }\n              break\n            case ContentEmbed:\n            case ContentAny:\n            case ContentJSON:\n            case ContentType:\n            case ContentBinary:\n              if (renderContent) {\n                d.usedAttributes = currentAttributes\n                usingCurrentAttributes = true\n                if (c.deleted ? retainDeletes : retainInserts) {\n                  d.retain(c.content.getLength(), null, attribution ?? {})\n                } else if (deep && c.content.constructor === ContentType) {\n                  d.insert([/** @type {any} */(c.content).type.getContent(am, optsAll)], null, attribution)\n                } else {\n                  d.insert(c.content.getContent(), null, attribution)\n                }\n              } else if (renderDelete) {\n                d.delete(1)\n              } else if (retainContent) {\n                if (c.content.constructor === ContentType && modified?.has(/** @type {ContentType} */ (c.content).type)) {\n                  // @todo use current transaction instead\n                  d.modify(/** @type {any} */ (c.content).type.getContent(am, opts))\n                } else {\n                  d.usedAttributes = changedAttributes\n                  usingChangedAttributes = true\n                  d.retain(1)\n                }\n              }\n              break\n            case ContentFormat: {\n              const { key, value } = /** @type {ContentFormat} */ (c.content)\n              const currAttrVal = currentAttributes[key] ?? null\n              if (attribution != null && (c.deleted || !object.hasProperty(previousUnattributedAttributes, key))) {\n                previousUnattributedAttributes[key] = c.deleted ? value : currAttrVal\n              }\n              // @todo write a function \"updateCurrentAttributes\" and \"updateChangedAttributes\"\n              // # Update Attributes\n              if (renderContent || renderDelete) {\n                // create fresh references\n                if (usingCurrentAttributes) {\n                  currentAttributes = object.assign({}, currentAttributes)\n                  usingCurrentAttributes = false\n                }\n                if (usingChangedAttributes) {\n                  usingChangedAttributes = false\n                  changedAttributes = object.assign({}, changedAttributes)\n                }\n              }\n              if (renderContent || renderDelete) {\n                if (c.deleted) {\n                  // content was deleted, but is possibly attributed\n                  if (!equalAttrs(value, currAttrVal)) { // do nothing if nothing changed\n                    if (equalAttrs(currAttrVal, previousAttributes[key] ?? null) && changedAttributes[key] !== undefined) {\n                      delete changedAttributes[key]\n                    } else {\n                      changedAttributes[key] = currAttrVal\n                    }\n                    // current attributes doesn't change\n                    previousAttributes[key] = value\n                  }\n                } else { // !c.deleted\n                  // content was inserted, and is possibly attributed\n                  if (equalAttrs(value, currAttrVal)) {\n                    // item.delete(transaction)\n                  } else if (equalAttrs(value, previousAttributes[key] ?? null)) {\n                    delete changedAttributes[key]\n                  } else {\n                    changedAttributes[key] = value\n                  }\n                  if (value == null) {\n                    delete currentAttributes[key]\n                  } else {\n                    currentAttributes[key] = value\n                  }\n                }\n              } else if (retainContent && !c.deleted) {\n                // fresh reference to currentAttributes only\n                if (usingCurrentAttributes) {\n                  currentAttributes = object.assign({}, currentAttributes)\n                  usingCurrentAttributes = false\n                }\n                if (usingChangedAttributes && changedAttributes[key] !== undefined) {\n                  usingChangedAttributes = false\n                  changedAttributes = object.assign({}, changedAttributes)\n                }\n                if (value == null) {\n                  delete currentAttributes[key]\n                } else {\n                  currentAttributes[key] = value\n                }\n                delete changedAttributes[key]\n                previousAttributes[key] = value\n              }\n              // # Update Attributions\n              if (attribution != null || object.hasProperty(previousUnattributedAttributes, key)) {\n                /**\n                 * @type {import('../utils/AttributionManager.js').Attribution}\n                 */\n                const formattingAttribution = object.assign({}, d.usedAttribution)\n                const changedAttributedAttributes = /** @type {{ [key: string]: Array<any> }} */ (formattingAttribution.format = object.assign({}, formattingAttribution.format ?? {}))\n                if (attribution == null || equalAttrs(previousUnattributedAttributes[key], currentAttributes[key] ?? null)) {\n                  // an unattributed formatting attribute was found or an attributed formatting\n                  // attribute was found that resets to the previous status\n                  delete changedAttributedAttributes[key]\n                  delete previousUnattributedAttributes[key]\n                } else {\n                  const by = changedAttributedAttributes[key] = (changedAttributedAttributes[key]?.slice() ?? [])\n                  by.push(...((c.deleted ? attribution.delete : attribution.insert) ?? []))\n                  const attributedAt = (c.deleted ? attribution.deletedAt : attribution.insertedAt)\n                  if (attributedAt) formattingAttribution.formatAt = attributedAt\n                }\n                if (object.isEmpty(changedAttributedAttributes)) {\n                  d.useAttribution(null)\n                } else if (attribution != null) {\n                  const attributedAt = (c.deleted ? attribution.deletedAt : attribution.insertedAt)\n                  if (attributedAt != null) formattingAttribution.formatAt = attributedAt\n                  d.useAttribution(formattingAttribution)\n                }\n              }\n              break\n            }\n          }\n        }\n      }\n    }\n    return /** @type {any} */ (d.done(false))\n  }\n\n  /**\n   * Render the difference to another ydoc (which can be empty) and highlight the differences with\n   * attributions.\n   *\n   * @param {AbstractAttributionManager} am\n   * @return {ToDeepEventDelta<EventDelta>}\n   */\n  getContentDeep (am = noAttributionsManager) {\n    return /** @type {any} */ (this.getContent(am, { deep: true }))\n  }\n\n  /**\n   * Apply a {@link Delta} on this shared type.\n   *\n   * @param {delta.Delta<any,any,any,any,any>} d The changes to apply on this element.\n   * @param {AbstractAttributionManager} am\n   *\n   * @public\n   */\n  applyDelta (d, am = noAttributionsManager) {\n    if (this.doc == null) {\n      (this._prelim || (this._prelim = /** @type {any} */ (delta.create()))).apply(d)\n    } else {\n      // @todo this was moved here from ytext. Make this more generic\n      transact(this.doc, transaction => {\n        const currPos = new ItemTextListPosition(null, this._start, 0, new Map(), am)\n        for (const op of d.children) {\n          if (delta.$textOp.check(op)) {\n            insertText(transaction, /** @type {any} */ (this), currPos, op.insert, op.format || {})\n          } else if (delta.$insertOp.check(op)) {\n            for (let i = 0; i < op.insert.length; i++) {\n              let ins = op.insert[i]\n              if (delta.$deltaAny.check(ins)) {\n                if (ins.name != null) {\n                  const t = new YXmlElement(ins.name)\n                  t.applyDelta(ins)\n                  ins = t\n                } else {\n                  error.unexpectedCase()\n                }\n              }\n              insertText(transaction, /** @type {any} */ (this), currPos, ins, op.format || {})\n            }\n          } else if (delta.$retainOp.check(op)) {\n            currPos.formatText(transaction, /** @type {any} */ (this), op.retain, op.format || {})\n          } else if (delta.$deleteOp.check(op)) {\n            deleteText(transaction, currPos, op.delete)\n          } else if (delta.$modifyOp.check(op)) {\n            if (currPos.right) {\n              /** @type {ContentType} */ (currPos.right.content).type.applyDelta(op.value)\n            } else {\n              error.unexpectedCase()\n            }\n            currPos.formatText(transaction, /** @type {any} */ (this), 1, op.format || {})\n          } else {\n            error.unexpectedCase()\n          }\n        }\n        for (const op of d.attrs) {\n          if (delta.$insertOp.check(op)) {\n            typeMapSet(transaction, /** @type {any} */ (this), op.key, op.value)\n          } else if (delta.$deleteOp.check(op)) {\n            typeMapDelete(transaction, /** @type {any} */ (this), op.key)\n          } else {\n            const sub = typeMapGet(/** @type {any} */ (this), op.key)\n            if (!(sub instanceof AbstractType)) {\n              error.unexpectedCase()\n            }\n            sub.applyDelta(op.value)\n          }\n        }\n      })\n    }\n  }\n}\n\n/**\n * @param {any} a\n * @param {any} b\n * @return {boolean}\n */\nexport const equalAttrs = (a, b) => a === b || (typeof a === 'object' && typeof b === 'object' && a && b && object.equalFlat(a, b))\n\n/**\n * @template {delta.Delta<any,any,any,any,any>} D\n * @typedef {D extends delta.Delta<infer N,infer Attrs,infer Cs,infer Text,any>\n *   ? delta.Delta<\n *       N,\n *       { [K in keyof Attrs]: TypeToDelta<Attrs[K]> },\n *       TypeToDelta<Cs>,\n *       Text\n *     >\n *   : D\n * } ToDeepEventDelta\n */\n\n/**\n * @template {any} T\n * @typedef {(Extract<T,AbstractType<any>> extends AbstractType<infer D> ? (unknown extends D ? never : ToDeepEventDelta<D>) : never) | Exclude<T,AbstractType<any>>} TypeToDelta\n */\n\n/**\n * @param {AbstractType<any>} type\n * @param {number} start\n * @param {number} end\n * @return {Array<any>}\n *\n * @private\n * @function\n */\nexport const typeListSlice = (type, start, end) => {\n  type.doc ?? warnPrematureAccess()\n  if (start < 0) {\n    start = type._length + start\n  }\n  if (end < 0) {\n    end = type._length + end\n  }\n  let len = end - start\n  const cs = []\n  let n = type._start\n  while (n !== null && len > 0) {\n    if (n.countable && !n.deleted) {\n      const c = n.content.getContent()\n      if (c.length <= start) {\n        start -= c.length\n      } else {\n        for (let i = start; i < c.length && len > 0; i++) {\n          cs.push(c[i])\n          len--\n        }\n        start = 0\n      }\n    }\n    n = n.right\n  }\n  return cs\n}\n\n/**\n * @param {import('../utils/types.js').YType} type\n * @return {Array<any>}\n *\n * @private\n * @function\n */\nexport const typeListToArray = type => {\n  type.doc ?? warnPrematureAccess()\n  const cs = []\n  let n = type._start\n  while (n !== null) {\n    if (n.countable && !n.deleted) {\n      const c = n.content.getContent()\n      for (let i = 0; i < c.length; i++) {\n        cs.push(c[i])\n      }\n    }\n    n = n.right\n  }\n  return cs\n}\n\n/**\n * @param {AbstractType<any>} type\n * @param {Snapshot} snapshot\n * @return {Array<any>}\n *\n * @private\n * @function\n */\nexport const typeListToArraySnapshot = (type, snapshot) => {\n  const cs = []\n  let n = type._start\n  while (n !== null) {\n    if (n.countable && isVisible(n, snapshot)) {\n      const c = n.content.getContent()\n      for (let i = 0; i < c.length; i++) {\n        cs.push(c[i])\n      }\n    }\n    n = n.right\n  }\n  return cs\n}\n\n/**\n * Executes a provided function on once on every element of this YArray.\n *\n * @param {AbstractType<any>} type\n * @param {function(any,number,any):void} f A function to execute on every element of this YArray.\n *\n * @private\n * @function\n */\nexport const typeListForEach = (type, f) => {\n  let index = 0\n  let n = type._start\n  type.doc ?? warnPrematureAccess()\n  while (n !== null) {\n    if (n.countable && !n.deleted) {\n      const c = n.content.getContent()\n      for (let i = 0; i < c.length; i++) {\n        f(c[i], index++, type)\n      }\n    }\n    n = n.right\n  }\n}\n\n/**\n * @template C,R\n * @param {AbstractType<any>} type\n * @param {function(C,number,AbstractType<any>):R} f\n * @return {Array<R>}\n *\n * @private\n * @function\n */\nexport const typeListMap = (type, f) => {\n  /**\n   * @type {Array<any>}\n   */\n  const result = []\n  typeListForEach(type, (c, i) => {\n    result.push(f(c, i, type))\n  })\n  return result\n}\n\n/**\n * @param {AbstractType} type\n * @return {IterableIterator<any>}\n *\n * @private\n * @function\n */\nexport const typeListCreateIterator = type => {\n  let n = type._start\n  /**\n   * @type {Array<any>|null}\n   */\n  let currentContent = null\n  let currentContentIndex = 0\n  return {\n    [Symbol.iterator] () {\n      return this\n    },\n    next: () => {\n      // find some content\n      if (currentContent === null) {\n        while (n !== null && n.deleted) {\n          n = n.right\n        }\n        // check if we reached the end, no need to check currentContent, because it does not exist\n        if (n === null) {\n          return {\n            done: true,\n            value: undefined\n          }\n        }\n        // we found n, so we can set currentContent\n        currentContent = n.content.getContent()\n        currentContentIndex = 0\n        n = n.right // we used the content of n, now iterate to next\n      }\n      const value = currentContent[currentContentIndex++]\n      // check if we need to empty currentContent\n      if (currentContent.length <= currentContentIndex) {\n        currentContent = null\n      }\n      return {\n        done: false,\n        value\n      }\n    }\n  }\n}\n\n/**\n * Executes a provided function on once on every element of this YArray.\n * Operates on a snapshotted state of the document.\n *\n * @param {AbstractType} type\n * @param {function(any,number,AbstractType):void} f A function to execute on every element of this YArray.\n * @param {Snapshot} snapshot\n *\n * @private\n * @function\n */\nexport const typeListForEachSnapshot = (type, f, snapshot) => {\n  let index = 0\n  let n = type._start\n  while (n !== null) {\n    if (n.countable && isVisible(n, snapshot)) {\n      const c = n.content.getContent()\n      for (let i = 0; i < c.length; i++) {\n        f(c[i], index++, type)\n      }\n    }\n    n = n.right\n  }\n}\n\n/**\n * @param {import('../utils/types.js').YType} type\n * @param {number} index\n * @return {any}\n *\n * @private\n * @function\n */\nexport const typeListGet = (type, index) => {\n  type.doc ?? warnPrematureAccess()\n  const marker = findMarker(type, index)\n  let n = type._start\n  if (marker !== null) {\n    n = marker.p\n    index -= marker.index\n  }\n  for (; n !== null; n = n.right) {\n    if (!n.deleted && n.countable) {\n      if (index < n.length) {\n        return n.content.getContent()[index]\n      }\n      index -= n.length\n    }\n  }\n}\n\n/**\n * @param {Transaction} transaction\n * @param {YType_} parent\n * @param {Item?} referenceItem\n * @param {Array<_YValue>} content\n *\n * @private\n * @function\n */\nexport const typeListInsertGenericsAfter = (transaction, parent, referenceItem, content) => {\n  let left = referenceItem\n  const doc = transaction.doc\n  const ownClientId = doc.clientID\n  const store = doc.store\n  const right = referenceItem === null ? parent._start : referenceItem.right\n  /**\n   * @type {Array<Object|Array<any>|number|null>}\n   */\n  let jsonContent = []\n  const packJsonContent = () => {\n    if (jsonContent.length > 0) {\n      left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentAny(jsonContent))\n      left.integrate(transaction, 0)\n      jsonContent = []\n    }\n  }\n  content.forEach(c => {\n    if (c === null) {\n      jsonContent.push(c)\n    } else {\n      switch (c.constructor) {\n        case Number:\n        case Object:\n        case undefined:\n        case Boolean:\n        case Array:\n        case String:\n        case BigInt:\n        case Date:\n          jsonContent.push(c)\n          break\n        default:\n          packJsonContent()\n          switch (c.constructor) {\n            case Uint8Array:\n            case ArrayBuffer:\n              left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentBinary(new Uint8Array(/** @type {Uint8Array} */ (c))))\n              left.integrate(transaction, 0)\n              break\n            case Doc:\n              left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentDoc(/** @type {Doc} */ (c)))\n              left.integrate(transaction, 0)\n              break\n            default:\n              if (c instanceof AbstractType) {\n                left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentType(/** @type {any} */ (c)))\n                left.integrate(transaction, 0)\n              } else {\n                throw new Error('Unexpected content type in insert operation')\n              }\n          }\n      }\n    }\n  })\n  packJsonContent()\n}\n\nconst lengthExceeded = () => error.create('Length exceeded!')\n\n/**\n * @param {Transaction} transaction\n * @param {YType_} parent\n * @param {number} index\n * @param {Array<Object<string,any>|Array<any>|number|null|string|Uint8Array>} content\n *\n * @private\n * @function\n */\nexport const typeListInsertGenerics = (transaction, parent, index, content) => {\n  if (index > parent._length) {\n    throw lengthExceeded()\n  }\n  if (index === 0) {\n    if (parent._searchMarker) {\n      updateMarkerChanges(parent._searchMarker, index, content.length)\n    }\n    return typeListInsertGenericsAfter(transaction, parent, null, content)\n  }\n  const startIndex = index\n  const marker = findMarker(parent, index)\n  let n = parent._start\n  if (marker !== null) {\n    n = marker.p\n    index -= marker.index\n    // we need to iterate one to the left so that the algorithm works\n    if (index === 0) {\n      // @todo refactor this as it actually doesn't consider formats\n      n = n.prev // important! get the left undeleted item so that we can actually decrease index\n      index += (n && n.countable && !n.deleted) ? n.length : 0\n    }\n  }\n  for (; n !== null; n = n.right) {\n    if (!n.deleted && n.countable) {\n      if (index <= n.length) {\n        if (index < n.length) {\n          // insert in-between\n          getItemCleanStart(transaction, createID(n.id.client, n.id.clock + index))\n        }\n        break\n      }\n      index -= n.length\n    }\n  }\n  if (parent._searchMarker) {\n    updateMarkerChanges(parent._searchMarker, startIndex, content.length)\n  }\n  return typeListInsertGenericsAfter(transaction, parent, n, content)\n}\n\n/**\n * Pushing content is special as we generally want to push after the last item. So we don't have to update\n * the search marker.\n *\n * @param {Transaction} transaction\n * @param {YType_} parent\n * @param {Array<Object<string,any>|Array<any>|number|null|string|Uint8Array>} content\n *\n * @private\n * @function\n */\nexport const typeListPushGenerics = (transaction, parent, content) => {\n  // Use the marker with the highest index and iterate to the right.\n  const marker = (parent._searchMarker || []).reduce((maxMarker, currMarker) => currMarker.index > maxMarker.index ? currMarker : maxMarker, { index: 0, p: parent._start })\n  let n = marker.p\n  if (n) {\n    while (n.right) {\n      n = n.right\n    }\n  }\n  return typeListInsertGenericsAfter(transaction, parent, n, content)\n}\n\n/**\n * @param {Transaction} transaction\n * @param {import('../utils/types.js').YType} parent\n * @param {number} index\n * @param {number} length\n *\n * @private\n * @function\n */\nexport const typeListDelete = (transaction, parent, index, length) => {\n  if (length === 0) { return }\n  const startIndex = index\n  const startLength = length\n  const marker = findMarker(parent, index)\n  let n = parent._start\n  if (marker !== null) {\n    n = marker.p\n    index -= marker.index\n  }\n  // compute the first item to be deleted\n  for (; n !== null && index > 0; n = n.right) {\n    if (!n.deleted && n.countable) {\n      if (index < n.length) {\n        getItemCleanStart(transaction, createID(n.id.client, n.id.clock + index))\n      }\n      index -= n.length\n    }\n  }\n  // delete all items until done\n  while (length > 0 && n !== null) {\n    if (!n.deleted) {\n      if (length < n.length) {\n        getItemCleanStart(transaction, createID(n.id.client, n.id.clock + length))\n      }\n      n.delete(transaction)\n      length -= n.length\n    }\n    n = n.right\n  }\n  if (length > 0) {\n    throw lengthExceeded()\n  }\n  if (parent._searchMarker) {\n    updateMarkerChanges(parent._searchMarker, startIndex, -startLength + length /* in case we remove the above exception */)\n  }\n}\n\n/**\n * @param {Transaction} transaction\n * @param {YType_} parent\n * @param {string} key\n *\n * @private\n * @function\n */\nexport const typeMapDelete = (transaction, parent, key) => {\n  const c = parent._map.get(key)\n  if (c !== undefined) {\n    c.delete(transaction)\n  }\n}\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType} parent\n * @param {string} key\n * @param {_YValue} value\n *\n * @private\n * @function\n */\nexport const typeMapSet = (transaction, parent, key, value) => {\n  const left = parent._map.get(key) || null\n  const doc = transaction.doc\n  const ownClientId = doc.clientID\n  let content\n  if (value == null) {\n    content = new ContentAny([value])\n  } else {\n    switch (value.constructor) {\n      case Number:\n      case Object:\n      case Boolean:\n      case Array:\n      case String:\n      case Date:\n      case BigInt:\n        content = new ContentAny([value])\n        break\n      case Uint8Array:\n        content = new ContentBinary(/** @type {Uint8Array} */ (value))\n        break\n      case Doc:\n        content = new ContentDoc(/** @type {Doc} */ (value))\n        break\n      default:\n        if (value instanceof AbstractType) {\n          content = new ContentType(/** @type {any} */ (value))\n        } else {\n          throw new Error('Unexpected content type')\n        }\n    }\n  }\n  new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left && left.lastId, null, null, parent, key, content).integrate(transaction, 0)\n}\n\n/**\n * @param {AbstractType<any,any>} parent\n * @param {string} key\n * @return {Object<string,any>|number|null|Array<any>|string|Uint8Array|AbstractType<any>|undefined}\n *\n * @private\n * @function\n */\nexport const typeMapGet = (parent, key) => {\n  parent.doc ?? warnPrematureAccess()\n  const val = parent._map.get(key)\n  return val !== undefined && !val.deleted ? val.content.getContent()[val.length - 1] : undefined\n}\n\n/**\n * @param {AbstractType<any>} parent\n * @return {Object<string,Object<string,any>|number|null|Array<any>|string|Uint8Array|AbstractType<any>|undefined>}\n *\n * @private\n * @function\n */\nexport const typeMapGetAll = (parent) => {\n  /**\n   * @type {Object<string,any>}\n   */\n  const res = {}\n  parent.doc ?? warnPrematureAccess()\n  parent._map.forEach((value, key) => {\n    if (!value.deleted) {\n      res[key] = value.content.getContent()[value.length - 1]\n    }\n  })\n  return res\n}\n\n/**\n * @todo move this to getContent/getDelta\n *\n * Render the difference to another ydoc (which can be empty) and highlight the differences with\n * attributions.\n *\n * Note that deleted content that was not deleted in prevYdoc is rendered as an insertion with the\n * attribution `{ isDeleted: true, .. }`.\n *\n * @template {delta.DeltaBuilder<any,any,any,any>} TypeDelta\n * @param {TypeDelta} d\n * @param {YType_} parent\n * @param {Set<string|null>?} attrsToRender\n * @param {import('../internals.js').AbstractAttributionManager} am\n * @param {boolean} deep\n * @param {Set<import('../utils/types.js').YType>|Map<import('../utils/types.js').YType,any>|null} [modified] - set of types that should be rendered as modified children\n * @param {import('../utils/IdSet.js').IdSet?} [deletedItems]\n * @param {import('../utils/IdSet.js').IdSet?} [itemsToRender]\n * @param {any} [opts]\n * @param {any} [optsAll]\n *\n * @private\n * @function\n */\nexport const typeMapGetDelta = (d, parent, attrsToRender, am, deep, modified, deletedItems, itemsToRender, opts, optsAll) => {\n  // @todo support modified ops!\n  /**\n   * @param {Item} item\n   * @param {string} key\n   */\n  const renderAttrs = (item, key) => {\n    /**\n     * @type {Array<import('../internals.js').AttributedContent<any>>}\n     */\n    const cs = []\n    am.readContent(cs, item.id.client, item.id.clock, item.deleted, item.content, 1)\n    const { deleted, attrs, content } = cs[cs.length - 1]\n    const attribution = createAttributionFromAttributionItems(attrs, deleted)\n    let c = array.last(content.getContent())\n    if (deleted) {\n      if (itemsToRender == null || itemsToRender.hasId(item.lastId)) {\n        d.unset(key, attribution, c)\n      }\n    } else if (deep && c instanceof AbstractType && modified?.has(c)) {\n      d.update(key, c.getContent(am, opts))\n    } else {\n      // find prev content\n      let prevContentItem = item\n      // this algorithm is problematic. should check all previous content using am.readcontent\n      for (; prevContentItem.left !== null && deletedItems?.hasId(prevContentItem.left.lastId); prevContentItem = prevContentItem.left) {\n        // nop\n      }\n      const prevValue = (prevContentItem !== item && itemsToRender?.hasId(prevContentItem.lastId)) ? array.last(prevContentItem.content.getContent()) : undefined\n      if (deep && c instanceof AbstractType) {\n        c = /** @type {any} */(c).getContent(am, optsAll)\n      }\n      d.set(key, c, attribution, prevValue)\n    }\n  }\n  if (attrsToRender == null) {\n    parent._map.forEach(renderAttrs)\n  } else {\n    attrsToRender.forEach(key => key != null && renderAttrs(/** @type {Item} */ (parent._map.get(key)), key))\n  }\n}\n\n/**\n * @param {AbstractType<any>} parent\n * @param {string} key\n * @return {boolean}\n *\n * @private\n * @function\n */\nexport const typeMapHas = (parent, key) => {\n  parent.doc ?? warnPrematureAccess()\n  const val = parent._map.get(key)\n  return val !== undefined && !val.deleted\n}\n\n/**\n * @param {AbstractType<any>} parent\n * @param {string} key\n * @param {Snapshot} snapshot\n * @return {Object<string,any>|number|null|Array<any>|string|Uint8Array|AbstractType<any>|undefined}\n *\n * @private\n * @function\n */\nexport const typeMapGetSnapshot = (parent, key, snapshot) => {\n  let v = parent._map.get(key) || null\n  while (v !== null && (!snapshot.sv.has(v.id.client) || v.id.clock >= (snapshot.sv.get(v.id.client) || 0))) {\n    v = v.left\n  }\n  return v !== null && isVisible(v, snapshot) ? v.content.getContent()[v.length - 1] : undefined\n}\n\n/**\n * @param {AbstractType<any>} parent\n * @param {Snapshot} snapshot\n * @return {Object<string,Object<string,any>|number|null|Array<any>|string|Uint8Array|AbstractType<any>|undefined>}\n *\n * @private\n * @function\n */\nexport const typeMapGetAllSnapshot = (parent, snapshot) => {\n  /**\n   * @type {Object<string,any>}\n   */\n  const res = {}\n  parent._map.forEach((value, key) => {\n    /**\n     * @type {Item|null}\n     */\n    let v = value\n    while (v !== null && (!snapshot.sv.has(v.id.client) || v.id.clock >= (snapshot.sv.get(v.id.client) || 0))) {\n      v = v.left\n    }\n    if (v !== null && isVisible(v, snapshot)) {\n      res[key] = v.content.getContent()[v.length - 1]\n    }\n  })\n  return res\n}\n\n/**\n * @param {AbstractType<any> & { _map: Map<string, Item> }} type\n * @return {IterableIterator<Array<any>>}\n *\n * @private\n * @function\n */\nexport const createMapIterator = type => {\n  type.doc ?? warnPrematureAccess()\n  return iterator.iteratorFilter(type._map.entries(), /** @param {any} entry */ entry => !entry[1].deleted)\n}\n","/**\n * @module YArray\n */\n\nimport {\n  AbstractType,\n  typeListGet,\n  typeListToArray,\n  typeListForEach,\n  typeListCreateIterator,\n  typeListInsertGenerics,\n  typeListPushGenerics,\n  typeListDelete,\n  typeListMap,\n  YArrayRefID,\n  transact,\n  warnPrematureAccess,\n  typeListSlice,\n  noAttributionsManager,\n  AbstractAttributionManager, ArraySearchMarker, UpdateDecoderV1, UpdateDecoderV2, UpdateEncoderV1, UpdateEncoderV2, Doc, Transaction, Item // eslint-disable-line\n} from '../internals.js'\n\nimport * as delta from 'lib0/delta' // eslint-disable-line\n\n/**\n * A shared Array implementation.\n * @template {import('../utils/types.js').YValue} T\n * @extends {AbstractType<delta.ArrayDelta<T>,YArray<T>>}\n * @implements {Iterable<T>}\n */\n// @todo remove this\n// @ts-ignore\nexport class YArray extends AbstractType {\n  constructor () {\n    super()\n    /**\n     * @type {Array<any>?}\n     * @private\n     */\n    this._prelimContent = []\n    /**\n     * @type {Array<ArraySearchMarker>}\n     */\n    this._searchMarker = []\n  }\n\n  /**\n   * Construct a new YArray containing the specified items.\n   * @template {import('../utils/types.js').YValue} T\n   * @param {Array<T>} items\n   * @return {YArray<T>}\n   */\n  static from (items) {\n    /**\n     * @type {YArray<T>}\n     */\n    const a = new YArray()\n    a.push(items)\n    return a\n  }\n\n  /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item?} item\n   */\n  _integrate (y, item) {\n    super._integrate(y, item)\n    this.insert(0, /** @type {Array<any>} */ (this._prelimContent))\n    this._prelimContent = null\n  }\n\n  /**\n   * Makes a copy of this data type that can be included somewhere else.\n   *\n   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.\n   *\n   * @return {YArray<T>}\n   */\n  clone () {\n    /**\n     * @type {this}\n     */\n    const arr = /** @type {this} */ (new YArray())\n    arr.insert(0, this.toArray().map(el =>\n      // @ts-ignore\n      el instanceof AbstractType ? /** @type {any} */ (el.clone()) : el\n    ))\n    return arr\n  }\n\n  get length () {\n    this.doc ?? warnPrematureAccess()\n    return this._length\n  }\n\n  /**\n   * Inserts new content at an index.\n   *\n   * Important: This function expects an array of content. Not just a content\n   * object. The reason for this \"weirdness\" is that inserting several elements\n   * is very efficient when it is done as a single operation.\n   *\n   * @example\n   *  // Insert character 'a' at position 0\n   *  yarray.insert(0, ['a'])\n   *  // Insert numbers 1, 2 at position 1\n   *  yarray.insert(1, [1, 2])\n   *\n   * @param {number} index The index to insert content at.\n   * @param {Array<T>} content The array of content\n   */\n  insert (index, content) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeListInsertGenerics(transaction, this, index, /** @type {any} */ (content))\n      })\n    } else {\n      /** @type {Array<any>} */ (this._prelimContent).splice(index, 0, ...content)\n    }\n  }\n\n  /**\n   * Appends content to this YArray.\n   *\n   * @param {Array<T>} content Array of content to append.\n   *\n   * @todo Use the following implementation in all types.\n   */\n  push (content) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeListPushGenerics(transaction, this, /** @type {any} */ (content))\n      })\n    } else {\n      /** @type {Array<any>} */ (this._prelimContent).push(...content)\n    }\n  }\n\n  /**\n   * Prepends content to this YArray.\n   *\n   * @param {Array<T>} content Array of content to prepend.\n   */\n  unshift (content) {\n    this.insert(0, content)\n  }\n\n  /**\n   * Deletes elements starting from an index.\n   *\n   * @param {number} index Index at which to start deleting elements\n   * @param {number} length The number of elements to remove. Defaults to 1.\n   */\n  delete (index, length = 1) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeListDelete(transaction, this, index, length)\n      })\n    } else {\n      /** @type {Array<any>} */ (this._prelimContent).splice(index, length)\n    }\n  }\n\n  /**\n   * Returns the i-th element from a YArray.\n   *\n   * @param {number} index The index of the element to return from the YArray\n   * @return {T}\n   */\n  get (index) {\n    return typeListGet(this, index)\n  }\n\n  /**\n   * Transforms this YArray to a JavaScript Array.\n   *\n   * @return {Array<T>}\n   */\n  toArray () {\n    return typeListToArray(this)\n  }\n\n  /**\n   * Render the difference to another ydoc (which can be empty) and highlight the differences with\n   * attributions.\n   *\n   * Note that deleted content that was not deleted in prevYdoc is rendered as an insertion with the\n   * attribution `{ isDeleted: true, .. }`.\n   *\n   * @param {AbstractAttributionManager} am\n   * @return {delta.ArrayDelta<import('./AbstractType.js').TypeToDelta<T>>} The Delta representation of this type.\n   *\n   * @public\n   */\n  getContentDeep (am = noAttributionsManager) {\n    return super.getContentDeep(am)\n  }\n\n  /**\n   * Returns a portion of this YArray into a JavaScript Array selected\n   * from start to end (end not included).\n   *\n   * @param {number} [start]\n   * @param {number} [end]\n   * @return {Array<T>}\n   */\n  slice (start = 0, end = this.length) {\n    return typeListSlice(this, start, end)\n  }\n\n  /**\n   * Transforms this Shared Type to a JSON object.\n   *\n   * @return {Array<any>}\n   */\n  toJSON () {\n    return this.map(c => c instanceof AbstractType ? c.toJSON() : c)\n  }\n\n  /**\n   * Returns an Array with the result of calling a provided function on every\n   * element of this YArray.\n   *\n   * @template M\n   * @param {function(T,number,YArray<T>):M} f Function that produces an element of the new Array\n   * @return {Array<M>} A new array with each element being the result of the\n   *                 callback function\n   */\n  map (f) {\n    return typeListMap(this, /** @type {any} */ (f))\n  }\n\n  /**\n   * Executes a provided function once on every element of this YArray.\n   *\n   * @param {function(T,number,YArray<T>):void} f A function to execute on every element of this YArray.\n   */\n  forEach (f) {\n    typeListForEach(this, f)\n  }\n\n  /**\n   * @return {IterableIterator<T>}\n   */\n  [Symbol.iterator] () {\n    return typeListCreateIterator(this)\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YArrayRefID)\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} _decoder\n * @return {import('../utils/types.js').YType}\n *\n * @private\n * @function\n */\nexport const readYArray = _decoder => new YArray()\n","/**\n * @module YMap\n */\n\nimport {\n  AbstractType,\n  typeMapDelete,\n  typeMapSet,\n  typeMapGet,\n  typeMapHas,\n  createMapIterator,\n  YMapRefID,\n  transact,\n  warnPrematureAccess,\n  UpdateDecoderV1, UpdateDecoderV2, UpdateEncoderV1, UpdateEncoderV2, Doc, Item // eslint-disable-line\n} from '../internals.js'\n\nimport * as iterator from 'lib0/iterator'\nimport * as delta from 'lib0/delta' // eslint-disable-line\n\n/**\n * @template MapType\n * A shared Map implementation.\n *\n * @extends AbstractType<delta.MapDelta<{[K in string]:MapType}>>\n * @implements {Iterable<[string, MapType]>}\n */\nexport class YMap extends AbstractType {\n  /**\n   *\n   * @param {Iterable<readonly [string, any]>=} entries - an optional iterable to initialize the YMap\n   */\n  constructor (entries) {\n    super()\n    /**\n     * @type {Map<string,any>?}\n     * @private\n     */\n    this._prelimContent = null\n\n    if (entries === undefined) {\n      this._prelimContent = new Map()\n    } else {\n      this._prelimContent = new Map(entries)\n    }\n  }\n\n  /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item?} item\n   */\n  _integrate (y, item) {\n    super._integrate(y, item)\n    ;/** @type {Map<string, any>} */ (this._prelimContent).forEach((value, key) => {\n      this.set(key, value)\n    })\n    this._prelimContent = null\n  }\n\n  /**\n   * Makes a copy of this data type that can be included somewhere else.\n   *\n   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.\n   *\n   * @return {this}\n   */\n  clone () {\n    const map = this._copy()\n    this.forEach((value, key) => {\n      map.set(key, value instanceof AbstractType ? /** @type {typeof value} */ (value.clone()) : value)\n    })\n    return map\n  }\n\n  /**\n   * Transforms this Shared Type to a JSON object.\n   *\n   * @return {Object<string,any>}\n   */\n  toJSON () {\n    this.doc ?? warnPrematureAccess()\n    /**\n     * @type {Object<string,MapType>}\n     */\n    const map = {}\n    this._map.forEach((item, key) => {\n      if (!item.deleted) {\n        const v = item.content.getContent()[item.length - 1]\n        map[key] = v instanceof AbstractType ? v.toJSON() : v\n      }\n    })\n    return map\n  }\n\n  /**\n   * Returns the size of the YMap (count of key/value pairs)\n   *\n   * @return {number}\n   */\n  get size () {\n    return [...createMapIterator(this)].length\n  }\n\n  /**\n   * Returns the keys for each element in the YMap Type.\n   *\n   * @return {IterableIterator<string>}\n   */\n  keys () {\n    return iterator.iteratorMap(createMapIterator(this), /** @param {any} v */ v => v[0])\n  }\n\n  /**\n   * Returns the values for each element in the YMap Type.\n   *\n   * @return {IterableIterator<MapType>}\n   */\n  values () {\n    return iterator.iteratorMap(createMapIterator(this), /** @param {any} v */ v => v[1].content.getContent()[v[1].length - 1])\n  }\n\n  /**\n   * Returns an Iterator of [key, value] pairs\n   *\n   * @return {IterableIterator<[string, MapType]>}\n   */\n  entries () {\n    return iterator.iteratorMap(createMapIterator(this), /** @param {any} v */ v => /** @type {any} */ ([v[0], v[1].content.getContent()[v[1].length - 1]]))\n  }\n\n  /**\n   * Executes a provided function on once on every key-value pair.\n   *\n   * @param {function(MapType,string,YMap<MapType>):void} f A function to execute on every element of this YArray.\n   */\n  forEach (f) {\n    this.doc ?? warnPrematureAccess()\n    this._map.forEach((item, key) => {\n      if (!item.deleted) {\n        f(item.content.getContent()[item.length - 1], key, this)\n      }\n    })\n  }\n\n  /**\n   * Returns an Iterator of [key, value] pairs\n   *\n   * @return {IterableIterator<[string, MapType]>}\n   */\n  [Symbol.iterator] () {\n    return this.entries()\n  }\n\n  /**\n   * Remove a specified element from this YMap.\n   *\n   * @param {string} key The key of the element to remove.\n   */\n  delete (key) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeMapDelete(transaction, this, key)\n      })\n    } else {\n      /** @type {Map<string, any>} */ (this._prelimContent).delete(key)\n    }\n  }\n\n  /**\n   * Adds or updates an element with a specified key and value.\n   * @template {MapType} VAL\n   *\n   * @param {string} key The key of the element to add to this YMap\n   * @param {VAL} value The value of the element to add\n   * @return {VAL}\n   */\n  set (key, value) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeMapSet(transaction, this, key, /** @type {any} */ (value))\n      })\n    } else {\n      /** @type {Map<string, any>} */ (this._prelimContent).set(key, value)\n    }\n    return value\n  }\n\n  /**\n   * Returns a specified element from this YMap.\n   *\n   * @param {string} key\n   * @return {MapType|undefined}\n   */\n  get (key) {\n    return /** @type {any} */ (typeMapGet(this, key))\n  }\n\n  /**\n   * Returns a boolean indicating whether the specified key exists or not.\n   *\n   * @param {string} key The key to test.\n   * @return {boolean}\n   */\n  has (key) {\n    return typeMapHas(this, key)\n  }\n\n  /**\n   * Removes all elements from this YMap.\n   */\n  clear () {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        this.forEach(function (_value, key, map) {\n          typeMapDelete(transaction, map, key)\n        })\n      })\n    } else {\n      /** @type {Map<string, any>} */ (this._prelimContent).clear()\n    }\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YMapRefID)\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} _decoder\n * @return {import('../utils/types.js').YType}\n *\n * @private\n * @function\n */\nexport const readYMap = _decoder => new YMap()\n","/**\n * @module YText\n */\n\nimport {\n  AbstractType,\n  getItemCleanStart,\n  getState,\n  createID,\n  YTextRefID,\n  transact,\n  ContentEmbed,\n  GC,\n  ContentFormat,\n  ContentString,\n  iterateStructsByIdSet,\n  findMarker,\n  typeMapDelete,\n  typeMapSet,\n  typeMapGet,\n  typeMapGetAll,\n  updateMarkerChanges,\n  ContentType,\n  warnPrematureAccess,\n  noAttributionsManager, AbstractAttributionManager, ArraySearchMarker, UpdateDecoderV1, UpdateDecoderV2, UpdateEncoderV1, UpdateEncoderV2, Doc, Item, Transaction, // eslint-disable-line\n  createIdSet,\n  equalAttrs\n} from '../internals.js'\n\nimport * as math from 'lib0/math'\nimport * as traits from 'lib0/traits'\nimport * as map from 'lib0/map'\nimport * as error from 'lib0/error'\n\nexport class ItemTextListPosition {\n  /**\n   * @param {Item|null} left\n   * @param {Item|null} right\n   * @param {number} index\n   * @param {Map<string,any>} currentAttributes\n   * @param {AbstractAttributionManager} am\n   */\n  constructor (left, right, index, currentAttributes, am) {\n    this.left = left\n    this.right = right\n    this.index = index\n    this.currentAttributes = currentAttributes\n    this.am = am\n  }\n\n  /**\n   * Only call this if you know that this.right is defined\n   */\n  forward () {\n    if (this.right === null) {\n      error.unexpectedCase()\n    }\n    switch (this.right.content.constructor) {\n      case ContentFormat:\n        if (!this.right.deleted) {\n          updateCurrentAttributes(this.currentAttributes, /** @type {ContentFormat} */ (this.right.content))\n        }\n        break\n      default:\n        this.index += this.am.contentLength(this.right)\n        break\n    }\n    this.left = this.right\n    this.right = this.right.right\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {import('../utils/types.js').YType} parent\n   * @param {number} length\n   * @param {Object<string,any>} attributes\n   *\n   * @function\n   */\n  formatText (transaction, parent, length, attributes) {\n    const doc = transaction.doc\n    const ownClientId = doc.clientID\n    minimizeAttributeChanges(this, attributes)\n    const negatedAttributes = insertAttributes(transaction, parent, this, attributes)\n    // iterate until first non-format or null is found\n    // delete all formats with attributes[format.key] != null\n    // also check the attributes after the first non-format as we do not want to insert redundant negated attributes there\n    // eslint-disable-next-line no-labels\n    iterationLoop: while (\n      this.right !== null &&\n      (length > 0 ||\n        (\n          negatedAttributes.size > 0 &&\n          ((this.right.deleted && this.am.contentLength(this.right) === 0) || this.right.content.constructor === ContentFormat)\n        )\n      )\n    ) {\n      switch (this.right.content.constructor) {\n        case ContentFormat: {\n          if (!this.right.deleted) {\n            const { key, value } = /** @type {ContentFormat} */ (this.right.content)\n            const attr = attributes[key]\n            if (attr !== undefined) {\n              if (equalAttrs(attr, value)) {\n                negatedAttributes.delete(key)\n              } else {\n                if (length === 0) {\n                  // no need to further extend negatedAttributes\n                  // eslint-disable-next-line no-labels\n                  break iterationLoop\n                }\n                negatedAttributes.set(key, value)\n              }\n              this.right.delete(transaction)\n            } else {\n              this.currentAttributes.set(key, value)\n            }\n          }\n          break\n        }\n        default: {\n          const item = this.right\n          const rightLen = this.am.contentLength(item)\n          if (length < rightLen) {\n            /**\n             * @type {Array<import('../internals.js').AttributedContent<any>>}\n             */\n            const contents = []\n            this.am.readContent(contents, item.id.client, item.id.clock, item.deleted, item.content, 0)\n            let i = 0\n            for (; i < contents.length && length > 0; i++) {\n              const c = contents[i]\n              if ((!c.deleted || c.attrs != null) && c.content.isCountable()) {\n                length -= c.content.getLength()\n              }\n            }\n            if (length < 0 || (length === 0 && i !== contents.length)) {\n              const c = contents[--i]\n              getItemCleanStart(transaction, createID(item.id.client, c.clock + c.content.getLength() + length))\n            }\n          } else {\n            length -= rightLen\n          }\n          break\n        }\n      }\n      this.forward()\n    }\n    // Quill just assumes that the editor starts with a newline and that it always\n    // ends with a newline. We only insert that newline when a new newline is\n    // inserted - i.e when length is bigger than type.length\n    if (length > 0) {\n      let newlines = ''\n      for (; length > 0; length--) {\n        newlines += '\\n'\n      }\n      this.right = new Item(createID(ownClientId, getState(doc.store, ownClientId)), this.left, this.left && this.left.lastId, this.right, this.right && this.right.id, parent, null, new ContentString(newlines))\n      this.right.integrate(transaction, 0)\n      this.forward()\n    }\n    insertNegatedAttributes(transaction, parent, this, negatedAttributes)\n  }\n}\n\n/**\n * @param {Transaction} transaction\n * @param {ItemTextListPosition} pos\n * @param {number} count steps to move forward\n * @return {ItemTextListPosition}\n *\n * @private\n * @function\n */\nconst findNextPosition = (transaction, pos, count) => {\n  while (pos.right !== null && count > 0) {\n    switch (pos.right.content.constructor) {\n      case ContentFormat:\n        if (!pos.right.deleted) {\n          updateCurrentAttributes(pos.currentAttributes, /** @type {ContentFormat} */ (pos.right.content))\n        }\n        break\n      default:\n        if (!pos.right.deleted) {\n          if (count < pos.right.length) {\n            // split right\n            getItemCleanStart(transaction, createID(pos.right.id.client, pos.right.id.clock + count))\n          }\n          pos.index += pos.right.length\n          count -= pos.right.length\n        }\n        break\n    }\n    pos.left = pos.right\n    pos.right = pos.right.right\n    // pos.forward() - we don't forward because that would halve the performance because we already do the checks above\n  }\n  return pos\n}\n\n/**\n * @param {Transaction} transaction\n * @param {import('../utils/types.js').YType} parent\n * @param {number} index\n * @param {boolean} useSearchMarker\n * @return {ItemTextListPosition}\n *\n * @private\n * @function\n */\nconst findPosition = (transaction, parent, index, useSearchMarker) => {\n  const currentAttributes = new Map()\n  const marker = useSearchMarker ? findMarker(parent, index) : null\n  if (marker) {\n    const pos = new ItemTextListPosition(marker.p.left, marker.p, marker.index, currentAttributes, noAttributionsManager)\n    return findNextPosition(transaction, pos, index - marker.index)\n  } else {\n    const pos = new ItemTextListPosition(null, parent._start, 0, currentAttributes, noAttributionsManager)\n    return findNextPosition(transaction, pos, index)\n  }\n}\n\n/**\n * Negate applied formats\n *\n * @param {Transaction} transaction\n * @param {import('../utils/types.js').YType} parent\n * @param {ItemTextListPosition} currPos\n * @param {Map<string,any>} negatedAttributes\n *\n * @private\n * @function\n */\nconst insertNegatedAttributes = (transaction, parent, currPos, negatedAttributes) => {\n  // check if we really need to remove attributes\n  while (\n    currPos.right !== null && (\n      (currPos.right.deleted && (currPos.am === noAttributionsManager || currPos.am.contentLength(currPos.right) === 0)) || (\n        currPos.right.content.constructor === ContentFormat &&\n        equalAttrs(negatedAttributes.get(/** @type {ContentFormat} */ (currPos.right.content).key), /** @type {ContentFormat} */ (currPos.right.content).value)\n      )\n    )\n  ) {\n    if (!currPos.right.deleted) {\n      negatedAttributes.delete(/** @type {ContentFormat} */ (currPos.right.content).key)\n    }\n    currPos.forward()\n  }\n  const doc = transaction.doc\n  const ownClientId = doc.clientID\n  negatedAttributes.forEach((val, key) => {\n    const left = currPos.left\n    const right = currPos.right\n    const nextFormat = new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key, val))\n    nextFormat.integrate(transaction, 0)\n    currPos.right = nextFormat\n    currPos.forward()\n  })\n}\n\n/**\n * @param {Map<string,any>} currentAttributes\n * @param {ContentFormat} format\n *\n * @private\n * @function\n */\nconst updateCurrentAttributes = (currentAttributes, format) => {\n  const { key, value } = format\n  if (value === null) {\n    currentAttributes.delete(key)\n  } else {\n    currentAttributes.set(key, value)\n  }\n}\n\n/**\n * @param {ItemTextListPosition} currPos\n * @param {Object<string,any>} attributes\n *\n * @private\n * @function\n */\nconst minimizeAttributeChanges = (currPos, attributes) => {\n  // go right while attributes[right.key] === right.value (or right is deleted)\n  while (true) {\n    if (currPos.right === null) {\n      break\n    } else if (currPos.right.deleted ? (currPos.am.contentLength(currPos.right) === 0) : (!currPos.right.deleted && currPos.right.content.constructor === ContentFormat && equalAttrs(attributes[(/** @type {ContentFormat} */ (currPos.right.content)).key] ?? null, /** @type {ContentFormat} */ (currPos.right.content).value))) {\n      //\n    } else {\n      break\n    }\n    currPos.forward()\n  }\n}\n\n/**\n * @param {Transaction} transaction\n * @param {import('../utils/types.js').YType} parent\n * @param {ItemTextListPosition} currPos\n * @param {Object<string,any>} attributes\n * @return {Map<string,any>}\n *\n * @private\n * @function\n **/\nconst insertAttributes = (transaction, parent, currPos, attributes) => {\n  const doc = transaction.doc\n  const ownClientId = doc.clientID\n  const negatedAttributes = new Map()\n  // insert format-start items\n  for (const key in attributes) {\n    const val = attributes[key]\n    const currentVal = currPos.currentAttributes.get(key) ?? null\n    if (!equalAttrs(currentVal, val)) {\n      // save negated attribute (set null if currentVal undefined)\n      negatedAttributes.set(key, currentVal)\n      const { left, right } = currPos\n      currPos.right = new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key, val))\n      currPos.right.integrate(transaction, 0)\n      currPos.forward()\n    }\n  }\n  return negatedAttributes\n}\n\n/**\n * @param {Transaction} transaction\n * @param {import('../utils/types.js').YType} parent\n * @param {ItemTextListPosition} currPos\n * @param {string|object|import('../utils/types.js').YType} text\n * @param {Object<string,any>} attributes\n *\n * @private\n * @function\n **/\nexport const insertText = (transaction, parent, currPos, text, attributes) => {\n  currPos.currentAttributes.forEach((_val, key) => {\n    if (attributes[key] === undefined) {\n      attributes[key] = null\n    }\n  })\n  const doc = transaction.doc\n  const ownClientId = doc.clientID\n  minimizeAttributeChanges(currPos, attributes)\n  const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes)\n  // insert content\n  const content = text.constructor === String ? new ContentString(/** @type {string} */ (text)) : (text instanceof AbstractType ? new ContentType(text) : new ContentEmbed(text))\n  let { left, right, index } = currPos\n  if (parent._searchMarker) {\n    updateMarkerChanges(parent._searchMarker, currPos.index, content.getLength())\n  }\n  right = new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, content)\n  right.integrate(transaction, 0)\n  currPos.right = right\n  currPos.index = index\n  currPos.forward()\n  insertNegatedAttributes(transaction, parent, currPos, negatedAttributes)\n}\n\n/**\n * Call this function after string content has been deleted in order to\n * clean up formatting Items.\n *\n * @param {Transaction} transaction\n * @param {Item} start\n * @param {Item|null} curr exclusive end, automatically iterates to the next Content Item\n * @param {Map<string,any>} startAttributes\n * @param {Map<string,any>} currAttributes\n * @return {number} The amount of formatting Items deleted.\n *\n * @function\n */\nconst cleanupFormattingGap = (transaction, start, curr, startAttributes, currAttributes) => {\n  if (!transaction.doc.cleanupFormatting) return 0\n  /**\n   * @type {Item|null}\n   */\n  let end = start\n  /**\n   * @type {Map<string,ContentFormat>}\n   */\n  const endFormats = map.create()\n  while (end && (!end.countable || end.deleted)) {\n    if (!end.deleted && end.content.constructor === ContentFormat) {\n      const cf = /** @type {ContentFormat} */ (end.content)\n      endFormats.set(cf.key, cf)\n    }\n    end = end.right\n  }\n  let cleanups = 0\n  let reachedCurr = false\n  while (start !== end) {\n    if (curr === start) {\n      reachedCurr = true\n    }\n    if (!start.deleted) {\n      const content = start.content\n      switch (content.constructor) {\n        case ContentFormat: {\n          const { key, value } = /** @type {ContentFormat} */ (content)\n          const startAttrValue = startAttributes.get(key) ?? null\n          if (endFormats.get(key) !== content || startAttrValue === value) {\n            // Either this format is overwritten or it is not necessary because the attribute already existed.\n            start.delete(transaction)\n            transaction.cleanUps.add(start.id.client, start.id.clock, start.length)\n            cleanups++\n            if (!reachedCurr && (currAttributes.get(key) ?? null) === value && startAttrValue !== value) {\n              if (startAttrValue === null) {\n                currAttributes.delete(key)\n              } else {\n                currAttributes.set(key, startAttrValue)\n              }\n            }\n          }\n          if (!reachedCurr && !start.deleted) {\n            updateCurrentAttributes(currAttributes, /** @type {ContentFormat} */ (content))\n          }\n          break\n        }\n      }\n    }\n    start = /** @type {Item} */ (start.right)\n  }\n  return cleanups\n}\n\n/**\n * @param {Transaction} transaction\n * @param {Item | null} item\n */\nconst cleanupContextlessFormattingGap = (transaction, item) => {\n  if (!transaction.doc.cleanupFormatting) return 0\n  // iterate until item.right is null or content\n  while (item && item.right && (item.right.deleted || !item.right.countable)) {\n    item = item.right\n  }\n  const attrs = new Set()\n  // iterate back until a content item is found\n  while (item && (item.deleted || !item.countable)) {\n    if (!item.deleted && item.content.constructor === ContentFormat) {\n      const key = /** @type {ContentFormat} */ (item.content).key\n      if (attrs.has(key)) {\n        item.delete(transaction)\n        transaction.cleanUps.add(item.id.client, item.id.clock, item.length)\n      } else {\n        attrs.add(key)\n      }\n    }\n    item = item.left\n  }\n}\n\n/**\n * This function is experimental and subject to change / be removed.\n *\n * Ideally, we don't need this function at all. Formatting attributes should be cleaned up\n * automatically after each change. This function iterates twice over the complete YText type\n * and removes unnecessary formatting attributes. This is also helpful for testing.\n *\n * This function won't be exported anymore as soon as there is confidence that the YText type works as intended.\n *\n * @param {YText<any>} type\n * @return {number} How many formatting attributes have been cleaned up.\n */\nexport const cleanupYTextFormatting = type => {\n  if (!type.doc?.cleanupFormatting) return 0\n  let res = 0\n  transact(/** @type {Doc} */ (type.doc), transaction => {\n    let start = /** @type {Item} */ (type._start)\n    let end = type._start\n    let startAttributes = map.create()\n    const currentAttributes = map.copy(startAttributes)\n    while (end) {\n      if (end.deleted === false) {\n        switch (end.content.constructor) {\n          case ContentFormat:\n            updateCurrentAttributes(currentAttributes, /** @type {ContentFormat} */ (end.content))\n            break\n          default:\n            res += cleanupFormattingGap(transaction, start, end, startAttributes, currentAttributes)\n            startAttributes = map.copy(currentAttributes)\n            start = end\n            break\n        }\n      }\n      end = end.right\n    }\n  })\n  return res\n}\n\n/**\n * This will be called by the transaction once the event handlers are called to potentially cleanup\n * formatting attributes.\n *\n * @param {Transaction} transaction\n */\nexport const cleanupYTextAfterTransaction = transaction => {\n  /**\n   * @type {Set<YText<any>>}\n   */\n  const needFullCleanup = new Set()\n  // check if another formatting item was inserted\n  const doc = transaction.doc\n  iterateStructsByIdSet(transaction, transaction.insertSet, (item) => {\n    if (\n      !item.deleted && /** @type {Item} */ (item).content.constructor === ContentFormat && item.constructor !== GC\n    ) {\n      needFullCleanup.add(/** @type {any} */ (item).parent)\n    }\n  })\n  // cleanup in a new transaction\n  transact(doc, (t) => {\n    iterateStructsByIdSet(transaction, transaction.deleteSet, item => {\n      if (item instanceof GC || !(/** @type {YText<any>} */ (item.parent)._hasFormatting) || needFullCleanup.has(/** @type {YText<any>} */ (item.parent))) {\n        return\n      }\n      const parent = /** @type {YText<any>} */ (item.parent)\n      if (item.content.constructor === ContentFormat) {\n        needFullCleanup.add(parent)\n      } else {\n        // If no formatting attribute was inserted or deleted, we can make due with contextless\n        // formatting cleanups.\n        // Contextless: it is not necessary to compute currentAttributes for the affected position.\n        cleanupContextlessFormattingGap(t, item)\n      }\n    })\n    // If a formatting item was inserted, we simply clean the whole type.\n    // We need to compute currentAttributes for the current position anyway.\n    for (const yText of needFullCleanup) {\n      cleanupYTextFormatting(yText)\n    }\n  })\n}\n\n/**\n * @param {Transaction} transaction\n * @param {ItemTextListPosition} currPos\n * @param {number} length\n * @return {ItemTextListPosition}\n *\n * @private\n * @function\n */\nexport const deleteText = (transaction, currPos, length) => {\n  const startLength = length\n  const startAttrs = map.copy(currPos.currentAttributes)\n  const start = currPos.right\n  while (length > 0 && currPos.right !== null) {\n    if (!currPos.right.deleted) {\n      switch (currPos.right.content.constructor) {\n        case ContentType:\n        case ContentEmbed:\n        case ContentString:\n          if (length < currPos.right.length) {\n            getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length))\n          }\n          length -= currPos.right.length\n          currPos.right.delete(transaction)\n          break\n      }\n    } else if (currPos.am !== noAttributionsManager) {\n      const item = currPos.right\n      /**\n       * @type {Array<import('../internals.js').AttributedContent<any>>}\n       */\n      const contents = []\n      currPos.am.readContent(contents, item.id.client, item.id.clock, true, item.content, 0)\n      for (let i = 0; i < contents.length; i++) {\n        const c = contents[i]\n        if (c.content.isCountable() && c.attrs != null) {\n          // deleting already deleted content. store that information in a meta property, but do\n          // nothing\n          const contentLen = math.min(c.content.getLength(), length)\n          map.setIfUndefined(transaction.meta, 'attributedDeletes', createIdSet).add(item.id.client, c.clock, contentLen)\n          length -= contentLen\n        }\n      }\n      const lastContent = contents.length > 0 ? contents[contents.length - 1] : null\n      const nextItemClock = item.id.clock + item.length\n      const nextContentClock = lastContent != null ? lastContent.clock + lastContent.content.getLength() : nextItemClock\n      if (nextContentClock < nextItemClock) {\n        getItemCleanStart(transaction, createID(item.id.client, nextContentClock))\n      }\n    }\n    currPos.forward()\n  }\n  if (start) {\n    cleanupFormattingGap(transaction, start, currPos.right, startAttrs, currPos.currentAttributes)\n  }\n  const parent = /** @type {AbstractType<any>} */ (/** @type {Item} */ (currPos.left || currPos.right).parent)\n  if (parent._searchMarker) {\n    updateMarkerChanges(parent._searchMarker, currPos.index, -startLength + length)\n  }\n  return currPos\n}\n\n/**\n * The Quill Delta format represents changes on a text document with\n * formatting information. For more information visit {@link https://quilljs.com/docs/delta/|Quill Delta}\n *\n * @example\n *   {\n *     ops: [\n *       { insert: 'Gandalf', attributes: { bold: true } },\n *       { insert: ' the ' },\n *       { insert: 'Grey', attributes: { color: '#cccccc' } }\n *     ]\n *   }\n *\n */\n\n/**\n  * Attributes that can be assigned to a selection of text.\n  *\n  * @example\n  *   {\n  *     bold: true,\n  *     font-size: '40px'\n  *   }\n  *\n  * @typedef {Object} TextAttributes\n  */\n\n/**\n * Type that represents text with formatting information.\n *\n * This type replaces y-richtext as this implementation is able to handle\n * block formats (format information on a paragraph), embeds (complex elements\n * like pictures and videos), and text formats (**bold**, *italic*).\n *\n * @template {{ [key:string]:any } | import('../utils/types.js').YType} [Embeds={ [key:string]:any } | import('../utils/types.js').YType]\n * @extends {AbstractType<import('lib0/delta').TextDelta<Embeds>>}\n */\nexport class YText extends AbstractType {\n  /**\n   * @param {String} [string] The initial value of the YText.\n   */\n  constructor (string) {\n    super()\n    /**\n     * Array of pending operations on this type\n     * @type {Array<function():void>?}\n     */\n    this._pending = string !== undefined ? [() => this.insert(0, string)] : []\n    /**\n     * @type {Array<ArraySearchMarker>|null}\n     */\n    this._searchMarker = []\n    /**\n     * Whether this YText contains formatting attributes.\n     * This flag is updated when a formatting item is integrated (see ContentFormat.integrate)\n     */\n    this._hasFormatting = false\n  }\n\n  /**\n   * Number of characters of this text type.\n   *\n   * @type {number}\n   */\n  get length () {\n    this.doc ?? warnPrematureAccess()\n    return this._length\n  }\n\n  /**\n   * @param {Doc} y\n   * @param {Item?} item\n   */\n  _integrate (y, item) {\n    super._integrate(y, item)\n    try {\n      /** @type {Array<function>} */ (this._pending).forEach(f => f())\n    } catch (e) {\n      console.error(e)\n    }\n    this._pending = null\n  }\n\n  /**\n   * Makes a copy of this data type that can be included somewhere else.\n   *\n   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.\n   *\n   * @return {YText<Embeds>}\n   */\n  clone () {\n    /**\n     * @type {YText<Embeds>}\n     */\n    const text = /** @type {any} */ (new YText())\n    text.applyDelta(this.getContent())\n    return text\n  }\n\n  /**\n   * Creates YTextEvent and calls observers.\n   *\n   * @param {Transaction} transaction\n   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.\n   */\n  _callObserver (transaction, parentSubs) {\n    super._callObserver(transaction, parentSubs)\n    // If a remote change happened, we try to cleanup potential formatting duplicates.\n    if (!transaction.local && this._hasFormatting) {\n      transaction._needFormattingCleanup = true\n    }\n  }\n\n  /**\n   * Returns the unformatted string representation of this YText type.\n   *\n   * @public\n   */\n  toString () {\n    this.doc ?? warnPrematureAccess()\n    let str = ''\n    /**\n     * @type {Item|null}\n     */\n    let n = this._start\n    while (n !== null) {\n      if (!n.deleted && n.countable && n.content.constructor === ContentString) {\n        str += /** @type {ContentString} */ (n.content).str\n      }\n      n = n.right\n    }\n    return str\n  }\n\n  /**\n   * Returns the unformatted string representation of this YText type.\n   *\n   * @return {string}\n   * @public\n   */\n  toJSON () {\n    return this.toString()\n  }\n\n  /**\n   * Insert text at a given index.\n   *\n   * @param {number} index The index at which to start inserting.\n   * @param {String} text The text to insert at the specified position.\n   * @param {TextAttributes} [attributes] Optionally define some formatting\n   *                                    information to apply on the inserted\n   *                                    Text.\n   * @public\n   */\n  insert (index, text, attributes) {\n    if (text.length <= 0) {\n      return\n    }\n    const y = this.doc\n    if (y !== null) {\n      transact(y, transaction => {\n        const pos = findPosition(transaction, this, index, !attributes)\n        if (!attributes) {\n          attributes = {}\n          // @ts-ignore\n          pos.currentAttributes.forEach((v, k) => { attributes[k] = v })\n        }\n        insertText(transaction, this, pos, text, attributes)\n      })\n    } else {\n      /** @type {Array<function>} */ (this._pending).push(() => this.insert(index, text, attributes))\n    }\n  }\n\n  /**\n   * Inserts an embed at a index.\n   *\n   * @param {number} index The index to insert the embed at.\n   * @param {Object | AbstractType<any>} embed The Object that represents the embed.\n   * @param {TextAttributes} [attributes] Attribute information to apply on the\n   *                                    embed\n   *\n   * @public\n   */\n  insertEmbed (index, embed, attributes) {\n    const y = this.doc\n    if (y !== null) {\n      transact(y, transaction => {\n        const pos = findPosition(transaction, this, index, !attributes)\n        insertText(transaction, this, pos, embed, attributes || {})\n      })\n    } else {\n      /** @type {Array<function>} */ (this._pending).push(() => this.insertEmbed(index, embed, attributes || {}))\n    }\n  }\n\n  /**\n   * Deletes text starting from an index.\n   *\n   * @param {number} index Index at which to start deleting.\n   * @param {number} length The number of characters to remove. Defaults to 1.\n   *\n   * @public\n   */\n  delete (index, length) {\n    if (length === 0) {\n      return\n    }\n    const y = this.doc\n    if (y !== null) {\n      transact(y, transaction => {\n        deleteText(transaction, findPosition(transaction, this, index, true), length)\n      })\n    } else {\n      /** @type {Array<function>} */ (this._pending).push(() => this.delete(index, length))\n    }\n  }\n\n  /**\n   * Assigns properties to a range of text.\n   *\n   * @param {number} index The position where to start formatting.\n   * @param {number} length The amount of characters to assign properties to.\n   * @param {TextAttributes} attributes Attribute information to apply on the\n   *                                    text.\n   *\n   * @public\n   */\n  format (index, length, attributes) {\n    if (length === 0) {\n      return\n    }\n    const y = this.doc\n    if (y !== null) {\n      transact(y, transaction => {\n        const pos = findPosition(transaction, this, index, false)\n        if (pos.right === null) {\n          return\n        }\n        pos.formatText(transaction, this, length, attributes)\n      })\n    } else {\n      /** @type {Array<function>} */ (this._pending).push(() => this.format(index, length, attributes))\n    }\n  }\n\n  /**\n   * Removes an attribute.\n   *\n   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.\n   *\n   * @param {String} attributeName The attribute name that is to be removed.\n   *\n   * @public\n   */\n  removeAttribute (attributeName) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeMapDelete(transaction, this, attributeName)\n      })\n    } else {\n      /** @type {Array<function>} */ (this._pending).push(() => this.removeAttribute(attributeName))\n    }\n  }\n\n  /**\n   * Sets or updates an attribute.\n   *\n   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.\n   *\n   * @param {String} attributeName The attribute name that is to be set.\n   * @param {any} attributeValue The attribute value that is to be set.\n   *\n   * @public\n   */\n  setAttribute (attributeName, attributeValue) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeMapSet(transaction, this, attributeName, attributeValue)\n      })\n    } else {\n      /** @type {Array<function>} */ (this._pending).push(() => this.setAttribute(attributeName, attributeValue))\n    }\n  }\n\n  /**\n   * Returns an attribute value that belongs to the attribute name.\n   *\n   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.\n   *\n   * @param {String} attributeName The attribute name that identifies the\n   *                               queried value.\n   * @return {any} The queried attribute value.\n   *\n   * @public\n   */\n  getAttribute (attributeName) {\n    return /** @type {any} */ (typeMapGet(this, attributeName))\n  }\n\n  /**\n   * Returns all attribute name/value pairs in a JSON Object.\n   *\n   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.\n   *\n   * @return {Object<string, any>} A JSON Object that describes the attributes.\n   *\n   * @public\n   */\n  getAttributes () {\n    return typeMapGetAll(this)\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YTextRefID)\n  }\n\n  /**\n   * @param {this} other\n   */\n  [traits.EqualityTraitSymbol] (other) {\n    return this.getContent().equals(other.getContent())\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} _decoder\n * @return {import('../utils/types.js').YType}\n *\n * @private\n * @function\n */\nexport const readYText = _decoder => new YText()\n","/**\n * @module YXml\n */\n\nimport {\n  AbstractType,\n  typeListMap,\n  typeListForEach,\n  typeListInsertGenerics,\n  typeListInsertGenericsAfter,\n  typeListDelete,\n  typeListToArray,\n  YXmlFragmentRefID,\n  transact,\n  typeListGet,\n  typeListSlice,\n  warnPrematureAccess,\n  YXmlElement, UpdateDecoderV1, UpdateDecoderV2, UpdateEncoderV1, UpdateEncoderV2, Doc, Transaction, Item, YXmlText, YXmlHook // eslint-disable-line\n} from '../internals.js'\n\nimport * as delta from 'lib0/delta' // eslint-disable-line\nimport * as error from 'lib0/error'\n\n/**\n * Define the elements to which a set of CSS queries apply.\n * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors|CSS_Selectors}\n *\n * @example\n *   query = '.classSelector'\n *   query = 'nodeSelector'\n *   query = '#idSelector'\n *\n * @typedef {string} CSS_Selector\n */\n\n/**\n * Dom filter function.\n *\n * @callback domFilter\n * @param {string} nodeName The nodeName of the element\n * @param {Map} attributes The map of attributes.\n * @return {boolean} Whether to include the Dom node in the YXmlElement.\n */\n\n/**\n * Represents a list of {@link YXmlElement}.and {@link YXmlText} types.\n * A YxmlFragment is similar to a {@link YXmlElement}, but it does not have a\n * nodeName and it does not have attributes. Though it can be bound to a DOM\n * element - in this case the attributes and the nodeName are not shared.\n *\n * @public\n * @template {any} [Children=any]\n * @template {{[K in string]:any}} [Attrs={}]\n * @extends AbstractType<delta.Delta<any,Attrs,Children,any>>\n */\nexport class YXmlFragment extends AbstractType {\n  constructor () {\n    super()\n    /**\n     * @todo remove _prelimContent\n     * @type {Array<any>|null}\n     */\n    this._prelimContent = []\n  }\n\n  /**\n   * @type {YXmlElement|YXmlText|null}\n   */\n  get firstChild () {\n    const first = this._first\n    return first ? first.content.getContent()[0] : null\n  }\n\n  /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item?} item\n   */\n  _integrate (y, item) {\n    super._integrate(y, item)\n    this.insert(0, /** @type {Array<any>} */ (this._prelimContent))\n    this._prelimContent = null\n  }\n\n  /**\n   * Makes a copy of this data type that can be included somewhere else.\n   *\n   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.\n   *\n   * @return {this}\n   */\n  clone () {\n    const el = this._copy()\n    el.insert(0, this.toArray().map(item => item instanceof AbstractType ? item.clone() : item))\n    return el\n  }\n\n  get length () {\n    this.doc ?? warnPrematureAccess()\n    return this._prelimContent === null ? this._length : this._prelimContent.length\n  }\n\n  /**\n   * Get the string representation of all the children of this YXmlFragment.\n   *\n   * @return {string} The string representation of all children.\n   */\n  toString () {\n    return typeListMap(this, xml => xml.toString()).join('')\n  }\n\n  /**\n   * @return {string}\n   */\n  toJSON () {\n    return this.toString()\n  }\n\n  /**\n   * Inserts new content at an index.\n   *\n   * @example\n   *  // Insert character 'a' at position 0\n   *  xml.insert(0, [new Y.XmlText('text')])\n   *\n   * @param {number} index The index to insert content at\n   * @param {Array<YXmlElement|YXmlText|YXmlHook>} content The array of content\n   */\n  insert (index, content) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeListInsertGenerics(transaction, this, index, content)\n      })\n    } else {\n      // @ts-ignore _prelimContent is defined because this is not yet integrated\n      this._prelimContent.splice(index, 0, ...content)\n    }\n  }\n\n  /**\n   * Inserts new content at an index.\n   *\n   * @example\n   *  // Insert character 'a' at position 0\n   *  xml.insert(0, [new Y.XmlText('text')])\n   *\n   * @param {null|Item|YXmlElement|YXmlText} ref The index to insert content at\n   * @param {Array<YXmlElement|YXmlText>} content The array of content\n   */\n  insertAfter (ref, content) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        const refItem = (ref && ref instanceof AbstractType) ? ref._item : ref\n        typeListInsertGenericsAfter(transaction, this, refItem, content)\n      })\n    } else {\n      const pc = /** @type {Array<any>} */ (this._prelimContent)\n      const index = ref === null ? 0 : pc.findIndex(el => el === ref) + 1\n      if (index === 0 && ref !== null) {\n        throw error.create('Reference item not found')\n      }\n      pc.splice(index, 0, ...content)\n    }\n  }\n\n  /**\n   * Deletes elements starting from an index.\n   *\n   * @param {number} index Index at which to start deleting elements\n   * @param {number} [length=1] The number of elements to remove. Defaults to 1.\n   */\n  delete (index, length = 1) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeListDelete(transaction, this, index, length)\n      })\n    } else {\n      // @ts-ignore _prelimContent is defined because this is not yet integrated\n      this._prelimContent.splice(index, length)\n    }\n  }\n\n  /**\n   * Transforms this YArray to a JavaScript Array.\n   *\n   * @return {Array<YXmlElement|YXmlText|YXmlHook>}\n   */\n  toArray () {\n    return typeListToArray(this)\n  }\n\n  /**\n   * Appends content to this YArray.\n   *\n   * @param {Array<YXmlElement|YXmlText>} content Array of content to append.\n   */\n  push (content) {\n    this.insert(this.length, content)\n  }\n\n  /**\n   * Prepends content to this YArray.\n   *\n   * @param {Array<YXmlElement|YXmlText>} content Array of content to prepend.\n   */\n  unshift (content) {\n    this.insert(0, content)\n  }\n\n  /**\n   * Returns the i-th element from a YArray.\n   *\n   * @param {number} index The index of the element to return from the YArray\n   * @return {YXmlElement|YXmlText}\n   */\n  get (index) {\n    return typeListGet(this, index)\n  }\n\n  /**\n   * Returns a portion of this YXmlFragment into a JavaScript Array selected\n   * from start to end (end not included).\n   *\n   * @param {number} [start]\n   * @param {number} [end]\n   * @return {Array<YXmlElement|YXmlText>}\n   */\n  slice (start = 0, end = this.length) {\n    return typeListSlice(this, start, end)\n  }\n\n  /**\n   * Executes a provided function on once on every child element.\n   *\n   * @param {function(YXmlElement|YXmlText,number, typeof self):void} f A function to execute on every element of this YArray.\n   */\n  forEach (f) {\n    typeListForEach(this, f)\n  }\n\n  /**\n   * Transform the properties of this type to binary and write it to an\n   * BinaryEncoder.\n   *\n   * This is called when this Item is sent to a remote peer.\n   *\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YXmlFragmentRefID)\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} _decoder\n * @return {import('../utils/types.js').YType}\n *\n * @private\n * @function\n */\nexport const readYXmlFragment = _decoder => new YXmlFragment()\n","import * as object from 'lib0/object'\n\nimport {\n  YXmlFragment,\n  transact,\n  typeMapDelete,\n  typeMapHas,\n  typeMapSet,\n  typeMapGet,\n  typeMapGetAll,\n  typeMapGetAllSnapshot,\n  YXmlElementRefID,\n  Snapshot, YXmlText, ContentType, AbstractType, UpdateDecoderV1, UpdateDecoderV2, UpdateEncoderV1, UpdateEncoderV2, Doc, Item, // eslint-disable-line\n} from '../internals.js'\n\n/**\n * @typedef {Object|number|null|Array<any>|string|Uint8Array|AbstractType<any>} ValueTypes\n */\n\n/**\n * An YXmlElement imitates the behavior of a\n * https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element\n *\n * * An YXmlElement has attributes (key value pairs)\n * * An YXmlElement has childElements that must inherit from YXmlElement\n *\n * @template {{ [key: string]: any }} [Attrs={ [key: string]: string }]\n * @template {any} [Children=any]\n * @extends YXmlFragment<Children,Attrs>\n */\nexport class YXmlElement extends YXmlFragment {\n  constructor (nodeName = 'UNDEFINED') {\n    super()\n    this.nodeName = nodeName\n    /**\n     * @type {Map<string, any>|null}\n     */\n    this._prelimAttrs = new Map()\n  }\n\n  /**\n   * @type {YXmlElement|YXmlText|null}\n   */\n  get nextSibling () {\n    const n = this._item ? this._item.next : null\n    return n ? /** @type {YXmlElement|YXmlText} */ (/** @type {ContentType} */ (n.content).type) : null\n  }\n\n  /**\n   * @type {YXmlElement|YXmlText|null}\n   */\n  get prevSibling () {\n    const n = this._item ? this._item.prev : null\n    return n ? /** @type {YXmlElement|YXmlText} */ (/** @type {ContentType} */ (n.content).type) : null\n  }\n\n  /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item?} item\n   */\n  _integrate (y, item) {\n    super._integrate(y, item)\n    ;(/** @type {Map<string, any>} */ (this._prelimAttrs)).forEach((value, key) => {\n      this.setAttribute(key, value)\n    })\n    this._prelimAttrs = null\n  }\n\n  /**\n   * Creates an Item with the same effect as this Item (without position effect)\n   *\n   * @return {this}\n   */\n  _copy () {\n    return /** @type {any} */ (new YXmlElement(this.nodeName))\n  }\n\n  /**\n   * Makes a copy of this data type that can be included somewhere else.\n   *\n   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.\n   *\n   * @return {this}\n   */\n  clone () {\n    const el = this._copy()\n    const attrs = this.getAttributes()\n    object.forEach(attrs, (value, key) => {\n      if (typeof value === 'string') {\n        el.setAttribute(key, value)\n      }\n    })\n    // @ts-ignore\n    el.insert(0, this.toArray().map(item => item instanceof AbstractType ? item.clone() : item))\n    return el\n  }\n\n  /**\n   * Returns the XML serialization of this YXmlElement.\n   * The attributes are ordered by attribute-name, so you can easily use this\n   * method to compare YXmlElements\n   *\n   * @return {string} The string representation of this type.\n   *\n   * @public\n   */\n  toString () {\n    const attrs = this.getAttributes()\n    const stringBuilder = []\n    const keys = []\n    for (const key in attrs) {\n      keys.push(key)\n    }\n    keys.sort()\n    const keysLen = keys.length\n    for (let i = 0; i < keysLen; i++) {\n      const key = keys[i]\n      stringBuilder.push(key + '=\"' + attrs[key] + '\"')\n    }\n    const nodeName = this.nodeName.toLocaleLowerCase()\n    const attrsString = stringBuilder.length > 0 ? ' ' + stringBuilder.join(' ') : ''\n    return `<${nodeName}${attrsString}>${super.toString()}</${nodeName}>`\n  }\n\n  /**\n   * Removes an attribute from this YXmlElement.\n   *\n   * @param {string} attributeName The attribute name that is to be removed.\n   *\n   * @public\n   */\n  removeAttribute (attributeName) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeMapDelete(transaction, this, attributeName)\n      })\n    } else {\n      /** @type {Map<string,any>} */ (this._prelimAttrs).delete(attributeName)\n    }\n  }\n\n  /**\n   * Sets or updates an attribute.\n   *\n   * @template {keyof Attrs & string} KEY\n   *\n   * @param {KEY} attributeName The attribute name that is to be set.\n   * @param {Attrs[KEY]} attributeValue The attribute value that is to be set.\n   *\n   * @public\n   */\n  setAttribute (attributeName, attributeValue) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeMapSet(transaction, this, attributeName, /** @type {any} */ (attributeValue))\n      })\n    } else {\n      /** @type {Map<string, any>} */ (this._prelimAttrs).set(attributeName, attributeValue)\n    }\n  }\n\n  /**\n   * Returns an attribute value that belongs to the attribute name.\n   *\n   * @template {keyof Attrs & string} KEY\n   *\n   * @param {KEY} attributeName The attribute name that identifies the\n   *                               queried value.\n   * @return {Attrs[KEY]|undefined} The queried attribute value.\n   *\n   * @public\n   */\n  getAttribute (attributeName) {\n    return /** @type {any} */ (typeMapGet(this, attributeName))\n  }\n\n  /**\n   * Returns whether an attribute exists\n   *\n   * @param {string} attributeName The attribute name to check for existence.\n   * @return {boolean} whether the attribute exists.\n   *\n   * @public\n   */\n  hasAttribute (attributeName) {\n    return /** @type {any} */ (typeMapHas(this, attributeName))\n  }\n\n  /**\n   * Returns all attribute name/value pairs in a JSON Object.\n   *\n   * @param {Snapshot} [snapshot]\n   * @return {{ [Key in Extract<keyof Attrs,string>]?: Attrs[Key]}} A JSON Object that describes the attributes.\n   *\n   * @public\n   */\n  getAttributes (snapshot) {\n    return /** @type {any} */ (snapshot ? typeMapGetAllSnapshot(this, snapshot) : typeMapGetAll(this))\n  }\n\n  /**\n   * Transform the properties of this type to binary and write it to an\n   * BinaryEncoder.\n   *\n   * This is called when this Item is sent to a remote peer.\n   *\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YXmlElementRefID)\n    encoder.writeKey(this.nodeName)\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {import('../utils/types.js').YType}\n *\n * @function\n */\nexport const readYXmlElement = decoder => new YXmlElement(decoder.readKey())\n","import {\n  YMap,\n  YXmlHookRefID,\n  UpdateDecoderV1, UpdateDecoderV2, UpdateEncoderV1, UpdateEncoderV2 // eslint-disable-line\n} from '../internals.js'\n\n/**\n * You can manage binding to a custom type with YXmlHook.\n *\n * @extends {YMap<any>}\n */\nexport class YXmlHook extends YMap {\n  /**\n   * @param {string} hookName nodeName of the Dom Node.\n   */\n  constructor (hookName) {\n    super()\n    /**\n     * @type {string}\n     */\n    this.hookName = hookName\n  }\n\n  /**\n   * @return {this}\n   */\n  _copy () {\n    return /** @type {this} */ (new YXmlHook(this.hookName))\n  }\n\n  /**\n   * Makes a copy of this data type that can be included somewhere else.\n   *\n   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.\n   *\n   * @return {this}\n   */\n  clone () {\n    const el = this._copy()\n    this.forEach((value, key) => {\n      el.set(key, value)\n    })\n    return el\n  }\n\n  /**\n   * Transform the properties of this type to binary and write it to an\n   * BinaryEncoder.\n   *\n   * This is called when this Item is sent to a remote peer.\n   *\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YXmlHookRefID)\n    encoder.writeKey(this.hookName)\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {import('../utils/types.js').YType}\n *\n * @private\n * @function\n */\nexport const readYXmlHook = decoder =>\n  new YXmlHook(decoder.readKey())\n","import {\n  YText,\n  YXmlTextRefID,\n  ContentType, YXmlElement, UpdateDecoderV1, UpdateDecoderV2, UpdateEncoderV1, UpdateEncoderV2, // eslint-disable-line\n} from '../internals.js'\n\n/**\n * @todo can we deprecate this?\n *\n * Represents text in a Dom Element. In the future this type will also handle\n * simple formatting information like bold and italic.\n * @extends YText\n */\nexport class YXmlText extends YText {\n  /**\n   * @type {YXmlElement|YXmlText|null}\n   */\n  get nextSibling () {\n    const n = this._item ? this._item.next : null\n    return n ? /** @type {YXmlElement|YXmlText} */ (/** @type {ContentType} */ (n.content).type) : null\n  }\n\n  /**\n   * @type {YXmlElement|YXmlText|null}\n   */\n  get prevSibling () {\n    const n = this._item ? this._item.prev : null\n    return n ? /** @type {YXmlElement|YXmlText} */ (/** @type {ContentType} */ (n.content).type) : null\n  }\n\n  /**\n   * Makes a copy of this data type that can be included somewhere else.\n   *\n   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.\n   *\n   * @return {this}\n   */\n  clone () {\n    const text = /** @type {this} */ (this._copy())\n    text.applyDelta(this.getContent())\n    return text\n  }\n\n  /**\n   * @return {string}\n   */\n  toJSON () {\n    return this.toString()\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YXmlTextRefID)\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} _decoder\n * @return {import('../utils/types.js').YType}\n *\n * @private\n * @function\n */\nexport const readYXmlText = _decoder => new YXmlText()\n","import {\n  UpdateEncoderV1, UpdateEncoderV2, ID, Transaction // eslint-disable-line\n} from '../internals.js'\n\nimport * as error from 'lib0/error'\n\nexport class AbstractStruct {\n  /**\n   * @param {ID} id\n   * @param {number} length\n   */\n  constructor (id, length) {\n    this.id = id\n    this.length = length\n  }\n\n  /**\n   * @type {boolean}\n   */\n  get deleted () {\n    throw error.methodUnimplemented()\n  }\n\n  /**\n   * Merge this struct with the item to the right.\n   * This method is already assuming that `this.id.clock + this.length === this.id.clock`.\n   * Also this method does *not* remove right from StructStore!\n   * @param {AbstractStruct} right\n   * @return {boolean} whether this merged with right\n   */\n  mergeWith (right) {\n    return false\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n   * @param {number} offset\n   * @param {number} encodingRef\n   */\n  write (encoder, offset, encodingRef) {\n    throw error.methodUnimplemented()\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {number} offset\n   */\n  integrate (transaction, offset) {\n    throw error.methodUnimplemented()\n  }\n\n  /**\n   * @param {number} diff\n   * @return {import('../internals.js').GC|import('../internals.js').Item}\n   */\n  splice (diff) {\n    throw error.methodUnimplemented()\n  }\n}\n","import {\n  AbstractStruct,\n  addStruct,\n  addStructToIdSet,\n  addToIdSet,\n  createID,\n  UpdateEncoderV1, UpdateEncoderV2, StructStore, Transaction // eslint-disable-line\n} from '../internals.js'\n\nexport const structGCRefNumber = 0\n\n/**\n * @private\n */\nexport class GC extends AbstractStruct {\n  get deleted () {\n    return true\n  }\n\n  delete () {}\n\n  /**\n   * @param {GC} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    if (this.constructor !== right.constructor) {\n      return false\n    }\n    this.length += right.length\n    return true\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {number} offset - @todo remove offset parameter\n   */\n  integrate (transaction, offset) {\n    if (offset > 0) {\n      this.id.clock += offset\n      this.length -= offset\n    }\n    addToIdSet(transaction.deleteSet, this.id.client, this.id.clock, this.length)\n    addStructToIdSet(transaction.insertSet, this)\n    addStruct(transaction.doc.store, this)\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   * @param {number} offsetEnd\n   */\n  write (encoder, offset, offsetEnd) {\n    encoder.writeInfo(structGCRefNumber)\n    encoder.writeLen(this.length - offset - offsetEnd)\n  }\n\n  /**\n   * @param {Transaction} _transaction\n   * @param {StructStore} _store\n   * @return {null | number}\n   */\n  getMissing (_transaction, _store) {\n    return null\n  }\n\n  /**\n   * gc structs can't be spliced.\n   *\n   * If this feature is required in the future, then need to try to merge this struct after\n   * transaction.\n   *\n   * @param {number} diff\n   */\n  splice (diff) {\n    const other = new GC(createID(this.id.client, this.id.clock + diff), this.length - diff)\n    this.length = diff\n    return other\n  }\n}\n","import {\n  UpdateDecoderV1, UpdateDecoderV2, UpdateEncoderV1, UpdateEncoderV2, StructStore, Item, Transaction // eslint-disable-line\n} from '../internals.js'\n\nimport * as error from 'lib0/error'\n\nexport class ContentBinary {\n  /**\n   * @param {Uint8Array} content\n   */\n  constructor (content) {\n    this.content = content\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return 1\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return [this.content]\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentBinary}\n   */\n  copy () {\n    return new ContentBinary(this.content)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentBinary}\n   */\n  splice (offset) {\n    throw error.methodUnimplemented()\n  }\n\n  /**\n   * @param {ContentBinary} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    return false\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {}\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {}\n  /**\n   * @param {Transaction} _tr\n   */\n  gc (_tr) {}\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} _offset\n   * @param {number} _offsetEnd\n   */\n  write (encoder, _offset, _offsetEnd) {\n    encoder.writeBuf(this.content)\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 3\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2 } decoder\n * @return {ContentBinary}\n */\nexport const readContentBinary = decoder => new ContentBinary(decoder.readBuf())\n","import {\n  addToIdSet,\n  UpdateDecoderV1, UpdateDecoderV2, UpdateEncoderV1, UpdateEncoderV2, StructStore, Item, Transaction // eslint-disable-line\n} from '../internals.js'\n\nexport class ContentDeleted {\n  /**\n   * @param {number} len\n   */\n  constructor (len) {\n    this.len = len\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return this.len\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return []\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return false\n  }\n\n  /**\n   * @return {ContentDeleted}\n   */\n  copy () {\n    return new ContentDeleted(this.len)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentDeleted}\n   */\n  splice (offset) {\n    const right = new ContentDeleted(this.len - offset)\n    this.len = offset\n    return right\n  }\n\n  /**\n   * @param {ContentDeleted} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    this.len += right.len\n    return true\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {\n    addToIdSet(transaction.deleteSet, item.id.client, item.id.clock, this.len)\n    item.markDeleted()\n  }\n\n  /**\n   * @param {Transaction} _transaction\n   */\n  delete (_transaction) {}\n  /**\n   * @param {Transaction} _tr\n   */\n  gc (_tr) {}\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   * @param {number} offsetEnd\n   */\n  write (encoder, offset, offsetEnd) {\n    encoder.writeLen(this.len - offset - offsetEnd)\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 1\n  }\n}\n\n/**\n * @private\n *\n * @param {UpdateDecoderV1 | UpdateDecoderV2 } decoder\n * @return {ContentDeleted}\n */\nexport const readContentDeleted = decoder => new ContentDeleted(decoder.readLen())\n","import {\n  Doc, UpdateDecoderV1, UpdateDecoderV2, UpdateEncoderV1, UpdateEncoderV2, StructStore, Transaction, Item // eslint-disable-line\n} from '../internals.js'\n\nimport * as error from 'lib0/error'\n\n/**\n * @param {string} guid\n * @param {Object<string, any>} opts\n */\nconst createDocFromOpts = (guid, opts) => new Doc({ guid, ...opts, shouldLoad: opts.shouldLoad || opts.autoLoad || false })\n\n/**\n * @private\n */\nexport class ContentDoc {\n  /**\n   * @param {Doc} doc\n   */\n  constructor (doc) {\n    if (doc._item) {\n      console.error('This document was already integrated as a sub-document. You should create a second instance instead with the same guid.')\n    }\n    /**\n     * @type {Doc}\n     */\n    this.doc = doc\n    /**\n     * @type {any}\n     */\n    const opts = {}\n    this.opts = opts\n    if (!doc.gc) {\n      opts.gc = false\n    }\n    if (doc.autoLoad) {\n      opts.autoLoad = true\n    }\n    if (doc.meta !== null) {\n      opts.meta = doc.meta\n    }\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return 1\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return [this.doc]\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentDoc}\n   */\n  copy () {\n    return new ContentDoc(createDocFromOpts(this.doc.guid, this.opts))\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentDoc}\n   */\n  splice (offset) {\n    throw error.methodUnimplemented()\n  }\n\n  /**\n   * @param {ContentDoc} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    return false\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {\n    // this needs to be reflected in doc.destroy as well\n    this.doc._item = item\n    transaction.subdocsAdded.add(this.doc)\n    if (this.doc.shouldLoad) {\n      transaction.subdocsLoaded.add(this.doc)\n    }\n  }\n\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {\n    if (transaction.subdocsAdded.has(this.doc)) {\n      transaction.subdocsAdded.delete(this.doc)\n    } else {\n      transaction.subdocsRemoved.add(this.doc)\n    }\n  }\n\n  /**\n   * @param {Transaction} _tr\n   */\n  gc (_tr) {}\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} _offset\n   * @param {number} _offsetEnd\n   */\n  write (encoder, _offset, _offsetEnd) {\n    encoder.writeString(this.doc.guid)\n    encoder.writeAny(this.opts)\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 9\n  }\n}\n\n/**\n * @private\n *\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentDoc}\n */\nexport const readContentDoc = decoder => new ContentDoc(createDocFromOpts(decoder.readString(), decoder.readAny()))\n","import {\n  UpdateDecoderV1, UpdateDecoderV2, UpdateEncoderV1, UpdateEncoderV2, StructStore, Item, Transaction // eslint-disable-line\n} from '../internals.js'\n\nimport * as error from 'lib0/error'\n\n/**\n * @private\n */\nexport class ContentEmbed {\n  /**\n   * @param {Object} embed\n   */\n  constructor (embed) {\n    this.embed = embed\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return 1\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return [this.embed]\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentEmbed}\n   */\n  copy () {\n    return new ContentEmbed(this.embed)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentEmbed}\n   */\n  splice (offset) {\n    throw error.methodUnimplemented()\n  }\n\n  /**\n   * @param {ContentEmbed} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    return false\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {}\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {}\n  /**\n   * @param {Transaction} _tr\n   */\n  gc (_tr) {}\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} _offset\n   * @param {number} _offsetEnd\n   */\n  write (encoder, _offset, _offsetEnd) {\n    encoder.writeJSON(this.embed)\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 5\n  }\n}\n\n/**\n * @private\n *\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentEmbed}\n */\nexport const readContentEmbed = decoder => new ContentEmbed(decoder.readJSON())\n","import {\n  YText, UpdateDecoderV1, UpdateDecoderV2, UpdateEncoderV1, UpdateEncoderV2, Item, StructStore, Transaction // eslint-disable-line\n} from '../internals.js'\n\nimport * as error from 'lib0/error'\n\n/**\n * @private\n */\nexport class ContentFormat {\n  /**\n   * @param {string} key\n   * @param {Object} value\n   */\n  constructor (key, value) {\n    this.key = key\n    this.value = value\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return 1\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return []\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return false\n  }\n\n  /**\n   * @return {ContentFormat}\n   */\n  copy () {\n    return new ContentFormat(this.key, this.value)\n  }\n\n  /**\n   * @param {number} _offset\n   * @return {ContentFormat}\n   */\n  splice (_offset) {\n    throw error.methodUnimplemented()\n  }\n\n  /**\n   * @param {ContentFormat} _right\n   * @return {boolean}\n   */\n  mergeWith (_right) {\n    return false\n  }\n\n  /**\n   * @param {Transaction} _transaction\n   * @param {Item} item\n   */\n  integrate (_transaction, item) {\n    // @todo searchmarker are currently unsupported for rich text documents\n    const p = /** @type {YText<any>} */ (item.parent)\n    p._searchMarker = null\n    p._hasFormatting = true\n  }\n\n  /**\n   * @param {Transaction} _transaction\n   */\n  delete (_transaction) {}\n  /**\n   * @param {Transaction} _tr\n   */\n  gc (_tr) {}\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} _offset\n   * @param {number} _offsetEnd\n   */\n  write (encoder, _offset, _offsetEnd) {\n    encoder.writeKey(this.key)\n    encoder.writeJSON(this.value)\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 6\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentFormat}\n */\nexport const readContentFormat = decoder => new ContentFormat(decoder.readKey(), decoder.readJSON())\n","import {\n  UpdateDecoderV1, UpdateDecoderV2, UpdateEncoderV1, UpdateEncoderV2, Transaction, Item, StructStore // eslint-disable-line\n} from '../internals.js'\n\n/**\n * @private\n */\nexport class ContentJSON {\n  /**\n   * @param {Array<any>} arr\n   */\n  constructor (arr) {\n    /**\n     * @type {Array<any>}\n     */\n    this.arr = arr\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return this.arr.length\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return this.arr\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentJSON}\n   */\n  copy () {\n    return new ContentJSON(this.arr)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentJSON}\n   */\n  splice (offset) {\n    const right = new ContentJSON(this.arr.slice(offset))\n    this.arr = this.arr.slice(0, offset)\n    return right\n  }\n\n  /**\n   * @param {ContentJSON} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    this.arr = this.arr.concat(right.arr)\n    return true\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {}\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {}\n  /**\n   * @param {Transaction} _tr\n   */\n  gc (_tr) {}\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   * @param {number} offsetEnd\n   */\n  write (encoder, offset, offsetEnd) {\n    const end = this.arr.length - offsetEnd\n    encoder.writeLen(end - offset)\n    for (let i = offset; i < end; i++) {\n      const c = this.arr[i]\n      encoder.writeString(c === undefined ? 'undefined' : JSON.stringify(c))\n    }\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 2\n  }\n}\n\n/**\n * @private\n *\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentJSON}\n */\nexport const readContentJSON = decoder => {\n  const len = decoder.readLen()\n  const cs = []\n  for (let i = 0; i < len; i++) {\n    const c = decoder.readString()\n    if (c === 'undefined') {\n      cs.push(undefined)\n    } else {\n      cs.push(JSON.parse(c))\n    }\n  }\n  return new ContentJSON(cs)\n}\n","import {\n  UpdateEncoderV1, UpdateEncoderV2, UpdateDecoderV1, UpdateDecoderV2, Transaction, Item, StructStore // eslint-disable-line\n} from '../internals.js'\n\nimport * as env from 'lib0/environment'\nimport * as object from 'lib0/object'\n\nconst isDevMode = env.getVariable('node_env') === 'development'\n\nexport class ContentAny {\n  /**\n   * @param {Array<any>} arr\n   */\n  constructor (arr) {\n    /**\n     * @type {Array<any>}\n     */\n    this.arr = arr\n    isDevMode && object.deepFreeze(arr)\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return this.arr.length\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return this.arr\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentAny}\n   */\n  copy () {\n    return new ContentAny(this.arr)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentAny}\n   */\n  splice (offset) {\n    const right = new ContentAny(this.arr.slice(offset))\n    this.arr = this.arr.slice(0, offset)\n    return right\n  }\n\n  /**\n   * @param {ContentAny} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    this.arr = this.arr.concat(right.arr)\n    return true\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {}\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {}\n  /**\n   * @param {Transaction} _tr\n   */\n  gc (_tr) {}\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   * @param {number} offsetEnd\n   */\n  write (encoder, offset, offsetEnd) {\n    const end = this.arr.length - offsetEnd\n    encoder.writeLen(end - offset)\n    for (let i = offset; i < end; i++) {\n      const c = this.arr[i]\n      encoder.writeAny(c)\n    }\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 8\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentAny}\n */\nexport const readContentAny = decoder => {\n  const len = decoder.readLen()\n  const cs = []\n  for (let i = 0; i < len; i++) {\n    cs.push(decoder.readAny())\n  }\n  return new ContentAny(cs)\n}\n","import {\n  UpdateDecoderV1, UpdateDecoderV2, UpdateEncoderV1, UpdateEncoderV2, Transaction, Item, StructStore // eslint-disable-line\n} from '../internals.js'\n\n/**\n * @private\n */\nexport class ContentString {\n  /**\n   * @param {string} str\n   */\n  constructor (str) {\n    /**\n     * @type {string}\n     */\n    this.str = str\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return this.str.length\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return this.str.split('')\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentString}\n   */\n  copy () {\n    return new ContentString(this.str)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentString}\n   */\n  splice (offset) {\n    const right = new ContentString(this.str.slice(offset))\n    this.str = this.str.slice(0, offset)\n\n    // Prevent encoding invalid documents because of splitting of surrogate pairs: https://github.com/yjs/yjs/issues/248\n    const firstCharCode = this.str.charCodeAt(offset - 1)\n    if (firstCharCode >= 0xD800 && firstCharCode <= 0xDBFF) {\n      // Last character of the left split is the start of a surrogate utf16/ucs2 pair.\n      // We don't support splitting of surrogate pairs because this may lead to invalid documents.\n      // Replace the invalid character with a unicode replacement character ( / U+FFFD)\n      this.str = this.str.slice(0, offset - 1) + ''\n      // replace right as well\n      right.str = '' + right.str.slice(1)\n    }\n    return right\n  }\n\n  /**\n   * @param {ContentString} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    this.str += right.str\n    return true\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {}\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {}\n  /**\n   * @param {Transaction} _tr\n   */\n  gc (_tr) {}\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   * @param {number} offsetEnd\n   */\n  write (encoder, offset, offsetEnd) {\n    encoder.writeString((offset === 0 && offsetEnd === 0) ? this.str : this.str.slice(offset, this.str.length - offsetEnd))\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 4\n  }\n}\n\n/**\n * @private\n *\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentString}\n */\nexport const readContentString = decoder => new ContentString(decoder.readString())\n","import {\n  readYArray,\n  readYMap,\n  readYText,\n  readYXmlElement,\n  readYXmlFragment,\n  readYXmlHook,\n  readYXmlText,\n  UpdateDecoderV1, UpdateDecoderV2, UpdateEncoderV1, UpdateEncoderV2, Transaction, Item // eslint-disable-line\n} from '../internals.js'\n\n/**\n * @typedef {import('../utils/types.js').YType} YType_CT\n */\n\nimport * as error from 'lib0/error'\n\n/**\n * @type {Array<(decoder: UpdateDecoderV1 | UpdateDecoderV2)=>(import('../utils/types.js').YType)>}\n * @private\n */\nexport const typeRefs = [\n  readYArray,\n  readYMap,\n  readYText,\n  readYXmlElement,\n  readYXmlFragment,\n  readYXmlHook,\n  readYXmlText\n]\n\nexport const YArrayRefID = 0\nexport const YMapRefID = 1\nexport const YTextRefID = 2\nexport const YXmlElementRefID = 3\nexport const YXmlFragmentRefID = 4\nexport const YXmlHookRefID = 5\nexport const YXmlTextRefID = 6\n\n/**\n * @private\n */\nexport class ContentType {\n  /**\n   * @param {YType_CT} type\n   */\n  constructor (type) {\n    /**\n     * @type {YType_CT}\n     */\n    this.type = type\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return 1\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return [this.type]\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentType}\n   */\n  copy () {\n    return new ContentType(this.type._copy())\n  }\n\n  /**\n   * @param {number} _offset\n   * @return {ContentType}\n   */\n  splice (_offset) {\n    throw error.methodUnimplemented()\n  }\n\n  /**\n   * @param {ContentType} _right\n   * @return {boolean}\n   */\n  mergeWith (_right) {\n    return false\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {\n    this.type._integrate(transaction.doc, item)\n  }\n\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {\n    let item = this.type._start\n    while (item !== null) {\n      if (!item.deleted) {\n        item.delete(transaction)\n      } else if (!transaction.insertSet.hasId(item.id)) {\n        // This will be gc'd later and we want to merge it if possible\n        // We try to merge all deleted items after each transaction,\n        // but we have no knowledge about that this needs to be merged\n        // since it is not in transaction.ds. Hence we add it to transaction._mergeStructs\n        transaction._mergeStructs.push(item)\n      }\n      item = item.right\n    }\n    this.type._map.forEach(item => {\n      if (!item.deleted) {\n        item.delete(transaction)\n      } else if (!transaction.insertSet.hasId(item.id)) {\n        // same as above\n        transaction._mergeStructs.push(item)\n      }\n    })\n    transaction.changed.delete(this.type)\n  }\n\n  /**\n   * @param {Transaction} tr\n   */\n  gc (tr) {\n    let item = this.type._start\n    while (item !== null) {\n      item.gc(tr, true)\n      item = item.right\n    }\n    this.type._start = null\n    this.type._map.forEach(/** @param {Item | null} item */ (item) => {\n      while (item !== null) {\n        item.gc(tr, true)\n        item = item.left\n      }\n    })\n    this.type._map = new Map()\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} _offset\n   * @param {number} _offsetEnd\n   */\n  write (encoder, _offset, _offsetEnd) {\n    this.type._write(encoder)\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 7\n  }\n}\n\n/**\n * @private\n *\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentType}\n */\nexport const readContentType = decoder => new ContentType(typeRefs[decoder.readTypeRef()](decoder))\n","import {\n  GC,\n  getState,\n  AbstractStruct,\n  replaceStruct,\n  addStruct,\n  addToIdSet,\n  findRootTypeKey,\n  compareIDs,\n  getItem,\n  getItemCleanEnd,\n  getItemCleanStart,\n  readContentDeleted,\n  readContentBinary,\n  readContentJSON,\n  readContentAny,\n  readContentString,\n  readContentEmbed,\n  readContentDoc,\n  createID,\n  readContentFormat,\n  readContentType,\n  addChangedTypeToTransaction,\n  addStructToIdSet,\n  IdSet, StackItem, UpdateDecoderV1, UpdateDecoderV2, UpdateEncoderV1, UpdateEncoderV2, ContentType, ContentDeleted, StructStore, ID, AbstractType, Transaction, // eslint-disable-line\n} from '../internals.js'\n\nimport * as error from 'lib0/error'\nimport * as binary from 'lib0/binary'\nimport * as array from 'lib0/array'\n\n/**\n * @typedef {import('../utils/types.js').YType} YType__\n */\n\n/**\n * @todo This should return several items\n *\n * @param {StructStore} store\n * @param {ID} id\n * @return {{item:Item, diff:number}}\n */\nexport const followRedone = (store, id) => {\n  /**\n   * @type {ID|null}\n   */\n  let nextID = id\n  let diff = 0\n  let item\n  do {\n    if (diff > 0) {\n      nextID = createID(nextID.client, nextID.clock + diff)\n    }\n    item = getItem(store, nextID)\n    diff = nextID.clock - item.id.clock\n    nextID = item.redone\n  } while (nextID !== null && item instanceof Item)\n  return {\n    item, diff\n  }\n}\n\n/**\n * Make sure that neither item nor any of its parents is ever deleted.\n *\n * This property does not persist when storing it into a database or when\n * sending it to other peers\n *\n * @param {Item|null} item\n * @param {boolean} keep\n */\nexport const keepItem = (item, keep) => {\n  while (item !== null && item.keep !== keep) {\n    item.keep = keep\n    item = /** @type {YType__} */ (item.parent)._item\n  }\n}\n\n/**\n * Split leftItem into two items\n * @param {Transaction?} transaction\n * @param {Item} leftItem\n * @param {number} diff\n * @return {Item}\n *\n * @function\n * @private\n */\nexport const splitItem = (transaction, leftItem, diff) => {\n  // create rightItem\n  const { client, clock } = leftItem.id\n  const rightItem = new Item(\n    createID(client, clock + diff),\n    leftItem,\n    createID(client, clock + diff - 1),\n    leftItem.right,\n    leftItem.rightOrigin,\n    leftItem.parent,\n    leftItem.parentSub,\n    leftItem.content.splice(diff)\n  )\n  if (leftItem.deleted) {\n    rightItem.markDeleted()\n  }\n  if (leftItem.keep) {\n    rightItem.keep = true\n  }\n  if (leftItem.redone !== null) {\n    rightItem.redone = createID(leftItem.redone.client, leftItem.redone.clock + diff)\n  }\n  if (transaction != null) {\n    // update left (do not set leftItem.rightOrigin as it will lead to problems when syncing)\n    leftItem.right = rightItem\n    // update right\n    if (rightItem.right !== null) {\n      rightItem.right.left = rightItem\n    }\n    // right is more specific.\n    transaction._mergeStructs.push(rightItem)\n    // update parent._map\n    if (rightItem.parentSub !== null && rightItem.right === null) {\n      /** @type {YType__} */ (rightItem.parent)._map.set(rightItem.parentSub, rightItem)\n    }\n  } else {\n    rightItem.left = null\n    rightItem.right = null\n  }\n  leftItem.length = diff\n  return rightItem\n}\n\n/**\n * More generalized version of splitItem. Split leftStruct into two structs\n * @param {Transaction?} transaction\n * @param {AbstractStruct} leftStruct\n * @param {number} diff\n * @return {GC|Item}\n *\n * @function\n * @private\n */\nexport const splitStruct = (transaction, leftStruct, diff) => {\n  if (leftStruct instanceof Item) {\n    return splitItem(transaction, leftStruct, diff)\n  } else {\n    const rightItem = leftStruct.splice(diff)\n    transaction?._mergeStructs.push(rightItem)\n    return rightItem\n  }\n}\n\n/**\n * @param {Array<StackItem>} stack\n * @param {ID} id\n */\nconst isDeletedByUndoStack = (stack, id) => array.some(stack, /** @param {StackItem} s */ s => s.deletions.hasId(id))\n\n/**\n * Redoes the effect of this operation.\n *\n * @param {Transaction} transaction The Yjs instance.\n * @param {Item} item\n * @param {Set<Item>} redoitems\n * @param {IdSet} itemsToDelete\n * @param {boolean} ignoreRemoteMapChanges\n * @param {import('../utils/UndoManager.js').UndoManager} um\n *\n * @return {Item|null}\n *\n * @private\n */\nexport const redoItem = (transaction, item, redoitems, itemsToDelete, ignoreRemoteMapChanges, um) => {\n  const doc = transaction.doc\n  const store = doc.store\n  const ownClientID = doc.clientID\n  const redone = item.redone\n  if (redone !== null) {\n    return getItemCleanStart(transaction, redone)\n  }\n  let parentItem = /** @type {YType__} */ (item.parent)._item\n  /**\n   * @type {Item|null}\n   */\n  let left = null\n  /**\n   * @type {Item|null}\n   */\n  let right\n  // make sure that parent is redone\n  if (parentItem !== null && parentItem.deleted === true) {\n    // try to undo parent if it will be undone anyway\n    if (parentItem.redone === null && (!redoitems.has(parentItem) || redoItem(transaction, parentItem, redoitems, itemsToDelete, ignoreRemoteMapChanges, um) === null)) {\n      return null\n    }\n    while (parentItem.redone !== null) {\n      parentItem = getItemCleanStart(transaction, parentItem.redone)\n    }\n  }\n  /**\n   * @type {YType__}\n   */\n  const parentType = /** @type {YType__} */ (parentItem === null ? item.parent : /** @type {ContentType} */ (parentItem.content).type)\n\n  if (item.parentSub === null) {\n    // Is an array item. Insert at the old position\n    left = item.left\n    right = item\n    // find next cloned_redo items\n    while (left !== null) {\n      /**\n       * @type {Item|null}\n       */\n      let leftTrace = left\n      // trace redone until parent matches\n      while (leftTrace !== null && /** @type {YType__} */ (leftTrace.parent)._item !== parentItem) {\n        leftTrace = leftTrace.redone === null ? null : getItemCleanStart(transaction, leftTrace.redone)\n      }\n      if (leftTrace !== null && /** @type {YType__} */ (leftTrace.parent)._item === parentItem) {\n        left = leftTrace\n        break\n      }\n      left = left.left\n    }\n    while (right !== null) {\n      /**\n       * @type {Item|null}\n       */\n      let rightTrace = right\n      // trace redone until parent matches\n      while (rightTrace !== null && /** @type {YType__} */ (rightTrace.parent)._item !== parentItem) {\n        rightTrace = rightTrace.redone === null ? null : getItemCleanStart(transaction, rightTrace.redone)\n      }\n      if (rightTrace !== null && /** @type {YType__} */ (rightTrace.parent)._item === parentItem) {\n        right = rightTrace\n        break\n      }\n      right = right.right\n    }\n  } else {\n    right = null\n    if (item.right && !ignoreRemoteMapChanges) {\n      left = item\n      // Iterate right while right is in itemsToDelete\n      // If it is intended to delete right while item is redone, we can expect that item should replace right.\n      while (left !== null && left.right !== null && (left.right.redone || itemsToDelete.hasId(left.right.id) || isDeletedByUndoStack(um.undoStack, left.right.id) || isDeletedByUndoStack(um.redoStack, left.right.id))) {\n        left = left.right\n        // follow redone\n        while (left.redone) left = getItemCleanStart(transaction, left.redone)\n      }\n      if (left && left.right !== null) {\n        // It is not possible to redo this item because it conflicts with a\n        // change from another client\n        return null\n      }\n    } else {\n      left = parentType._map.get(item.parentSub) || null\n    }\n  }\n  const nextClock = getState(store, ownClientID)\n  const nextId = createID(ownClientID, nextClock)\n  const redoneItem = new Item(\n    nextId,\n    left, left && left.lastId,\n    right, right && right.id,\n    parentType,\n    item.parentSub,\n    item.content.copy()\n  )\n  item.redone = nextId\n  keepItem(redoneItem, true)\n  redoneItem.integrate(transaction, 0)\n  return redoneItem\n}\n\n/**\n * Abstract class that represents any content.\n */\nexport class Item extends AbstractStruct {\n  /**\n   * @param {ID} id\n   * @param {Item | null} left\n   * @param {ID | null} origin\n   * @param {Item | null} right\n   * @param {ID | null} rightOrigin\n   * @param {AbstractType<any,any>|ID|null} parent Is a type if integrated, is null if it is possible to copy parent from left or right, is ID before integration to search for it.\n   * @param {string | null} parentSub\n   * @param {AbstractContent} content\n   */\n  constructor (id, left, origin, right, rightOrigin, parent, parentSub, content) {\n    super(id, content.getLength())\n    /**\n     * The item that was originally to the left of this item.\n     * @type {ID | null}\n     */\n    this.origin = origin\n    /**\n     * The item that is currently to the left of this item.\n     * @type {Item | null}\n     */\n    this.left = left\n    /**\n     * The item that is currently to the right of this item.\n     * @type {Item | null}\n     */\n    this.right = right\n    /**\n     * The item that was originally to the right of this item.\n     * @type {ID | null}\n     */\n    this.rightOrigin = rightOrigin\n    /**\n     * @type {AbstractType<any,any>|ID|null}\n     */\n    this.parent = parent\n    /**\n     * If the parent refers to this item with some kind of key (e.g. YMap, the\n     * key is specified here. The key is then used to refer to the list in which\n     * to insert this item. If `parentSub = null` type._start is the list in\n     * which to insert to. Otherwise it is `parent._map`.\n     * @type {String | null}\n     */\n    this.parentSub = parentSub\n    /**\n     * If this type's effect is redone this type refers to the type that undid\n     * this operation.\n     * @type {ID | null}\n     */\n    this.redone = null\n    /**\n     * @type {AbstractContent}\n     */\n    this.content = content\n    /**\n     * bit1: keep\n     * bit2: countable\n     * bit3: deleted\n     * bit4: mark - mark node as fast-search-marker\n     * @type {number} byte\n     */\n    this.info = this.content.isCountable() ? binary.BIT2 : 0\n  }\n\n  /**\n   * This is used to mark the item as an indexed fast-search marker\n   *\n   * @type {boolean}\n   */\n  set marker (isMarked) {\n    if (((this.info & binary.BIT4) > 0) !== isMarked) {\n      this.info ^= binary.BIT4\n    }\n  }\n\n  get marker () {\n    return (this.info & binary.BIT4) > 0\n  }\n\n  /**\n   * If true, do not garbage collect this Item.\n   */\n  get keep () {\n    return (this.info & binary.BIT1) > 0\n  }\n\n  set keep (doKeep) {\n    if (this.keep !== doKeep) {\n      this.info ^= binary.BIT1\n    }\n  }\n\n  get countable () {\n    return (this.info & binary.BIT2) > 0\n  }\n\n  /**\n   * Whether this item was deleted or not.\n   * @type {Boolean}\n   */\n  get deleted () {\n    return (this.info & binary.BIT3) > 0\n  }\n\n  set deleted (doDelete) {\n    if (this.deleted !== doDelete) {\n      this.info ^= binary.BIT3\n    }\n  }\n\n  markDeleted () {\n    this.info |= binary.BIT3\n  }\n\n  /**\n   * Return the creator clientID of the missing op or define missing items and return null.\n   *\n   * @param {Transaction} transaction\n   * @param {StructStore} store\n   * @return {null | number}\n   */\n  getMissing (transaction, store) {\n    if (this.origin && (this.origin.clock >= getState(store, this.origin.client) || store.skips.hasId(this.origin))) {\n      return this.origin.client\n    }\n    if (this.rightOrigin && (this.rightOrigin.clock >= getState(store, this.rightOrigin.client) || store.skips.hasId(this.rightOrigin))) {\n      return this.rightOrigin.client\n    }\n    if (this.parent && this.parent.constructor === ID && (this.parent.clock >= getState(store, this.parent.client) || store.skips.hasId(this.parent))) {\n      return this.parent.client\n    }\n    // We have all missing ids, now find the items\n    if (this.origin) {\n      this.left = getItemCleanEnd(transaction, store, this.origin)\n      this.origin = this.left.lastId\n    }\n    if (this.rightOrigin) {\n      this.right = getItemCleanStart(transaction, this.rightOrigin)\n      this.rightOrigin = this.right.id\n    }\n    if ((this.left && this.left.constructor === GC) || (this.right && this.right.constructor === GC)) {\n      this.parent = null\n    } else if (!this.parent) {\n      // only set parent if this shouldn't be garbage collected\n      if (this.left && this.left.constructor === Item) {\n        this.parent = this.left.parent\n        this.parentSub = this.left.parentSub\n      } else if (this.right && this.right.constructor === Item) {\n        this.parent = this.right.parent\n        this.parentSub = this.right.parentSub\n      }\n    } else if (this.parent.constructor === ID) {\n      const parentItem = getItem(store, this.parent)\n      if (parentItem.constructor === GC) {\n        this.parent = null\n      } else {\n        this.parent = /** @type {ContentType} */ (parentItem.content).type\n      }\n    }\n    return null\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {number} offset\n   */\n  integrate (transaction, offset) {\n    if (offset > 0) {\n      this.id.clock += offset\n      this.left = getItemCleanEnd(transaction, transaction.doc.store, createID(this.id.client, this.id.clock - 1))\n      this.origin = this.left.lastId\n      this.content = this.content.splice(offset)\n      this.length -= offset\n    }\n\n    if (this.parent) {\n      if ((!this.left && (!this.right || this.right.left !== null)) || (this.left && this.left.right !== this.right)) {\n        /**\n         * @type {Item|null}\n         */\n        let left = this.left\n\n        /**\n         * @type {Item|null}\n         */\n        let o\n        // set o to the first conflicting item\n        if (left !== null) {\n          o = left.right\n        } else if (this.parentSub !== null) {\n          o = /** @type {AbstractType<any>} */ (this.parent)._map.get(this.parentSub) || null\n          while (o !== null && o.left !== null) {\n            o = o.left\n          }\n        } else {\n          o = /** @type {AbstractType<any>} */ (this.parent)._start\n        }\n        // TODO: use something like DeleteSet here (a tree implementation would be best)\n        // @todo use global set definitions\n        /**\n         * @type {Set<Item>}\n         */\n        const conflictingItems = new Set()\n        /**\n         * @type {Set<Item>}\n         */\n        const itemsBeforeOrigin = new Set()\n        // Let c in conflictingItems, b in itemsBeforeOrigin\n        // ***{origin}bbbb{this}{c,b}{c,b}{o}***\n        // Note that conflictingItems is a subset of itemsBeforeOrigin\n        while (o !== null && o !== this.right) {\n          itemsBeforeOrigin.add(o)\n          conflictingItems.add(o)\n          if (compareIDs(this.origin, o.origin)) {\n            // case 1\n            if (o.id.client < this.id.client) {\n              left = o\n              conflictingItems.clear()\n            } else if (compareIDs(this.rightOrigin, o.rightOrigin)) {\n              // this and o are conflicting and point to the same integration points. The id decides which item comes first.\n              // Since this is to the left of o, we can break here\n              break\n            } // else, o might be integrated before an item that this conflicts with. If so, we will find it in the next iterations\n          } else if (o.origin !== null && itemsBeforeOrigin.has(getItem(transaction.doc.store, o.origin))) { // use getItem instead of getItemCleanEnd because we don't want / need to split items.\n            // case 2\n            if (!conflictingItems.has(getItem(transaction.doc.store, o.origin))) {\n              left = o\n              conflictingItems.clear()\n            }\n          } else {\n            break\n          }\n          o = o.right\n        }\n        this.left = left\n      }\n      // reconnect left/right + update parent map/start if necessary\n      if (this.left !== null) {\n        const right = this.left.right\n        this.right = right\n        this.left.right = this\n      } else {\n        let r\n        if (this.parentSub !== null) {\n          r = /** @type {AbstractType<any>} */ (this.parent)._map.get(this.parentSub) || null\n          while (r !== null && r.left !== null) {\n            r = r.left\n          }\n        } else {\n          r = /** @type {AbstractType<any>} */ (this.parent)._start\n          ;/** @type {AbstractType<any>} */ (this.parent)._start = this\n        }\n        this.right = r\n      }\n      if (this.right !== null) {\n        this.right.left = this\n      } else if (this.parentSub !== null) {\n        // set as current parent value if right === null and this is parentSub\n        /** @type {AbstractType<any>} */ (this.parent)._map.set(this.parentSub, this)\n        if (this.left !== null) {\n          // this is the current attribute value of parent. delete right\n          this.left.delete(transaction)\n        }\n      }\n      // adjust length of parent\n      if (this.parentSub === null && this.countable && !this.deleted) {\n        /** @type {AbstractType<any>} */ (this.parent)._length += this.length\n      }\n      addStructToIdSet(transaction.insertSet, this)\n      addStruct(transaction.doc.store, this)\n      this.content.integrate(transaction, this)\n      // add parent to transaction.changed\n      addChangedTypeToTransaction(transaction, /** @type {import('../utils/types.js').YType} */ (this.parent), this.parentSub)\n      if ((/** @type {AbstractType<any>} */ (this.parent)._item !== null && /** @type {AbstractType<any>} */ (this.parent)._item.deleted) || (this.parentSub !== null && this.right !== null)) {\n        // delete if parent is deleted or if this is not the current attribute value of parent\n        this.delete(transaction)\n      }\n    } else {\n      // parent is not defined. Integrate GC struct instead\n      new GC(this.id, this.length).integrate(transaction, 0)\n    }\n  }\n\n  /**\n   * Returns the next non-deleted item\n   */\n  get next () {\n    let n = this.right\n    while (n !== null && n.deleted) {\n      n = n.right\n    }\n    return n\n  }\n\n  /**\n   * Returns the previous non-deleted item\n   */\n  get prev () {\n    let n = this.left\n    while (n !== null && n.deleted) {\n      n = n.left\n    }\n    return n\n  }\n\n  /**\n   * Computes the last content address of this Item.\n   */\n  get lastId () {\n    // allocating ids is pretty costly because of the amount of ids created, so we try to reuse whenever possible\n    return this.length === 1 ? this.id : createID(this.id.client, this.id.clock + this.length - 1)\n  }\n\n  /**\n   * Try to merge two items\n   *\n   * @param {Item} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    if (\n      this.constructor === right.constructor &&\n      compareIDs(right.origin, this.lastId) &&\n      this.right === right &&\n      compareIDs(this.rightOrigin, right.rightOrigin) &&\n      this.id.client === right.id.client &&\n      this.id.clock + this.length === right.id.clock &&\n      this.deleted === right.deleted &&\n      this.redone === null &&\n      right.redone === null &&\n      this.content.constructor === right.content.constructor &&\n      this.content.mergeWith(right.content)\n    ) {\n      const searchMarker = /** @type {AbstractType<any>} */ (this.parent)._searchMarker\n      if (searchMarker) {\n        searchMarker.forEach(marker => {\n          if (marker.p === right) {\n            // right is going to be \"forgotten\" so we need to update the marker\n            marker.p = this\n            // adjust marker index\n            if (!this.deleted && this.countable) {\n              marker.index -= this.length\n            }\n          }\n        })\n      }\n      if (right.keep) {\n        this.keep = true\n      }\n      this.right = right.right\n      if (this.right !== null) {\n        this.right.left = this\n      }\n      this.length += right.length\n      return true\n    }\n    return false\n  }\n\n  /**\n   * Mark this Item as deleted.\n   *\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {\n    if (!this.deleted) {\n      const parent = /** @type {import('../utils/types.js').YType} */ (this.parent)\n      // adjust the length of parent\n      if (this.countable && this.parentSub === null) {\n        parent._length -= this.length\n      }\n      this.markDeleted()\n      addToIdSet(transaction.deleteSet, this.id.client, this.id.clock, this.length)\n      addChangedTypeToTransaction(transaction, parent, this.parentSub)\n      this.content.delete(transaction)\n    }\n  }\n\n  /**\n   * @param {Transaction} tr\n   * @param {boolean} parentGCd\n   */\n  gc (tr, parentGCd) {\n    if (!this.deleted) {\n      throw error.unexpectedCase()\n    }\n    this.content.gc(tr)\n    if (parentGCd) {\n      replaceStruct(tr, this, new GC(this.id, this.length))\n    } else {\n      this.content = new ContentDeleted(this.length)\n    }\n  }\n\n  /**\n   * Transform the properties of this type to binary and write it to an\n   * BinaryEncoder.\n   *\n   * This is called when this Item is sent to a remote peer.\n   *\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n   * @param {number} offset\n   * @param {number} offsetEnd\n   */\n  write (encoder, offset, offsetEnd) {\n    const origin = offset > 0 ? createID(this.id.client, this.id.clock + offset - 1) : this.origin\n    const rightOrigin = this.rightOrigin\n    const parentSub = this.parentSub\n    const info = (this.content.getRef() & binary.BITS5) |\n      (origin === null ? 0 : binary.BIT8) | // origin is defined\n      (rightOrigin === null ? 0 : binary.BIT7) | // right origin is defined\n      (parentSub === null ? 0 : binary.BIT6) // parentSub is non-null\n    encoder.writeInfo(info)\n    if (origin !== null) {\n      encoder.writeLeftID(origin)\n    }\n    if (rightOrigin !== null) {\n      encoder.writeRightID(rightOrigin)\n    }\n    if (origin === null && rightOrigin === null) {\n      const parent = /** @type {AbstractType<any>} */ (this.parent)\n      if (parent._item !== undefined) {\n        const parentItem = parent._item\n        if (parentItem === null) {\n          // parent type on y._map\n          // find the correct key\n          const ykey = findRootTypeKey(parent)\n          encoder.writeParentInfo(true) // write parentYKey\n          encoder.writeString(ykey)\n        } else {\n          encoder.writeParentInfo(false) // write parent id\n          encoder.writeLeftID(parentItem.id)\n        }\n      } else if (parent.constructor === String) { // this edge case was added by differential updates\n        encoder.writeParentInfo(true) // write parentYKey\n        encoder.writeString(parent)\n      } else if (parent.constructor === ID) {\n        encoder.writeParentInfo(false) // write parent id\n        encoder.writeLeftID(parent)\n      } else {\n        error.unexpectedCase()\n      }\n      if (parentSub !== null) {\n        encoder.writeString(parentSub)\n      }\n    }\n    this.content.write(encoder, offset, offsetEnd)\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @param {number} info\n */\nexport const readItemContent = (decoder, info) => contentRefs[info & binary.BITS5](decoder)\n\n/**\n * A lookup map for reading Item content.\n *\n * @type {Array<function(UpdateDecoderV1 | UpdateDecoderV2):AbstractContent>}\n */\nexport const contentRefs = [\n  () => { error.unexpectedCase() }, // GC is not ItemContent\n  readContentDeleted, // 1\n  readContentJSON, // 2\n  readContentBinary, // 3\n  readContentString, // 4\n  readContentEmbed, // 5\n  readContentFormat, // 6\n  readContentType, // 7\n  readContentAny, // 8\n  readContentDoc, // 9\n  () => { error.unexpectedCase() } // 10 - Skip is not ItemContent\n]\n\n/**\n * Do not implement this class!\n */\nexport class AbstractContent {\n  /**\n   * @return {number}\n   */\n  getLength () {\n    throw error.methodUnimplemented()\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    throw error.methodUnimplemented()\n  }\n\n  /**\n   * Should return false if this Item is some kind of meta information\n   * (e.g. format information).\n   *\n   * * Whether this Item should be addressable via `yarray.get(i)`\n   * * Whether this Item should be counted when computing yarray.length\n   *\n   * @return {boolean}\n   */\n  isCountable () {\n    throw error.methodUnimplemented()\n  }\n\n  /**\n   * @return {AbstractContent}\n   */\n  copy () {\n    throw error.methodUnimplemented()\n  }\n\n  /**\n   * @param {number} _offset\n   * @return {AbstractContent}\n   */\n  splice (_offset) {\n    throw error.methodUnimplemented()\n  }\n\n  /**\n   * @param {AbstractContent} _right\n   * @return {boolean}\n   */\n  mergeWith (_right) {\n    throw error.methodUnimplemented()\n  }\n\n  /**\n   * @param {Transaction} _transaction\n   * @param {Item} _item\n   */\n  integrate (_transaction, _item) {\n    throw error.methodUnimplemented()\n  }\n\n  /**\n   * @param {Transaction} _transaction\n   */\n  delete (_transaction) {\n    throw error.methodUnimplemented()\n  }\n\n  /**\n   * @param {Transaction} _transaction\n   */\n  gc (_transaction) {\n    throw error.methodUnimplemented()\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} _encoder\n   * @param {number} _offset\n   * @param {number} _offsetEnd\n   */\n  write (_encoder, _offset, _offsetEnd) {\n    throw error.methodUnimplemented()\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    throw error.methodUnimplemented()\n  }\n}\n","import {\n  AbstractStruct,\n  addStruct,\n  addToIdSet,\n  UpdateEncoderV1, UpdateEncoderV2, StructStore, Transaction, // eslint-disable-line\n  createID\n} from '../internals.js'\n\nimport * as encoding from 'lib0/encoding'\n\nexport const structSkipRefNumber = 10\n\n/**\n * @private\n */\nexport class Skip extends AbstractStruct {\n  get deleted () {\n    return false\n  }\n\n  delete () {}\n\n  /**\n   * @param {Skip} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    if (this.constructor !== right.constructor) {\n      return false\n    }\n    this.length += right.length\n    return true\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {number} offset\n   */\n  integrate (transaction, offset) {\n    if (offset > 0) {\n      this.id.clock += offset\n      this.length -= offset\n    }\n    addToIdSet(transaction.doc.store.skips, this.id.client, this.id.clock, this.length)\n    addStruct(transaction.doc.store, this)\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeInfo(structSkipRefNumber)\n    // write as VarUint because Skips can't make use of predictable length-encoding\n    encoding.writeVarUint(encoder.restEncoder, this.length - offset)\n  }\n\n  /**\n   * @param {Transaction} _transaction\n   * @param {StructStore} _store\n   * @return {null | number}\n   */\n  getMissing (_transaction, _store) {\n    return null\n  }\n\n  /**\n   * @param {number} diff\n   */\n  splice (diff) {\n    const other = new Skip(createID(this.id.client, this.id.clock + diff), this.length - diff)\n    this.length = diff\n    return other\n  }\n}\n"],"names":["buf","log"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,MAAM,iBAAiB,SAAS,YAAY,CAAC;AACpD;AACA;AACA;AACA;AACA,EAAE,WAAW,CAAC,CAAC,IAAI,EAAE,SAAS,EAAE;AAChC,IAAI,KAAK;AACT,IAAI,IAAI,CAAC,GAAG,GAAG;AACf,IAAI,IAAI,CAAC,SAAS,GAAG;AACrB,EAAE;AACF;;ACNO,MAAM,OAAO,CAAC;AACrB;AACA;AACA;AACA;AACA,EAAE,WAAW,CAAC,CAAC,KAAK,EAAE,GAAG,EAAE;AAC3B;AACA;AACA;AACA,IAAI,IAAI,CAAC,KAAK,GAAG;AACjB;AACA;AACA;AACA,IAAI,IAAI,CAAC,GAAG,GAAG;AACf,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE,QAAQ,CAAC,CAAC,KAAK,EAAE,GAAG,EAAE;AACxB,IAAI,OAAO,IAAI,OAAO,CAAC,KAAK,EAAE,GAAG;AACjC,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE,IAAI,KAAK,CAAC,GAAG;AACf,IAAI,OAAO;AACX,EAAE;AACF;;AAEO,MAAM,YAAY,CAAC;AAC1B;AACA;AACA;AACA;AACA;AACA,EAAE,WAAW,CAAC,CAAC,KAAK,EAAE,GAAG,EAAE,MAAM,EAAE;AACnC;AACA;AACA;AACA,IAAI,IAAI,CAAC,KAAK,GAAG;AACjB;AACA;AACA;AACA,IAAI,IAAI,CAAC,GAAG,GAAG;AACf;AACA;AACA;AACA,IAAI,IAAI,CAAC,MAAM,GAAG;AAClB,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,kBAAkB,GAAG,CAAC,KAAK,EAAE,GAAG,EAAE,MAAM,KAAK,IAAI,YAAY,CAAC,KAAK,EAAE,GAAG,EAAE,MAAM;;AAEtF,MAAM,QAAQ,CAAC;AACtB;AACA;AACA;AACA,EAAE,WAAW,CAAC,CAAC,GAAG,EAAE;AACpB,IAAI,IAAI,CAAC,MAAM,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA,IAAI,IAAI,CAAC,WAAW,GAAG;AACvB;AACA;AACA;AACA,IAAI,IAAI,CAAC,IAAI,GAAG;AAChB,EAAE;;AAEF,EAAE,IAAI,CAAC,GAAG;AACV,IAAI,OAAO,IAAI,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE;AACzC,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE,GAAG,CAAC,CAAC,KAAK,EAAE,MAAM,EAAE;AACtB,IAAI,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC;AAC/C,IAAI,IAAI,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,GAAG,KAAK,KAAK,EAAE;AACzC,MAAM,IAAI,IAAI,CAAC,WAAW,EAAE;AAC5B,QAAQ,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,GAAG,IAAI,OAAO,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,GAAG,GAAG,MAAM;AACnF,QAAQ,IAAI,CAAC,WAAW,GAAG;AAC3B,MAAM,CAAC,MAAM;AACb,QAAQ,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,GAAG,IAAI;AAC/C,MAAM;AACN,IAAI,CAAC,MAAM;AACX,MAAM,IAAI,CAAC,MAAM,GAAG;AACpB,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC,KAAK,EAAE,MAAM,CAAC;AAC/C,IAAI;AACJ,EAAE;;AAEF;AACA;AACA;AACA,EAAE,MAAM,CAAC,GAAG;AACZ,IAAI,MAAM,GAAG,GAAG,IAAI,CAAC;AACrB,IAAI,IAAI,CAAC,WAAW,GAAG;AACvB,IAAI,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE;AACtB,MAAM,IAAI,CAAC,MAAM,GAAG;AACpB,MAAM,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,KAAK,GAAG,CAAC,CAAC,KAAK;AAC1C;AACA;AACA;AACA;AACA,MAAM,IAAI,CAAC,EAAE;AACb,MAAM,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AAC9C,QAAQ,MAAM,IAAI,GAAG,GAAG,CAAC,CAAC,GAAG,CAAC;AAC9B,QAAQ,MAAM,KAAK,GAAG,GAAG,CAAC,CAAC;AAC3B,QAAQ,IAAI,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,GAAG,IAAI,KAAK,CAAC,KAAK,EAAE;AAClD,UAAU,MAAM,CAAC,GAAG,KAAK,CAAC,KAAK,GAAG,KAAK,CAAC,GAAG,GAAG,IAAI,CAAC;AACnD,UAAU,IAAI,IAAI,CAAC,GAAG,GAAG,CAAC,EAAE;AAC5B,YAAY,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,IAAI,OAAO,CAAC,IAAI,CAAC,KAAK,EAAE,CAAC;AAClD,UAAU;AACV,QAAQ,CAAC,MAAM,IAAI,IAAI,CAAC,GAAG,KAAK,CAAC,EAAE;AACnC,UAAU,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG;AACvB,QAAQ,CAAC,MAAM;AACf,UAAU,IAAI,CAAC,GAAG,CAAC,EAAE;AACrB,YAAY,GAAG,CAAC,CAAC,CAAC,GAAG;AACrB,UAAU;AACV,UAAU,CAAC;AACX,QAAQ;AACR,MAAM;AACN,MAAM,GAAG,CAAC,MAAM,GAAG,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG;AAClD,IAAI;AACJ,IAAI,OAAO;AACX,EAAE;AACF;;AAEA;AACA;AACA;AACO,MAAM,KAAK,CAAC;AACnB,EAAE,WAAW,CAAC,GAAG;AACjB;AACA;AACA;AACA,IAAI,IAAI,CAAC,OAAO,GAAG,IAAI,GAAG;AAC1B,EAAE;;AAEF,EAAE,OAAO,CAAC,GAAG;AACb,IAAI,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,KAAK;AACjC,EAAE;;AAEF;AACA;AACA;AACA,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE;AACd,IAAI,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,MAAM,EAAE,MAAM,KAAK;AAC7C,MAAM,MAAM,CAAC,MAAM,EAAE,CAAC,OAAO,CAAC,CAAC,KAAK,KAAK;AACzC,QAAQ,CAAC,CAAC,KAAK,EAAE,MAAM;AACvB,MAAM,CAAC;AACP,IAAI,CAAC;AACL,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE,KAAK,CAAC,CAAC,EAAE,EAAE;AACb,IAAI,OAAO,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,MAAM,EAAE,EAAE,CAAC,KAAK;AACvC,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE,GAAG,CAAC,CAAC,MAAM,EAAE,KAAK,EAAE;AACtB,IAAI,MAAM,EAAE,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM;AACtC,IAAI,IAAI,EAAE,EAAE;AACZ,MAAM,OAAO,mBAAmB,CAAC,EAAE,CAAC,MAAM,EAAE,EAAE,KAAK,CAAC,KAAK;AACzD,IAAI;AACJ,IAAI,OAAO;AACX,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,KAAK,CAAC,CAAC,MAAM,EAAE,KAAK,EAAE,GAAG,EAAE;AAC7B,IAAI,MAAM,EAAE,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM;AACtC;AACA;AACA;AACA,IAAI,MAAM,GAAG,GAAG;AAChB,IAAI,IAAI,EAAE,EAAE;AACZ;AACA;AACA;AACA,MAAM,MAAM,MAAM,GAAG,EAAE,CAAC,MAAM;AAC9B,MAAM,IAAI,KAAK,GAAG,wBAAwB,CAAC,MAAM,EAAE,KAAK;AACxD,MAAM,IAAI,KAAK,KAAK,IAAI,EAAE;AAC1B,QAAQ,IAAI,IAAI,GAAG;AACnB,QAAQ,OAAO,KAAK,GAAG,MAAM,CAAC,MAAM,EAAE;AACtC,UAAU,IAAI,CAAC,GAAG,MAAM,CAAC,KAAK;AAC9B,UAAU,IAAI,CAAC,CAAC,KAAK,GAAG,KAAK,EAAE;AAC/B,YAAY,CAAC,GAAG,IAAI,OAAO,CAAC,KAAK,EAAE,CAAC,CAAC,GAAG,IAAI,KAAK,GAAG,CAAC,CAAC,KAAK,CAAC;AAC5D,UAAU;AACV,UAAU,IAAI,CAAC,CAAC,KAAK,GAAG,CAAC,CAAC,GAAG,GAAG,KAAK,GAAG,GAAG,EAAE;AAC7C,YAAY,CAAC,GAAG,IAAI,OAAO,CAAC,CAAC,CAAC,KAAK,EAAE,KAAK,GAAG,GAAG,GAAG,CAAC,CAAC,KAAK;AAC1D,UAAU;AACV,UAAU,IAAI,CAAC,CAAC,GAAG,IAAI,CAAC,EAAE;AAC1B,UAAU,MAAM,OAAO,GAAG,IAAI,IAAI,IAAI,GAAG,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,GAAG,GAAG;AACjE,UAAU,IAAI,OAAO,GAAG,CAAC,CAAC,KAAK,EAAE;AACjC,YAAY,GAAG,CAAC,IAAI,CAAC,kBAAkB,CAAC,OAAO,EAAE,CAAC,CAAC,KAAK,GAAG,OAAO,EAAE,KAAK,CAAC;AAC1E,UAAU;AACV,UAAU,IAAI,GAAG;AACjB,UAAU,GAAG,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAC,CAAC,KAAK,EAAE,CAAC,CAAC,GAAG,EAAE,IAAI,CAAC;AAC3D,UAAU,KAAK;AACf,QAAQ;AACR,MAAM;AACN,IAAI;AACJ,IAAI,IAAI,GAAG,CAAC,MAAM,GAAG,CAAC,EAAE;AACxB,MAAM,MAAM,IAAI,GAAG,GAAG,CAAC,GAAG,CAAC,MAAM,GAAG,CAAC;AACrC,MAAM,MAAM,GAAG,GAAG,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;AACpC,MAAM,IAAI,GAAG,GAAG,KAAK,GAAG,GAAG,EAAE;AAC7B,QAAQ,GAAG,CAAC,IAAI,CAAC,kBAAkB,CAAC,GAAG,EAAE,KAAK,GAAG,GAAG,GAAG,GAAG,EAAE,KAAK,CAAC;AAClE,MAAM;AACN,IAAI,CAAC,MAAM;AACX,MAAM,GAAG,CAAC,IAAI,CAAC,kBAAkB,CAAC,KAAK,EAAE,GAAG,EAAE,KAAK,CAAC;AACpD,IAAI;AACJ,IAAI,OAAO;AACX,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE,GAAG,CAAC,CAAC,MAAM,EAAE,KAAK,EAAE,GAAG,EAAE;AAC3B,IAAI,UAAU,CAAC,IAAI,EAAE,MAAM,EAAE,KAAK,EAAE,GAAG;AACvC,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE,MAAM,CAAC,CAAC,MAAM,EAAE,KAAK,EAAE,GAAG,EAAE;AAC9B,IAAI,qBAAqB,CAAC,IAAI,EAAE,MAAM,EAAE,KAAK,EAAE,GAAG;AAClD,EAAE;;AAEF;AACA;AACA;AACA,EAAE,CAAC,MAAM,CAAC,mBAAmB,EAAE,CAAC,KAAK,EAAE;AACvC,IAAI,OAAO,WAAW,CAAC,IAAI,EAAE,KAAK;AAClC,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,qBAAqB,GAAG,CAAC,GAAG,EAAE,MAAM,EAAE,KAAK,EAAE,GAAG,KAAK;AAClE,EAAE,MAAM,EAAE,GAAG,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM;AACnC,EAAE,IAAI,EAAE,IAAI,GAAG,GAAG,CAAC,EAAE;AACrB,IAAI,MAAM,GAAG,GAAG,EAAE,CAAC,MAAM;AACzB,IAAI,IAAI,KAAK,GAAG,wBAAwB,CAAC,GAAG,EAAE,KAAK;AACnD,IAAI,IAAI,KAAK,IAAI,IAAI,EAAE;AACvB,MAAM,KAAK,IAAI,CAAC,GAAG,GAAG,CAAC,KAAK,CAAC,EAAE,KAAK,GAAG,GAAG,CAAC,MAAM,IAAI,CAAC,CAAC,KAAK,GAAG,KAAK,GAAG,GAAG,EAAE,CAAC,GAAG,GAAG,CAAC,EAAE,KAAK,CAAC,EAAE;AAC9F,QAAQ,IAAI,CAAC,CAAC,KAAK,GAAG,KAAK,EAAE;AAC7B,UAAU,GAAG,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,KAAK,EAAE,KAAK,GAAG,CAAC,CAAC,KAAK;AAC1D,UAAU,IAAI,KAAK,GAAG,GAAG,GAAG,CAAC,CAAC,KAAK,GAAG,CAAC,CAAC,GAAG,EAAE;AAC7C,YAAY,GAAG,CAAC,MAAM,CAAC,KAAK,GAAG,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,QAAQ,CAAC,KAAK,GAAG,GAAG,EAAE,CAAC,CAAC,KAAK,GAAG,CAAC,CAAC,GAAG,GAAG,KAAK,GAAG,GAAG,CAAC;AAC3F,UAAU;AACV,QAAQ,CAAC,MAAM,IAAI,KAAK,GAAG,GAAG,GAAG,CAAC,CAAC,KAAK,GAAG,CAAC,CAAC,GAAG,EAAE;AAClD;AACA,UAAU,GAAG,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,QAAQ,CAAC,KAAK,GAAG,GAAG,EAAE,CAAC,CAAC,KAAK,GAAG,CAAC,CAAC,GAAG,GAAG,KAAK,GAAG,GAAG;AAC5E,QAAQ,CAAC,MAAM,IAAI,GAAG,CAAC,MAAM,KAAK,CAAC,EAAE;AACrC,UAAU,GAAG,CAAC,OAAO,CAAC,MAAM,CAAC,MAAM;AACnC,UAAU;AACV,QAAQ,CAAC,MAAM;AACf,UAAU,GAAG,CAAC,MAAM,CAAC,KAAK,EAAE,EAAE,CAAC;AAC/B,QAAQ;AACR,MAAM;AACN,IAAI;AACJ,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,qBAAqB,GAAG,CAAC,WAAW,EAAE,EAAE,EAAE,CAAC;AACxD,EAAE,EAAE,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,QAAQ,EAAE,QAAQ,KAAK;AAC7C,IAAI,MAAM,MAAM,GAAG,QAAQ,CAAC,MAAM;AAClC,IAAI,MAAM,OAAO,kCAAkC,WAAW,CAAC,GAAG,CAAC,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC;AAC9F,IAAI,IAAI,OAAO,IAAI,IAAI,EAAE;AACzB,MAAM,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AAC9C,QAAQ,MAAM,GAAG,GAAG,MAAM,CAAC,CAAC;AAC5B,QAAQ,cAAc,CAAC,WAAW,EAAE,OAAO,EAAE,GAAG,CAAC,KAAK,EAAE,GAAG,CAAC,GAAG,EAAE,CAAC;AAClE,MAAM;AACN,IAAI;AACJ,EAAE,CAAC;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,mBAAmB,GAAG,CAAC,GAAG,EAAE,KAAK,KAAK;AACnD,EAAE,IAAI,IAAI,GAAG;AACb,EAAE,IAAI,KAAK,GAAG,GAAG,CAAC,MAAM,GAAG;AAC3B,EAAE,OAAO,IAAI,IAAI,KAAK,EAAE;AACxB,IAAI,MAAM,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,IAAI,GAAG,KAAK,IAAI,CAAC;AAClD,IAAI,MAAM,GAAG,GAAG,GAAG,CAAC,QAAQ;AAC5B,IAAI,MAAM,QAAQ,GAAG,GAAG,CAAC;AACzB,IAAI,IAAI,QAAQ,IAAI,KAAK,EAAE;AAC3B,MAAM,IAAI,KAAK,GAAG,QAAQ,GAAG,GAAG,CAAC,GAAG,EAAE;AACtC,QAAQ,OAAO;AACf,MAAM;AACN,MAAM,IAAI,GAAG,QAAQ,GAAG;AACxB,IAAI,CAAC,MAAM;AACX,MAAM,KAAK,GAAG,QAAQ,GAAG;AACzB,IAAI;AACJ,EAAE;AACF,EAAE,OAAO;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,wBAAwB,GAAG,CAAC,GAAG,EAAE,KAAK,KAAK;AACxD,EAAE,IAAI,IAAI,GAAG;AACb,EAAE,IAAI,KAAK,GAAG,GAAG,CAAC,MAAM,GAAG;AAC3B,EAAE,OAAO,IAAI,IAAI,KAAK,EAAE;AACxB,IAAI,MAAM,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,IAAI,GAAG,KAAK,IAAI,CAAC;AAClD,IAAI,MAAM,GAAG,GAAG,GAAG,CAAC,QAAQ;AAC5B,IAAI,MAAM,QAAQ,GAAG,GAAG,CAAC;AACzB,IAAI,IAAI,QAAQ,IAAI,KAAK,EAAE;AAC3B,MAAM,IAAI,KAAK,GAAG,QAAQ,GAAG,GAAG,CAAC,GAAG,EAAE;AACtC,QAAQ,OAAO;AACf,MAAM;AACN,MAAM,IAAI,GAAG,QAAQ,GAAG;AACxB,IAAI,CAAC,MAAM;AACX,MAAM,KAAK,GAAG,QAAQ,GAAG;AACzB,IAAI;AACJ,EAAE;AACF,EAAE,OAAO,IAAI,GAAG,GAAG,CAAC,MAAM,GAAG,IAAI,GAAG;AACpC;;AAEA;AACA;AACA;AACA;AACY,MAAC,WAAW,GAAG,MAAM,IAAI;AACrC,EAAE,MAAM,MAAM,GAAG,IAAI,KAAK;AAC1B,EAAE,KAAK,IAAI,IAAI,GAAG,CAAC,EAAE,IAAI,GAAG,MAAM,CAAC,MAAM,EAAE,IAAI,EAAE,EAAE;AACnD,IAAI,MAAM,CAAC,IAAI,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,UAAU,EAAE,MAAM,KAAK;AACzD,MAAM,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE;AACvC;AACA;AACA,QAAQ,MAAM,GAAG,GAAG,UAAU,CAAC,MAAM,EAAE,CAAC,KAAK;AAC7C,QAAQ,KAAK,IAAI,CAAC,GAAG,IAAI,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AACvD,UAAU,MAAM,OAAO,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM;AACtD,UAAU,IAAI,OAAO,EAAE;AACvB,YAAY,KAAK,CAAC,QAAQ,CAAC,GAAG,EAAE,OAAO,CAAC,MAAM,EAAE;AAChD,UAAU;AACV,QAAQ;AACR,QAAQ,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,EAAE,IAAI,QAAQ,CAAC,GAAG,CAAC;AACpD,MAAM;AACN,IAAI,CAAC;AACL,EAAE;AACF,EAAE,OAAO;AACT;;AAEA;AACA;AACA;AACA;AACA;AACY,MAAC,gBAAgB,GAAG,CAAC,IAAI,EAAE,GAAG,KAAK;AAC/C,EAAE,GAAG,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,SAAS,EAAE,MAAM,KAAK;AAC7C,IAAI,MAAM,YAAY,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM;AAChD,IAAI,IAAI,YAAY,EAAE;AACtB,MAAM,KAAK,CAAC,QAAQ,CAAC,YAAY,CAAC,MAAM,EAAE,EAAE,SAAS,CAAC,MAAM,EAAE;AAC9D,MAAM,YAAY,CAAC,MAAM,GAAG;AAC5B,IAAI,CAAC,MAAM;AACX,MAAM,MAAM,GAAG,GAAG,SAAS,CAAC,IAAI;AAChC,MAAM,GAAG,CAAC,MAAM,GAAG;AACnB,MAAM,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,sBAAsB,GAAG;AACtD,IAAI;AACJ,EAAE,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACY,MAAC,eAAe,GAAG;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,QAAQ,GAAG,CAAC,GAAG,EAAE,OAAO,KAAK;AAC1C;AACA;AACA;AACA,EAAE,MAAM,GAAG,wBAAwB,GAAG,YAAY,KAAK,GAAG,IAAI,KAAK,EAAE,GAAG,IAAI,KAAK,EAAE;AACnF,EAAE,MAAM,MAAM,GAAG,GAAG,YAAY,KAAK,GAAG,QAAQ,GAAG;AACnD,EAAE,GAAG,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,UAAU,EAAE,MAAM,KAAK;AAC9C;AACA;AACA;AACA,IAAI,IAAI,SAAS,GAAG;AACpB,IAAI,MAAM,eAAe,GAAG,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM;AACtD,IAAI,MAAM,SAAS,GAAG,UAAU,CAAC,MAAM;AACvC,IAAI,IAAI,eAAe,IAAI,IAAI,EAAE;AACjC,MAAM,SAAS,GAAG,SAAS,CAAC,KAAK;AACjC,IAAI,CAAC,MAAM;AACX,MAAM,MAAM,cAAc,GAAG,eAAe,CAAC,MAAM;AACnD,MAAM,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG;AACzB,MAAM,IAAI,SAAS,GAAG,SAAS,CAAC,CAAC;AACjC,MAAM,OAAO,CAAC,GAAG,SAAS,CAAC,MAAM,IAAI,CAAC,GAAG,cAAc,CAAC,MAAM,EAAE;AAChE,QAAQ,MAAM,CAAC,GAAG,cAAc,CAAC,CAAC;AAClC,QAAQ,IAAI,SAAS,CAAC,KAAK,GAAG,SAAS,CAAC,GAAG,IAAI,CAAC,CAAC,KAAK,EAAE;AACxD,UAAU,IAAI,SAAS,CAAC,GAAG,GAAG,CAAC,EAAE,SAAS,CAAC,IAAI,CAAC,SAAS;AACzD,UAAU,SAAS,GAAG,SAAS,CAAC,EAAE,CAAC;AACnC,QAAQ,CAAC,MAAM,IAAI,CAAC,CAAC,KAAK,GAAG,CAAC,CAAC,GAAG,IAAI,SAAS,CAAC,KAAK,EAAE;AACvD,UAAU,CAAC;AACX,QAAQ,CAAC,MAAM,IAAI,CAAC,CAAC,KAAK,IAAI,SAAS,CAAC,KAAK,EAAE;AAC/C,UAAU,MAAM,QAAQ,GAAG,CAAC,CAAC,KAAK,GAAG,CAAC,CAAC;AACvC,UAAU,MAAM,MAAM,GAAG,SAAS,CAAC,KAAK,GAAG,SAAS,CAAC,GAAG,GAAG;AAC3D,UAAU,IAAI,MAAM,GAAG,CAAC,EAAE;AAC1B,YAAY,SAAS,GAAG,SAAS,CAAC,QAAQ,CAAC,QAAQ,EAAE,MAAM;AAC3D,YAAY,CAAC;AACb,UAAU,CAAC,MAAM;AACjB;AACA,YAAY,SAAS,GAAG,SAAS,CAAC,EAAE,CAAC;AACrC,UAAU;AACV,QAAQ,CAAC,MAAM;AACf;AACA,UAAU,MAAM,OAAO,GAAG,CAAC,CAAC,KAAK,GAAG,SAAS,CAAC;AAC9C,UAAU,SAAS,CAAC,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,SAAS,CAAC,KAAK,EAAE,OAAO,CAAC;AACrE;AACA,UAAU,SAAS,GAAG,SAAS,CAAC,QAAQ,CAAC,SAAS,CAAC,KAAK,GAAG,CAAC,CAAC,GAAG,GAAG,OAAO,EAAE,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,GAAG,GAAG,CAAC,CAAC,GAAG,GAAG,OAAO,EAAE,CAAC,CAAC;AACxH,UAAU,IAAI,SAAS,CAAC,GAAG,KAAK,CAAC,EAAE,SAAS,GAAG,SAAS,CAAC,EAAE,CAAC;AAC5D,eAAe,CAAC;AAChB,QAAQ;AACR,MAAM;AACN,MAAM,IAAI,SAAS,IAAI,IAAI,EAAE;AAC7B,QAAQ,SAAS,CAAC,IAAI,CAAC,SAAS;AAChC,MAAM;AACN,MAAM,CAAC;AACP,MAAM,OAAO,CAAC,GAAG,SAAS,CAAC,MAAM,EAAE;AACnC,QAAQ,SAAS,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,EAAE,CAAC;AACrC,MAAM;AACN,IAAI;AACJ;AACA,IAAI,IAAI,SAAS,CAAC,MAAM,GAAG,CAAC,EAAE,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,sBAAsB,IAAI,MAAM,CAAC,SAAS,CAAC;AAC/F,EAAE,CAAC;AACH,EAAE,OAAO;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,SAAS,GAAG;;AAEzB;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,cAAc,GAAG,CAAC,IAAI,EAAE,IAAI,KAAK;AAC9C;AACA;AACA;AACA,EAAE,MAAM,GAAG,wBAAwB,IAAI,YAAY,KAAK,GAAG,IAAI,KAAK,EAAE,GAAG,IAAI,KAAK,EAAE;AACpF,EAAE,MAAM,MAAM,GAAG,IAAI,YAAY,KAAK,GAAG,QAAQ,GAAG;AACpD,EAAE,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,QAAQ,EAAE,MAAM,KAAK;AAC7C;AACA;AACA;AACA,IAAI,MAAM,SAAS,GAAG;AACtB,IAAI,MAAM,QAAQ,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM;AAC5C,IAAI,MAAM,OAAO,GAAG,QAAQ,CAAC,MAAM;AACnC,IAAI,IAAI,QAAQ,IAAI,IAAI,EAAE;AAC1B,MAAM,MAAM,OAAO,GAAG,QAAQ,CAAC,MAAM;AACrC,MAAM,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,MAAM,IAAI,CAAC,GAAG,OAAO,CAAC,MAAM,GAAG;AACxE,QAAQ,MAAM,MAAM,GAAG,OAAO,CAAC,CAAC;AAChC,QAAQ,MAAM,MAAM,GAAG,OAAO,CAAC,CAAC;AAChC;AACA,QAAQ,MAAM,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,KAAK,EAAE,MAAM,CAAC,KAAK;AACzD,QAAQ,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,GAAG,IAAI,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC,EAAE,MAAM,CAAC,GAAG,IAAI,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC;AACrG,QAAQ,IAAI,GAAG,GAAG,CAAC,EAAE;AACrB,UAAU,SAAS,CAAC,IAAI,CAAC,MAAM,YAAY;AAC3C,cAAc,IAAI,SAAS,CAAC,KAAK,EAAE,GAAG,6CAA6C,CAAC,MAAM,CAAC,KAAK,EAAE,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC;AACtH,cAAc,IAAI,OAAO,CAAC,KAAK,EAAE,GAAG;AACpC;AACA,QAAQ;AACR,QAAQ,IAAI,MAAM,CAAC,KAAK,GAAG,MAAM,CAAC,GAAG,GAAG,MAAM,CAAC,KAAK,GAAG,MAAM,CAAC,GAAG,EAAE;AACnE,UAAU,CAAC;AACX,QAAQ,CAAC,MAAM;AACf,UAAU,CAAC;AACX,QAAQ;AACR,MAAM;AACN,IAAI;AACJ;AACA,IAAI,IAAI,SAAS,CAAC,MAAM,GAAG,CAAC,EAAE,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,sBAAsB,IAAI,MAAM,CAAC,SAAS,CAAC;AAC/F,EAAE,CAAC;AACH,EAAE,2BAA2B,GAAG;AAChC;;AAEY,MAAC,aAAa,GAAG;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,UAAU,GAAG,CAAC,KAAK,EAAE,MAAM,EAAE,KAAK,EAAE,MAAM,KAAK;AAC5D,EAAE,IAAI,MAAM,KAAK,CAAC,EAAE;AACpB,EAAE,MAAM,QAAQ,GAAG,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM;AAC3C,EAAE,IAAI,QAAQ,EAAE;AAChB,IAAI,QAAQ,CAAC,GAAG,CAAC,KAAK,EAAE,MAAM;AAC9B,EAAE,CAAC,MAAM;AACT,IAAI,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,EAAE,IAAI,QAAQ,CAAC,CAAC,IAAI,OAAO,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC,CAAC;AACxE,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,gBAAgB,GAAG,CAAC,KAAK,EAAE,MAAM,KAAK,UAAU,CAAC,KAAK,EAAE,MAAM,CAAC,EAAE,CAAC,MAAM,EAAE,MAAM,CAAC,EAAE,CAAC,KAAK,EAAE,MAAM,CAAC,MAAM;;AAEzG,MAAC,WAAW,GAAG,MAAM,IAAI,KAAK;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,8BAA8B,GAAG,EAAE,IAAI;AACpD,EAAE,MAAM,EAAE,GAAG,WAAW;AACxB,EAAE,EAAE,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,KAAK;AAC1C;AACA;AACA;AACA,IAAI,MAAM,OAAO,GAAG;AACpB,IAAI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AAC7C,MAAM,MAAM,MAAM,GAAG,OAAO,CAAC,CAAC;AAC9B,MAAM,IAAI,MAAM,CAAC,OAAO,EAAE;AAC1B,QAAQ,MAAM,KAAK,GAAG,MAAM,CAAC,EAAE,CAAC;AAChC,QAAQ,IAAI,GAAG,GAAG,MAAM,CAAC;AACzB,QAAQ,IAAI,CAAC,GAAG,CAAC,GAAG,OAAO,CAAC,MAAM,EAAE;AACpC,UAAU,KAAK,IAAI,IAAI,GAAG,OAAO,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,GAAG,OAAO,CAAC,MAAM,IAAI,IAAI,CAAC,OAAO,EAAE,IAAI,GAAG,OAAO,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,EAAE;AAC3G,YAAY,GAAG,IAAI,IAAI,CAAC;AACxB,UAAU;AACV,QAAQ;AACR,QAAQ,OAAO,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC;AAC5C,MAAM;AACN,IAAI;AACJ,IAAI,IAAI,OAAO,CAAC,MAAM,GAAG,CAAC,EAAE;AAC5B,MAAM,EAAE,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,EAAE,IAAI,QAAQ,CAAC,OAAO,CAAC;AAClD,IAAI;AACJ,EAAE,CAAC;AACH,EAAE,OAAO;AACT;;AAEA;AACA;AACA;AACA;AACA;AACY,MAAC,6BAA6B,GAAG,CAAC,OAAO,EAAE,aAAa,KAAK;AACzE;AACA;AACA;AACA,EAAE,MAAM,OAAO,GAAG;AAClB,EAAE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AAC3C,IAAI,MAAM,MAAM,GAAG,OAAO,CAAC,CAAC;AAC5B,IAAI,IAAI,EAAE,aAAa,IAAI,MAAM,CAAC,OAAO,CAAC,EAAE;AAC5C,MAAM,MAAM,KAAK,GAAG,MAAM,CAAC,EAAE,CAAC;AAC9B,MAAM,IAAI,GAAG,GAAG,MAAM,CAAC;AACvB,MAAM,IAAI,CAAC,GAAG,CAAC,GAAG,OAAO,CAAC,MAAM,EAAE;AAClC;AACA,QAAQ,KAAK,IAAI,IAAI,GAAG,OAAO,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,GAAG,OAAO,CAAC,MAAM,IAAI,EAAE,aAAa,IAAI,IAAI,CAAC,OAAO,CAAC,EAAE,IAAI,GAAG,OAAO,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,EAAE;AAC7H,UAAU,GAAG,IAAI,IAAI,CAAC;AACtB,QAAQ;AACR,MAAM;AACN,MAAM,OAAO,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC;AAC1C,IAAI;AACJ,EAAE;AACF,EAAE,OAAO;AACT;;AAEA;AACA;AACA;AACA;AACY,MAAC,8BAA8B,GAAG,CAAC,EAAE,EAAE,aAAa,KAAK;AACrE,EAAE,MAAM,KAAK,GAAG,WAAW;AAC3B,EAAE,EAAE,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,KAAK;AAC1C,IAAI,MAAM,OAAO,GAAG,6BAA6B,CAAC,OAAO,EAAE,aAAa;AACxE,IAAI,IAAI,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE;AAC9B,MAAM,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,EAAE,IAAI,QAAQ,CAAC,OAAO,CAAC;AACrD,IAAI;AACJ,EAAE,CAAC;AACH,EAAE,OAAO;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,UAAU,GAAG,CAAC,OAAO,EAAE,KAAK,KAAK;AAC9C,EAAE,QAAQ,CAAC,YAAY,CAAC,OAAO,CAAC,WAAW,EAAE,KAAK,CAAC,OAAO,CAAC,IAAI;AAC/D;AACA,EAAE,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,OAAO,EAAE;AACpC,KAAK,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;AAC/B,KAAK,OAAO,CAAC,CAAC,CAAC,MAAM,EAAE,SAAS,CAAC,KAAK;AACtC,MAAM,MAAM,QAAQ,GAAG,SAAS,CAAC,MAAM;AACvC,MAAM,OAAO,CAAC,gBAAgB;AAC9B,MAAM,QAAQ,CAAC,YAAY,CAAC,OAAO,CAAC,WAAW,EAAE,MAAM;AACvD,MAAM,MAAM,GAAG,GAAG,QAAQ,CAAC;AAC3B,MAAM,QAAQ,CAAC,YAAY,CAAC,OAAO,CAAC,WAAW,EAAE,GAAG;AACpD,MAAM,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;AACpC,QAAQ,MAAM,IAAI,GAAG,QAAQ,CAAC,CAAC;AAC/B,QAAQ,OAAO,CAAC,eAAe,CAAC,IAAI,CAAC,KAAK;AAC1C,QAAQ,OAAO,CAAC,aAAa,CAAC,IAAI,CAAC,GAAG;AACtC,MAAM;AACN,IAAI,CAAC;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,SAAS,GAAG,OAAO,IAAI;AACpC,EAAE,MAAM,EAAE,GAAG,IAAI,KAAK;AACtB,EAAE,MAAM,UAAU,GAAG,QAAQ,CAAC,WAAW,CAAC,OAAO,CAAC,WAAW;AAC7D,EAAE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,UAAU,EAAE,CAAC,EAAE,EAAE;AACvC,IAAI,OAAO,CAAC,aAAa;AACzB,IAAI,MAAM,MAAM,GAAG,QAAQ,CAAC,WAAW,CAAC,OAAO,CAAC,WAAW;AAC3D,IAAI,MAAM,eAAe,GAAG,QAAQ,CAAC,WAAW,CAAC,OAAO,CAAC,WAAW;AACpE,IAAI,IAAI,eAAe,GAAG,CAAC,EAAE;AAC7B;AACA;AACA;AACA,MAAM,MAAM,QAAQ,GAAG;AACvB,MAAM,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,eAAe,EAAE,CAAC,EAAE,EAAE;AAChD,QAAQ,QAAQ,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC,OAAO,CAAC,WAAW,EAAE,EAAE,OAAO,CAAC,SAAS,EAAE,CAAC;AAC7E,MAAM;AACN,MAAM,EAAE,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,EAAE,IAAI,QAAQ,CAAC,QAAQ,CAAC;AACnD,IAAI;AACJ,EAAE;AACF,EAAE,OAAO;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,qBAAqB,GAAG,CAAC,OAAO,EAAE,WAAW,EAAE,KAAK,KAAK;AACtE,EAAE,MAAM,WAAW,GAAG,IAAI,KAAK;AAC/B,EAAE,MAAM,UAAU,GAAG,QAAQ,CAAC,WAAW,CAAC,OAAO,CAAC,WAAW;AAC7D,EAAE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,UAAU,EAAE,CAAC,EAAE,EAAE;AACvC,IAAI,OAAO,CAAC,aAAa;AACzB,IAAI,MAAM,MAAM,GAAG,QAAQ,CAAC,WAAW,CAAC,OAAO,CAAC,WAAW;AAC3D,IAAI,MAAM,eAAe,GAAG,QAAQ,CAAC,WAAW,CAAC,OAAO,CAAC,WAAW;AACpE,IAAI,MAAM,OAAO,GAAG,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,IAAI;AACjD,IAAI,MAAM,KAAK,GAAG,QAAQ,CAAC,KAAK,EAAE,MAAM;AACxC,IAAI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,eAAe,EAAE,CAAC,EAAE,EAAE;AAC9C,MAAM,MAAM,KAAK,GAAG,OAAO,CAAC,WAAW;AACvC,MAAM,MAAM,QAAQ,GAAG,KAAK,GAAG,OAAO,CAAC,SAAS;AAChD,MAAM,IAAI,KAAK,GAAG,KAAK,EAAE;AACzB,QAAQ,IAAI,KAAK,GAAG,QAAQ,EAAE;AAC9B,UAAU,UAAU,CAAC,WAAW,EAAE,MAAM,EAAE,KAAK,EAAE,QAAQ,GAAG,KAAK;AACjE,QAAQ;AACR,QAAQ,IAAI,KAAK,GAAG,WAAW,CAAC,OAAO,EAAE,KAAK;AAC9C;AACA;AACA;AACA;AACA,QAAQ,IAAI,MAAM,GAAG,OAAO,CAAC,KAAK;AAClC;AACA,QAAQ,IAAI,CAAC,MAAM,CAAC,OAAO,IAAI,MAAM,CAAC,EAAE,CAAC,KAAK,GAAG,KAAK,IAAI,MAAM,YAAY,IAAI,EAAE;AAClF;AACA,UAAU,OAAO,CAAC,MAAM,CAAC,EAAE,KAAK,EAAE,CAAC,EAAE,SAAS,CAAC,WAAW,EAAE,MAAM,EAAE,KAAK,GAAG,MAAM,CAAC,EAAE,CAAC,KAAK,CAAC;AAC5F,QAAQ;AACR,QAAQ,OAAO,KAAK,GAAG,OAAO,CAAC,MAAM,EAAE;AACvC;AACA,UAAU,MAAM,GAAG,OAAO,CAAC,KAAK,EAAE;AAClC,UAAU,IAAI,MAAM,CAAC,EAAE,CAAC,KAAK,GAAG,QAAQ,EAAE;AAC1C,YAAY,IAAI,CAAC,MAAM,CAAC,OAAO,EAAE;AACjC,cAAc,IAAI,MAAM,YAAY,IAAI,EAAE;AAC1C,gBAAgB,IAAI,QAAQ,GAAG,MAAM,CAAC,EAAE,CAAC,KAAK,GAAG,MAAM,CAAC,MAAM,EAAE;AAChE,kBAAkB,OAAO,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC,EAAE,SAAS,CAAC,WAAW,EAAE,MAAM,EAAE,QAAQ,GAAG,MAAM,CAAC,EAAE,CAAC,KAAK,CAAC;AACrG,gBAAgB;AAChB,gBAAgB,MAAM,CAAC,MAAM,CAAC,WAAW;AACzC,cAAc,CAAC,MAAM;AACrB,gBAAgB,MAAM,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE,CAAC,KAAK,EAAE,KAAK;AACzD,gBAAgB,WAAW,CAAC,GAAG,CAAC,MAAM,EAAE,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,MAAM,EAAE,QAAQ,GAAG,CAAC,CAAC;AAChF,cAAc;AACd,YAAY;AACZ,UAAU,CAAC,MAAM;AACjB,YAAY;AACZ,UAAU;AACV,QAAQ;AACR,MAAM,CAAC,MAAM;AACb,QAAQ,UAAU,CAAC,WAAW,EAAE,MAAM,EAAE,KAAK,EAAE,QAAQ,GAAG,KAAK;AAC/D,MAAM;AACN,IAAI;AACJ,EAAE;AACF,EAAE,IAAI,WAAW,CAAC,OAAO,CAAC,IAAI,GAAG,CAAC,EAAE;AACpC,IAAI,MAAM,EAAE,GAAG,IAAI,eAAe;AAClC,IAAI,QAAQ,CAAC,YAAY,CAAC,EAAE,CAAC,WAAW,EAAE,CAAC,EAAC;AAC5C,IAAI,UAAU,CAAC,EAAE,EAAE,WAAW;AAC9B,IAAI,OAAO,EAAE,CAAC,YAAY;AAC1B,EAAE;AACF,EAAE,OAAO;AACT;;AAEA;AACA;AACA;AACA;AACY,MAAC,WAAW,GAAG,CAAC,GAAG,EAAE,GAAG,KAAK;AACzC,EAAE,IAAI,GAAG,CAAC,OAAO,CAAC,IAAI,KAAK,GAAG,CAAC,OAAO,CAAC,IAAI,EAAE,OAAO;AACpD,EAAE,KAAK,MAAM,CAAC,MAAM,EAAE,aAAa,CAAC,IAAI,GAAG,CAAC,OAAO,CAAC,OAAO,EAAE,EAAE;AAC/D,IAAI,MAAM,YAAY,GAAG,aAAa,CAAC,MAAM;AAC7C,IAAI,MAAM,YAAY,GAAG,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE,MAAM;AACxD,IAAI,IAAI,YAAY,KAAK,SAAS,IAAI,YAAY,CAAC,MAAM,KAAK,YAAY,CAAC,MAAM,EAAE,OAAO;AAC1F,IAAI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,YAAY,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AAClD,MAAM,MAAM,GAAG,GAAG,YAAY,CAAC,CAAC;AAChC,MAAM,MAAM,GAAG,GAAG,YAAY,CAAC,CAAC;AAChC,MAAM,IAAI,GAAG,CAAC,KAAK,KAAK,GAAG,CAAC,KAAK,IAAI,GAAG,CAAC,GAAG,KAAK,GAAG,CAAC,GAAG,EAAE;AAC1D,QAAQ,OAAO;AACf,MAAM;AACN,IAAI;AACJ,EAAE;AACF,EAAE,OAAO;AACT;;ACtzBA;AACA;AACA;;;AAsBY,MAAC,mBAAmB,GAAG,MAAM,CAAC;;AAE1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO,MAAM,GAAG,SAAS,YAAY,CAAC;AACtC;AACA;AACA;AACA,EAAE,WAAW,CAAC,CAAC,EAAE,IAAI,GAAG,MAAM,CAAC,MAAM,EAAE,EAAE,YAAY,GAAG,IAAI,EAAE,EAAE,GAAG,IAAI,EAAE,QAAQ,GAAG,MAAM,IAAI,EAAE,IAAI,GAAG,IAAI,EAAE,QAAQ,GAAG,KAAK,EAAE,UAAU,GAAG,IAAI,EAAE,eAAe,GAAG,KAAK,EAAE,GAAG,EAAE,EAAE;AAClL,IAAI,KAAK;AACT,IAAI,IAAI,CAAC,EAAE,GAAG;AACd,IAAI,IAAI,CAAC,QAAQ,GAAG;AACpB,IAAI,IAAI,CAAC,QAAQ,GAAG,mBAAmB;AACvC,IAAI,IAAI,CAAC,IAAI,GAAG;AAChB,IAAI,IAAI,CAAC,YAAY,GAAG;AACxB,IAAI,IAAI,CAAC,eAAe,GAAG;AAC3B,IAAI,IAAI,CAAC,iBAAiB,GAAG,CAAC;AAC9B;AACA;AACA;AACA,IAAI,IAAI,CAAC,KAAK,GAAG,IAAI,GAAG;AACxB,IAAI,IAAI,CAAC,KAAK,GAAG,IAAI,WAAW;AAChC;AACA;AACA;AACA,IAAI,IAAI,CAAC,YAAY,GAAG;AACxB;AACA;AACA;AACA,IAAI,IAAI,CAAC,oBAAoB,GAAG;AAChC;AACA;AACA;AACA,IAAI,IAAI,CAAC,OAAO,GAAG,IAAI,GAAG;AAC1B;AACA;AACA;AACA;AACA,IAAI,IAAI,CAAC,KAAK,GAAG;AACjB,IAAI,IAAI,CAAC,UAAU,GAAG;AACtB,IAAI,IAAI,CAAC,QAAQ,GAAG;AACpB,IAAI,IAAI,CAAC,IAAI,GAAG;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,IAAI,CAAC,QAAQ,GAAG;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,IAAI,CAAC,QAAQ,GAAG;AACpB,IAAI,IAAI,CAAC,WAAW,GAAG;AACvB;AACA;AACA;AACA,IAAI,IAAI,CAAC,UAAU,GAAG,OAAO,CAAC,MAAM,CAAC,OAAO,IAAI;AAChD,MAAM,IAAI,CAAC,EAAE,CAAC,MAAM,EAAE,MAAM;AAC5B,QAAQ,IAAI,CAAC,QAAQ,GAAG;AACxB,QAAQ,OAAO,CAAC,IAAI;AACpB,MAAM,CAAC;AACP,IAAI,CAAC;AACL,IAAI,MAAM,oBAAoB,GAAG,MAAM,OAAO,CAAC,MAAM,CAAC,OAAO,IAAI;AACjE;AACA;AACA;AACA,MAAM,MAAM,YAAY,GAAG,CAAC,QAAQ,KAAK;AACzC,QAAQ,IAAI,QAAQ,KAAK,SAAS,IAAI,QAAQ,KAAK,IAAI,EAAE;AACzD,UAAU,IAAI,CAAC,GAAG,CAAC,MAAM,EAAE,YAAY;AACvC,UAAU,OAAO;AACjB,QAAQ;AACR,MAAM;AACN,MAAM,IAAI,CAAC,EAAE,CAAC,MAAM,EAAE,YAAY;AAClC,IAAI,CAAC;AACL,IAAI,IAAI,CAAC,EAAE,CAAC,MAAM,EAAE,QAAQ,IAAI;AAChC,MAAM,IAAI,QAAQ,KAAK,KAAK,IAAI,IAAI,CAAC,QAAQ,EAAE;AAC/C,QAAQ,IAAI,CAAC,UAAU,GAAG,oBAAoB;AAC9C,MAAM;AACN,MAAM,IAAI,CAAC,QAAQ,GAAG,QAAQ,KAAK,SAAS,IAAI,QAAQ,KAAK;AAC7D,MAAM,IAAI,IAAI,CAAC,QAAQ,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE;AAC3C,QAAQ,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,CAAC,IAAI,CAAC;AAChC,MAAM;AACN,IAAI,CAAC;AACL;AACA;AACA;AACA;AACA;AACA,IAAI,IAAI,CAAC,UAAU,GAAG,oBAAoB;AAC1C,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,IAAI,CAAC,GAAG;AACV,IAAI,MAAM,IAAI,GAAG,IAAI,CAAC;AACtB,IAAI,IAAI,IAAI,KAAK,IAAI,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE;AAC3C,MAAM,QAAQ,oBAAoB,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,EAAE,WAAW,IAAI;AACpE,QAAQ,WAAW,CAAC,aAAa,CAAC,GAAG,CAAC,IAAI;AAC1C,MAAM,CAAC,EAAE,IAAI,EAAE,IAAI;AACnB,IAAI;AACJ,IAAI,IAAI,CAAC,UAAU,GAAG;AACtB,EAAE;;AAEF,EAAE,UAAU,CAAC,GAAG;AAChB,IAAI,OAAO,IAAI,CAAC;AAChB,EAAE;;AAEF,EAAE,cAAc,CAAC,GAAG;AACpB,IAAI,OAAO,IAAI,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,GAAG,CAAC,GAAG,IAAI,GAAG,CAAC,IAAI,CAAC;AAChE,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,QAAQ,CAAC,CAAC,CAAC,EAAE,MAAM,GAAG,IAAI,EAAE;AAC9B,IAAI,OAAO,QAAQ,CAAC,IAAI,EAAE,CAAC,EAAE,MAAM;AACnC,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,GAAG,CAAC,CAAC,IAAI,EAAE,eAAe,uBAAuB,YAAY,CAAC,EAAE;AAClE,IAAI,MAAM,IAAI,GAAG,GAAG,CAAC,cAAc,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,EAAE,MAAM;AAC5D;AACA,MAAM,MAAM,CAAC,GAAG,IAAI,eAAe;AACnC,MAAM,CAAC,CAAC,UAAU,CAAC,IAAI,EAAE,IAAI;AAC7B,MAAM,OAAO;AACb,IAAI,CAAC;AACL,IAAI,MAAM,MAAM,GAAG,IAAI,CAAC;AACxB;AACA,IAAI,IAAI,eAAe,KAAK,YAAY,IAAI,MAAM,KAAK,eAAe,EAAE;AACxE,MAAM,IAAI,MAAM,KAAK,YAAY,EAAE;AACnC;AACA,QAAQ,MAAM,CAAC,GAAG,IAAI,eAAe;AACrC,QAAQ,CAAC,CAAC,IAAI,GAAG,IAAI,CAAC;AACtB,QAAQ,IAAI,CAAC,IAAI,CAAC,OAAO,yBAAyB,CAAC,IAAI;AACvD,UAAU,OAAO,CAAC,KAAK,IAAI,EAAE,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE;AACzC;AACA,YAAY,CAAC,CAAC,MAAM,GAAG;AACvB,UAAU;AACV,QAAQ,CAAC;AACT,QAAQ,CAAC,CAAC,MAAM,GAAG,IAAI,CAAC;AACxB,QAAQ,KAAK,IAAI,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,CAAC,KAAK,IAAI,EAAE,CAAC,GAAG,CAAC,CAAC,KAAK,EAAE;AACxD,UAAU,CAAC,CAAC,MAAM,GAAG;AACrB,QAAQ;AACR,QAAQ,CAAC,CAAC,OAAO,GAAG,IAAI,CAAC;AACzB,QAAQ,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,EAAE,CAAC;AAC9B,QAAQ,CAAC,CAAC,UAAU,CAAC,IAAI,EAAE,IAAI;AAC/B,QAAQ,2CAA2C,CAAC;AACpD,MAAM,CAAC,MAAM;AACb,QAAQ,MAAM,IAAI,KAAK,CAAC,CAAC,mBAAmB,EAAE,IAAI,CAAC,sDAAsD,CAAC;AAC1G,MAAM;AACN,IAAI;AACJ,IAAI,2CAA2C,IAAI;AACnD,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,QAAQ,CAAC,CAAC,IAAI,GAAG,EAAE,EAAE;AACvB,IAAI,mCAAmC,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,MAAM,CAAC;AAC7D,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,OAAO,CAAC,CAAC,IAAI,GAAG,EAAE,EAAE;AACtB,IAAI,6BAA6B,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,KAAK,CAAC;AACtD,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,MAAM,CAAC,CAAC,IAAI,GAAG,EAAE,EAAE;AACrB,IAAI,+BAA+B,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC;AACvD,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,aAAa,CAAC,CAAC,IAAI,GAAG,EAAE,EAAE;AAC5B,IAAI,0DAA0D,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,WAAW,CAAC;AACzF,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,cAAc,CAAC,CAAC,IAAI,GAAG,EAAE,EAAE;AAC7B,IAAI,oCAAoC,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,YAAY,CAAC;AACpE,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,MAAM,CAAC,GAAG;AACZ;AACA;AACA;AACA,IAAI,MAAM,GAAG,GAAG;;AAEhB,IAAI,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,GAAG,KAAK;AACvC,MAAM,GAAG,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC,MAAM;AAC7B,IAAI,CAAC;;AAEL,IAAI,OAAO;AACX,EAAE;;AAEF;AACA;AACA;AACA,EAAE,OAAO,CAAC,GAAG;AACb,IAAI,IAAI,CAAC,WAAW,GAAG;AACvB,IAAI,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,OAAO,CAAC,MAAM,IAAI,MAAM,CAAC,OAAO,EAAE;AAC/D,IAAI,MAAM,IAAI,GAAG,IAAI,CAAC;AACtB,IAAI,IAAI,IAAI,KAAK,IAAI,EAAE;AACvB,MAAM,IAAI,CAAC,KAAK,GAAG;AACnB,MAAM,MAAM,OAAO,8BAA8B,IAAI,CAAC,OAAO;AAC7D,MAAM,OAAO,CAAC,GAAG,GAAG,IAAI,GAAG,CAAC,EAAE,IAAI,EAAE,IAAI,CAAC,IAAI,EAAE,GAAG,OAAO,CAAC,IAAI,EAAE,UAAU,EAAE,KAAK,EAAE;AACnF,MAAM,OAAO,CAAC,GAAG,CAAC,KAAK,GAAG;AAC1B,MAAM,QAAQ,oBAAoB,CAAC,IAAI,EAAE,MAAM,CAAC,GAAG,EAAE,WAAW,IAAI;AACpE,QAAQ,MAAM,GAAG,GAAG,OAAO,CAAC;AAC5B,QAAQ,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE;AAC3B,UAAU,WAAW,CAAC,YAAY,CAAC,GAAG,CAAC,GAAG;AAC1C,QAAQ;AACR,QAAQ,WAAW,CAAC,cAAc,CAAC,GAAG,CAAC,IAAI;AAC3C,MAAM,CAAC,EAAE,IAAI,EAAE,IAAI;AACnB,IAAI;AACJ;AACA,IAAI,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE,CAAC,IAAI,CAAC,EAAC;AAClC,IAAI,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,CAAC,IAAI,CAAC;AAC/B,IAAI,KAAK,CAAC,OAAO;AACjB,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACY,MAAC,QAAQ,GAAG,CAAC,IAAI,EAAE,IAAI,KAAK;AACxC,EAAE,MAAM,KAAK,GAAG,IAAI,GAAG,CAAC,IAAI;AAC5B,EAAE,WAAW,CAAC,KAAK,EAAE,mBAAmB,CAAC,IAAI,CAAC;AAC9C,EAAE,OAAO;AACT;;AC7WO,MAAM,WAAW,CAAC;AACzB;AACA;AACA;AACA,EAAE,WAAW,CAAC,CAAC,OAAO,EAAE;AACxB,IAAI,IAAI,CAAC,WAAW,GAAG;AACvB,EAAE;;AAEF,EAAE,aAAa,CAAC,GAAG;AACnB;AACA,EAAE;;AAEF;AACA;AACA;AACA,EAAE,WAAW,CAAC,GAAG;AACjB,IAAI,OAAO,QAAQ,CAAC,WAAW,CAAC,IAAI,CAAC,WAAW;AAChD,EAAE;;AAEF;AACA;AACA;AACA,EAAE,SAAS,CAAC,GAAG;AACf,IAAI,OAAO,QAAQ,CAAC,WAAW,CAAC,IAAI,CAAC,WAAW;AAChD,EAAE;AACF;;AAEO,MAAM,eAAe,SAAS,WAAW,CAAC;AACjD;AACA;AACA;AACA,EAAE,UAAU,CAAC,GAAG;AAChB,IAAI,OAAO,QAAQ,CAAC,QAAQ,CAAC,WAAW,CAAC,IAAI,CAAC,WAAW,CAAC,EAAE,QAAQ,CAAC,WAAW,CAAC,IAAI,CAAC,WAAW,CAAC;AAClG,EAAE;;AAEF;AACA;AACA;AACA,EAAE,WAAW,CAAC,GAAG;AACjB,IAAI,OAAO,QAAQ,CAAC,QAAQ,CAAC,WAAW,CAAC,IAAI,CAAC,WAAW,CAAC,EAAE,QAAQ,CAAC,WAAW,CAAC,IAAI,CAAC,WAAW,CAAC;AAClG,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE,UAAU,CAAC,GAAG;AAChB,IAAI,OAAO,QAAQ,CAAC,WAAW,CAAC,IAAI,CAAC,WAAW;AAChD,EAAE;;AAEF;AACA;AACA;AACA,EAAE,QAAQ,CAAC,GAAG;AACd,IAAI,OAAO,QAAQ,CAAC,SAAS,CAAC,IAAI,CAAC,WAAW;AAC9C,EAAE;;AAEF;AACA;AACA;AACA,EAAE,UAAU,CAAC,GAAG;AAChB,IAAI,OAAO,QAAQ,CAAC,aAAa,CAAC,IAAI,CAAC,WAAW;AAClD,EAAE;;AAEF;AACA;AACA;AACA,EAAE,cAAc,CAAC,GAAG;AACpB,IAAI,OAAO,QAAQ,CAAC,WAAW,CAAC,IAAI,CAAC,WAAW,CAAC,KAAK;AACtD,EAAE;;AAEF;AACA;AACA;AACA,EAAE,WAAW,CAAC,GAAG;AACjB,IAAI,OAAO,QAAQ,CAAC,WAAW,CAAC,IAAI,CAAC,WAAW;AAChD,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE,OAAO,CAAC,GAAG;AACb,IAAI,OAAO,QAAQ,CAAC,WAAW,CAAC,IAAI,CAAC,WAAW;AAChD,EAAE;;AAEF;AACA;AACA;AACA,EAAE,OAAO,CAAC,GAAG;AACb,IAAI,OAAO,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,WAAW;AAC5C,EAAE;;AAEF;AACA;AACA;AACA,EAAE,OAAO,CAAC,GAAG;AACb,IAAI,OAAO,MAAM,CAAC,cAAc,CAAC,QAAQ,CAAC,iBAAiB,CAAC,IAAI,CAAC,WAAW,CAAC;AAC7E,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE,QAAQ,CAAC,GAAG;AACd,IAAI,OAAO,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,aAAa,CAAC,IAAI,CAAC,WAAW,CAAC;AAC9D,EAAE;;AAEF;AACA;AACA;AACA,EAAE,OAAO,CAAC,GAAG;AACb,IAAI,OAAO,QAAQ,CAAC,aAAa,CAAC,IAAI,CAAC,WAAW;AAClD,EAAE;AACF;;AAEO,MAAM,WAAW,CAAC;AACzB;AACA;AACA;AACA,EAAE,WAAW,CAAC,CAAC,OAAO,EAAE;AACxB;AACA;AACA;AACA,IAAI,IAAI,CAAC,SAAS,GAAG;AACrB,IAAI,IAAI,CAAC,WAAW,GAAG;AACvB,EAAE;;AAEF,EAAE,aAAa,CAAC,GAAG;AACnB,IAAI,IAAI,CAAC,SAAS,GAAG;AACrB,EAAE;;AAEF;AACA;AACA;AACA,EAAE,WAAW,CAAC,GAAG;AACjB,IAAI,IAAI,CAAC,SAAS,IAAI,QAAQ,CAAC,WAAW,CAAC,IAAI,CAAC,WAAW;AAC3D,IAAI,OAAO,IAAI,CAAC;AAChB,EAAE;;AAEF;AACA;AACA;AACA,EAAE,SAAS,CAAC,GAAG;AACf,IAAI,MAAM,IAAI,GAAG,QAAQ,CAAC,WAAW,CAAC,IAAI,CAAC,WAAW,CAAC,GAAG;AAC1D,IAAI,IAAI,CAAC,SAAS,IAAI;AACtB,IAAI,OAAO;AACX,EAAE;AACF;;AAEO,MAAM,eAAe,SAAS,WAAW,CAAC;AACjD;AACA;AACA;AACA,EAAE,WAAW,CAAC,CAAC,OAAO,EAAE;AACxB,IAAI,KAAK,CAAC,OAAO;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,IAAI,CAAC,IAAI,GAAG;AAChB,IAAI,QAAQ,CAAC,WAAW,CAAC,OAAO,EAAC;AACjC,IAAI,IAAI,CAAC,eAAe,GAAG,IAAI,QAAQ,CAAC,oBAAoB,CAAC,QAAQ,CAAC,iBAAiB,CAAC,OAAO,CAAC;AAChG,IAAI,IAAI,CAAC,aAAa,GAAG,IAAI,QAAQ,CAAC,iBAAiB,CAAC,QAAQ,CAAC,iBAAiB,CAAC,OAAO,CAAC;AAC3F,IAAI,IAAI,CAAC,gBAAgB,GAAG,IAAI,QAAQ,CAAC,oBAAoB,CAAC,QAAQ,CAAC,iBAAiB,CAAC,OAAO,CAAC;AACjG,IAAI,IAAI,CAAC,iBAAiB,GAAG,IAAI,QAAQ,CAAC,oBAAoB,CAAC,QAAQ,CAAC,iBAAiB,CAAC,OAAO,CAAC;AAClG,IAAI,IAAI,CAAC,WAAW,GAAG,IAAI,QAAQ,CAAC,UAAU,CAAC,QAAQ,CAAC,iBAAiB,CAAC,OAAO,CAAC,EAAE,QAAQ,CAAC,SAAS;AACtG,IAAI,IAAI,CAAC,aAAa,GAAG,IAAI,QAAQ,CAAC,aAAa,CAAC,QAAQ,CAAC,iBAAiB,CAAC,OAAO,CAAC;AACvF,IAAI,IAAI,CAAC,iBAAiB,GAAG,IAAI,QAAQ,CAAC,UAAU,CAAC,QAAQ,CAAC,iBAAiB,CAAC,OAAO,CAAC,EAAE,QAAQ,CAAC,SAAS;AAC5G,IAAI,IAAI,CAAC,cAAc,GAAG,IAAI,QAAQ,CAAC,iBAAiB,CAAC,QAAQ,CAAC,iBAAiB,CAAC,OAAO,CAAC;AAC5F,IAAI,IAAI,CAAC,UAAU,GAAG,IAAI,QAAQ,CAAC,iBAAiB,CAAC,QAAQ,CAAC,iBAAiB,CAAC,OAAO,CAAC;AACxF,EAAE;;AAEF;AACA;AACA;AACA,EAAE,UAAU,CAAC,GAAG;AAChB,IAAI,OAAO,IAAI,EAAE,CAAC,IAAI,CAAC,aAAa,CAAC,IAAI,EAAE,EAAE,IAAI,CAAC,gBAAgB,CAAC,IAAI,EAAE;AACzE,EAAE;;AAEF;AACA;AACA;AACA,EAAE,WAAW,CAAC,GAAG;AACjB,IAAI,OAAO,IAAI,EAAE,CAAC,IAAI,CAAC,aAAa,CAAC,IAAI,EAAE,EAAE,IAAI,CAAC,iBAAiB,CAAC,IAAI,EAAE;AAC1E,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE,UAAU,CAAC,GAAG;AAChB,IAAI,OAAO,IAAI,CAAC,aAAa,CAAC,IAAI;AAClC,EAAE;;AAEF;AACA;AACA;AACA,EAAE,QAAQ,CAAC,GAAG;AACd,IAAI,8BAA8B,IAAI,CAAC,WAAW,CAAC,IAAI,EAAE;AACzD,EAAE;;AAEF;AACA;AACA;AACA,EAAE,UAAU,CAAC,GAAG;AAChB,IAAI,OAAO,IAAI,CAAC,aAAa,CAAC,IAAI;AAClC,EAAE;;AAEF;AACA;AACA;AACA,EAAE,cAAc,CAAC,GAAG;AACpB,IAAI,OAAO,IAAI,CAAC,iBAAiB,CAAC,IAAI,EAAE,KAAK;AAC7C,EAAE;;AAEF;AACA;AACA;AACA,EAAE,WAAW,CAAC,GAAG;AACjB,IAAI,OAAO,IAAI,CAAC,cAAc,CAAC,IAAI;AACnC,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE,OAAO,CAAC,GAAG;AACb,IAAI,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI;AAC/B,EAAE;;AAEF;AACA;AACA;AACA,EAAE,OAAO,CAAC,GAAG;AACb,IAAI,OAAO,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,WAAW;AAC5C,EAAE;;AAEF;AACA;AACA;AACA,EAAE,OAAO,CAAC,GAAG;AACb,IAAI,OAAO,QAAQ,CAAC,iBAAiB,CAAC,IAAI,CAAC,WAAW;AACtD,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,QAAQ,CAAC,GAAG;AACd,IAAI,OAAO,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,WAAW;AAC5C,EAAE;;AAEF;AACA;AACA;AACA,EAAE,OAAO,CAAC,GAAG;AACb,IAAI,MAAM,QAAQ,GAAG,IAAI,CAAC,eAAe,CAAC,IAAI;AAC9C,IAAI,IAAI,QAAQ,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE;AACrC,MAAM,OAAO,IAAI,CAAC,IAAI,CAAC,QAAQ;AAC/B,IAAI,CAAC,MAAM;AACX,MAAM,MAAM,GAAG,GAAG,IAAI,CAAC,aAAa,CAAC,IAAI;AACzC,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG;AACxB,MAAM,OAAO;AACb,IAAI;AACJ,EAAE;AACF;;ACjRO,MAAM,cAAc,CAAC;AAC5B,EAAE,WAAW,CAAC,GAAG;AACjB,IAAI,IAAI,CAAC,WAAW,GAAG,QAAQ,CAAC,aAAa;AAC7C,EAAE;;AAEF,EAAE,YAAY,CAAC,GAAG;AAClB,IAAI,OAAO,QAAQ,CAAC,YAAY,CAAC,IAAI,CAAC,WAAW;AACjD,EAAE;;AAEF,EAAE,gBAAgB,CAAC,GAAG;AACtB;AACA,EAAE;;AAEF;AACA;AACA;AACA,EAAE,eAAe,CAAC,CAAC,KAAK,EAAE;AAC1B,IAAI,QAAQ,CAAC,YAAY,CAAC,IAAI,CAAC,WAAW,EAAE,KAAK;AACjD,EAAE;;AAEF;AACA;AACA;AACA,EAAE,aAAa,CAAC,CAAC,GAAG,EAAE;AACtB,IAAI,QAAQ,CAAC,YAAY,CAAC,IAAI,CAAC,WAAW,EAAE,GAAG;AAC/C,EAAE;AACF;;AAEO,MAAM,eAAe,SAAS,cAAc,CAAC;AACpD;AACA;AACA;AACA,EAAE,WAAW,CAAC,CAAC,EAAE,EAAE;AACnB,IAAI,QAAQ,CAAC,YAAY,CAAC,IAAI,CAAC,WAAW,EAAE,EAAE,CAAC,MAAM;AACrD,IAAI,QAAQ,CAAC,YAAY,CAAC,IAAI,CAAC,WAAW,EAAE,EAAE,CAAC,KAAK;AACpD,EAAE;;AAEF;AACA;AACA;AACA,EAAE,YAAY,CAAC,CAAC,EAAE,EAAE;AACpB,IAAI,QAAQ,CAAC,YAAY,CAAC,IAAI,CAAC,WAAW,EAAE,EAAE,CAAC,MAAM;AACrD,IAAI,QAAQ,CAAC,YAAY,CAAC,IAAI,CAAC,WAAW,EAAE,EAAE,CAAC,KAAK;AACpD,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE,WAAW,CAAC,CAAC,MAAM,EAAE;AACvB,IAAI,QAAQ,CAAC,YAAY,CAAC,IAAI,CAAC,WAAW,EAAE,MAAM;AAClD,EAAE;;AAEF;AACA;AACA;AACA,EAAE,SAAS,CAAC,CAAC,IAAI,EAAE;AACnB,IAAI,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,WAAW,EAAE,IAAI;AAC9C,EAAE;;AAEF;AACA;AACA;AACA,EAAE,WAAW,CAAC,CAAC,CAAC,EAAE;AAClB,IAAI,QAAQ,CAAC,cAAc,CAAC,IAAI,CAAC,WAAW,EAAE,CAAC;AAC/C,EAAE;;AAEF;AACA;AACA;AACA,EAAE,eAAe,CAAC,CAAC,MAAM,EAAE;AAC3B,IAAI,QAAQ,CAAC,YAAY,CAAC,IAAI,CAAC,WAAW,EAAE,MAAM,GAAG,CAAC,GAAG,CAAC;AAC1D,EAAE;;AAEF;AACA;AACA;AACA,EAAE,YAAY,CAAC,CAAC,IAAI,EAAE;AACtB,IAAI,QAAQ,CAAC,YAAY,CAAC,IAAI,CAAC,WAAW,EAAE,IAAI;AAChD,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE,QAAQ,CAAC,CAAC,GAAG,EAAE;AACjB,IAAI,QAAQ,CAAC,YAAY,CAAC,IAAI,CAAC,WAAW,EAAE,GAAG;AAC/C,EAAE;;AAEF;AACA;AACA;AACA,EAAE,QAAQ,CAAC,CAAC,GAAG,EAAE;AACjB,IAAI,QAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,WAAW,EAAE,GAAG;AAC3C,EAAE;;AAEF;AACA;AACA;AACA,EAAE,QAAQ,CAAC,CAAC,GAAG,EAAE;AACjB,IAAI,QAAQ,CAAC,kBAAkB,CAAC,IAAI,CAAC,WAAW,EAAE,GAAG;AACrD,EAAE;;AAEF;AACA;AACA;AACA,EAAE,SAAS,CAAC,CAAC,KAAK,EAAE;AACpB,IAAI,QAAQ,CAAC,cAAc,CAAC,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC;AACnE,EAAE;;AAEF;AACA;AACA;AACA,EAAE,QAAQ,CAAC,CAAC,GAAG,EAAE;AACjB,IAAI,QAAQ,CAAC,cAAc,CAAC,IAAI,CAAC,WAAW,EAAE,GAAG;AACjD,EAAE;AACF;;AAEO,MAAM,cAAc,CAAC;AAC5B,EAAE,WAAW,CAAC,GAAG;AACjB,IAAI,IAAI,CAAC,WAAW,GAAG,QAAQ,CAAC,aAAa,GAAE;AAC/C,IAAI,IAAI,CAAC,SAAS,GAAG;AACrB,EAAE;;AAEF,EAAE,YAAY,CAAC,GAAG;AAClB,IAAI,OAAO,QAAQ,CAAC,YAAY,CAAC,IAAI,CAAC,WAAW;AACjD,EAAE;;AAEF,EAAE,gBAAgB,CAAC,GAAG;AACtB,IAAI,IAAI,CAAC,SAAS,GAAG;AACrB,EAAE;;AAEF;AACA;AACA;AACA,EAAE,eAAe,CAAC,CAAC,KAAK,EAAE;AAC1B,IAAI,MAAM,IAAI,GAAG,KAAK,GAAG,IAAI,CAAC;AAC9B,IAAI,IAAI,CAAC,SAAS,GAAG;AACrB,IAAI,QAAQ,CAAC,YAAY,CAAC,IAAI,CAAC,WAAW,EAAE,IAAI;AAChD,EAAE;;AAEF;AACA;AACA;AACA,EAAE,aAAa,CAAC,CAAC,GAAG,EAAE;AACtB,IAAI,IAAI,GAAG,KAAK,CAAC,EAAE;AACnB,MAAM,KAAK,CAAC,cAAc;AAC1B,IAAI;AACJ,IAAI,QAAQ,CAAC,YAAY,CAAC,IAAI,CAAC,WAAW,EAAE,GAAG,GAAG,CAAC;AACnD,IAAI,IAAI,CAAC,SAAS,IAAI;AACtB,EAAE;AACF;;AAEO,MAAM,eAAe,SAAS,cAAc,CAAC;AACpD,EAAE,WAAW,CAAC,GAAG;AACjB,IAAI,KAAK;AACT;AACA;AACA;AACA,IAAI,IAAI,CAAC,MAAM,GAAG,IAAI,GAAG;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,IAAI,CAAC,QAAQ,GAAG;AACpB,IAAI,IAAI,CAAC,eAAe,GAAG,IAAI,QAAQ,CAAC,oBAAoB;AAC5D,IAAI,IAAI,CAAC,aAAa,GAAG,IAAI,QAAQ,CAAC,iBAAiB;AACvD,IAAI,IAAI,CAAC,gBAAgB,GAAG,IAAI,QAAQ,CAAC,oBAAoB;AAC7D,IAAI,IAAI,CAAC,iBAAiB,GAAG,IAAI,QAAQ,CAAC,oBAAoB;AAC9D,IAAI,IAAI,CAAC,WAAW,GAAG,IAAI,QAAQ,CAAC,UAAU,CAAC,QAAQ,CAAC,UAAU;AAClE,IAAI,IAAI,CAAC,aAAa,GAAG,IAAI,QAAQ,CAAC,aAAa;AACnD,IAAI,IAAI,CAAC,iBAAiB,GAAG,IAAI,QAAQ,CAAC,UAAU,CAAC,QAAQ,CAAC,UAAU;AACxE,IAAI,IAAI,CAAC,cAAc,GAAG,IAAI,QAAQ,CAAC,iBAAiB;AACxD,IAAI,IAAI,CAAC,UAAU,GAAG,IAAI,QAAQ,CAAC,iBAAiB;AACpD,EAAE;;AAEF,EAAE,YAAY,CAAC,GAAG;AAClB,IAAI,MAAM,OAAO,GAAG,QAAQ,CAAC,aAAa;AAC1C,IAAI,QAAQ,CAAC,YAAY,CAAC,OAAO,EAAE,CAAC,EAAC;AACrC,IAAI,QAAQ,CAAC,kBAAkB,CAAC,OAAO,EAAE,IAAI,CAAC,eAAe,CAAC,YAAY,EAAE;AAC5E,IAAI,QAAQ,CAAC,kBAAkB,CAAC,OAAO,EAAE,IAAI,CAAC,aAAa,CAAC,YAAY,EAAE;AAC1E,IAAI,QAAQ,CAAC,kBAAkB,CAAC,OAAO,EAAE,IAAI,CAAC,gBAAgB,CAAC,YAAY,EAAE;AAC7E,IAAI,QAAQ,CAAC,kBAAkB,CAAC,OAAO,EAAE,IAAI,CAAC,iBAAiB,CAAC,YAAY,EAAE;AAC9E,IAAI,QAAQ,CAAC,kBAAkB,CAAC,OAAO,EAAE,QAAQ,CAAC,YAAY,CAAC,IAAI,CAAC,WAAW,CAAC;AAChF,IAAI,QAAQ,CAAC,kBAAkB,CAAC,OAAO,EAAE,IAAI,CAAC,aAAa,CAAC,YAAY,EAAE;AAC1E,IAAI,QAAQ,CAAC,kBAAkB,CAAC,OAAO,EAAE,QAAQ,CAAC,YAAY,CAAC,IAAI,CAAC,iBAAiB,CAAC;AACtF,IAAI,QAAQ,CAAC,kBAAkB,CAAC,OAAO,EAAE,IAAI,CAAC,cAAc,CAAC,YAAY,EAAE;AAC3E,IAAI,QAAQ,CAAC,kBAAkB,CAAC,OAAO,EAAE,IAAI,CAAC,UAAU,CAAC,YAAY,EAAE;AACvE;AACA,IAAI,QAAQ,CAAC,eAAe,CAAC,OAAO,EAAE,QAAQ,CAAC,YAAY,CAAC,IAAI,CAAC,WAAW,CAAC;AAC7E,IAAI,OAAO,QAAQ,CAAC,YAAY,CAAC,OAAO;AACxC,EAAE;;AAEF;AACA;AACA;AACA,EAAE,WAAW,CAAC,CAAC,EAAE,EAAE;AACnB,IAAI,IAAI,CAAC,aAAa,CAAC,KAAK,CAAC,EAAE,CAAC,MAAM;AACtC,IAAI,IAAI,CAAC,gBAAgB,CAAC,KAAK,CAAC,EAAE,CAAC,KAAK;AACxC,EAAE;;AAEF;AACA;AACA;AACA,EAAE,YAAY,CAAC,CAAC,EAAE,EAAE;AACpB,IAAI,IAAI,CAAC,aAAa,CAAC,KAAK,CAAC,EAAE,CAAC,MAAM;AACtC,IAAI,IAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC,EAAE,CAAC,KAAK;AACzC,EAAE;;AAEF;AACA;AACA;AACA,EAAE,WAAW,CAAC,CAAC,MAAM,EAAE;AACvB,IAAI,IAAI,CAAC,aAAa,CAAC,KAAK,CAAC,MAAM;AACnC,EAAE;;AAEF;AACA;AACA;AACA,EAAE,SAAS,CAAC,CAAC,IAAI,EAAE;AACnB,IAAI,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,IAAI;AAC/B,EAAE;;AAEF;AACA;AACA;AACA,EAAE,WAAW,CAAC,CAAC,CAAC,EAAE;AAClB,IAAI,IAAI,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC;AAC9B,EAAE;;AAEF;AACA;AACA;AACA,EAAE,eAAe,CAAC,CAAC,MAAM,EAAE;AAC3B,IAAI,IAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,GAAG,CAAC;AAC/C,EAAE;;AAEF;AACA;AACA;AACA,EAAE,YAAY,CAAC,CAAC,IAAI,EAAE;AACtB,IAAI,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC,IAAI;AAClC,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE,QAAQ,CAAC,CAAC,GAAG,EAAE;AACjB,IAAI,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,GAAG;AAC7B,EAAE;;AAEF;AACA;AACA;AACA,EAAE,QAAQ,CAAC,CAAC,GAAG,EAAE;AACjB,IAAI,QAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,WAAW,EAAE,GAAG;AAC3C,EAAE;;AAEF;AACA;AACA;AACA,EAAE,QAAQ,CAAC,CAAC,GAAG,EAAE;AACjB,IAAI,QAAQ,CAAC,kBAAkB,CAAC,IAAI,CAAC,WAAW,EAAE,GAAG;AACrD,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,SAAS,CAAC,CAAC,KAAK,EAAE;AACpB,IAAI,QAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,WAAW,EAAE,KAAK;AAC7C,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,QAAQ,CAAC,CAAC,GAAG,EAAE;AACjB,IAAI,MAAM,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,GAAG;AACrC,IAAI,IAAI,KAAK,KAAK,SAAS,EAAE;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,IAAI,CAAC,eAAe,CAAC,KAAK,CAAC,IAAI,CAAC,QAAQ,EAAE;AAChD,MAAM,IAAI,CAAC,aAAa,CAAC,KAAK,CAAC,GAAG;AAClC,IAAI,CAAC,MAAM;AACX,MAAM,IAAI,CAAC,eAAe,CAAC,KAAK,CAAC,KAAK;AACtC,IAAI;AACJ,EAAE;AACF;;AC/TA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAmCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,YAAY,GAAG,CAAC,OAAO,EAAE,OAAO,EAAE,MAAM,EAAE,QAAQ,KAAK;AAC7D,EAAE,IAAI,cAAc,GAAG,EAAC;AACxB;AACA;AACA;AACA,EAAE,MAAM,WAAW,GAAG;AACtB,EAAE,MAAM,kBAAkB,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;AAC3C,EAAE,MAAM,UAAU,GAAG,KAAK,CAAC,IAAI,CAAC,OAAO;AACvC,EAAE,MAAM,iBAAiB,GAAG,UAAU,CAAC,EAAE,CAAC,KAAK,GAAG,UAAU,CAAC;AAC7D,EAAE,QAAQ,CAAC,OAAO,CAAC,OAAO,IAAI;AAC9B,IAAI,MAAM,UAAU,GAAG,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,KAAK,EAAE,kBAAkB;AACjE,IAAI,MAAM,QAAQ,GAAG,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,KAAK,GAAG,OAAO,CAAC,GAAG,EAAE,iBAAiB;AAC5E,IAAI,IAAI,UAAU,IAAI,QAAQ,EAAE,MAAM;AACtC;AACA,IAAI,MAAM,KAAK,GAAG,WAAW,CAAC,OAAO,EAAE,UAAU;AACjD;AACA,IAAI,MAAM,GAAG,GAAG,WAAW,CAAC,OAAO,EAAE,QAAQ,GAAG,CAAC,CAAC,GAAG;AACrD,IAAI,cAAc,IAAI,GAAG,GAAG;AAC5B,IAAI,WAAW,CAAC,IAAI,CAAC;AACrB,MAAM,KAAK;AACX,MAAM,GAAG;AACT,MAAM,UAAU;AAChB,MAAM;AACN,KAAK;AACL,EAAE,CAAC;AACH,EAAE,cAAc,IAAI,QAAQ,CAAC,MAAM,GAAG;AACtC;AACA,EAAE,IAAI,KAAK,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC;AAC7B;AACA,EAAE,QAAQ,CAAC,YAAY,CAAC,OAAO,CAAC,WAAW,EAAE,cAAc;AAC3D,EAAE,OAAO,CAAC,WAAW,CAAC,MAAM;AAC5B;AACA,EAAE,QAAQ,CAAC,YAAY,CAAC,OAAO,CAAC,WAAW,EAAE,KAAK;AAClD,EAAE,WAAW,CAAC,OAAO,CAAC,UAAU,IAAI;AACpC,IAAI,MAAM,OAAO,GAAG,UAAU,CAAC,UAAU,GAAG;AAC5C,IAAI,IAAI,OAAO,GAAG,CAAC,EAAE;AACrB,MAAM,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE,KAAK,CAAC,EAAE,OAAO,CAAC,CAAC,KAAK,CAAC,OAAO,EAAE,CAAC;AACjE,MAAM,KAAK,IAAI;AACf,IAAI;AACJ,IAAI,KAAK,IAAI,CAAC,GAAG,UAAU,CAAC,KAAK,EAAE,CAAC,GAAG,UAAU,CAAC,GAAG,EAAE,CAAC,EAAE,EAAE;AAC5D,MAAM,MAAM,MAAM,GAAG,OAAO,CAAC,CAAC;AAC9B,MAAM,MAAM,SAAS,GAAG,MAAM,CAAC,EAAE,CAAC,KAAK,GAAG,MAAM,CAAC;AACjD,MAAM,MAAM,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,SAAS,GAAG,UAAU,CAAC,QAAQ,EAAE,CAAC;AACnE,MAAM,MAAM,CAAC,KAAK,CAAC,OAAO,EAAE,KAAK,GAAG,MAAM,CAAC,EAAE,CAAC,KAAK,EAAE,SAAS;AAC9D,MAAM,KAAK,GAAG,SAAS,GAAG;AAC1B,IAAI;AACJ,EAAE,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,mBAAmB,GAAG,CAAC,OAAO,EAAE,KAAK,EAAE,GAAG,KAAK;AAC5D;AACA,EAAE,MAAM,EAAE,GAAG,IAAI,GAAG;AACpB,EAAE,GAAG,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,MAAM,KAAK;AACjC;AACA,IAAI,IAAI,QAAQ,CAAC,KAAK,EAAE,MAAM,CAAC,GAAG,KAAK,EAAE;AACzC,MAAM,EAAE,CAAC,GAAG,CAAC,MAAM,EAAE,KAAK;AAC1B,IAAI;AACJ,EAAE,CAAC;AACH,EAAE,cAAc,CAAC,KAAK,CAAC,CAAC,OAAO,CAAC,CAAC,MAAM,EAAE,MAAM,KAAK;AACpD,IAAI,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE;AAC1B,MAAM,EAAE,CAAC,GAAG,CAAC,MAAM,EAAE,CAAC;AACtB,IAAI;AACJ,EAAE,CAAC;AACH;AACA,EAAE,QAAQ,CAAC,YAAY,CAAC,OAAO,CAAC,WAAW,EAAE,EAAE,CAAC,IAAI;AACpD;AACA;AACA,EAAE,KAAK,CAAC,IAAI,CAAC,EAAE,CAAC,OAAO,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,MAAM,EAAE,KAAK,CAAC,KAAK;AACpF,IAAI,MAAM,OAAO,kCAAkC,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC;AAC5E,IAAI,MAAM,UAAU,GAAG,OAAO,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC;AACjD,IAAI,YAAY,CAAC,OAAO,EAAE,OAAO,EAAE,MAAM,EAAE,CAAC,IAAI,OAAO,CAAC,KAAK,EAAE,UAAU,CAAC,EAAE,CAAC,KAAK,GAAG,UAAU,CAAC,MAAM,GAAG,KAAK,CAAC,CAAC;AAChH,EAAE,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,qBAAqB,GAAG,CAAC,OAAO,EAAE,KAAK,EAAE,KAAK,KAAK;AAChE;AACA,EAAE,QAAQ,CAAC,YAAY,CAAC,OAAO,CAAC,WAAW,EAAE,KAAK,CAAC,OAAO,CAAC,IAAI;AAC/D;AACA;AACA,EAAE,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,OAAO,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,MAAM,EAAE,GAAG,CAAC,KAAK;AAC7F,IAAI,MAAM,QAAQ,GAAG,GAAG,CAAC,MAAM;AAC/B,IAAI,MAAM,OAAO,kCAAkC,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC;AAC5E,IAAI,YAAY,CAAC,OAAO,EAAE,OAAO,EAAE,MAAM,EAAE,QAAQ;AACnD,EAAE,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,gBAAgB,GAAG,CAAC,WAAW,EAAE,KAAK,EAAE,iBAAiB,KAAK;AACpE;AACA;AACA;AACA,EAAE,MAAM,KAAK,GAAG;AAChB;AACA,EAAE,IAAI,oBAAoB,GAAG,KAAK,CAAC,IAAI,CAAC,iBAAiB,CAAC,OAAO,CAAC,IAAI,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,KAAK,CAAC,GAAG,CAAC;AAC9F,EAAE,IAAI,oBAAoB,CAAC,MAAM,KAAK,CAAC,EAAE;AACzC,IAAI,OAAO;AACX,EAAE;AACF,EAAE,MAAM,mBAAmB,GAAG,MAAM;AACpC,IAAI,IAAI,oBAAoB,CAAC,MAAM,KAAK,CAAC,EAAE;AAC3C,MAAM,OAAO;AACb,IAAI;AACJ,IAAI,IAAI,iBAAiB,kDAAkD,iBAAiB,CAAC,OAAO,CAAC,GAAG,CAAC,oBAAoB,CAAC,oBAAoB,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;AAC/J,IAAI,OAAO,iBAAiB,CAAC,IAAI,CAAC,MAAM,KAAK,iBAAiB,CAAC,CAAC,EAAE;AAClE,MAAM,oBAAoB,CAAC,GAAG;AAC9B,MAAM,IAAI,oBAAoB,CAAC,MAAM,GAAG,CAAC,EAAE;AAC3C,QAAQ,iBAAiB,kDAAkD,iBAAiB,CAAC,OAAO,CAAC,GAAG,CAAC,oBAAoB,CAAC,oBAAoB,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;AAC/J,MAAM,CAAC,MAAM;AACb,QAAQ,OAAO;AACf,MAAM;AACN,IAAI;AACJ,IAAI,OAAO;AACX,EAAE;AACF,EAAE,IAAI,gBAAgB,GAAG,mBAAmB;AAC5C,EAAE,IAAI,gBAAgB,KAAK,IAAI,EAAE;AACjC,IAAI,OAAO;AACX,EAAE;;AAEF;AACA;AACA;AACA,EAAE,MAAM,WAAW,GAAG,IAAI,WAAW;AACrC,EAAE,MAAM,SAAS,GAAG,IAAI,GAAG;AAC3B;AACA;AACA;AACA;AACA,EAAE,MAAM,eAAe,GAAG,CAAC,MAAM,EAAE,KAAK,KAAK;AAC7C,IAAI,MAAM,MAAM,GAAG,SAAS,CAAC,GAAG,CAAC,MAAM;AACvC,IAAI,IAAI,MAAM,IAAI,IAAI,IAAI,MAAM,GAAG,KAAK,EAAE;AAC1C,MAAM,SAAS,CAAC,GAAG,CAAC,MAAM,EAAE,KAAK;AACjC,IAAI;AACJ,EAAE;AACF;AACA;AACA;AACA,EAAE,IAAI,SAAS,sBAAsB,CAAC,gBAAgB,EAAE,IAAI,oBAAoB,CAAC,gBAAgB,EAAE,CAAC,EAAE;AACtG;AACA,EAAE,MAAM,KAAK,GAAG,IAAI,GAAG;;AAEvB;AACA;AACA;AACA;AACA;;AAEA,EAAE,MAAM,gBAAgB,GAAG,MAAM;AACjC,IAAI,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE;AAC9B,MAAM,MAAM,MAAM,GAAG,IAAI,CAAC,EAAE,CAAC;AAC7B,MAAM,MAAM,iBAAiB,GAAG,iBAAiB,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM;AACpE,MAAM,IAAI,iBAAiB,EAAE;AAC7B;AACA,QAAQ,iBAAiB,CAAC,CAAC;AAC3B,QAAQ,WAAW,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,EAAE,iBAAiB,CAAC,IAAI,CAAC,KAAK,CAAC,iBAAiB,CAAC,CAAC,CAAC;AACzF,QAAQ,iBAAiB,CAAC,OAAO,CAAC,MAAM,CAAC,MAAM;AAC/C,QAAQ,iBAAiB,CAAC,CAAC,GAAG;AAC9B,QAAQ,iBAAiB,CAAC,IAAI,GAAG;AACjC,MAAM,CAAC,MAAM;AACb;AACA,QAAQ,WAAW,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,EAAE,CAAC,IAAI,CAAC;AAC9C,MAAM;AACN;AACA,MAAM,oBAAoB,GAAG,oBAAoB,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,KAAK,MAAM;AAC1E,IAAI;AACJ,IAAI,KAAK,CAAC,MAAM,GAAG;AACnB,EAAE;;AAEF;AACA,EAAE,OAAO,IAAI,EAAE;AACf,IAAI,IAAI,SAAS,CAAC,WAAW,KAAK,IAAI,EAAE;AACxC,MAAM,MAAM,UAAU,GAAG,GAAG,CAAC,cAAc,CAAC,KAAK,EAAE,SAAS,CAAC,EAAE,CAAC,MAAM,EAAE,MAAM,QAAQ,CAAC,KAAK,EAAE,SAAS,CAAC,EAAE,CAAC,MAAM,CAAC;AAClH,MAAM,MAAM,MAAM,GAAG,UAAU,GAAG,SAAS,CAAC,EAAE,CAAC;AAC/C,MAAM,MAAM,OAAO,GAAG,SAAS,CAAC,UAAU,CAAC,WAAW,EAAE,KAAK;AAC7D,MAAM,IAAI,OAAO,KAAK,IAAI,EAAE;AAC5B,QAAQ,KAAK,CAAC,IAAI,CAAC,SAAS;AAC5B;AACA;AACA;AACA;AACA,QAAQ,MAAM,UAAU,GAAG,iBAAiB,CAAC,OAAO,CAAC,GAAG,wBAAwB,OAAO,EAAE,IAAI,EAAE,IAAI,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC;AAC7G,QAAQ,IAAI,UAAU,CAAC,IAAI,CAAC,MAAM,KAAK,UAAU,CAAC,CAAC,IAAI,OAAO,KAAK,SAAS,CAAC,EAAE,CAAC,MAAM,IAAI,KAAK,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,MAAM,KAAK,OAAO,CAAC,EAAE;AACpI;AACA,UAAU,eAAe,wBAAwB,OAAO,GAAG,QAAQ,CAAC,KAAK,EAAE,OAAO,CAAC;AACnF,UAAU,gBAAgB;AAC1B,QAAQ,CAAC,MAAM;AACf,UAAU,SAAS,GAAG,UAAU,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,EAAE;AACpD,UAAU;AACV,QAAQ;AACR,MAAM,CAAC,MAAM;AACb;AACA;AACA,QAAQ,IAAI,MAAM,GAAG,CAAC,EAAE;AACxB,UAAU,MAAM,IAAI,GAAG,IAAI,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,EAAE,CAAC,MAAM,EAAE,UAAU,CAAC,EAAE,CAAC,MAAM;AAClF,UAAU,IAAI,CAAC,SAAS,CAAC,WAAW,EAAE,CAAC;AACvC,QAAQ;AACR,QAAQ,SAAS,CAAC,SAAS,CAAC,WAAW,EAAE,CAAC;AAC1C,QAAQ,KAAK,CAAC,GAAG,CAAC,SAAS,CAAC,EAAE,CAAC,MAAM,EAAE,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,EAAE,CAAC,KAAK,GAAG,SAAS,CAAC,MAAM,EAAE,UAAU,CAAC;AAClG,MAAM;AACN,IAAI;AACJ;AACA,IAAI,IAAI,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE;AAC1B,MAAM,SAAS,2BAA2B,KAAK,CAAC,GAAG,EAAE;AACrD,IAAI,CAAC,MAAM,IAAI,gBAAgB,KAAK,IAAI,IAAI,gBAAgB,CAAC,CAAC,GAAG,gBAAgB,CAAC,IAAI,CAAC,MAAM,EAAE;AAC/F,MAAM,SAAS,2BAA2B,gBAAgB,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC,EAAE,CAAC;AACrF,IAAI,CAAC,MAAM;AACX,MAAM,gBAAgB,GAAG,mBAAmB;AAC5C,MAAM,IAAI,gBAAgB,KAAK,IAAI,EAAE;AACrC;AACA,QAAQ;AACR,MAAM,CAAC,MAAM;AACb,QAAQ,SAAS,2BAA2B,gBAAgB,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC,EAAE,CAAC;AACvF,MAAM;AACN,IAAI;AACJ,EAAE;AACF,EAAE,IAAI,WAAW,CAAC,OAAO,CAAC,IAAI,GAAG,CAAC,EAAE;AACpC,IAAI,MAAM,OAAO,GAAG,IAAI,eAAe;AACvC,IAAI,mBAAmB,CAAC,OAAO,EAAE,WAAW,EAAE,IAAI,GAAG,EAAE;AACvD;AACA;AACA,IAAI,QAAQ,CAAC,YAAY,CAAC,OAAO,CAAC,WAAW,EAAE,CAAC,EAAC;AACjD,IAAI,OAAO,EAAE,OAAO,EAAE,SAAS,EAAE,MAAM,EAAE,OAAO,CAAC,YAAY,EAAE;AAC/D,EAAE;AACF,EAAE,OAAO;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,2BAA2B,GAAG,CAAC,OAAO,EAAE,WAAW,KAAK,qBAAqB,CAAC,OAAO,EAAE,WAAW,CAAC,GAAG,CAAC,KAAK,EAAE,WAAW,CAAC,SAAS;;AAEhJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,YAAY,GAAG,CAAC,OAAO,EAAE,IAAI,EAAE,iBAAiB,EAAE,aAAa,GAAG,IAAI,eAAe,CAAC,OAAO,CAAC;AAC3G,EAAE,QAAQ,CAAC,IAAI,EAAE,WAAW,IAAI;AAChC;AACA,IAAI,WAAW,CAAC,KAAK,GAAG;AACxB,IAAI,IAAI,KAAK,GAAG;AAChB,IAAI,MAAM,GAAG,GAAG,WAAW,CAAC;AAC5B,IAAI,MAAM,KAAK,GAAG,GAAG,CAAC;AACtB;AACA,IAAI,MAAM,EAAE,GAAG,aAAa,CAAC,aAAa,EAAE,GAAG;AAC/C,IAAI,MAAM,UAAU,GAAG,WAAW;AAClC,IAAI,EAAE,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,MAAM,KAAK;AACtC,MAAM,MAAM,YAAY,GAAG,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM;AACnD,MAAM,IAAI,YAAY,EAAE;AACxB,QAAQ,MAAM,IAAI,GAAG,YAAY,CAAC,YAAY,CAAC,MAAM,GAAG,CAAC;AACzD,QAAQ,UAAU,CAAC,GAAG,CAAC,MAAM,EAAE,CAAC,EAAE,IAAI,CAAC,EAAE,CAAC,KAAK,GAAG,IAAI,CAAC,MAAM;AAC7D;AACA,QAAQ,KAAK,CAAC,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE,MAAM,EAAE,CAAC,OAAO,CAAC,OAAO,IAAI;AACrE,UAAU,UAAU,CAAC,MAAM,CAAC,MAAM,EAAE,OAAO,CAAC,KAAK,EAAE,OAAO,CAAC,GAAG;AAC9D,QAAQ,CAAC;AACT,MAAM;AACN,IAAI,CAAC;AACL;AACA,IAAI,yBAAyB,CAAC,EAAE,EAAE,UAAU;AAC5C;AACA;AACA;AACA;AACA,IAAI,MAAM,WAAW,GAAG,gBAAgB,CAAC,WAAW,EAAE,KAAK,EAAE,EAAE;AAC/D,IAAI,MAAM,OAAO,GAAG,KAAK,CAAC;AAC1B,IAAI,IAAI,OAAO,EAAE;AACjB;AACA,MAAM,KAAK,MAAM,CAAC,MAAM,EAAE,KAAK,CAAC,IAAI,OAAO,CAAC,OAAO,EAAE;AACrD,QAAQ,IAAI,EAAE,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,IAAI,KAAK,GAAG,QAAQ,CAAC,KAAK,EAAE,MAAM,CAAC,EAAE;AACvE,UAAU,KAAK,GAAG;AAClB,UAAU;AACV,QAAQ;AACR,MAAM;AACN,MAAM,IAAI,WAAW,EAAE;AACvB;AACA,QAAQ,KAAK,MAAM,CAAC,MAAM,EAAE,KAAK,CAAC,IAAI,WAAW,CAAC,OAAO,EAAE;AAC3D,UAAU,MAAM,MAAM,GAAG,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM;AACnD,UAAU,IAAI,MAAM,IAAI,IAAI,IAAI,MAAM,GAAG,KAAK,EAAE;AAChD,YAAY,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,EAAE,KAAK;AAC7C,UAAU;AACV,QAAQ;AACR,QAAQ,OAAO,CAAC,MAAM,GAAG,cAAc,CAAC,CAAC,OAAO,CAAC,MAAM,EAAE,WAAW,CAAC,MAAM,CAAC;AAC5E,MAAM;AACN,IAAI,CAAC,MAAM;AACX,MAAM,KAAK,CAAC,cAAc,GAAG;AAC7B,IAAI;AACJ;AACA;AACA,IAAI,MAAM,MAAM,GAAG,qBAAqB,CAAC,aAAa,EAAE,WAAW,EAAE,KAAK;AAC1E,IAAI,IAAI,KAAK,CAAC,SAAS,EAAE;AACzB;AACA,MAAM,MAAM,eAAe,GAAG,IAAI,eAAe,CAAC,QAAQ,CAAC,aAAa,CAAC,KAAK,CAAC,SAAS,CAAC;AACzF,MAAM,QAAQ,CAAC,WAAW,CAAC,eAAe,CAAC,WAAW,EAAC;AACvD,MAAM,MAAM,OAAO,GAAG,qBAAqB,CAAC,eAAe,EAAE,WAAW,EAAE,KAAK;AAC/E,MAAM,IAAI,MAAM,IAAI,OAAO,EAAE;AAC7B;AACA,QAAQ,KAAK,CAAC,SAAS,GAAG,cAAc,CAAC,CAAC,MAAM,EAAE,OAAO,CAAC;AAC1D,MAAM,CAAC,MAAM;AACb;AACA;AACA;AACA,QAAQ,KAAK,CAAC,SAAS,GAAG,MAAM,IAAI;AACpC,MAAM;AACN,IAAI,CAAC,MAAM;AACX;AACA,MAAM,KAAK,CAAC,SAAS,GAAG;AACxB,IAAI;AACJ;AACA;;AAEA;AACA;AACA,IAAI,IAAI,KAAK,EAAE;AACf,MAAM,MAAM,MAAM,uCAAuC,CAAC,KAAK,CAAC,cAAc,EAAE;AAChF,MAAM,KAAK,CAAC,cAAc,GAAG;AAC7B,MAAM,aAAa,CAAC,WAAW,CAAC,GAAG,EAAE,MAAM;AAC3C,IAAI;AACJ,EAAE,CAAC,EAAE,iBAAiB,EAAE,KAAK;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,UAAU,GAAG,CAAC,OAAO,EAAE,IAAI,EAAE,iBAAiB,KAAK,YAAY,CAAC,OAAO,EAAE,IAAI,EAAE,iBAAiB,EAAE,IAAI,eAAe,CAAC,OAAO,CAAC;;AAE3I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,aAAa,GAAG,CAAC,IAAI,EAAE,MAAM,EAAE,iBAAiB,EAAE,QAAQ,GAAG,eAAe,KAAK;AAC9F,EAAE,MAAM,OAAO,GAAG,QAAQ,CAAC,aAAa,CAAC,MAAM;AAC/C,EAAE,YAAY,CAAC,OAAO,EAAE,IAAI,EAAE,iBAAiB,EAAE,IAAI,QAAQ,CAAC,OAAO,CAAC;AACtE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,WAAW,GAAG,CAAC,IAAI,EAAE,MAAM,EAAE,iBAAiB,KAAK,aAAa,CAAC,IAAI,EAAE,MAAM,EAAE,iBAAiB,EAAE,eAAe;;AAE9H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,kBAAkB,GAAG,CAAC,OAAO,EAAE,GAAG,EAAE,iBAAiB,GAAG,IAAI,GAAG,EAAE,KAAK;AACnF,EAAE,mBAAmB,CAAC,OAAO,EAAE,GAAG,CAAC,KAAK,EAAE,iBAAiB;AAC3D,EAAE,UAAU,CAAC,OAAO,EAAE,GAAG,CAAC,KAAK,CAAC,EAAE;AAClC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,qBAAqB,GAAG,CAAC,GAAG,EAAE,wBAAwB,GAAG,IAAI,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,OAAO,GAAG,IAAI,eAAe,EAAE,KAAK;AAC/H,EAAE,MAAM,iBAAiB,GAAG,iBAAiB,CAAC,wBAAwB;AACtE,EAAE,kBAAkB,CAAC,OAAO,EAAE,GAAG,EAAE,iBAAiB;AACpD,EAAE,MAAM,OAAO,GAAG,CAAC,OAAO,CAAC,YAAY,EAAE;AACzC;AACA,EAAE,IAAI,GAAG,CAAC,KAAK,CAAC,SAAS,EAAE;AAC3B,IAAI,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,SAAS;AACpC,EAAE;AACF,EAAE,IAAI,GAAG,CAAC,KAAK,CAAC,cAAc,EAAE;AAChC,IAAI,OAAO,CAAC,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,KAAK,CAAC,cAAc,CAAC,MAAM,EAAE,wBAAwB,CAAC;AACxF,EAAE;AACF,EAAE,IAAI,OAAO,CAAC,MAAM,GAAG,CAAC,EAAE;AAC1B,IAAI,IAAI,OAAO,CAAC,WAAW,KAAK,eAAe,EAAE;AACjD,MAAM,OAAO,YAAY,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,CAAC,KAAK,CAAC,KAAK,CAAC,GAAG,MAAM,GAAG,yBAAyB,CAAC,MAAM,CAAC,CAAC;AAC1G,IAAI,CAAC,MAAM,IAAI,OAAO,CAAC,WAAW,KAAK,eAAe,EAAE;AACxD,MAAM,OAAO,cAAc,CAAC,OAAO;AACnC,IAAI;AACJ,EAAE;AACF,EAAE,OAAO,OAAO,CAAC,CAAC;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,mBAAmB,GAAG,CAAC,GAAG,EAAE,wBAAwB,KAAK,qBAAqB,CAAC,GAAG,EAAE,wBAAwB,EAAE,IAAI,eAAe,EAAE;;AAEhJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,eAAe,GAAG,OAAO,IAAI;AAC1C,EAAE,MAAM,EAAE,GAAG,IAAI,GAAG;AACpB,EAAE,MAAM,QAAQ,GAAG,QAAQ,CAAC,WAAW,CAAC,OAAO,CAAC,WAAW;AAC3D,EAAE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,EAAE,CAAC,EAAE,EAAE;AACrC,IAAI,MAAM,MAAM,GAAG,QAAQ,CAAC,WAAW,CAAC,OAAO,CAAC,WAAW;AAC3D,IAAI,MAAM,KAAK,GAAG,QAAQ,CAAC,WAAW,CAAC,OAAO,CAAC,WAAW;AAC1D,IAAI,EAAE,CAAC,GAAG,CAAC,MAAM,EAAE,KAAK;AACxB,EAAE;AACF,EAAE,OAAO;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,iBAAiB,GAAG,YAAY,IAAI,eAAe,CAAC,IAAI,WAAW,CAAC,QAAQ,CAAC,aAAa,CAAC,YAAY,CAAC,CAAC;;AAEtH;AACA;AACA;AACA;AACA;AACY,MAAC,gBAAgB,GAAG,CAAC,OAAO,EAAE,EAAE,KAAK;AACjD,EAAE,QAAQ,CAAC,YAAY,CAAC,OAAO,CAAC,WAAW,EAAE,EAAE,CAAC,IAAI;AACpD,EAAE,KAAK,CAAC,IAAI,CAAC,EAAE,CAAC,OAAO,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,MAAM,EAAE,KAAK,CAAC,KAAK;AACpF,IAAI,QAAQ,CAAC,YAAY,CAAC,OAAO,CAAC,WAAW,EAAE,MAAM,EAAC;AACtD,IAAI,QAAQ,CAAC,YAAY,CAAC,OAAO,CAAC,WAAW,EAAE,KAAK;AACpD,EAAE,CAAC;AACH,EAAE,OAAO;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,wBAAwB,GAAG,CAAC,OAAO,EAAE,GAAG,KAAK,gBAAgB,CAAC,OAAO,EAAE,cAAc,CAAC,GAAG,CAAC,KAAK,CAAC;;AAE7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,mBAAmB,GAAG,CAAC,GAAG,EAAE,OAAO,GAAG,IAAI,cAAc,EAAE,KAAK;AAC5E,EAAE,IAAI,GAAG,YAAY,GAAG,EAAE;AAC1B,IAAI,gBAAgB,CAAC,OAAO,EAAE,GAAG;AACjC,EAAE,CAAC,MAAM;AACT,IAAI,wBAAwB,CAAC,OAAO,EAAE,GAAG;AACzC,EAAE;AACF,EAAE,OAAO,OAAO,CAAC,YAAY;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,iBAAiB,GAAG,GAAG,IAAI,mBAAmB,CAAC,GAAG,EAAE,IAAI,cAAc,EAAE;;AC5mBrF;AACA;AACA;AACA;AACA;AACA;AACA;AACO,MAAM,YAAY,CAAC;AAC1B,EAAE,WAAW,CAAC,GAAG;AACjB;AACA;AACA;AACA,IAAI,IAAI,CAAC,CAAC,GAAG;AACb,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,kBAAkB,GAAG,MAAM,IAAI,YAAY;;AAExD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,uBAAuB,GAAG,CAAC,YAAY,EAAE,CAAC;AACvD,EAAE,YAAY,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;;AAEvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,0BAA0B,GAAG,CAAC,YAAY,EAAE,CAAC,KAAK;AAC/D,EAAE,MAAM,CAAC,GAAG,YAAY,CAAC;AACzB,EAAE,MAAM,GAAG,GAAG,CAAC,CAAC;AAChB,EAAE,YAAY,CAAC,CAAC,GAAG,CAAC,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC;AACxC,EAAE,IAAI,GAAG,KAAK,YAAY,CAAC,CAAC,CAAC,MAAM,EAAE;AACrC,IAAI,OAAO,CAAC,KAAK,CAAC,0DAA0D;AAC5E,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,8BAA8B,GAAG,YAAY,IAAI;AAC9D,EAAE,YAAY,CAAC,CAAC,CAAC,MAAM,GAAG;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,yBAAyB,GAAG,CAAC,YAAY,EAAE,IAAI,EAAE,IAAI;AAClE,EAAE,CAAC,CAAC,OAAO,CAAC,YAAY,CAAC,CAAC,EAAE,CAAC,IAAI,EAAE,IAAI,CAAC;;AChFjC,MAAM,EAAE,CAAC;AAChB;AACA;AACA;AACA;AACA,EAAE,WAAW,CAAC,CAAC,MAAM,EAAE,KAAK,EAAE;AAC9B;AACA;AACA;AACA;AACA,IAAI,IAAI,CAAC,MAAM,GAAG;AAClB;AACA;AACA;AACA;AACA,IAAI,IAAI,CAAC,KAAK,GAAG;AACjB,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,UAAU,GAAG,CAAC,CAAC,EAAE,CAAC,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC,KAAK,IAAI,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,CAAC,MAAM,KAAK,CAAC,CAAC,MAAM,IAAI,CAAC,CAAC,KAAK,KAAK,CAAC,CAAC,KAAK;;AAExH;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,QAAQ,GAAG,CAAC,MAAM,EAAE,KAAK,KAAK,IAAI,EAAE,CAAC,MAAM,EAAE,KAAK;;AAE/D;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,OAAO,GAAG,CAAC,OAAO,EAAE,EAAE,KAAK;AACxC,EAAE,QAAQ,CAAC,YAAY,CAAC,OAAO,EAAE,EAAE,CAAC,MAAM;AAC1C,EAAE,QAAQ,CAAC,YAAY,CAAC,OAAO,EAAE,EAAE,CAAC,KAAK;AACzC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,MAAM,GAAG,OAAO;AAC7B,EAAE,QAAQ,CAAC,QAAQ,CAAC,WAAW,CAAC,OAAO,CAAC,EAAE,QAAQ,CAAC,WAAW,CAAC,OAAO,CAAC;;AAEvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,eAAe,GAAG,IAAI,IAAI;AACvC;AACA,EAAE,KAAK,MAAM,CAAC,GAAG,EAAE,KAAK,CAAC,IAAI,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,OAAO,EAAE,EAAE;AACvD,IAAI,IAAI,KAAK,KAAK,IAAI,EAAE;AACxB,MAAM,OAAO;AACb,IAAI;AACJ,EAAE;AACF,EAAE,MAAM,KAAK,CAAC,cAAc;AAC5B;;ACtFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,UAAU,GAAG,CAAC,MAAM,EAAE,KAAK,KAAK;AAC7C,EAAE,OAAO,KAAK,KAAK,IAAI,EAAE;AACzB,IAAI,IAAI,KAAK,CAAC,MAAM,KAAK,MAAM,EAAE;AACjC,MAAM,OAAO;AACb,IAAI;AACJ,IAAI,KAAK,oCAAoC,CAAC,KAAK,CAAC,MAAM,EAAE;AAC5D,EAAE;AACF,EAAE,OAAO;AACT;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,OAAO,GAAG,IAAI,IAAI;AAC/B,EAAE,MAAM,GAAG,GAAG;AACd,EAAE,IAAI,CAAC,GAAG,IAAI,CAAC;AACf,EAAE,OAAO,CAAC,EAAE;AACZ,IAAI,GAAG,CAAC,IAAI,CAAC,CAAC;AACd,IAAI,CAAC,GAAG,CAAC,CAAC;AACV,EAAE;AACF,EAAE,OAAO,CAAC,GAAG,CAAC,YAAY,EAAE,GAAG;AAC/B,EAAE,OAAO,CAAC,GAAG,CAAC,oBAAoB,EAAE,GAAG,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,OAAO,CAAC;AACnF;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,MAAM,gBAAgB,CAAC;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,WAAW,CAAC,CAAC,IAAI,EAAE,KAAK,EAAE,IAAI,EAAE,KAAK,GAAG,CAAC,EAAE;AAC7C;AACA;AACA;AACA,IAAI,IAAI,CAAC,IAAI,GAAG;AAChB;AACA;AACA;AACA,IAAI,IAAI,CAAC,KAAK,GAAG;AACjB;AACA;AACA;AACA,IAAI,IAAI,CAAC,IAAI,GAAG;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,IAAI,CAAC,KAAK,GAAG;AACjB,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACY,MAAC,sBAAsB,GAAG,IAAI,IAAI;AAC9C,EAAE,MAAM,IAAI,GAAG;AACf,EAAE,IAAI,IAAI,CAAC,IAAI,EAAE;AACjB,IAAI,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;AACrB,EAAE;AACF,EAAE,IAAI,IAAI,CAAC,KAAK,EAAE;AAClB,IAAI,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;AACtB,EAAE;AACF,EAAE,IAAI,IAAI,CAAC,IAAI,EAAE;AACjB,IAAI,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;AACrB,EAAE;AACF,EAAE,IAAI,IAAI,CAAC,KAAK,IAAI,IAAI,EAAE;AAC1B,IAAI,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;AACtB,EAAE;AACF,EAAE,OAAO;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,8BAA8B,GAAG,IAAI,IAAI,IAAI,gBAAgB,CAAC,IAAI,CAAC,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,IAAI,CAAC,KAAK,IAAI,IAAI,EAAE,IAAI,CAAC,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,IAAI,CAAC,KAAK,IAAI,IAAI,GAAG,CAAC,GAAG,IAAI,CAAC,KAAK;;AAE3Q,MAAM,gBAAgB,CAAC;AAC9B;AACA;AACA;AACA;AACA;AACA,EAAE,WAAW,CAAC,CAAC,IAAI,EAAE,KAAK,EAAE,KAAK,GAAG,CAAC,EAAE;AACvC;AACA;AACA;AACA,IAAI,IAAI,CAAC,IAAI,GAAG;AAChB;AACA;AACA;AACA,IAAI,IAAI,CAAC,KAAK,GAAG;AACjB,IAAI,IAAI,CAAC,KAAK,GAAG;AACjB,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,sBAAsB,GAAG,CAAC,IAAI,EAAE,KAAK,EAAE,KAAK,GAAG,CAAC,KAAK,IAAI,gBAAgB,CAAC,IAAI,EAAE,KAAK,EAAE,KAAK;;AAEzG;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,sBAAsB,GAAG,CAAC,IAAI,EAAE,IAAI,EAAE,KAAK,KAAK;AAC7D,EAAE,IAAI,MAAM,GAAG;AACf,EAAE,IAAI,KAAK,GAAG;AACd,EAAE,IAAI,IAAI,CAAC,KAAK,KAAK,IAAI,EAAE;AAC3B,IAAI,KAAK,GAAG,eAAe,CAAC,IAAI;AAChC,EAAE,CAAC,MAAM;AACT,IAAI,MAAM,GAAG,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,MAAM,EAAE,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,KAAK;AAC/D,EAAE;AACF,EAAE,OAAO,IAAI,gBAAgB,CAAC,MAAM,EAAE,KAAK,EAAE,IAAI,EAAE,KAAK;AACxD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,mCAAmC,GAAG,CAAC,IAAI,EAAE,KAAK,EAAE,KAAK,GAAG,CAAC,EAAE,kBAAkB,GAAG,qBAAqB,KAAK;AAC3H,EAAE,IAAI,CAAC,GAAG,IAAI,CAAC;AACf,EAAE,IAAI,KAAK,GAAG,CAAC,EAAE;AACjB;AACA,IAAI,IAAI,KAAK,KAAK,CAAC,EAAE;AACrB,MAAM,OAAO,sBAAsB,CAAC,IAAI,EAAE,IAAI,EAAE,KAAK;AACrD,IAAI;AACJ,IAAI,KAAK;AACT,EAAE;AACF,EAAE,OAAO,CAAC,KAAK,IAAI,EAAE;AACrB,IAAI,MAAM,GAAG,GAAG,kBAAkB,CAAC,aAAa,CAAC,CAAC;AAClD,IAAI,IAAI,GAAG,GAAG,KAAK,EAAE;AACrB;AACA,MAAM,OAAO,sBAAsB,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC,CAAC,EAAE,CAAC,MAAM,EAAE,CAAC,CAAC,EAAE,CAAC,KAAK,GAAG,KAAK,CAAC,EAAE,KAAK;AAC1F,IAAI;AACJ,IAAI,KAAK,IAAI;AACb,IAAI,IAAI,CAAC,CAAC,KAAK,KAAK,IAAI,IAAI,KAAK,GAAG,CAAC,EAAE;AACvC;AACA,MAAM,OAAO,sBAAsB,CAAC,IAAI,EAAE,CAAC,CAAC,MAAM,EAAE,KAAK;AACzD,IAAI;AACJ,IAAI,CAAC,GAAG,CAAC,CAAC;AACV,EAAE;AACF,EAAE,OAAO,sBAAsB,CAAC,IAAI,EAAE,IAAI,EAAE,KAAK;AACjD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,qBAAqB,GAAG,CAAC,OAAO,EAAE,IAAI,KAAK;AACxD,EAAE,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG;AACvC,EAAE,IAAI,IAAI,KAAK,IAAI,EAAE;AACrB,IAAI,QAAQ,CAAC,YAAY,CAAC,OAAO,EAAE,CAAC;AACpC,IAAI,OAAO,CAAC,OAAO,EAAE,IAAI;AACzB,EAAE,CAAC,MAAM,IAAI,KAAK,KAAK,IAAI,EAAE;AAC7B;AACA,IAAI,QAAQ,CAAC,UAAU,CAAC,OAAO,EAAE,CAAC;AAClC,IAAI,QAAQ,CAAC,cAAc,CAAC,OAAO,EAAE,KAAK;AAC1C,EAAE,CAAC,MAAM,IAAI,IAAI,KAAK,IAAI,EAAE;AAC5B;AACA,IAAI,QAAQ,CAAC,UAAU,CAAC,OAAO,EAAE,CAAC;AAClC,IAAI,OAAO,CAAC,OAAO,EAAE,IAAI;AACzB,EAAE,CAAC,MAAM;AACT,IAAI,MAAM,KAAK,CAAC,cAAc;AAC9B,EAAE;AACF,EAAE,QAAQ,CAAC,WAAW,CAAC,OAAO,EAAE,KAAK;AACrC,EAAE,OAAO;AACT;;AAEA;AACA;AACA;AACA;AACY,MAAC,sBAAsB,GAAG,IAAI,IAAI;AAC9C,EAAE,MAAM,OAAO,GAAG,QAAQ,CAAC,aAAa;AACxC,EAAE,qBAAqB,CAAC,OAAO,EAAE,IAAI;AACrC,EAAE,OAAO,QAAQ,CAAC,YAAY,CAAC,OAAO;AACtC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,oBAAoB,GAAG,OAAO,IAAI;AAC/C,EAAE,IAAI,IAAI,GAAG;AACb,EAAE,IAAI,KAAK,GAAG;AACd,EAAE,IAAI,MAAM,GAAG;AACf,EAAE,QAAQ,QAAQ,CAAC,WAAW,CAAC,OAAO,CAAC;AACvC,IAAI,KAAK,CAAC;AACV;AACA,MAAM,MAAM,GAAG,MAAM,CAAC,OAAO;AAC7B,MAAM;AACN,IAAI,KAAK,CAAC;AACV;AACA,MAAM,KAAK,GAAG,QAAQ,CAAC,aAAa,CAAC,OAAO;AAC5C,MAAM;AACN,IAAI,KAAK,CAAC,EAAE;AACZ;AACA,MAAM,IAAI,GAAG,MAAM,CAAC,OAAO;AAC3B,IAAI;AACJ;AACA,EAAE,MAAM,KAAK,GAAG,QAAQ,CAAC,UAAU,CAAC,OAAO,CAAC,GAAG,QAAQ,CAAC,UAAU,CAAC,OAAO,CAAC,GAAG;AAC9E,EAAE,OAAO,IAAI,gBAAgB,CAAC,IAAI,EAAE,KAAK,EAAE,MAAM,EAAE,KAAK;AACxD;;AAEA;AACA;AACA;AACA;AACY,MAAC,sBAAsB,GAAG,UAAU,IAAI,oBAAoB,CAAC,QAAQ,CAAC,aAAa,CAAC,UAAU,CAAC;;AAE3G;AACA;AACA;AACA;AACA,MAAM,iBAAiB,GAAG,CAAC,KAAK,EAAE,EAAE,KAAK;AACzC,EAAE,MAAM,IAAI,GAAG,OAAO,CAAC,KAAK,EAAE,EAAE;AAChC,EAAE,MAAM,IAAI,GAAG,EAAE,CAAC,KAAK,GAAG,IAAI,CAAC,EAAE,CAAC;AAClC,EAAE,OAAO;AACT,IAAI,IAAI,EAAE;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,0CAA0C,GAAG,CAAC,IAAI,EAAE,GAAG,EAAE,qBAAqB,GAAG,IAAI,EAAE,kBAAkB,GAAG,qBAAqB,KAAK;AACnJ,EAAE,MAAM,KAAK,GAAG,GAAG,CAAC;AACpB,EAAE,MAAM,OAAO,GAAG,IAAI,CAAC;AACvB,EAAE,MAAM,MAAM,GAAG,IAAI,CAAC;AACtB,EAAE,MAAM,KAAK,GAAG,IAAI,CAAC;AACrB,EAAE,MAAM,KAAK,GAAG,IAAI,CAAC;AACrB,EAAE,IAAI,IAAI,GAAG;AACb,EAAE,IAAI,KAAK,GAAG;AACd,EAAE,IAAI,OAAO,KAAK,IAAI,EAAE;AACxB,IAAI,IAAI,QAAQ,CAAC,KAAK,EAAE,OAAO,CAAC,MAAM,CAAC,IAAI,OAAO,CAAC,KAAK,EAAE;AAC1D,MAAM,OAAO;AACb,IAAI;AACJ,IAAI,MAAM,GAAG,GAAG,qBAAqB,GAAG,YAAY,CAAC,KAAK,EAAE,OAAO,CAAC,GAAG,iBAAiB,CAAC,KAAK,EAAE,OAAO;AACvG,IAAI,MAAM,KAAK,GAAG,GAAG,CAAC;AACtB,IAAI,IAAI,EAAE,KAAK,YAAY,IAAI,CAAC,EAAE;AAClC,MAAM,OAAO;AACb,IAAI;AACJ,IAAI,IAAI,qCAAqC,KAAK,CAAC,MAAM;AACzD,IAAI,IAAI,IAAI,CAAC,KAAK,KAAK,IAAI,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE;AACpD,MAAM,KAAK,GAAG,kBAAkB,CAAC,aAAa,CAAC,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,GAAG,CAAC,IAAI,IAAI,KAAK,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,EAAC;AACnG,MAAM,IAAI,CAAC,GAAG,KAAK,CAAC;AACpB,MAAM,OAAO,CAAC,KAAK,IAAI,EAAE;AACzB,QAAQ,KAAK,IAAI,kBAAkB,CAAC,aAAa,CAAC,CAAC;AACnD,QAAQ,CAAC,GAAG,CAAC,CAAC;AACd,MAAM;AACN,IAAI;AACJ,EAAE,CAAC,MAAM;AACT,IAAI,IAAI,KAAK,KAAK,IAAI,EAAE;AACxB,MAAM,IAAI,GAAG,GAAG,CAAC,GAAG,CAAC,KAAK;AAC1B,IAAI,CAAC,MAAM,IAAI,MAAM,KAAK,IAAI,EAAE;AAChC,MAAM,IAAI,QAAQ,CAAC,KAAK,EAAE,MAAM,CAAC,MAAM,CAAC,IAAI,MAAM,CAAC,KAAK,EAAE;AAC1D;AACA,QAAQ,OAAO;AACf,MAAM;AACN,MAAM,MAAM,EAAE,IAAI,EAAE,GAAG,qBAAqB,GAAG,YAAY,CAAC,KAAK,EAAE,MAAM,CAAC,GAAG,EAAE,IAAI,EAAE,OAAO,CAAC,KAAK,EAAE,MAAM,CAAC;AAC3G,MAAM,IAAI,IAAI,YAAY,IAAI,IAAI,IAAI,CAAC,OAAO,YAAY,WAAW,EAAE;AACvE,QAAQ,IAAI,GAAG,IAAI,CAAC,OAAO,CAAC;AAC5B,MAAM,CAAC,MAAM;AACb;AACA,QAAQ,OAAO;AACf,MAAM;AACN,IAAI,CAAC,MAAM;AACX,MAAM,MAAM,KAAK,CAAC,cAAc;AAChC,IAAI;AACJ,IAAI,IAAI,KAAK,IAAI,CAAC,EAAE;AACpB,MAAM,KAAK,GAAG,IAAI,CAAC;AACnB,IAAI,CAAC,MAAM;AACX,MAAM,KAAK,GAAG;AACd,IAAI;AACJ,EAAE;AACF,EAAE,OAAO,sBAAsB,CAAC,IAAI,EAAE,KAAK,EAAE,IAAI,CAAC,KAAK;AACvD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,wBAAwB,GAAG,CAAC,CAAC,EAAE,CAAC,KAAK,CAAC,KAAK,CAAC;AACzD,EAAE,CAAC,KAAK,IAAI,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,CAAC,KAAK,KAAK,CAAC,CAAC,KAAK,IAAI,UAAU,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,UAAU,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,KAAK,KAAK,CAAC,CAAC;AAC/H;;ACrUO,MAAM,QAAQ,CAAC;AACtB;AACA;AACA;AACA;AACA,EAAE,WAAW,CAAC,CAAC,EAAE,EAAE,EAAE,EAAE;AACvB;AACA;AACA;AACA,IAAI,IAAI,CAAC,EAAE,GAAG;AACd;AACA;AACA;AACA;AACA,IAAI,IAAI,CAAC,EAAE,GAAG;AACd,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACY,MAAC,cAAc,GAAG,CAAC,KAAK,EAAE,KAAK,KAAK;AAChD,EAAE,MAAM,GAAG,GAAG,KAAK,CAAC;AACpB,EAAE,MAAM,GAAG,GAAG,KAAK,CAAC;AACpB,EAAE,IAAI,GAAG,CAAC,IAAI,KAAK,GAAG,CAAC,IAAI,EAAE;AAC7B,IAAI,OAAO;AACX,EAAE;AACF,EAAE,KAAK,MAAM,CAAC,GAAG,EAAE,KAAK,CAAC,IAAI,GAAG,CAAC,OAAO,EAAE,EAAE;AAC5C,IAAI,IAAI,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,KAAK,KAAK,EAAE;AAChC,MAAM,OAAO;AACb,IAAI;AACJ,EAAE;AACF,EAAE,OAAO,WAAW,CAAC,KAAK,CAAC,EAAE,EAAE,KAAK,CAAC,EAAE;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACY,MAAC,gBAAgB,GAAG,CAAC,QAAQ,EAAE,OAAO,GAAG,IAAI,cAAc,EAAE,KAAK;AAC9E,EAAE,UAAU,CAAC,OAAO,EAAE,QAAQ,CAAC,EAAE;AACjC,EAAE,gBAAgB,CAAC,OAAO,EAAE,QAAQ,CAAC,EAAE;AACvC,EAAE,OAAO,OAAO,CAAC,YAAY;AAC7B;;AAEA;AACA;AACA;AACA;AACY,MAAC,cAAc,GAAG,QAAQ,IAAI,gBAAgB,CAAC,QAAQ,EAAE,IAAI,cAAc,EAAE;;AAEzF;AACA;AACA;AACA;AACA;AACY,MAAC,gBAAgB,GAAG,CAAC,GAAG,EAAE,OAAO,GAAG,IAAI,WAAW,CAAC,QAAQ,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC,KAAK;AACjG,EAAE,OAAO,IAAI,QAAQ,CAAC,SAAS,CAAC,OAAO,CAAC,EAAE,eAAe,CAAC,OAAO,CAAC;AAClE;;AAEA;AACA;AACA;AACA;AACY,MAAC,cAAc,GAAG,GAAG,IAAI,gBAAgB,CAAC,GAAG,EAAE,IAAI,WAAW,CAAC,QAAQ,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC;;AAEvG;AACA;AACA;AACA;AACA;AACY,MAAC,cAAc,GAAG,CAAC,EAAE,EAAE,EAAE,KAAK,IAAI,QAAQ,CAAC,EAAE,EAAE,EAAE;;AAEjD,MAAC,aAAa,GAAG,cAAc,CAAC,WAAW,EAAE,EAAE,IAAI,GAAG,EAAE;;AAEpE;AACA;AACA;AACA;AACY,MAAC,QAAQ,GAAG,GAAG,IAAI,cAAc,CAAC,8BAA8B,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE,cAAc,CAAC,GAAG,CAAC,KAAK,CAAC;;AAElH;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,SAAS,GAAG,CAAC,IAAI,EAAE,QAAQ,KAAK,QAAQ,KAAK;AAC1D,IAAI,CAAC,IAAI,CAAC;AACV,IAAI,QAAQ,CAAC,EAAE,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,EAAE,CAAC,KAAK,IAAI,CAAC,QAAQ,CAAC,EAAE,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE;;AAE3H;AACA;AACA;AACA;AACY,MAAC,4BAA4B,GAAG,CAAC,WAAW,EAAE,QAAQ,KAAK;AACvE,EAAE,MAAM,IAAI,GAAG,GAAG,CAAC,cAAc,CAAC,WAAW,CAAC,IAAI,EAAE,4BAA4B,EAAE,GAAG,CAAC,MAAM;AAC5F,EAAE,MAAM,KAAK,GAAG,WAAW,CAAC,GAAG,CAAC;AAChC;AACA,EAAE,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE;AAC3B,IAAI,QAAQ,CAAC,EAAE,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,MAAM,KAAK;AAC3C,MAAM,IAAI,KAAK,GAAG,QAAQ,CAAC,KAAK,EAAE,MAAM,CAAC,EAAE;AAC3C,QAAQ,iBAAiB,CAAC,WAAW,EAAE,QAAQ,CAAC,MAAM,EAAE,KAAK,CAAC;AAC9D,MAAM;AACN,IAAI,CAAC;AACL,IAAI,qBAAqB,CAAC,WAAW,EAAE,QAAQ,CAAC,EAAE,EAAE,KAAK,IAAI,CAAC,CAAC;AAC/D,IAAI,IAAI,CAAC,GAAG,CAAC,QAAQ;AACrB,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,qBAAqB,GAAG,CAAC,SAAS,EAAE,QAAQ,EAAE,MAAM,GAAG,IAAI,GAAG,EAAE,KAAK;AAClF,EAAE,IAAI,SAAS,CAAC,EAAE,EAAE;AACpB;AACA,IAAI,MAAM,IAAI,KAAK,CAAC,qDAAqD;AACzE,EAAE;AACF,EAAE,MAAM,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG;;AAErB,EAAE,MAAM,OAAO,GAAG,IAAI,eAAe;AACrC,EAAE,SAAS,CAAC,QAAQ,CAAC,WAAW,IAAI;AACpC,IAAI,IAAI,IAAI,GAAG;AACf,IAAI,EAAE,CAAC,OAAO,CAAC,KAAK,IAAI;AACxB,MAAM,IAAI,KAAK,GAAG,CAAC,EAAE;AACrB,QAAQ,IAAI;AACZ,MAAM;AACN,IAAI,CAAC;AACL,IAAI,QAAQ,CAAC,YAAY,CAAC,OAAO,CAAC,WAAW,EAAE,IAAI;AACnD;AACA,IAAI,KAAK,MAAM,CAAC,MAAM,EAAE,KAAK,CAAC,IAAI,EAAE,EAAE;AACtC,MAAM,IAAI,KAAK,KAAK,CAAC,EAAE;AACvB,QAAQ;AACR,MAAM;AACN,MAAM,IAAI,KAAK,GAAG,QAAQ,CAAC,SAAS,CAAC,KAAK,EAAE,MAAM,CAAC,EAAE;AACrD,QAAQ,iBAAiB,CAAC,WAAW,EAAE,QAAQ,CAAC,MAAM,EAAE,KAAK,CAAC;AAC9D,MAAM;AACN,MAAM,MAAM,OAAO,GAAG,SAAS,CAAC,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,IAAI;AAC7D,MAAM,MAAM,eAAe,GAAG,WAAW,CAAC,OAAO,EAAE,KAAK,GAAG,CAAC;AAC5D;AACA,MAAM,QAAQ,CAAC,YAAY,CAAC,OAAO,CAAC,WAAW,EAAE,eAAe,GAAG,CAAC;AACpE,MAAM,OAAO,CAAC,WAAW,CAAC,MAAM;AAChC;AACA,MAAM,QAAQ,CAAC,YAAY,CAAC,OAAO,CAAC,WAAW,EAAE,CAAC;AAClD,MAAM,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,eAAe,EAAE,CAAC,EAAE,EAAE;AACjD,QAAQ,OAAO,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,OAAO,EAAE,CAAC,EAAE,CAAC;AACtC,MAAM;AACN,IAAI;AACJ,IAAI,UAAU,CAAC,OAAO,EAAE,EAAE;AAC1B,EAAE,CAAC;;AAEH,EAAE,aAAa,CAAC,MAAM,EAAE,OAAO,CAAC,YAAY,EAAE,EAAE,UAAU;AAC1D,EAAE,OAAO;AACT;;AAEA;AACA;AACA;AACA;AACA;AACY,MAAC,wBAAwB,GAAG,CAAC,QAAQ,EAAE,MAAM,EAAE,QAAQ,GAAG,eAAe,KAAK;AAE1F,EAAE,MAAM,aAAa,GAAG,IAAI,QAAQ,CAAC,QAAQ,CAAC,aAAa,CAAC,MAAM,CAAC;AACnE,EAAE,MAAM,WAAW,GAAG,IAAI,gBAAgB,CAAC,aAAa,EAAE,KAAK;AAC/D,EAAE,KAAK,IAAI,IAAI,GAAG,WAAW,CAAC,IAAI,EAAE,IAAI,KAAK,IAAI,EAAE,IAAI,GAAG,WAAW,CAAC,IAAI,EAAE,EAAE;AAE9E,IAAI,IAAI,CAAC,QAAQ,CAAC,EAAE,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,EAAE,CAAC,KAAK,GAAG,IAAI,CAAC,MAAM,EAAE;AAC9E,MAAM,OAAO;AACb,IAAI;AACJ,EAAE;AACF,EAAE,MAAM,QAAQ,GAAG,WAAW,CAAC,CAAC,QAAQ,CAAC,EAAE,EAAE,SAAS,CAAC,aAAa,CAAC,CAAC;AACtE,EAAE,OAAO,WAAW,CAAC,QAAQ,CAAC,EAAE,EAAE,QAAQ;AAC1C;;AAEA;AACA;AACA;AACA;AACY,MAAC,sBAAsB,GAAG,CAAC,QAAQ,EAAE,MAAM,KAAK,wBAAwB,CAAC,QAAQ,EAAE,MAAM,EAAE,eAAe;;AC7M/G,MAAM,WAAW,CAAC;AACzB,EAAE,WAAW,CAAC,GAAG;AACjB;AACA;AACA;AACA,IAAI,IAAI,CAAC,OAAO,GAAG,IAAI,GAAG;AAC1B;AACA;AACA;AACA;AACA,IAAI,IAAI,CAAC,cAAc,GAAG;AAC1B;AACA;AACA;AACA,IAAI,IAAI,CAAC,SAAS,GAAG;AACrB,IAAI,IAAI,CAAC,KAAK,GAAG,WAAW;AAC5B,EAAE;;AAEF,EAAE,IAAI,EAAE,CAAC,GAAG;AACZ,IAAI,OAAO,8BAA8B,CAAC,IAAI;AAC9C,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,cAAc,GAAG,KAAK,IAAI;AACvC,EAAE,MAAM,EAAE,GAAG,IAAI,GAAG;AACpB,EAAE,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,KAAK;AAC7C,IAAI,MAAM,MAAM,GAAG,OAAO,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC;AAC7C,IAAI,EAAE,CAAC,GAAG,CAAC,MAAM,EAAE,MAAM,CAAC,EAAE,CAAC,KAAK,GAAG,MAAM,CAAC,MAAM;AAClD,EAAE,CAAC;AACH,EAAE,KAAK,CAAC,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,MAAM,KAAK;AACjD,IAAI,EAAE,CAAC,GAAG,CAAC,MAAM,EAAE,KAAK,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC,CAAC,KAAK;AAC1C,EAAE,CAAC;AACH,EAAE,OAAO;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,QAAQ,GAAG,CAAC,KAAK,EAAE,MAAM,KAAK;AAC3C,EAAE,MAAM,OAAO,GAAG,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM;AAC1C,EAAE,IAAI,OAAO,KAAK,SAAS,EAAE;AAC7B,IAAI,OAAO;AACX,EAAE;AACF,EAAE,MAAM,UAAU,GAAG,OAAO,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC;AAC/C,EAAE,OAAO,UAAU,CAAC,EAAE,CAAC,KAAK,GAAG,UAAU,CAAC;AAC1C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,cAAc,GAAG,KAAK,IAAI;AACvC,EAAE,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,OAAO,IAAI;AACnC,IAAI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AAC7C,MAAM,MAAM,CAAC,GAAG,OAAO,CAAC,CAAC,GAAG,CAAC;AAC7B,MAAM,MAAM,CAAC,GAAG,OAAO,CAAC,CAAC;AACzB,MAAM,IAAI,CAAC,CAAC,EAAE,CAAC,KAAK,GAAG,CAAC,CAAC,MAAM,KAAK,CAAC,CAAC,EAAE,CAAC,KAAK,EAAE;AAChD,QAAQ,MAAM,IAAI,KAAK,CAAC,oCAAoC;AAC5D,MAAM;AACN,IAAI;AACJ,EAAE,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,SAAS,GAAG,CAAC,KAAK,EAAE,MAAM,KAAK;AAC5C,EAAE,IAAI,OAAO,GAAG,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE,CAAC,MAAM;AAClD,EAAE,IAAI,OAAO,KAAK,SAAS,EAAE;AAC7B,IAAI,OAAO,GAAG;AACd,IAAI,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE,CAAC,MAAM,EAAE,OAAO;AAC/C,EAAE,CAAC,MAAM;AACT,IAAI,MAAM,UAAU,GAAG,OAAO,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC;AACjD,IAAI,IAAI,UAAU,CAAC,EAAE,CAAC,KAAK,GAAG,UAAU,CAAC,MAAM,KAAK,MAAM,CAAC,EAAE,CAAC,KAAK,EAAE;AACrE;AACA,MAAM,IAAI,KAAK,GAAG,WAAW,CAAC,OAAO,EAAE,MAAM,CAAC,EAAE,CAAC,KAAK;AACtD,MAAM,MAAM,IAAI,GAAG,OAAO,CAAC,KAAK;AAChC,MAAM,MAAM,SAAS,GAAG,MAAM,CAAC,EAAE,CAAC,KAAK,GAAG,IAAI,CAAC,EAAE,CAAC;AAClD,MAAM,MAAM,OAAO,GAAG,IAAI,CAAC,EAAE,CAAC,KAAK,GAAG,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC,EAAE,CAAC,KAAK,GAAG,MAAM,CAAC;AAC7E,MAAM,IAAI,SAAS,GAAG,CAAC,EAAE;AACzB,QAAQ,OAAO,CAAC,MAAM,CAAC,KAAK,EAAE,EAAE,CAAC,EAAE,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,EAAE,CAAC,MAAM,EAAE,IAAI,CAAC,EAAE,CAAC,KAAK,CAAC,EAAE,SAAS,CAAC;AACjG,MAAM;AACN,MAAM,IAAI,OAAO,GAAG,CAAC,EAAE;AACvB,QAAQ,OAAO,CAAC,MAAM,CAAC,KAAK,GAAG,CAAC,EAAE,CAAC,EAAE,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,EAAE,CAAC,MAAM,EAAE,MAAM,CAAC,EAAE,CAAC,KAAK,GAAG,MAAM,CAAC,MAAM,CAAC,EAAE,OAAO,CAAC;AACnH,MAAM;AACN,MAAM,OAAO,CAAC,KAAK,CAAC,GAAG;AACvB,MAAM,KAAK,CAAC,KAAK,CAAC,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,MAAM,EAAE,MAAM,CAAC,EAAE,CAAC,KAAK,EAAE,MAAM,CAAC,MAAM;AACzE,MAAM;AACN,IAAI;AACJ,EAAE;AACF,EAAE,OAAO,CAAC,IAAI,CAAC,MAAM;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,WAAW,GAAG,CAAC,OAAO,EAAE,KAAK,KAAK;AAC/C,EAAE,IAAI,IAAI,GAAG;AACb,EAAE,IAAI,KAAK,GAAG,OAAO,CAAC,MAAM,GAAG;AAC/B,EAAE,IAAI,GAAG,GAAG,OAAO,CAAC,KAAK;AACzB,EAAE,IAAI,QAAQ,GAAG,GAAG,CAAC,EAAE,CAAC;AACxB,EAAE,IAAI,QAAQ,KAAK,KAAK,EAAE;AAC1B,IAAI,OAAO;AACX,EAAE;AACF;AACA;AACA;AACA,EAAE,IAAI,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,KAAK,IAAI,QAAQ,GAAG,GAAG,CAAC,MAAM,GAAG,CAAC,CAAC,IAAI,KAAK,EAAC;AAC1E,EAAE,OAAO,IAAI,IAAI,KAAK,EAAE;AACxB,IAAI,GAAG,GAAG,OAAO,CAAC,QAAQ;AAC1B,IAAI,QAAQ,GAAG,GAAG,CAAC,EAAE,CAAC;AACtB,IAAI,IAAI,QAAQ,IAAI,KAAK,EAAE;AAC3B,MAAM,IAAI,KAAK,GAAG,QAAQ,GAAG,GAAG,CAAC,MAAM,EAAE;AACzC,QAAQ,OAAO;AACf,MAAM;AACN,MAAM,IAAI,GAAG,QAAQ,GAAG;AACxB,IAAI,CAAC,MAAM;AACX,MAAM,KAAK,GAAG,QAAQ,GAAG;AACzB,IAAI;AACJ,IAAI,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,IAAI,GAAG,KAAK,IAAI,CAAC;AAC5C,EAAE;AACF;AACA;AACA,EAAE,MAAM,KAAK,CAAC,cAAc;AAC5B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,IAAI,GAAG,CAAC,KAAK,EAAE,EAAE,KAAK;AACnC;AACA;AACA;AACA;AACA,EAAE,MAAM,OAAO,GAAG,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC,MAAM;AAC7C,EAAE,OAAO,OAAO,CAAC,WAAW,CAAC,OAAO,EAAE,EAAE,CAAC,KAAK,CAAC;AAC/C;;AAEA;AACA;AACA;AACA;AACA;AACY,MAAC,OAAO,iDAAiD,IAAI;;AAEzE;AACA;AACA;AACA;AACA;AACY,MAAC,mBAAmB,GAAG,CAAC,WAAW,EAAE,OAAO,EAAE,KAAK,KAAK;AACpE,EAAE,MAAM,KAAK,GAAG,WAAW,CAAC,OAAO,EAAE,KAAK;AAC1C,EAAE,MAAM,MAAM,GAAG,OAAO,CAAC,KAAK;AAC9B,EAAE,IAAI,MAAM,CAAC,EAAE,CAAC,KAAK,GAAG,KAAK,EAAE;AAC/B,IAAI,OAAO,CAAC,MAAM,CAAC,KAAK,GAAG,CAAC,EAAE,CAAC,EAAE,WAAW,CAAC,WAAW,EAAE,MAAM,EAAE,KAAK,GAAG,MAAM,CAAC,EAAE,CAAC,KAAK,CAAC;AAC1F,IAAI,OAAO,KAAK,GAAG;AACnB,EAAE;AACF,EAAE,OAAO;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,iBAAiB,GAAG,CAAC,WAAW,EAAE,EAAE,KAAK;AACtD,EAAE,MAAM,OAAO,+BAA+B,WAAW,CAAC,GAAG,CAAC,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC,MAAM,CAAC;AAC1F,EAAE,OAAO,OAAO,CAAC,mBAAmB,CAAC,WAAW,EAAE,OAAO,EAAE,EAAE,CAAC,KAAK,CAAC;AACpE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,eAAe,GAAG,CAAC,WAAW,EAAE,KAAK,EAAE,EAAE,KAAK;AAC3D;AACA;AACA;AACA;AACA,EAAE,MAAM,OAAO,GAAG,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC,MAAM;AAC7C,EAAE,MAAM,KAAK,GAAG,WAAW,CAAC,OAAO,EAAE,EAAE,CAAC,KAAK;AAC7C,EAAE,MAAM,MAAM,GAAG,OAAO,CAAC,KAAK;AAC9B,EAAE,IAAI,EAAE,CAAC,KAAK,KAAK,MAAM,CAAC,EAAE,CAAC,KAAK,GAAG,MAAM,CAAC,MAAM,GAAG,CAAC,IAAI,MAAM,CAAC,WAAW,KAAK,EAAE,EAAE;AACrF,IAAI,OAAO,CAAC,MAAM,CAAC,KAAK,GAAG,CAAC,EAAE,CAAC,EAAE,SAAS,CAAC,WAAW,EAAE,MAAM,EAAE,EAAE,CAAC,KAAK,GAAG,MAAM,CAAC,EAAE,CAAC,KAAK,GAAG,CAAC,CAAC;AAC/F,EAAE;AACF,EAAE,OAAO;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,aAAa,GAAG,CAAC,EAAE,EAAE,MAAM,EAAE,SAAS,KAAK;AACxD,EAAE,MAAM,OAAO,kCAAkC,EAAE,CAAC,GAAG,CAAC,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE,CAAC,MAAM,CAAC;AAC3F,EAAE,OAAO,CAAC,WAAW,CAAC,OAAO,EAAE,MAAM,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,GAAG;AACnD,EAAE,EAAE,CAAC,aAAa,CAAC,IAAI,CAAC,SAAS;AACjC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,cAAc,GAAG,CAAC,WAAW,EAAE,OAAO,EAAE,UAAU,EAAE,GAAG,EAAE,CAAC,KAAK;AAC5E,EAAE,IAAI,GAAG,KAAK,CAAC,EAAE;AACjB,IAAI;AACJ,EAAE;AACF,EAAE,MAAM,QAAQ,GAAG,UAAU,GAAG;AAChC,EAAE,IAAI,KAAK,GAAG,mBAAmB,CAAC,WAAW,EAAE,OAAO,EAAE,UAAU;AAClE,EAAE,IAAI;AACN,EAAE,GAAG;AACL,IAAI,MAAM,GAAG,OAAO,CAAC,KAAK,EAAE;AAC5B,IAAI,IAAI,QAAQ,GAAG,MAAM,CAAC,EAAE,CAAC,KAAK,GAAG,MAAM,CAAC,MAAM,EAAE;AACpD,MAAM,mBAAmB,CAAC,WAAW,EAAE,OAAO,EAAE,QAAQ;AACxD,IAAI;AACJ,IAAI,CAAC,CAAC,MAAM;AACZ,EAAE,CAAC,QAAQ,KAAK,GAAG,OAAO,CAAC,MAAM,IAAI,OAAO,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,KAAK,GAAG,QAAQ;AACvE;;AC1QA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,MAAM,WAAW,CAAC;AACzB;AACA;AACA;AACA;AACA;AACA,EAAE,WAAW,CAAC,CAAC,GAAG,EAAE,MAAM,EAAE,KAAK,EAAE;AACnC;AACA;AACA;AACA;AACA,IAAI,IAAI,CAAC,GAAG,GAAG;AACf;AACA;AACA;AACA,IAAI,IAAI,CAAC,SAAS,GAAG,WAAW;AAChC;AACA;AACA;AACA;AACA,IAAI,IAAI,CAAC,QAAQ,GAAG,WAAW;AAC/B;AACA;AACA;AACA,IAAI,IAAI,CAAC,SAAS,GAAG,WAAW;AAChC;AACA;AACA;AACA;AACA,IAAI,IAAI,CAAC,YAAY,GAAG;AACxB;AACA;AACA;AACA;AACA,IAAI,IAAI,CAAC,WAAW,GAAG;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,IAAI,CAAC,OAAO,GAAG,IAAI,GAAG;AAC1B;AACA;AACA;AACA;AACA;AACA,IAAI,IAAI,CAAC,kBAAkB,GAAG,IAAI,GAAG;AACrC;AACA;AACA;AACA,IAAI,IAAI,CAAC,aAAa,GAAG;AACzB;AACA;AACA;AACA,IAAI,IAAI,CAAC,MAAM,GAAG;AAClB;AACA;AACA;AACA;AACA,IAAI,IAAI,CAAC,IAAI,GAAG,IAAI,GAAG;AACvB;AACA;AACA;AACA;AACA,IAAI,IAAI,CAAC,KAAK,GAAG;AACjB;AACA;AACA;AACA,IAAI,IAAI,CAAC,YAAY,GAAG,IAAI,GAAG;AAC/B;AACA;AACA;AACA,IAAI,IAAI,CAAC,cAAc,GAAG,IAAI,GAAG;AACjC;AACA;AACA;AACA,IAAI,IAAI,CAAC,aAAa,GAAG,IAAI,GAAG;AAChC;AACA;AACA;AACA,IAAI,IAAI,CAAC,sBAAsB,GAAG;AAClC,IAAI,IAAI,CAAC,KAAK,GAAG;AACjB,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,IAAI,WAAW,CAAC,GAAG;AACrB,IAAI,IAAI,IAAI,CAAC,YAAY,IAAI,IAAI,EAAE;AACnC,MAAM,MAAM,EAAE,GAAG,cAAc,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK;AAC9C,MAAM,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,MAAM,EAAE,MAAM,KAAK;AACzD,QAAQ,EAAE,CAAC,GAAG,CAAC,MAAM,EAAE,MAAM,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC,CAAC,KAAK;AAC/C,MAAM,CAAC;AACP,MAAM,IAAI,CAAC,YAAY,GAAG;AAC1B,IAAI;AACJ,IAAI,OAAO,IAAI,CAAC;AAChB,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,IAAI,UAAU,CAAC,GAAG;AACpB,IAAI,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,KAAK,CAAC,cAAc;AACzC,IAAI,IAAI,IAAI,CAAC,WAAW,IAAI,IAAI,EAAE;AAClC,MAAM,MAAM,EAAE,GAAG,cAAc,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK;AAC9C,MAAM,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,KAAK;AAC1D,QAAQ,MAAM,MAAM,GAAG,OAAO,CAAC,MAAM;AACrC,QAAQ,MAAM,CAAC,GAAG,MAAM,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC;AAC1C,QAAQ,EAAE,CAAC,GAAG,CAAC,MAAM,EAAE,CAAC,CAAC,KAAK,GAAG,CAAC,CAAC,GAAG;AACtC,MAAM,CAAC;AACP,MAAM,IAAI,CAAC,WAAW,GAAG;AACzB,IAAI;AACJ,IAAI,OAAO,IAAI,CAAC;AAChB,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACY,MAAC,iCAAiC,GAAG,CAAC,OAAO,EAAE,WAAW,KAAK;AAC3E,EAAE,IAAI,WAAW,CAAC,SAAS,CAAC,OAAO,CAAC,IAAI,KAAK,CAAC,IAAI,WAAW,CAAC,SAAS,CAAC,OAAO,CAAC,IAAI,KAAK,CAAC,EAAE;AAC5F,IAAI,OAAO;AACX,EAAE;AACF,EAAE,2BAA2B,CAAC,OAAO,EAAE,WAAW;AAClD,EAAE,UAAU,CAAC,OAAO,EAAE,WAAW,CAAC,SAAS;AAC3C,EAAE,OAAO;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,MAAM,GAAG,WAAW,IAAI;AACrC,EAAE,MAAM,CAAC,GAAG,WAAW,CAAC;AACxB,EAAE,OAAO,QAAQ,CAAC,CAAC,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC,CAAC,KAAK,EAAE,CAAC,CAAC,QAAQ,CAAC;AAC3D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,2BAA2B,GAAG,CAAC,WAAW,EAAE,IAAI,EAAE,SAAS,KAAK;AAC7E,EAAE,MAAM,IAAI,GAAG,IAAI,CAAC;AACpB,EAAE,IAAI,IAAI,KAAK,IAAI,KAAK,CAAC,IAAI,CAAC,OAAO,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,EAAE;AACjF,IAAI,GAAG,CAAC,cAAc,CAAC,WAAW,CAAC,OAAO,EAAE,IAAI,EAAE,GAAG,CAAC,MAAM,CAAC,CAAC,GAAG,CAAC,SAAS;AAC3E,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM,mBAAmB,GAAG,CAAC,OAAO,EAAE,GAAG,KAAK;AAC9C,EAAE,IAAI,KAAK,GAAG,OAAO,CAAC,GAAG;AACzB,EAAE,IAAI,IAAI,GAAG,OAAO,CAAC,GAAG,GAAG,CAAC;AAC5B,EAAE,IAAI,CAAC,GAAG;AACV,EAAE,OAAO,CAAC,GAAG,CAAC,EAAE,KAAK,GAAG,IAAI,EAAE,IAAI,GAAG,OAAO,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,EAAE;AACvD,IAAI,IAAI,IAAI,CAAC,OAAO,KAAK,KAAK,CAAC,OAAO,IAAI,IAAI,CAAC,WAAW,KAAK,KAAK,CAAC,WAAW,EAAE;AAClF,MAAM,IAAI,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,EAAE;AACjC,QAAQ,IAAI,KAAK,YAAY,IAAI,IAAI,KAAK,CAAC,SAAS,KAAK,IAAI,qCAAqC,CAAC,KAAK,CAAC,MAAM,EAAE,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,SAAS,CAAC,KAAK,KAAK,EAAE;AACtJ,2CAA2C,CAAC,KAAK,CAAC,MAAM,EAAE,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,SAAS,uBAAuB,IAAI;AAC7G,QAAQ;AACR,QAAQ;AACR,MAAM;AACN,IAAI;AACJ,IAAI;AACJ,EAAE;AACF,EAAE,MAAM,MAAM,GAAG,GAAG,GAAG;AACvB,EAAE,IAAI,MAAM,EAAE;AACd;AACA,IAAI,OAAO,CAAC,MAAM,CAAC,GAAG,GAAG,CAAC,GAAG,MAAM,EAAE,MAAM;AAC3C,EAAE;AACF,EAAE,OAAO;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM,cAAc,GAAG,CAAC,EAAE,EAAE,EAAE,EAAE,QAAQ,KAAK;AAC7C,EAAE,KAAK,MAAM,CAAC,MAAM,EAAE,YAAY,CAAC,IAAI,EAAE,CAAC,OAAO,CAAC,OAAO,EAAE,EAAE;AAC7D,IAAI,MAAM,WAAW,GAAG,YAAY,CAAC,MAAM;AAC3C,IAAI,MAAM,OAAO,kCAAkC,EAAE,CAAC,GAAG,CAAC,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC;AACnF,IAAI,KAAK,IAAI,EAAE,GAAG,WAAW,CAAC,MAAM,GAAG,CAAC,EAAE,EAAE,IAAI,CAAC,EAAE,EAAE,EAAE,EAAE;AACzD,MAAM,MAAM,UAAU,GAAG,WAAW,CAAC,EAAE;AACvC,MAAM,MAAM,kBAAkB,GAAG,UAAU,CAAC,KAAK,GAAG,UAAU,CAAC;AAC/D,MAAM;AACN,QAAQ,IAAI,EAAE,GAAG,WAAW,CAAC,OAAO,EAAE,UAAU,CAAC,KAAK,CAAC,EAAE,MAAM,GAAG,OAAO,CAAC,EAAE,CAAC;AAC7E,QAAQ,EAAE,GAAG,OAAO,CAAC,MAAM,IAAI,MAAM,CAAC,EAAE,CAAC,KAAK,GAAG,kBAAkB;AACnE,QAAQ,MAAM,GAAG,OAAO,CAAC,EAAE,EAAE;AAC7B,QAAQ;AACR,QAAQ,MAAM,MAAM,GAAG,OAAO,CAAC,EAAE;AACjC,QAAQ,IAAI,UAAU,CAAC,KAAK,GAAG,UAAU,CAAC,GAAG,IAAI,MAAM,CAAC,EAAE,CAAC,KAAK,EAAE;AAClE,UAAU;AACV,QAAQ;AACR,QAAQ,IAAI,MAAM,YAAY,IAAI,IAAI,MAAM,CAAC,OAAO,IAAI,CAAC,MAAM,CAAC,IAAI,IAAI,QAAQ,CAAC,MAAM,CAAC,EAAE;AAC1F,UAAU,MAAM,CAAC,EAAE,CAAC,EAAE,EAAE,KAAK;AAC7B,QAAQ;AACR,MAAM;AACN,IAAI;AACJ,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA,MAAM,QAAQ,GAAG,CAAC,EAAE,EAAE,KAAK,KAAK;AAChC;AACA;AACA,EAAE,EAAE,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,YAAY,EAAE,MAAM,KAAK;AAC/C,IAAI,MAAM,WAAW,GAAG,YAAY,CAAC,MAAM;AAC3C,IAAI,MAAM,OAAO,kCAAkC,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC;AAC5E,IAAI,KAAK,IAAI,EAAE,GAAG,WAAW,CAAC,MAAM,GAAG,CAAC,EAAE,EAAE,IAAI,CAAC,EAAE,EAAE,EAAE,EAAE;AACzD,MAAM,MAAM,UAAU,GAAG,WAAW,CAAC,EAAE;AACvC;AACA,MAAM,MAAM,qBAAqB,GAAG,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,GAAG,WAAW,CAAC,OAAO,EAAE,UAAU,CAAC,KAAK,GAAG,UAAU,CAAC,GAAG,GAAG,CAAC,CAAC;AAChI,MAAM;AACN,QAAQ,IAAI,EAAE,GAAG,qBAAqB,EAAE,MAAM,GAAG,OAAO,CAAC,EAAE,CAAC;AAC5D,QAAQ,EAAE,GAAG,CAAC,IAAI,MAAM,CAAC,EAAE,CAAC,KAAK,IAAI,UAAU,CAAC,KAAK;AACrD,QAAQ,MAAM,GAAG,OAAO,CAAC,EAAE;AAC3B,QAAQ;AACR,QAAQ,EAAE,IAAI,CAAC,GAAG,mBAAmB,CAAC,OAAO,EAAE,EAAE;AACjD,MAAM;AACN,IAAI;AACJ,EAAE,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA;AACY,MAAC,KAAK,GAAG,CAAC,EAAE,EAAE,KAAK,EAAE,QAAQ,KAAK;AAC9C,EAAE,cAAc,CAAC,EAAE,EAAE,KAAK,EAAE,QAAQ;AACpC,EAAE,QAAQ,CAAC,KAAK,EAAE,EAAE,CAAC,GAAG,CAAC,KAAK;AAC9B;;AAEA;AACA;AACA;AACA;AACA,MAAM,mBAAmB,GAAG,CAAC,mBAAmB,EAAE,CAAC,KAAK;AACxD,EAAE,IAAI,CAAC,GAAG,mBAAmB,CAAC,MAAM,EAAE;AACtC,IAAI,MAAM,WAAW,GAAG,mBAAmB,CAAC,CAAC;AAC7C,IAAI,WAAW,CAAC,KAAK,GAAG;AACxB,IAAI,MAAM,GAAG,GAAG,WAAW,CAAC;AAC5B,IAAI,MAAM,KAAK,GAAG,GAAG,CAAC;AACtB,IAAI,MAAM,EAAE,GAAG,WAAW,CAAC;AAC3B,IAAI,MAAM,YAAY,GAAG,WAAW,CAAC;AACrC;AACA,IAAI,IAAI;AACR,MAAM,GAAG,CAAC,IAAI,CAAC,qBAAqB,EAAE,CAAC,WAAW,EAAE,GAAG,CAAC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,MAAM,EAAE,GAAG;AACjB;AACA,MAAM,WAAW,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,QAAQ;AACjD,QAAQ,EAAE,CAAC,IAAI,CAAC,MAAM;AACtB,UAAU,IAAI,QAAQ,CAAC,KAAK,KAAK,IAAI,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,OAAO,EAAE;AAClE,YAAY,QAAQ,CAAC,aAAa,CAAC,WAAW,EAAE,IAAI;AACpD,UAAU;AACV,QAAQ,CAAC;AACT;AACA,MAAM,EAAE,CAAC,IAAI,CAAC,MAAM;AACpB;AACA,QAAQ,WAAW,CAAC,kBAAkB,CAAC,OAAO,CAAC,CAAC,MAAM,EAAE,IAAI,KAAK;AACjE;AACA;AACA,UAAU,IAAI,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,MAAM,GAAG,CAAC,KAAK,IAAI,CAAC,KAAK,KAAK,IAAI,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,EAAE;AACtF,YAAY,MAAM,GAAG;AACrB,eAAe,MAAM,CAAC,KAAK;AAC3B,gBAAgB,KAAK,CAAC,MAAM,CAAC,KAAK,KAAK,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC;AACnE;AACA,YAAY;AACZ,eAAe,OAAO,CAAC,KAAK,IAAI;AAChC,gBAAgB,KAAK,CAAC,aAAa,GAAG;AACtC;AACA,gBAAgB,KAAK,CAAC,KAAK,GAAG;AAC9B,cAAc,CAAC;AACf;AACA,YAAY;AACZ,eAAe,IAAI,CAAC,CAAC,MAAM,EAAE,MAAM,KAAK,MAAM,CAAC,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC,IAAI,CAAC,MAAM;AAC/E;AACA;AACA,YAAY,yBAAyB,CAAC,IAAI,CAAC,IAAI,EAAE,MAAM,EAAE,WAAW;AACpE,UAAU;AACV,QAAQ,CAAC;AACT,MAAM,CAAC;AACP,MAAM,EAAE,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,IAAI,CAAC,kBAAkB,EAAE,CAAC,WAAW,EAAE,GAAG,CAAC,CAAC;AACpE,MAAM,OAAO,CAAC,EAAE,EAAE,EAAE;AACpB,MAAM,IAAI,WAAW,CAAC,sBAAsB,IAAI,GAAG,CAAC,iBAAiB,EAAE;AACvE,QAAQ,4BAA4B,CAAC,WAAW;AAChD,MAAM;AACN,IAAI,CAAC,SAAS;AACd;AACA;AACA,MAAM,IAAI,GAAG,CAAC,EAAE,EAAE;AAClB,QAAQ,cAAc,CAAC,WAAW,EAAE,EAAE,EAAE,GAAG,CAAC,QAAQ;AACpD,MAAM;AACN,MAAM,QAAQ,CAAC,EAAE,EAAE,KAAK;;AAExB;AACA,MAAM,WAAW,CAAC,SAAS,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,GAAG,EAAE,MAAM,KAAK;AAC7D,QAAQ,MAAM,UAAU,GAAG,GAAG,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC,CAAC;AAC3C,QAAQ,MAAM,OAAO,kCAAkC,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC;AAChF;AACA,QAAQ,MAAM,cAAc,GAAG,IAAI,CAAC,GAAG,CAAC,WAAW,CAAC,OAAO,EAAE,UAAU,CAAC,EAAE,CAAC;AAC3E,QAAQ,KAAK,IAAI,CAAC,GAAG,OAAO,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,cAAc,GAAG;AAC/D,UAAU,CAAC,IAAI,CAAC,GAAG,mBAAmB,CAAC,OAAO,EAAE,CAAC;AACjD,QAAQ;AACR,MAAM,CAAC;AACP;AACA;AACA;AACA,MAAM,KAAK,IAAI,CAAC,GAAG,YAAY,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE;AACzD,QAAQ,MAAM,EAAE,MAAM,EAAE,KAAK,EAAE,GAAG,YAAY,CAAC,CAAC,CAAC,CAAC;AAClD,QAAQ,MAAM,OAAO,kCAAkC,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC;AAChF,QAAQ,MAAM,iBAAiB,GAAG,WAAW,CAAC,OAAO,EAAE,KAAK;AAC5D,QAAQ,IAAI,iBAAiB,GAAG,CAAC,GAAG,OAAO,CAAC,MAAM,EAAE;AACpD,UAAU,IAAI,mBAAmB,CAAC,OAAO,EAAE,iBAAiB,GAAG,CAAC,CAAC,GAAG,CAAC,EAAE;AACvE,YAAY,QAAQ;AACpB,UAAU;AACV,QAAQ;AACR,QAAQ,IAAI,iBAAiB,GAAG,CAAC,EAAE;AACnC,UAAU,mBAAmB,CAAC,OAAO,EAAE,iBAAiB;AACxD,QAAQ;AACR,MAAM;AACN,MAAM,IAAI,CAAC,WAAW,CAAC,KAAK,IAAI,WAAW,CAAC,SAAS,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE;AACjF,QAAQ,OAAO,CAAC,KAAK,CAAC,OAAO,CAAC,MAAM,EAAE,OAAO,CAAC,IAAI,EAAE,QAAQ,EAAE,OAAO,CAAC,MAAM,EAAE,OAAO,CAAC,GAAG,EAAE,oEAAoE;AAC/J,QAAQ,GAAG,CAAC,QAAQ,GAAG,mBAAmB;AAC1C,MAAM;AACN;AACA,MAAM,GAAG,CAAC,IAAI,CAAC,yBAAyB,EAAE,CAAC,WAAW,EAAE,GAAG,CAAC;AAC5D,MAAM,IAAI,GAAG,CAAC,UAAU,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE;AACxC,QAAQ,MAAM,OAAO,GAAG,IAAI,eAAe;AAC3C,QAAQ,MAAM,UAAU,GAAG,iCAAiC,CAAC,OAAO,EAAE,WAAW;AACjF,QAAQ,IAAI,UAAU,EAAE;AACxB,UAAU,GAAG,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC,OAAO,CAAC,YAAY,EAAE,EAAE,WAAW,CAAC,MAAM,EAAE,GAAG,EAAE,WAAW,CAAC;AAC3F,QAAQ;AACR,MAAM;AACN,MAAM,IAAI,GAAG,CAAC,UAAU,CAAC,GAAG,CAAC,UAAU,CAAC,EAAE;AAC1C,QAAQ,MAAM,OAAO,GAAG,IAAI,eAAe;AAC3C,QAAQ,MAAM,UAAU,GAAG,iCAAiC,CAAC,OAAO,EAAE,WAAW;AACjF,QAAQ,IAAI,UAAU,EAAE;AACxB,UAAU,GAAG,CAAC,IAAI,CAAC,UAAU,EAAE,CAAC,OAAO,CAAC,YAAY,EAAE,EAAE,WAAW,CAAC,MAAM,EAAE,GAAG,EAAE,WAAW,CAAC;AAC7F,QAAQ;AACR,MAAM;AACN,MAAM,MAAM,EAAE,YAAY,EAAE,aAAa,EAAE,cAAc,EAAE,GAAG;AAC9D,MAAM,IAAI,YAAY,CAAC,IAAI,GAAG,CAAC,IAAI,cAAc,CAAC,IAAI,GAAG,CAAC,IAAI,aAAa,CAAC,IAAI,GAAG,CAAC,EAAE;AACtF,QAAQ,YAAY,CAAC,OAAO,CAAC,MAAM,IAAI;AACvC,UAAU,MAAM,CAAC,QAAQ,GAAG,GAAG,CAAC;AAChC,UAAU,IAAI,MAAM,CAAC,YAAY,IAAI,IAAI,EAAE;AAC3C,YAAY,MAAM,CAAC,YAAY,GAAG,GAAG,CAAC;AACtC,UAAU;AACV,UAAU,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM;AAChC,QAAQ,CAAC;AACT,QAAQ,cAAc,CAAC,OAAO,CAAC,MAAM,IAAI,GAAG,CAAC,OAAO,CAAC,MAAM,CAAC,MAAM,CAAC;AACnE,QAAQ,GAAG,CAAC,IAAI,CAAC,SAAS,EAAE,CAAC,EAAE,MAAM,EAAE,aAAa,EAAE,KAAK,EAAE,YAAY,EAAE,OAAO,EAAE,cAAc,EAAE,EAAE,GAAG,EAAE,WAAW,CAAC;AACvH,QAAQ,cAAc,CAAC,OAAO,CAAC,MAAM,IAAI,MAAM,CAAC,OAAO,EAAE;AACzD,MAAM;;AAEN,MAAM,IAAI,mBAAmB,CAAC,MAAM,IAAI,CAAC,GAAG,CAAC,EAAE;AAC/C,QAAQ,GAAG,CAAC,oBAAoB,GAAG;AACnC,QAAQ,GAAG,CAAC,IAAI,CAAC,sBAAsB,EAAE,CAAC,GAAG,EAAE,mBAAmB,CAAC;AACnE,MAAM,CAAC,MAAM;AACb,QAAQ,mBAAmB,CAAC,mBAAmB,EAAE,CAAC,GAAG,CAAC;AACtD,MAAM;AACN,IAAI;AACJ,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,QAAQ,GAAG,CAAC,GAAG,EAAE,CAAC,EAAE,MAAM,GAAG,IAAI,EAAE,KAAK,GAAG,IAAI,KAAK;AACjE,EAAE,MAAM,mBAAmB,GAAG,GAAG,CAAC;AAClC,EAAE,IAAI,WAAW,GAAG;AACpB;AACA;AACA;AACA,EAAE,IAAI,MAAM,GAAG;AACf,EAAE,IAAI,GAAG,CAAC,YAAY,KAAK,IAAI,EAAE;AACjC,IAAI,WAAW,GAAG;AAClB,IAAI,GAAG,CAAC,YAAY,GAAG,IAAI,WAAW,CAAC,GAAG,EAAE,MAAM,EAAE,KAAK;AACzD,IAAI,mBAAmB,CAAC,IAAI,CAAC,GAAG,CAAC,YAAY;AAC7C,IAAI,IAAI,mBAAmB,CAAC,MAAM,KAAK,CAAC,EAAE;AAC1C,MAAM,GAAG,CAAC,IAAI,CAAC,uBAAuB,EAAE,CAAC,GAAG,CAAC;AAC7C,IAAI;AACJ,IAAI,GAAG,CAAC,IAAI,CAAC,mBAAmB,EAAE,CAAC,GAAG,CAAC,YAAY,EAAE,GAAG,CAAC;AACzD,EAAE;AACF,EAAE,IAAI;AACN,IAAI,MAAM,GAAG,CAAC,CAAC,GAAG,CAAC,YAAY;AAC/B,EAAE,CAAC,SAAS;AACZ,IAAI,IAAI,WAAW,EAAE;AACrB,MAAM,MAAM,aAAa,GAAG,GAAG,CAAC,YAAY,KAAK,mBAAmB,CAAC,CAAC;AACtE,MAAM,GAAG,CAAC,YAAY,GAAG;AACzB,MAAM,IAAI,aAAa,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mBAAmB,CAAC,mBAAmB,EAAE,CAAC;AAClD,MAAM;AACN,IAAI;AACJ,EAAE;AACF,EAAE,OAAO;AACT;;ACtdO,MAAM,SAAS,CAAC;AACvB;AACA;AACA;AACA;AACA,EAAE,WAAW,CAAC,CAAC,SAAS,EAAE,UAAU,EAAE;AACtC,IAAI,IAAI,CAAC,UAAU,GAAG;AACtB,IAAI,IAAI,CAAC,SAAS,GAAG;AACrB;AACA;AACA;AACA,IAAI,IAAI,CAAC,IAAI,GAAG,IAAI,GAAG;AACvB,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,yBAAyB,GAAG,CAAC,EAAE,EAAE,EAAE,EAAE,SAAS,KAAK;AACzD,EAAE,qBAAqB,CAAC,EAAE,EAAE,SAAS,CAAC,SAAS,EAAE,IAAI,IAAI;AACzD,IAAI,IAAI,IAAI,YAAY,IAAI,IAAI,EAAE,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,IAAI,IAAI,KAAK,EAAE,CAAC,GAAG,IAAI,UAAU,mDAAmD,IAAI,GAAG,IAAI,CAAC,CAAC,EAAE;AACrJ,MAAM,QAAQ,CAAC,IAAI,EAAE,KAAK;AAC1B,IAAI;AACJ,EAAE,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,YAAY,GAAG,CAAC,WAAW,EAAE,KAAK,EAAE,SAAS,KAAK;AACxD;AACA;AACA;AACA;AACA,EAAE,IAAI,GAAG,GAAG;AACZ,EAAE,MAAM,GAAG,GAAG,WAAW,CAAC;AAC1B,EAAE,MAAM,KAAK,GAAG,WAAW,CAAC;AAC5B,EAAE,QAAQ,CAAC,GAAG,EAAE,WAAW,IAAI;AAC/B,IAAI,OAAO,KAAK,CAAC,MAAM,GAAG,CAAC,IAAI,WAAW,CAAC,aAAa,KAAK,IAAI,EAAE;AACnE,MAAM,MAAM,KAAK,GAAG,GAAG,CAAC;AACxB,MAAM,MAAM,SAAS,6BAA6B,KAAK,CAAC,GAAG,EAAE;AAC7D;AACA;AACA;AACA,MAAM,MAAM,WAAW,GAAG,IAAI,GAAG;AACjC;AACA;AACA;AACA,MAAM,MAAM,aAAa,GAAG;AAC5B,MAAM,IAAI,eAAe,GAAG;AAC5B,MAAM,qBAAqB,CAAC,WAAW,EAAE,SAAS,CAAC,UAAU,EAAE,MAAM,IAAI;AACzE,QAAQ,IAAI,MAAM,YAAY,IAAI,EAAE;AACpC,UAAU,IAAI,MAAM,CAAC,MAAM,KAAK,IAAI,EAAE;AACtC,YAAY,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,GAAG,YAAY,CAAC,KAAK,EAAE,MAAM,CAAC,EAAE;AAC9D,YAAY,IAAI,IAAI,GAAG,CAAC,EAAE;AAC1B,cAAc,IAAI,GAAG,iBAAiB,CAAC,WAAW,EAAE,QAAQ,CAAC,IAAI,CAAC,EAAE,CAAC,MAAM,EAAE,IAAI,CAAC,EAAE,CAAC,KAAK,GAAG,IAAI,CAAC;AAClG,YAAY;AACZ,YAAY,MAAM,GAAG;AACrB,UAAU;AACV,UAAU,IAAI,CAAC,MAAM,CAAC,OAAO,IAAI,KAAK,CAAC,IAAI,CAAC,IAAI,IAAI,IAAI,KAAK,WAAW,CAAC,GAAG,IAAI,UAAU,mDAAmD,IAAI,wBAAwB,MAAM,EAAE,CAAC,EAAE;AACpL,YAAY,aAAa,CAAC,IAAI,CAAC,MAAM;AACrC,UAAU;AACV,QAAQ;AACR,MAAM,CAAC;AACP,MAAM,qBAAqB,CAAC,WAAW,EAAE,SAAS,CAAC,SAAS,EAAE,MAAM,IAAI;AACxE,QAAQ;AACR,UAAU,MAAM,YAAY,IAAI;AAChC,UAAU,KAAK,CAAC,IAAI,CAAC,IAAI,IAAI,IAAI,KAAK,WAAW,CAAC,GAAG,IAAI,UAAU,mDAAmD,IAAI,GAAG,MAAM,CAAC,CAAC;AACrI;AACA,UAAU,CAAC,SAAS,CAAC,UAAU,CAAC,KAAK,CAAC,MAAM,CAAC,EAAE;AAC/C,UAAU;AACV,UAAU,WAAW,CAAC,GAAG,CAAC,MAAM;AAChC,QAAQ;AACR,MAAM,CAAC;AACP,MAAM,WAAW,CAAC,OAAO,CAAC,MAAM,IAAI;AACpC,QAAQ,eAAe,GAAG,QAAQ,CAAC,WAAW,EAAE,MAAM,EAAE,WAAW,EAAE,SAAS,CAAC,UAAU,EAAE,WAAW,CAAC,sBAAsB,EAAE,WAAW,CAAC,KAAK,IAAI,IAAI;AACxJ,MAAM,CAAC;AACP;AACA;AACA,MAAM,KAAK,IAAI,CAAC,GAAG,aAAa,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE;AAC1D,QAAQ,MAAM,IAAI,GAAG,aAAa,CAAC,CAAC;AACpC,QAAQ,IAAI,WAAW,CAAC,YAAY,CAAC,IAAI,CAAC,EAAE;AAC5C,UAAU,IAAI,CAAC,MAAM,CAAC,WAAW;AACjC,UAAU,eAAe,GAAG;AAC5B,QAAQ;AACR,MAAM;AACN,MAAM,WAAW,CAAC,aAAa,GAAG,eAAe,GAAG,SAAS,GAAG;AAChE,IAAI;AACJ,IAAI,WAAW,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,QAAQ,EAAE,IAAI,KAAK;AACpD;AACA,MAAM,IAAI,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,aAAa,EAAE;AACpD,QAAQ,IAAI,CAAC,aAAa,CAAC,MAAM,GAAG;AACpC,MAAM;AACN,IAAI,CAAC;AACL,IAAI,GAAG,GAAG;AACV,EAAE,CAAC,EAAE,WAAW;AAChB,EAAE,MAAM,GAAG,GAAG,WAAW,CAAC;AAC1B,EAAE,IAAI,GAAG,IAAI,IAAI,EAAE;AACnB,IAAI,MAAM,kBAAkB,GAAG,GAAG,CAAC;AACnC,IAAI,WAAW,CAAC,IAAI,CAAC,mBAAmB,EAAE,CAAC,EAAE,SAAS,EAAE,GAAG,EAAE,IAAI,EAAE,SAAS,EAAE,kBAAkB,EAAE,MAAM,EAAE,WAAW,EAAE,EAAE,WAAW,CAAC;AACrI,IAAI,WAAW,CAAC,aAAa,GAAG;AAChC,EAAE;AACF,EAAE,OAAO;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,MAAM,WAAW,SAAS,YAAY,CAAC;AAC9C;AACA;AACA;AACA;AACA,EAAE,WAAW,CAAC,CAAC,SAAS,EAAE;AAC1B,IAAI,cAAc,GAAG,GAAG;AACxB,IAAI,kBAAkB,GAAG,GAAG,IAAI,IAAI;AACpC,IAAI,YAAY,GAAG,MAAM,IAAI;AAC7B,IAAI,cAAc,GAAG,IAAI,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC;AACpC,IAAI,sBAAsB,GAAG,KAAK;AAClC,IAAI,GAAG,uBAAuB,KAAK,CAAC,OAAO,CAAC,SAAS,CAAC,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG,SAAS,YAAY,GAAG,GAAG,SAAS,GAAG,SAAS,CAAC,GAAG;AAChI,GAAG,GAAG,EAAE,EAAE;AACV,IAAI,KAAK;AACT;AACA;AACA;AACA,IAAI,IAAI,CAAC,KAAK,GAAG;AACjB,IAAI,IAAI,CAAC,GAAG,GAAG;AACf,IAAI,IAAI,CAAC,UAAU,CAAC,SAAS;AAC7B,IAAI,IAAI,CAAC,YAAY,GAAG;AACxB,IAAI,cAAc,CAAC,GAAG,CAAC,IAAI;AAC3B,IAAI,IAAI,CAAC,cAAc,GAAG;AAC1B,IAAI,IAAI,CAAC,kBAAkB,GAAG;AAC9B;AACA;AACA;AACA,IAAI,IAAI,CAAC,SAAS,GAAG;AACrB;AACA;AACA;AACA,IAAI,IAAI,CAAC,SAAS,GAAG;AACrB;AACA;AACA;AACA;AACA;AACA,IAAI,IAAI,CAAC,OAAO,GAAG;AACnB,IAAI,IAAI,CAAC,OAAO,GAAG;AACnB;AACA;AACA;AACA;AACA;AACA,IAAI,IAAI,CAAC,aAAa,GAAG;AACzB,IAAI,IAAI,CAAC,UAAU,GAAG;AACtB,IAAI,IAAI,CAAC,sBAAsB,GAAG;AAClC,IAAI,IAAI,CAAC,cAAc,GAAG;AAC1B;AACA;AACA;AACA,IAAI,IAAI,CAAC,uBAAuB,GAAG,WAAW,IAAI;AAClD;AACA,MAAM;AACN,QAAQ,CAAC,IAAI,CAAC,kBAAkB,CAAC,WAAW,CAAC;AAC7C,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,IAAI,WAAW,CAAC,kBAAkB,CAAC,GAAG,mDAAmD,IAAI,EAAE,IAAI,IAAI,KAAK,IAAI,CAAC,GAAG,CAAC;AAClJ,SAAS,CAAC,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,WAAW,CAAC,MAAM,CAAC,KAAK,CAAC,WAAW,CAAC,MAAM,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,WAAW,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC;AAC1I,QAAQ;AACR,QAAQ;AACR,MAAM;AACN,MAAM,MAAM,OAAO,GAAG,IAAI,CAAC;AAC3B,MAAM,MAAM,OAAO,GAAG,IAAI,CAAC;AAC3B,MAAM,MAAM,KAAK,GAAG,OAAO,GAAG,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;AACpD,MAAM,IAAI,OAAO,EAAE;AACnB,QAAQ,IAAI,CAAC,aAAa,GAAE;AAC5B,MAAM,CAAC,MAAM,IAAI,CAAC,OAAO,EAAE;AAC3B;AACA,QAAQ,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE,IAAI;AAC9B,MAAM;AACN,MAAM,MAAM,UAAU,GAAG,WAAW,CAAC;AACrC,MAAM,MAAM,GAAG,GAAG,IAAI,CAAC,WAAW;AAClC,MAAM,IAAI,MAAM,GAAG;AACnB,MAAM,IAAI,IAAI,CAAC,UAAU,GAAG,CAAC,IAAI,GAAG,GAAG,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,cAAc,IAAI,KAAK,CAAC,MAAM,GAAG,CAAC,IAAI,CAAC,OAAO,IAAI,CAAC,OAAO,EAAE;AAC1H;AACA,QAAQ,MAAM,MAAM,GAAG,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC;AAC7C,QAAQ,MAAM,CAAC,SAAS,GAAG,WAAW,CAAC,CAAC,MAAM,CAAC,SAAS,EAAE,WAAW,CAAC,SAAS,CAAC;AAChF,QAAQ,MAAM,CAAC,UAAU,GAAG,WAAW,CAAC,CAAC,MAAM,CAAC,UAAU,EAAE,UAAU,CAAC;AACvE,MAAM,CAAC,MAAM;AACb;AACA,QAAQ,KAAK,CAAC,IAAI,CAAC,IAAI,SAAS,CAAC,WAAW,CAAC,SAAS,EAAE,UAAU,CAAC;AACnE,QAAQ,MAAM,GAAG;AACjB,MAAM;AACN,MAAM,IAAI,CAAC,OAAO,IAAI,CAAC,OAAO,EAAE;AAChC,QAAQ,IAAI,CAAC,UAAU,GAAG;AAC1B,MAAM;AACN;AACA,MAAM,qBAAqB,CAAC,WAAW,EAAE,WAAW,CAAC,SAAS,+BAA+B,IAAI,IAAI;AACrG,QAAQ,IAAI,IAAI,YAAY,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,IAAI,IAAI,KAAK,WAAW,CAAC,GAAG,IAAI,UAAU,mDAAmD,IAAI,GAAG,IAAI,CAAC,CAAC,EAAE;AACpK,UAAU,QAAQ,CAAC,IAAI,EAAE,IAAI;AAC7B,QAAQ;AACR,MAAM,CAAC;AACP;AACA;AACA;AACA,MAAM,MAAM,WAAW,GAAG,CAAC,EAAE,SAAS,EAAE,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,EAAE,MAAM,EAAE,WAAW,CAAC,MAAM,EAAE,IAAI,EAAE,OAAO,GAAG,MAAM,GAAG,MAAM,EAAE,kBAAkB,EAAE,WAAW,CAAC,kBAAkB,EAAE,EAAE,IAAI;AACxL,MAAM,IAAI,MAAM,EAAE;AAClB,QAAQ,IAAI,CAAC,IAAI,CAAC,kBAAkB,EAAE,WAAW;AACjD,MAAM,CAAC,MAAM;AACb,QAAQ,IAAI,CAAC,IAAI,CAAC,oBAAoB,EAAE,WAAW;AACnD,MAAM;AACN,IAAI;AACJ,IAAI,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,kBAAkB,EAAE,IAAI,CAAC,uBAAuB;AAChE,IAAI,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,SAAS,EAAE,MAAM;AACjC,MAAM,IAAI,CAAC,OAAO;AAClB,IAAI,CAAC;AACL,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE,UAAU,CAAC,CAAC,MAAM,EAAE;AACtB,IAAI,MAAM,MAAM,GAAG,IAAI,GAAG,CAAC,IAAI,CAAC,KAAK;AACrC,IAAI,MAAM,GAAG,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC,GAAG,MAAM,GAAG,CAAC,MAAM;AACrD,IAAI,MAAM,CAAC,OAAO,CAAC,KAAK,IAAI;AAC5B,MAAM,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE;AAC9B,QAAQ,MAAM,CAAC,GAAG,CAAC,KAAK;AACxB,QAAQ,IAAI,KAAK,YAAY,YAAY,GAAG,KAAK,CAAC,GAAG,KAAK,IAAI,CAAC,GAAG,GAAG,KAAK,KAAK,IAAI,CAAC,GAAG,EAAE,OAAO,CAAC,IAAI,CAAC,0BAA0B,EAAC;AACjI,QAAQ,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK;AAC7B,MAAM;AACN,IAAI,CAAC;AACL,EAAE;;AAEF;AACA;AACA;AACA,EAAE,gBAAgB,CAAC,CAAC,MAAM,EAAE;AAC5B,IAAI,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,MAAM;AAClC,EAAE;;AAEF;AACA;AACA;AACA,EAAE,mBAAmB,CAAC,CAAC,MAAM,EAAE;AAC/B,IAAI,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC,MAAM;AACrC,EAAE;;AAEF,EAAE,KAAK,CAAC,CAAC,cAAc,GAAG,IAAI,EAAE,cAAc,GAAG,IAAI,EAAE;AACvD,IAAI,IAAI,CAAC,cAAc,IAAI,IAAI,CAAC,OAAO,EAAE,MAAM,cAAc,IAAI,IAAI,CAAC,OAAO,EAAE,CAAC,EAAE;AAClF,MAAM,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE,IAAI;AAC9B,QAAQ,IAAI,cAAc,EAAE;AAC5B,UAAU,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,IAAI,IAAI,yBAAyB,CAAC,EAAE,EAAE,IAAI,EAAE,IAAI,CAAC;AAClF,UAAU,IAAI,CAAC,SAAS,GAAG;AAC3B,QAAQ;AACR,QAAQ,IAAI,cAAc,EAAE;AAC5B,UAAU,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,IAAI,IAAI,yBAAyB,CAAC,EAAE,EAAE,IAAI,EAAE,IAAI,CAAC;AAClF,UAAU,IAAI,CAAC,SAAS,GAAG;AAC3B,QAAQ;AACR,QAAQ,IAAI,CAAC,IAAI,CAAC,eAAe,EAAE,CAAC,EAAE,gBAAgB,EAAE,cAAc,EAAE,gBAAgB,EAAE,cAAc,EAAE,CAAC;AAC3G,MAAM,CAAC;AACP,IAAI;AACJ,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,aAAa,CAAC,GAAG;AACnB,IAAI,IAAI,CAAC,UAAU,GAAG;AACtB,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE,IAAI,CAAC,GAAG;AACV,IAAI,IAAI,CAAC,OAAO,GAAG;AACnB,IAAI,IAAI;AACR,IAAI,IAAI;AACR,MAAM,GAAG,GAAG,YAAY,CAAC,IAAI,EAAE,IAAI,CAAC,SAAS,EAAE,MAAM;AACrD,IAAI,CAAC,SAAS;AACd,MAAM,IAAI,CAAC,OAAO,GAAG;AACrB,IAAI;AACJ,IAAI,OAAO;AACX,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE,IAAI,CAAC,GAAG;AACV,IAAI,IAAI,CAAC,OAAO,GAAG;AACnB,IAAI,IAAI;AACR,IAAI,IAAI;AACR,MAAM,GAAG,GAAG,YAAY,CAAC,IAAI,EAAE,IAAI,CAAC,SAAS,EAAE,MAAM;AACrD,IAAI,CAAC,SAAS;AACd,MAAM,IAAI,CAAC,OAAO,GAAG;AACrB,IAAI;AACJ,IAAI,OAAO;AACX,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE,OAAO,CAAC,GAAG;AACb,IAAI,OAAO,IAAI,CAAC,SAAS,CAAC,MAAM,GAAG;AACnC,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE,OAAO,CAAC,GAAG;AACb,IAAI,OAAO,IAAI,CAAC,SAAS,CAAC,MAAM,GAAG;AACnC,EAAE;;AAEF,EAAE,OAAO,CAAC,GAAG;AACb,IAAI,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC,IAAI;AACnC,IAAI,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,kBAAkB,EAAE,IAAI,CAAC,uBAAuB;AACjE,IAAI,KAAK,CAAC,OAAO;AACjB,EAAE;AACF;;AC9VA;AACA;AACA;AACA,WAAW,yBAAyB,EAAE,OAAO,EAAE;AAC/C,EAAE,MAAM,iBAAiB,GAAG,QAAQ,CAAC,WAAW,CAAC,OAAO,CAAC,WAAW;AACpE,EAAE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,iBAAiB,EAAE,CAAC,EAAE,EAAE;AAC9C,IAAI,MAAM,eAAe,GAAG,QAAQ,CAAC,WAAW,CAAC,OAAO,CAAC,WAAW;AACpE,IAAI,MAAM,MAAM,GAAG,OAAO,CAAC,UAAU;AACrC,IAAI,IAAI,KAAK,GAAG,QAAQ,CAAC,WAAW,CAAC,OAAO,CAAC,WAAW;AACxD,IAAI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,eAAe,EAAE,CAAC,EAAE,EAAE;AAC9C,MAAM,MAAM,IAAI,GAAG,OAAO,CAAC,QAAQ;AACnC;AACA,MAAM,IAAI,IAAI,KAAK,EAAE,EAAE;AACvB,QAAQ,MAAM,GAAG,GAAG,QAAQ,CAAC,WAAW,CAAC,OAAO,CAAC,WAAW;AAC5D,QAAQ,MAAM,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE,KAAK,CAAC,EAAE,GAAG;AACnD,QAAQ,KAAK,IAAI;AACjB,MAAM,CAAC,MAAM,IAAI,CAAC,MAAM,CAAC,KAAK,GAAG,IAAI,MAAM,CAAC,EAAE;AAC9C,QAAQ,MAAM,kBAAkB,GAAG,CAAC,IAAI,IAAI,MAAM,CAAC,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC,MAAM;AAC5E;AACA;AACA;AACA;AACA,QAAQ,MAAM,MAAM,GAAG,IAAI,IAAI;AAC/B,UAAU,QAAQ,CAAC,MAAM,EAAE,KAAK,CAAC;AACjC,UAAU,IAAI;AACd,UAAU,CAAC,IAAI,GAAG,MAAM,CAAC,IAAI,MAAM,MAAM,CAAC,IAAI,GAAG,OAAO,CAAC,UAAU,EAAE,GAAG,IAAI;AAC5E,UAAU,IAAI;AACd,UAAU,CAAC,IAAI,GAAG,MAAM,CAAC,IAAI,MAAM,MAAM,CAAC,IAAI,GAAG,OAAO,CAAC,WAAW,EAAE,GAAG,IAAI;AAC7E;AACA,UAAU,kBAAkB,IAAI,OAAO,CAAC,cAAc,EAAE,GAAG,OAAO,CAAC,UAAU,EAAE,GAAG,OAAO,CAAC,UAAU,EAAE,IAAI,IAAI;AAC9G,UAAU,kBAAkB,IAAI,CAAC,IAAI,GAAG,MAAM,CAAC,IAAI,MAAM,MAAM,CAAC,IAAI,GAAG,OAAO,CAAC,UAAU,EAAE,GAAG,IAAI;AAClG,UAAU,eAAe,CAAC,OAAO,EAAE,IAAI,CAAC;AACxC;AACA,QAAQ,MAAM;AACd,QAAQ,KAAK,IAAI,MAAM,CAAC;AACxB,MAAM,CAAC,MAAM;AACb,QAAQ,MAAM,GAAG,GAAG,OAAO,CAAC,OAAO;AACnC,QAAQ,MAAM,IAAI,EAAE,CAAC,QAAQ,CAAC,MAAM,EAAE,KAAK,CAAC,EAAE,GAAG;AACjD,QAAQ,KAAK,IAAI;AACjB,MAAM;AACN,IAAI;AACJ,EAAE;AACF;;AAEO,MAAM,gBAAgB,CAAC;AAC9B;AACA;AACA;AACA;AACA,EAAE,WAAW,CAAC,CAAC,OAAO,EAAE,WAAW,EAAE;AACrC,IAAI,IAAI,CAAC,GAAG,GAAG,yBAAyB,CAAC,OAAO;AAChD;AACA;AACA;AACA,IAAI,IAAI,CAAC,IAAI,GAAG;AAChB,IAAI,IAAI,CAAC,IAAI,GAAG;AAChB,IAAI,IAAI,CAAC,WAAW,GAAG;AACvB,IAAI,IAAI,CAAC,IAAI;AACb,EAAE;;AAEF;AACA;AACA;AACA,EAAE,IAAI,CAAC,GAAG;AACV;AACA,IAAI,GAAG;AACP,MAAM,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,CAAC,KAAK,IAAI;AAC3C,IAAI,CAAC,QAAQ,IAAI,CAAC,WAAW,IAAI,IAAI,CAAC,IAAI,KAAK,IAAI,IAAI,IAAI,CAAC,IAAI,CAAC,WAAW,KAAK,IAAI;AACrF,IAAI,OAAO,IAAI,CAAC;AAChB,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACY,MAAC,SAAS,GAAG,MAAM,IAAI,WAAW,CAAC,MAAM,EAAE,eAAe;;AAEtE;AACA;AACA;AACA;AACY,MAAC,WAAW,GAAG,CAAC,MAAM,EAAE,QAAQ,GAAG,eAAe,KAAK;AACnE,EAAE,MAAM,OAAO,GAAG;AAClB,EAAE,MAAM,aAAa,GAAG,IAAI,QAAQ,CAAC,QAAQ,CAAC,aAAa,CAAC,MAAM,CAAC;AACnE,EAAE,MAAM,WAAW,GAAG,IAAI,gBAAgB,CAAC,aAAa,EAAE,KAAK;AAC/D,EAAE,KAAK,IAAI,IAAI,GAAG,WAAW,CAAC,IAAI,EAAE,IAAI,KAAK,IAAI,EAAE,IAAI,GAAG,WAAW,CAAC,IAAI,EAAE,EAAE;AAC9E,IAAI,OAAO,CAAC,IAAI,CAAC,IAAI;AACrB,EAAE;AACF,EAAE,OAAO,CAAC,KAAK,CAAC,WAAW,EAAE,OAAO;AACpC,EAAE,MAAM,EAAE,GAAG,SAAS,CAAC,aAAa;AACpC,EAAE,OAAO,CAAC,KAAK,CAAC,aAAa,EAAE,EAAE;AACjC;;AAEA;AACA;AACA;AACA;AACY,MAAC,YAAY,GAAG,CAAC,MAAM,KAAK,cAAc,CAAC,MAAM,EAAE,eAAe;;AAE9E;AACA;AACA;AACA;AACA;AACY,MAAC,cAAc,GAAG,CAAC,MAAM,EAAE,QAAQ,GAAG,eAAe,KAAK;AACtE,EAAE,MAAM,OAAO,GAAG;AAClB,EAAE,MAAM,aAAa,GAAG,IAAI,QAAQ,CAAC,QAAQ,CAAC,aAAa,CAAC,MAAM,CAAC;AACnE,EAAE,MAAM,WAAW,GAAG,IAAI,gBAAgB,CAAC,aAAa,EAAE,KAAK;AAC/D,EAAE,KAAK,IAAI,IAAI,GAAG,WAAW,CAAC,IAAI,EAAE,IAAI,KAAK,IAAI,EAAE,IAAI,GAAG,WAAW,CAAC,IAAI,EAAE,EAAE;AAC9E,IAAI,OAAO,CAAC,IAAI,CAAC,IAAI;AACrB,EAAE;AACF,EAAE,OAAO;AACT,IAAI,OAAO;AACX,IAAI,EAAE,EAAE,SAAS,CAAC,aAAa;AAC/B;AACA;;AAEO,MAAM,gBAAgB,CAAC;AAC9B;AACA;AACA;AACA,EAAE,WAAW,CAAC,CAAC,OAAO,EAAE;AACxB,IAAI,IAAI,CAAC,UAAU,GAAG;AACtB,IAAI,IAAI,CAAC,UAAU,GAAG;AACtB,IAAI,IAAI,CAAC,OAAO,GAAG;AACnB,IAAI,IAAI,CAAC,OAAO,GAAG;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,IAAI,CAAC,aAAa,GAAG;AACzB,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACY,MAAC,YAAY,GAAG,OAAO,IAAI,cAAc,CAAC,OAAO,EAAE,eAAe,EAAE,eAAe;;AAE/F;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,6BAA6B,GAAG,CAAC,MAAM,EAAE,QAAQ,GAAG,cAAc,EAAE,QAAQ,GAAG,eAAe,KAAK;AAChH,EAAE,MAAM,OAAO,GAAG,IAAI,QAAQ;AAC9B,EAAE,MAAM,aAAa,GAAG,IAAI,gBAAgB,CAAC,IAAI,QAAQ,CAAC,QAAQ,CAAC,aAAa,CAAC,MAAM,CAAC,CAAC,EAAE,KAAK;AAChG,EAAE,IAAI,IAAI,GAAG,aAAa,CAAC;AAC3B,EAAE,IAAI,IAAI,KAAK,IAAI,EAAE;AACrB,IAAI,IAAI,IAAI,GAAG;AACf,IAAI,IAAI,UAAU,GAAG,IAAI,CAAC,EAAE,CAAC;AAC7B,IAAI,IAAI,YAAY,GAAG,IAAI,CAAC,EAAE,CAAC,KAAK,KAAK,EAAC;AAC1C,IAAI,IAAI,SAAS,GAAG,YAAY,GAAG,CAAC,GAAG,IAAI,CAAC,EAAE,CAAC,KAAK,GAAG,IAAI,CAAC;AAC5D,IAAI,OAAO,IAAI,KAAK,IAAI,EAAE,IAAI,GAAG,aAAa,CAAC,IAAI,EAAE,EAAE;AACvD,MAAM,IAAI,UAAU,KAAK,IAAI,CAAC,EAAE,CAAC,MAAM,EAAE;AACzC,QAAQ,IAAI,SAAS,KAAK,CAAC,EAAE;AAC7B,UAAU,IAAI;AACd;AACA;AACA,UAAU,QAAQ,CAAC,YAAY,CAAC,OAAO,CAAC,WAAW,EAAE,UAAU;AAC/D,UAAU,QAAQ,CAAC,YAAY,CAAC,OAAO,CAAC,WAAW,EAAE,SAAS;AAC9D,QAAQ;AACR,QAAQ,UAAU,GAAG,IAAI,CAAC,EAAE,CAAC;AAC7B,QAAQ,SAAS,GAAG;AACpB,QAAQ,YAAY,GAAG,IAAI,CAAC,EAAE,CAAC,KAAK,KAAK;AACzC,MAAM;AACN;AACA,MAAM,IAAI,IAAI,CAAC,WAAW,KAAK,IAAI,EAAE;AACrC,QAAQ,YAAY,GAAG;AACvB,MAAM;AACN,MAAM,IAAI,CAAC,YAAY,EAAE;AACzB,QAAQ,SAAS,GAAG,IAAI,CAAC,EAAE,CAAC,KAAK,GAAG,IAAI,CAAC;AACzC,MAAM;AACN,IAAI;AACJ;AACA,IAAI,IAAI,SAAS,KAAK,CAAC,EAAE;AACzB,MAAM,IAAI;AACV,MAAM,QAAQ,CAAC,YAAY,CAAC,OAAO,CAAC,WAAW,EAAE,UAAU;AAC3D,MAAM,QAAQ,CAAC,YAAY,CAAC,OAAO,CAAC,WAAW,EAAE,SAAS;AAC1D,IAAI;AACJ;AACA,IAAI,MAAM,GAAG,GAAG,QAAQ,CAAC,aAAa;AACtC,IAAI,QAAQ,CAAC,YAAY,CAAC,GAAG,EAAE,IAAI;AACnC,IAAI,QAAQ,CAAC,kBAAkB,CAAC,GAAG,EAAE,OAAO,CAAC,WAAW;AACxD,IAAI,OAAO,CAAC,WAAW,GAAG;AAC1B,IAAI,OAAO,OAAO,CAAC,YAAY;AAC/B,EAAE,CAAC,MAAM;AACT,IAAI,QAAQ,CAAC,YAAY,CAAC,OAAO,CAAC,WAAW,EAAE,CAAC;AAChD,IAAI,OAAO,OAAO,CAAC,YAAY;AAC/B,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACY,MAAC,2BAA2B,GAAG,MAAM,IAAI,6BAA6B,CAAC,MAAM,EAAE,cAAc,EAAE,eAAe;;AAE1H;AACA;AACA;AACA;AACY,MAAC,oBAAoB,GAAG,CAAC,MAAM,EAAE,QAAQ,GAAG,eAAe,KAAK;AAC5E,EAAE,MAAM,aAAa,GAAG,IAAI,QAAQ,CAAC,QAAQ,CAAC,aAAa,CAAC,MAAM,CAAC;AACnE,EAAE,MAAM,WAAW,GAAG,IAAI,gBAAgB,CAAC,aAAa,EAAE,IAAI;AAC9D,EAAE,MAAM,OAAO,GAAG,WAAW;AAC7B,EAAE,IAAI,YAAY,GAAG;AACrB,EAAE,IAAI,SAAS,GAAG;AAClB,EAAE,IAAI,OAAO,GAAG;AAChB,EAAE,KAAK,IAAI,IAAI,GAAG,WAAW,CAAC,IAAI,EAAE,IAAI,KAAK,IAAI,EAAE,IAAI,GAAG,WAAW,CAAC,IAAI,EAAE,EAAE;AAC9E,IAAI,MAAM,MAAM,GAAG,IAAI,CAAC;AACxB,IAAI,IAAI,YAAY,KAAK,MAAM,CAAC,MAAM,IAAI,SAAS,GAAG,OAAO,KAAK,MAAM,CAAC,KAAK,EAAE;AAChF;AACA,MAAM,OAAO,IAAI,IAAI,CAAC;AACtB,IAAI,CAAC,MAAM;AACX,MAAM,IAAI,YAAY,IAAI,CAAC,EAAE;AAC7B,QAAQ,OAAO,CAAC,GAAG,CAAC,YAAY,EAAE,SAAS,EAAE,OAAO;AACpD,MAAM;AACN,MAAM,YAAY,GAAG,MAAM,CAAC;AAC5B,MAAM,SAAS,GAAG,MAAM,CAAC;AACzB,MAAM,OAAO,GAAG,IAAI,CAAC;AACrB,IAAI;AACJ,EAAE;AACF,EAAE,IAAI,YAAY,IAAI,CAAC,EAAE;AACzB,IAAI,OAAO,CAAC,GAAG,CAAC,YAAY,EAAE,SAAS,EAAE,OAAO;AAChD,EAAE;AACF,EAAE,MAAM,OAAO,GAAG,SAAS,CAAC,aAAa;AACzC,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO;AAC3B;;AAEA;AACA;AACA;AACY,MAAC,kBAAkB,GAAG,MAAM,IAAI,oBAAoB,CAAC,MAAM,EAAE,eAAe;;AAExF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,WAAW,GAAG,CAAC,IAAI,EAAE,IAAI,KAAK;AACpC,EAAE,IAAI,IAAI,CAAC,WAAW,KAAK,EAAE,EAAE;AAC/B,IAAI,MAAM,EAAE,MAAM,EAAE,KAAK,EAAE,GAAG,IAAI,CAAC;AACnC,IAAI,OAAO,IAAI,EAAE,CAAC,QAAQ,CAAC,MAAM,EAAE,KAAK,GAAG,IAAI,CAAC,EAAE,IAAI,CAAC,MAAM,GAAG,IAAI;AACpE,EAAE,CAAC,MAAM,IAAI,IAAI,CAAC,WAAW,KAAK,IAAI,EAAE;AACxC,IAAI,MAAM,EAAE,MAAM,EAAE,KAAK,EAAE,GAAG,IAAI,CAAC;AACnC,IAAI,OAAO,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE,KAAK,GAAG,IAAI,CAAC,EAAE,IAAI,CAAC,MAAM,GAAG,IAAI;AACtE,EAAE,CAAC,MAAM;AACT,IAAI,MAAM,QAAQ,wBAAwB,IAAI;AAC9C,IAAI,MAAM,EAAE,MAAM,EAAE,KAAK,EAAE,GAAG,QAAQ,CAAC;AACvC,IAAI,OAAO,IAAI,IAAI;AACnB,MAAM,QAAQ,CAAC,MAAM,EAAE,KAAK,GAAG,IAAI,CAAC;AACpC,MAAM,IAAI;AACV,MAAM,QAAQ,CAAC,MAAM,EAAE,KAAK,GAAG,IAAI,GAAG,CAAC,CAAC;AACxC,MAAM,IAAI;AACV,MAAM,QAAQ,CAAC,WAAW;AAC1B,MAAM,QAAQ,CAAC,MAAM;AACrB,MAAM,QAAQ,CAAC,SAAS;AACxB,MAAM,QAAQ,CAAC,OAAO,CAAC,MAAM,CAAC,IAAI;AAClC;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,cAAc,GAAG,CAAC,OAAO,EAAE,QAAQ,GAAG,eAAe,EAAE,QAAQ,GAAG,eAAe,KAAK;AACnG,EAAE,IAAI,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE;AAC5B,IAAI,OAAO,OAAO,CAAC,CAAC;AACpB,EAAE;AACF,EAAE,MAAM,cAAc,GAAG,OAAO,CAAC,GAAG,CAAC,MAAM,IAAI,IAAI,QAAQ,CAAC,QAAQ,CAAC,aAAa,CAAC,MAAM,CAAC,CAAC;AAC3F,EAAE,IAAI,kBAAkB,GAAG,cAAc,CAAC,GAAG,CAAC,OAAO,IAAI,IAAI,gBAAgB,CAAC,OAAO,EAAE,IAAI,CAAC;;AAE5F;AACA;AACA;AACA;AACA,EAAE,IAAI,SAAS,GAAG;;AAElB,EAAE,MAAM,aAAa,GAAG,IAAI,QAAQ;AACpC;AACA,EAAE,MAAM,iBAAiB,GAAG,IAAI,gBAAgB,CAAC,aAAa;;AAE9D;AACA;AACA;;AAEA,EAAE,OAAO,IAAI,EAAE;AACf;AACA,IAAI,kBAAkB,GAAG,kBAAkB,CAAC,MAAM,CAAC,GAAG,IAAI,GAAG,CAAC,IAAI,KAAK,IAAI;AAC3E,IAAI,kBAAkB,CAAC,IAAI;AAC3B,8CAA8C,CAAC,IAAI,EAAE,IAAI,KAAK;AAC9D,QAAQ,IAAI,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,MAAM,KAAK,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,MAAM,EAAE;AACzD,UAAU,MAAM,SAAS,GAAG,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,KAAK,GAAG,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC;AAC9D,UAAU,IAAI,SAAS,KAAK,CAAC,EAAE;AAC/B;AACA,YAAY,OAAO,IAAI,CAAC,IAAI,CAAC,WAAW,KAAK,IAAI,CAAC,IAAI,CAAC;AACvD,gBAAgB;AAChB,gBAAgB,IAAI,CAAC,IAAI,CAAC,WAAW,KAAK,IAAI,GAAG,CAAC,GAAG,EAAE;AACvD,UAAU,CAAC,MAAM;AACjB,YAAY,OAAO;AACnB,UAAU;AACV,QAAQ,CAAC,MAAM;AACf,UAAU,OAAO,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,MAAM,GAAG,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC;AACpD,QAAQ;AACR,MAAM;AACN;AACA,IAAI,IAAI,kBAAkB,CAAC,MAAM,KAAK,CAAC,EAAE;AACzC,MAAM;AACN,IAAI;AACJ,IAAI,MAAM,WAAW,GAAG,kBAAkB,CAAC,CAAC;AAC5C;AACA;AACA,IAAI,MAAM,WAAW,4BAA4B,CAAC,WAAW,CAAC,IAAI,EAAE,EAAE,CAAC;;AAEvE,IAAI,IAAI,SAAS,KAAK,IAAI,EAAE;AAC5B,MAAM,IAAI,IAAI,oCAAoC,WAAW,CAAC,IAAI;AAClE,MAAM,IAAI,QAAQ,GAAG;;AAErB;AACA;AACA,MAAM,OAAO,IAAI,KAAK,IAAI,IAAI,IAAI,CAAC,EAAE,CAAC,KAAK,GAAG,IAAI,CAAC,MAAM,IAAI,SAAS,CAAC,MAAM,CAAC,EAAE,CAAC,KAAK,GAAG,SAAS,CAAC,MAAM,CAAC,MAAM,IAAI,IAAI,CAAC,EAAE,CAAC,MAAM,IAAI,SAAS,CAAC,MAAM,CAAC,EAAE,CAAC,MAAM,EAAE;AAClK,QAAQ,IAAI,GAAG,WAAW,CAAC,IAAI;AAC/B,QAAQ,QAAQ,GAAG;AACnB,MAAM;AACN,MAAM;AACN,QAAQ,IAAI,KAAK,IAAI;AACrB,QAAQ,IAAI,CAAC,EAAE,CAAC,MAAM,KAAK,WAAW;AACtC,SAAS,QAAQ,IAAI,IAAI,CAAC,EAAE,CAAC,KAAK,GAAG,SAAS,CAAC,MAAM,CAAC,EAAE,CAAC,KAAK,GAAG,SAAS,CAAC,MAAM,CAAC,MAAM,CAAC;AACzF,QAAQ;AACR,QAAQ;AACR,MAAM;;AAEN,MAAM,IAAI,WAAW,KAAK,SAAS,CAAC,MAAM,CAAC,EAAE,CAAC,MAAM,EAAE;AACtD,QAAQ,6BAA6B,CAAC,iBAAiB,EAAE,SAAS,CAAC,MAAM,EAAE,SAAS,CAAC,MAAM;AAC3F,QAAQ,SAAS,GAAG,EAAE,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,CAAC;AAC7C,QAAQ,WAAW,CAAC,IAAI;AACxB,MAAM,CAAC,MAAM;AACb,QAAQ,IAAI,SAAS,CAAC,MAAM,CAAC,EAAE,CAAC,KAAK,GAAG,SAAS,CAAC,MAAM,CAAC,MAAM,GAAG,IAAI,CAAC,EAAE,CAAC,KAAK,EAAE;AACjF;AACA,UAAU,IAAI,SAAS,CAAC,MAAM,CAAC,WAAW,KAAK,IAAI,EAAE;AACrD;AACA,YAAY,SAAS,CAAC,MAAM,CAAC,MAAM,GAAG,IAAI,CAAC,EAAE,CAAC,KAAK,GAAG,IAAI,CAAC,MAAM,GAAG,SAAS,CAAC,MAAM,CAAC,EAAE,CAAC;AACxF,UAAU,CAAC,MAAM;AACjB,YAAY,6BAA6B,CAAC,iBAAiB,EAAE,SAAS,CAAC,MAAM,EAAE,SAAS,CAAC,MAAM;AAC/F,YAAY,MAAM,IAAI,GAAG,IAAI,CAAC,EAAE,CAAC,KAAK,GAAG,SAAS,CAAC,MAAM,CAAC,EAAE,CAAC,KAAK,GAAG,SAAS,CAAC,MAAM,CAAC;AACtF;AACA;AACA;AACA,YAAY,MAAM,MAAM,GAAG,IAAI,IAAI,CAAC,QAAQ,CAAC,WAAW,EAAE,SAAS,CAAC,MAAM,CAAC,EAAE,CAAC,KAAK,GAAG,SAAS,CAAC,MAAM,CAAC,MAAM,CAAC,EAAE,IAAI;AACpH,YAAY,SAAS,GAAG,EAAE,MAAM,EAAE,MAAM,EAAE,CAAC;AAC3C,UAAU;AACV,QAAQ,CAAC,MAAM;AACf,UAAU,MAAM,IAAI,GAAG,SAAS,CAAC,MAAM,CAAC,EAAE,CAAC,KAAK,GAAG,SAAS,CAAC,MAAM,CAAC,MAAM,GAAG,IAAI,CAAC,EAAE,CAAC;AACrF,UAAU,IAAI,IAAI,GAAG,CAAC,EAAE;AACxB,YAAY,IAAI,SAAS,CAAC,MAAM,CAAC,WAAW,KAAK,IAAI,EAAE;AACvD;AACA,cAAc,SAAS,CAAC,MAAM,CAAC,MAAM,IAAI;AACzC,YAAY,CAAC,MAAM;AACnB,cAAc,IAAI,GAAG,WAAW,CAAC,IAAI,EAAE,IAAI;AAC3C,YAAY;AACZ,UAAU;AACV,UAAU,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,SAAS,qBAAqB,IAAI,EAAE,EAAE;AACtE,YAAY,6BAA6B,CAAC,iBAAiB,EAAE,SAAS,CAAC,MAAM,EAAE,SAAS,CAAC,MAAM;AAC/F,YAAY,SAAS,GAAG,EAAE,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,CAAC;AACjD,YAAY,WAAW,CAAC,IAAI;AAC5B,UAAU;AACV,QAAQ;AACR,MAAM;AACN,IAAI,CAAC,MAAM;AACX,MAAM,SAAS,GAAG,EAAE,MAAM,4BAA4B,WAAW,CAAC,IAAI,CAAC,EAAE,MAAM,EAAE,CAAC;AAClF,MAAM,WAAW,CAAC,IAAI;AACtB,IAAI;AACJ,IAAI;AACJ,MAAM,IAAI,IAAI,GAAG,WAAW,CAAC,IAAI;AACjC,MAAM,IAAI,KAAK,IAAI,IAAI,IAAI,CAAC,EAAE,CAAC,MAAM,KAAK,WAAW,IAAI,IAAI,CAAC,EAAE,CAAC,KAAK,KAAK,SAAS,CAAC,MAAM,CAAC,EAAE,CAAC,KAAK,GAAG,SAAS,CAAC,MAAM,CAAC,MAAM,IAAI,IAAI,CAAC,WAAW,KAAK,IAAI;AAC3J,MAAM,IAAI,GAAG,WAAW,CAAC,IAAI;AAC7B,MAAM;AACN,MAAM,6BAA6B,CAAC,iBAAiB,EAAE,SAAS,CAAC,MAAM,EAAE,SAAS,CAAC,MAAM;AACzF,MAAM,SAAS,GAAG,EAAE,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,CAAC;AAC3C,IAAI;AACJ,EAAE;AACF,EAAE,IAAI,SAAS,KAAK,IAAI,EAAE;AAC1B,IAAI,6BAA6B,CAAC,iBAAiB,EAAE,SAAS,CAAC,MAAM,EAAE,SAAS,CAAC,MAAM;AACvF,IAAI,SAAS,GAAG;AAChB,EAAE;AACF,EAAE,uBAAuB,CAAC,iBAAiB;;AAE3C,EAAE,MAAM,GAAG,GAAG,cAAc,CAAC,GAAG,CAAC,OAAO,IAAI,SAAS,CAAC,OAAO,CAAC;AAC9D,EAAE,MAAM,EAAE,GAAG,WAAW,CAAC,GAAG;AAC5B,EAAE,UAAU,CAAC,aAAa,EAAE,EAAE;AAC9B,EAAE,OAAO,aAAa,CAAC,YAAY;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,YAAY,GAAG,CAAC,MAAM,EAAE,EAAE,EAAE,QAAQ,GAAG,eAAe,EAAE,QAAQ,GAAG,eAAe,KAAK;AACpG,EAAE,MAAM,KAAK,GAAG,iBAAiB,CAAC,EAAE;AACpC,EAAE,MAAM,OAAO,GAAG,IAAI,QAAQ;AAC9B,EAAE,MAAM,gBAAgB,GAAG,IAAI,gBAAgB,CAAC,OAAO;AACvD,EAAE,MAAM,OAAO,GAAG,IAAI,QAAQ,CAAC,QAAQ,CAAC,aAAa,CAAC,MAAM,CAAC;AAC7D,EAAE,MAAM,MAAM,GAAG,IAAI,gBAAgB,CAAC,OAAO,EAAE,KAAK;AACpD,EAAE,OAAO,MAAM,CAAC,IAAI,EAAE;AACtB,IAAI,MAAM,IAAI,GAAG,MAAM,CAAC;AACxB,IAAI,MAAM,UAAU,GAAG,IAAI,CAAC,EAAE,CAAC;AAC/B,IAAI,MAAM,OAAO,GAAG,KAAK,CAAC,GAAG,CAAC,UAAU,CAAC,IAAI;AAC7C,IAAI,IAAI,MAAM,CAAC,IAAI,CAAC,WAAW,KAAK,IAAI,EAAE;AAC1C;AACA,MAAM,MAAM,CAAC,IAAI;AACjB,MAAM;AACN,IAAI;AACJ,IAAI,IAAI,IAAI,CAAC,EAAE,CAAC,KAAK,GAAG,IAAI,CAAC,MAAM,GAAG,OAAO,EAAE;AAC/C,MAAM,6BAA6B,CAAC,gBAAgB,EAAE,IAAI,EAAE,IAAI,CAAC,GAAG,CAAC,OAAO,GAAG,IAAI,CAAC,EAAE,CAAC,KAAK,EAAE,CAAC,CAAC;AAChG,MAAM,MAAM,CAAC,IAAI;AACjB,MAAM,OAAO,MAAM,CAAC,IAAI,IAAI,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,MAAM,KAAK,UAAU,EAAE;AAClE,QAAQ,6BAA6B,CAAC,gBAAgB,EAAE,MAAM,CAAC,IAAI,EAAE,CAAC;AACtE,QAAQ,MAAM,CAAC,IAAI;AACnB,MAAM;AACN,IAAI,CAAC,MAAM;AACX;AACA,MAAM,OAAO,MAAM,CAAC,IAAI,IAAI,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,MAAM,KAAK,UAAU,IAAI,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,KAAK,GAAG,MAAM,CAAC,IAAI,CAAC,MAAM,IAAI,OAAO,EAAE;AAC1H,QAAQ,MAAM,CAAC,IAAI;AACnB,MAAM;AACN,IAAI;AACJ,EAAE;AACF,EAAE,uBAAuB,CAAC,gBAAgB;AAC1C;AACA,EAAE,MAAM,EAAE,GAAG,SAAS,CAAC,OAAO;AAC9B,EAAE,UAAU,CAAC,OAAO,EAAE,EAAE;AACxB,EAAE,OAAO,OAAO,CAAC,YAAY;AAC7B;;AAEA;AACA;AACA;AACA;AACY,MAAC,UAAU,GAAG,CAAC,MAAM,EAAE,EAAE,KAAK,YAAY,CAAC,MAAM,EAAE,EAAE,EAAE,eAAe,EAAE,eAAe;;AAEnG;AACA;AACA;AACA,MAAM,qBAAqB,GAAG,UAAU,IAAI;AAC5C,EAAE,IAAI,UAAU,CAAC,OAAO,GAAG,CAAC,EAAE;AAC9B,IAAI,UAAU,CAAC,aAAa,CAAC,IAAI,CAAC,EAAE,OAAO,EAAE,UAAU,CAAC,OAAO,EAAE,WAAW,EAAE,QAAQ,CAAC,YAAY,CAAC,UAAU,CAAC,OAAO,CAAC,WAAW,CAAC,EAAE;AACrI,IAAI,UAAU,CAAC,OAAO,CAAC,WAAW,GAAG,QAAQ,CAAC,aAAa;AAC3D,IAAI,UAAU,CAAC,OAAO,GAAG;AACzB,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM,6BAA6B,GAAG,CAAC,UAAU,EAAE,MAAM,EAAE,MAAM,KAAK;AACtE;AACA,EAAE,IAAI,UAAU,CAAC,OAAO,GAAG,CAAC,IAAI,UAAU,CAAC,UAAU,KAAK,MAAM,CAAC,EAAE,CAAC,MAAM,EAAE;AAC5E,IAAI,qBAAqB,CAAC,UAAU;AACpC,EAAE;AACF,EAAE,IAAI,UAAU,CAAC,OAAO,KAAK,CAAC,EAAE;AAChC,IAAI,UAAU,CAAC,UAAU,GAAG,MAAM,CAAC,EAAE,CAAC;AACtC;AACA,IAAI,UAAU,CAAC,OAAO,CAAC,WAAW,CAAC,MAAM,CAAC,EAAE,CAAC,MAAM;AACnD;AACA,IAAI,QAAQ,CAAC,YAAY,CAAC,UAAU,CAAC,OAAO,CAAC,WAAW,EAAE,MAAM,CAAC,EAAE,CAAC,KAAK,GAAG,MAAM;AAClF,EAAE;AACF,EAAE,MAAM,CAAC,KAAK,CAAC,UAAU,CAAC,OAAO,EAAE,MAAM,EAAE,CAAC;AAC5C,EAAE,UAAU,CAAC,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,uBAAuB,GAAG,CAAC,UAAU,KAAK;AAChD,EAAE,qBAAqB,CAAC,UAAU;;AAElC;AACA,EAAE,MAAM,WAAW,GAAG,UAAU,CAAC,OAAO,CAAC;;AAEzC;AACA;AACA;AACA;;AAEA;AACA,EAAE,QAAQ,CAAC,YAAY,CAAC,WAAW,EAAE,UAAU,CAAC,aAAa,CAAC,MAAM;;AAEpE,EAAE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,UAAU,CAAC,aAAa,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AAC5D,IAAI,MAAM,WAAW,GAAG,UAAU,CAAC,aAAa,CAAC,CAAC;AAClD;AACA;AACA;AACA;AACA,IAAI,QAAQ,CAAC,YAAY,CAAC,WAAW,EAAE,WAAW,CAAC,OAAO;AAC1D;AACA,IAAI,QAAQ,CAAC,eAAe,CAAC,WAAW,EAAE,WAAW,CAAC,WAAW;AACjE,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,mBAAmB,GAAG,CAAC,MAAM,EAAE,gBAAgB,EAAE,QAAQ,EAAE,QAAQ,KAAK;AACrF,EAAE,MAAM,aAAa,GAAG,IAAI,QAAQ,CAAC,QAAQ,CAAC,aAAa,CAAC,MAAM,CAAC;AACnE,EAAE,MAAM,WAAW,GAAG,IAAI,gBAAgB,CAAC,aAAa,EAAE,KAAK;AAC/D,EAAE,MAAM,aAAa,GAAG,IAAI,QAAQ;AACpC,EAAE,MAAM,UAAU,GAAG,IAAI,gBAAgB,CAAC,aAAa;AACvD,EAAE,KAAK,IAAI,IAAI,GAAG,WAAW,CAAC,IAAI,EAAE,IAAI,KAAK,IAAI,EAAE,IAAI,GAAG,WAAW,CAAC,IAAI,EAAE,EAAE;AAC9E,IAAI,6BAA6B,CAAC,UAAU,EAAE,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;AACvE,EAAE;AACF,EAAE,uBAAuB,CAAC,UAAU;AACpC,EAAE,MAAM,EAAE,GAAG,SAAS,CAAC,aAAa;AACpC,EAAE,UAAU,CAAC,aAAa,EAAE,EAAE;AAC9B,EAAE,OAAO,aAAa,CAAC,YAAY;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM,gBAAgB,GAAG,CAAC,EAAE,UAAU,GAAG,IAAI,EAAE,OAAO,GAAG,IAAI,EAAE,IAAI,GAAG,IAAI,EAAE,GAAG,EAAE,KAAK;AACtF,EAAE,IAAI,CAAC,GAAG;AACV,EAAE,MAAM,WAAW,GAAG,GAAG,CAAC,MAAM;AAChC,EAAE,MAAM,aAAa,GAAG,GAAG,CAAC,MAAM;AAClC,EAAE,MAAM,kBAAkB,GAAG,GAAG,CAAC,MAAM;AACvC,EAAE,MAAM,oBAAoB,GAAG,GAAG,CAAC,MAAM;AACzC,EAAE,oBAAoB,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,EAAC;AACtC;AACA;AACA;AACA;AACA,EAAE,OAAO,KAAK,IAAI;AAClB,IAAI,QAAQ,KAAK,CAAC,WAAW;AAC7B,MAAM,KAAK,EAAE;AACb,MAAM,KAAK,IAAI;AACf,QAAQ,OAAO;AACf,MAAM,KAAK,IAAI,EAAE;AACjB,QAAQ,MAAM,IAAI,wBAAwB,KAAK;AAC/C,QAAQ,MAAM,OAAO,GAAG,IAAI,CAAC;AAC7B,QAAQ,QAAQ,OAAO,CAAC,WAAW;AACnC,UAAU,KAAK,cAAc;AAC7B,YAAY;AACZ,UAAU,KAAK,WAAW,EAAE;AAC5B,YAAY,IAAI,IAAI,EAAE;AACtB,cAAc,MAAM,IAAI,8BAA8B,CAAC,OAAO,EAAE;AAChE,cAAc,IAAI,IAAI,YAAY,WAAW,EAAE;AAC/C,gBAAgB,IAAI,CAAC,QAAQ,GAAG,GAAG,CAAC,cAAc,CAAC,aAAa,EAAE,IAAI,CAAC,QAAQ,EAAE,MAAM,OAAO,GAAG,CAAC;AAClG,cAAc;AACd;AACA,cAAc,IAAI,IAAI,YAAY,QAAQ,EAAE;AAC5C,gBAAgB,IAAI,CAAC,QAAQ,GAAG,GAAG,CAAC,cAAc,CAAC,aAAa,EAAE,IAAI,CAAC,QAAQ,EAAE,MAAM,OAAO,GAAG,CAAC;AAClG,cAAc;AACd,YAAY;AACZ,YAAY;AACZ,UAAU;AACV,UAAU,KAAK,UAAU,EAAE;AAC3B,YAAY,MAAM,CAAC,8BAA8B,OAAO;AACxD,YAAY,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,MAAM,CAAC;AACrC,YAAY;AACZ,UAAU;AACV,UAAU,KAAK,aAAa,EAAE;AAC9B,YAAY,MAAM,CAAC,iCAAiC,OAAO;AAC3D,YAAY,CAAC,CAAC,OAAO,GAAG,IAAI,UAAU,CAAC,CAAC,CAAC,CAAC;AAC1C,YAAY;AACZ,UAAU;AACV,UAAU,KAAK,UAAU,EAAE;AAC3B,YAAY,MAAM,CAAC,8BAA8B,OAAO;AACxD,YAAY,IAAI,OAAO,EAAE;AACzB,cAAc,CAAC,CAAC,IAAI,GAAG;AACvB,cAAc,CAAC,CAAC,GAAG,CAAC,IAAI,GAAG,CAAC,GAAG;AAC/B,YAAY;AACZ,YAAY;AACZ,UAAU;AACV,UAAU,KAAK,YAAY,EAAE;AAC7B,YAAY,MAAM,CAAC,gCAAgC,OAAO;AAC1D,YAAY,CAAC,CAAC,KAAK,GAAG;AACtB,YAAY;AACZ,UAAU;AACV,UAAU,KAAK,aAAa,EAAE;AAC9B,YAAY,MAAM,CAAC,iCAAiC,OAAO;AAC3D,YAAY,IAAI,UAAU,EAAE;AAC5B,cAAc,CAAC,CAAC,GAAG,GAAG,GAAG,CAAC,cAAc,CAAC,kBAAkB,EAAE,CAAC,CAAC,GAAG,EAAE,MAAM,CAAC,GAAG,EAAE;AAChF,cAAc,CAAC,CAAC,KAAK,GAAG,GAAG,CAAC,cAAc,CAAC,oBAAoB,EAAE,CAAC,CAAC,KAAK,EAAE,OAAO,EAAE,CAAC,EAAE,CAAC;AACvF,YAAY;AACZ,YAAY;AACZ,UAAU;AACV,UAAU,KAAK,WAAW,EAAE;AAC5B,YAAY,MAAM,CAAC,+BAA+B,OAAO;AACzD,YAAY,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,MAAM,CAAC;AACrC,YAAY;AACZ,UAAU;AACV,UAAU,KAAK,aAAa,EAAE;AAC9B,YAAY,MAAM,CAAC,iCAAiC,OAAO;AAC3D,YAAY,CAAC,CAAC,GAAG,GAAG,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,GAAG,EAAE,IAAI,EAAE,EAAE,CAAC,CAAC,GAAG,CAAC,MAAM;AAC7D,YAAY;AACZ,UAAU;AACV,UAAU;AACV;AACA,YAAY,KAAK,CAAC,cAAc;AAChC;AACA,QAAQ,IAAI,IAAI,CAAC,SAAS,EAAE;AAC5B,UAAU,IAAI,CAAC,SAAS,GAAG,GAAG,CAAC,cAAc,CAAC,WAAW,EAAE,IAAI,CAAC,SAAS,EAAE,MAAM,CAAC,GAAG,EAAE;AACvF,QAAQ;AACR,QAAQ,CAAC;AACT,QAAQ,OAAO;AACf,MAAM;AACN,MAAM;AACN;AACA,QAAQ,KAAK,CAAC,cAAc;AAC5B;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,eAAe,GAAG,CAAC,MAAM,EAAE,IAAI,KAAK,mBAAmB,CAAC,MAAM,EAAE,gBAAgB,CAAC,IAAI,CAAC,EAAE,eAAe,EAAE,eAAe;;AAErI;AACA;AACA;AACA;AACY,MAAC,iBAAiB,GAAG,CAAC,MAAM,EAAE,IAAI,KAAK,mBAAmB,CAAC,MAAM,EAAE,gBAAgB,CAAC,IAAI,CAAC,EAAE,eAAe,EAAE,eAAe;;AAEvI;AACA;AACA;AACY,MAAC,yBAAyB,GAAG,MAAM,IAAI,mBAAmB,CAAC,MAAM,EAAE,CAAC,CAAC,EAAE,EAAE,eAAe,EAAE,eAAe;;AAErH;AACA;AACA;AACY,MAAC,yBAAyB,GAAG,MAAM,IAAI,mBAAmB,CAAC,MAAM,EAAE,CAAC,CAAC,EAAE,EAAE,eAAe,EAAE,eAAe;;AC5rBrH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO,MAAM,MAAM,CAAC;AACpB;AACA;AACA;AACA;AACA;AACA,EAAE,WAAW,CAAC,CAAC,MAAM,EAAE,WAAW,EAAE,IAAI,EAAE;AAC1C;AACA;AACA;AACA;AACA,IAAI,IAAI,CAAC,MAAM,GAAG;AAClB;AACA;AACA;AACA;AACA,IAAI,IAAI,CAAC,aAAa,GAAG;AACzB;AACA;AACA;AACA;AACA,IAAI,IAAI,CAAC,WAAW,GAAG;AACvB;AACA;AACA;AACA,IAAI,IAAI,CAAC,MAAM,GAAG;AAClB;AACA;AACA;AACA,IAAI,IAAI,CAAC,UAAU,GAAG;AACtB;AACA;AACA;AACA,IAAI,IAAI,CAAC,KAAK,GAAG;AACjB;AACA;AACA;AACA;AACA;AACA,IAAI,IAAI,CAAC,gBAAgB,GAAG;AAC5B;AACA;AACA;AACA;AACA,IAAI,IAAI,CAAC,WAAW,GAAG,IAAI,GAAG;AAC9B,IAAI,IAAI,EAAE,OAAO,CAAC,CAAC,GAAG,KAAK;AAC3B,MAAM,IAAI,GAAG,KAAK,IAAI,EAAE;AACxB,QAAQ,IAAI,CAAC,gBAAgB,GAAG;AAChC,MAAM,CAAC,MAAM;AACb,QAAQ,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,GAAG;AAChC,MAAM;AACN,IAAI,CAAC;AACL,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,IAAI,IAAI,CAAC,GAAG;AACd,IAAI,OAAO,IAAI,CAAC,KAAK,KAAK,IAAI,CAAC,KAAK,GAAG,SAAS,CAAC,IAAI,CAAC,aAAa,EAAE,IAAI,CAAC,MAAM,CAAC;AACjF,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,OAAO,CAAC,CAAC,MAAM,EAAE;AACnB,IAAI,OAAO,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,KAAK,CAAC,MAAM,CAAC,EAAE;AACrD,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,IAAI,CAAC,CAAC,MAAM,EAAE;AAChB,IAAI,OAAO,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,KAAK,CAAC,MAAM,CAAC,EAAE;AACrD,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,QAAQ,CAAC,CAAC,EAAE,GAAG,qBAAqB,EAAE,EAAE,IAAI,EAAE,GAAG,EAAE,EAAE;AACvD,IAAI,MAAM,aAAa,GAAG,WAAW,CAAC,CAAC,SAAS,CAAC,IAAI,CAAC,WAAW,CAAC,SAAS,EAAE,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,EAAE,SAAS,CAAC,IAAI,CAAC,WAAW,CAAC,SAAS,EAAE,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,CAAC;AAC5K;AACA;AACA;AACA;AACA;AACA,IAAI,IAAI,QAAQ,GAAG,IAAI,CAAC,WAAW,CAAC;AACpC,IAAI,IAAI,IAAI,EAAE;AACd;AACA,MAAM,MAAM,QAAQ,GAAG,IAAI,GAAG;AAC9B,MAAM,QAAQ,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,IAAI,KAAK;AACxC,QAAQ,QAAQ,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,GAAG,CAAC,KAAK,CAAC;AACzC,MAAM,CAAC;AACP,MAAM,KAAK,IAAI,CAAC,IAAI,QAAQ,CAAC,IAAI,EAAE,EAAE;AACrC,QAAQ,OAAO,CAAC,CAAC,KAAK,IAAI,IAAI,EAAE;AAChC,UAAU,MAAM,IAAI,GAAG,CAAC,CAAC;AACzB,UAAU,MAAM,EAAE,GAAG,GAAG,CAAC,cAAc,CAAC,QAAQ,EAAE,IAAI,EAAE,MAAM,EAAE,GAAG,CAAC,MAAM;AAC1E,UAAU,IAAI,IAAI,IAAI,CAAC,EAAE,CAAC,GAAG,CAAC,IAAI,CAAC,SAAS,CAAC,EAAE;AAC/C,YAAY,EAAE,CAAC,GAAG,CAAC,IAAI,CAAC,SAAS;AACjC,YAAY,CAAC,uBAAuB,IAAI,CAAC,MAAM;AAC/C,UAAU,CAAC,MAAM;AACjB,YAAY;AACZ,UAAU;AACV,QAAQ;AACR,MAAM;AACN,MAAM,QAAQ,GAAG;AACjB,IAAI;AACJ,IAAI,2BAA2B,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,EAAE,EAAE,EAAE,aAAa,EAAE,aAAa,EAAE,IAAI,EAAE,YAAY,EAAE,IAAI,CAAC,WAAW,CAAC,SAAS,EAAE,IAAI,EAAE,CAAC,CAAC,IAAI,EAAE,QAAQ,EAAE,CAAC;AACnK,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,IAAI,KAAK,CAAC,GAAG;AACf,IAAI,2BAA2B,IAAI,CAAC,MAAM,KAAK,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,QAAQ,EAAE,CAAC,IAAI,EAAE,CAAC;AACpF,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,IAAI,SAAS,CAAC,GAAG;AACnB,IAAI,2BAA2B,IAAI,CAAC,UAAU,KAAK,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,QAAQ,CAAC,qBAAqB,EAAE,EAAE,IAAI,EAAE,IAAI,EAAE,CAAC,CAAC;AAC1H,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,SAAS,GAAG,CAAC,MAAM,EAAE,KAAK,EAAE,EAAE,GAAG,qBAAqB,KAAK;AACxE,EAAE,MAAM,IAAI,GAAG;AACf,EAAE,MAAM,GAAG,uBAAuB,MAAM,CAAC,GAAG;AAC5C,EAAE,OAAO,KAAK,CAAC,KAAK,KAAK,IAAI,IAAI,KAAK,KAAK,MAAM,EAAE;AACnD,IAAI,IAAI,KAAK,CAAC,KAAK,CAAC,SAAS,KAAK,IAAI,EAAE;AACxC;AACA,MAAM,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,KAAK,CAAC,SAAS;AACxC,IAAI,CAAC,MAAM;AACX,MAAM,MAAM,MAAM,qDAAqD,KAAK,CAAC,KAAK,CAAC,MAAM;AACzF;AACA,MAAM,MAAM,IAAI,oCAAoC,0CAA0C,CAAC,sBAAsB,CAAC,MAAM,EAAE,KAAK,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,KAAK,EAAE,EAAE,CAAC;AAC9J,MAAM,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK;AAC7B,IAAI;AACJ,IAAI,KAAK,0BAA0B,KAAK,CAAC,KAAK,CAAC,MAAM;AACrD,EAAE;AACF,EAAE,OAAO;AACT;;AC1MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,aAAa,GAAG,CAAC,OAAO,EAAE,GAAG,KAAK;AAC/C,EAAE,MAAM,UAAU,GAAG,IAAI,SAAS;AAClC,EAAE,MAAM,iBAAiB,GAAG,QAAQ,CAAC,WAAW,CAAC,OAAO,CAAC,WAAW;AACpE,EAAE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,iBAAiB,EAAE,CAAC,EAAE,EAAE;AAC9C,IAAI,MAAM,eAAe,GAAG,QAAQ,CAAC,WAAW,CAAC,OAAO,CAAC,WAAW;AACpE;AACA;AACA;AACA,IAAI,MAAM,IAAI,GAAG,IAAI,KAAK,CAAC,eAAe;AAC1C,IAAI,MAAM,MAAM,GAAG,OAAO,CAAC,UAAU;AACrC,IAAI,IAAI,KAAK,GAAG,QAAQ,CAAC,WAAW,CAAC,OAAO,CAAC,WAAW;AACxD,IAAI,UAAU,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,EAAE,IAAI,WAAW,CAAC,IAAI,CAAC;AACxD,IAAI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,eAAe,EAAE,CAAC,EAAE,EAAE;AAC9C,MAAM,MAAM,IAAI,GAAG,OAAO,CAAC,QAAQ;AACnC,MAAM,QAAQ,MAAM,CAAC,KAAK,GAAG,IAAI;AACjC,QAAQ,KAAK,CAAC,EAAE;AAChB,UAAU,MAAM,GAAG,GAAG,OAAO,CAAC,OAAO;AACrC,UAAU,IAAI,CAAC,CAAC,CAAC,GAAG,IAAI,EAAE,CAAC,QAAQ,CAAC,MAAM,EAAE,KAAK,CAAC,EAAE,GAAG;AACvD,UAAU,KAAK,IAAI;AACnB,UAAU;AACV,QAAQ;AACR,QAAQ,KAAK,EAAE,EAAE;AACjB;AACA,UAAU,MAAM,GAAG,GAAG,QAAQ,CAAC,WAAW,CAAC,OAAO,CAAC,WAAW;AAC9D,UAAU,IAAI,CAAC,CAAC,CAAC,GAAG,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE,KAAK,CAAC,EAAE,GAAG;AACzD,UAAU,KAAK,IAAI;AACnB,UAAU;AACV,QAAQ;AACR,QAAQ,SAAS;AACjB;AACA;AACA;AACA;AACA;AACA,UAAU,MAAM,kBAAkB,GAAG,CAAC,IAAI,IAAI,MAAM,CAAC,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC,MAAM;AAC9E;AACA;AACA;AACA;AACA,UAAU,MAAM,MAAM,GAAG,IAAI,IAAI;AACjC,YAAY,QAAQ,CAAC,MAAM,EAAE,KAAK,CAAC;AACnC,YAAY,IAAI;AAChB,YAAY,CAAC,IAAI,GAAG,MAAM,CAAC,IAAI,MAAM,MAAM,CAAC,IAAI,GAAG,OAAO,CAAC,UAAU,EAAE,GAAG,IAAI;AAC9E,YAAY,IAAI;AAChB,YAAY,CAAC,IAAI,GAAG,MAAM,CAAC,IAAI,MAAM,MAAM,CAAC,IAAI,GAAG,OAAO,CAAC,WAAW,EAAE,GAAG,IAAI;AAC/E,YAAY,kBAAkB,IAAI,OAAO,CAAC,cAAc,EAAE,GAAG,GAAG,CAAC,GAAG,CAAC,OAAO,CAAC,UAAU,EAAE,CAAC,GAAG,OAAO,CAAC,UAAU,EAAE,IAAI,IAAI;AACzH,YAAY,kBAAkB,IAAI,CAAC,IAAI,GAAG,MAAM,CAAC,IAAI,MAAM,MAAM,CAAC,IAAI,GAAG,OAAO,CAAC,UAAU,EAAE,GAAG,IAAI;AACpG,YAAY,eAAe,CAAC,OAAO,EAAE,IAAI,CAAC;AAC1C;AACA,UAAU,IAAI,CAAC,CAAC,CAAC,GAAG;AACpB,UAAU,KAAK,IAAI,MAAM,CAAC;AAC1B,QAAQ;AACR;AACA,IAAI;AACJ,EAAE;AACF,EAAE,OAAO;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,yBAAyB,GAAG,CAAC,EAAE,EAAE,OAAO,KAAK;AAC1D;AACA,EAAE,OAAO,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,MAAM,KAAK;AAC7C,IAAI,MAAM,OAAO,8BAA8B,CAAC,EAAE,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,GAAG;AACzE,IAAI,IAAI,OAAO,IAAI,IAAI,EAAE;AACzB,MAAM,MAAM,WAAW,GAAG,OAAO,CAAC,CAAC;AACnC,MAAM,MAAM,UAAU,GAAG,OAAO,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC;AACnD,MAAM,MAAM,QAAQ,GAAG,KAAK,CAAC,MAAM;AACnC,MAAM,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AAChD,QAAQ,MAAM,KAAK,GAAG,QAAQ,CAAC,CAAC;AAChC,QAAQ,IAAI,UAAU,GAAG;AACzB,QAAQ,IAAI,KAAK,CAAC,KAAK,IAAI,UAAU,CAAC,EAAE,CAAC,KAAK,GAAG,UAAU,CAAC,MAAM,EAAE;AACpE,QAAQ,IAAI,KAAK,CAAC,KAAK,GAAG,WAAW,CAAC,EAAE,CAAC,KAAK,EAAE;AAChD,UAAU,UAAU,GAAG,mBAAmB,CAAC,IAAI,EAAE,OAAO,EAAE,KAAK,CAAC,KAAK;AACrE,QAAQ;AACR,QAAQ,IAAI,QAAQ,GAAG,OAAO,CAAC,OAAM;AACrC,QAAQ,IAAI,KAAK,CAAC,KAAK,GAAG,KAAK,CAAC,GAAG,IAAI,WAAW,CAAC,EAAE,CAAC,KAAK,EAAE;AAC7D,QAAQ,IAAI,KAAK,CAAC,KAAK,GAAG,KAAK,CAAC,GAAG,GAAG,UAAU,CAAC,EAAE,CAAC,KAAK,GAAG,UAAU,CAAC,MAAM,EAAE;AAC/E,UAAU,QAAQ,GAAG,mBAAmB,CAAC,IAAI,EAAE,OAAO,EAAE,KAAK,CAAC,KAAK,GAAG,KAAK,CAAC,GAAG;AAC/E,QAAQ;AACR,QAAQ,IAAI,UAAU,GAAG,QAAQ,EAAE;AACnC,UAAU,OAAO,CAAC,UAAU,CAAC,GAAG,IAAI,IAAI,CAAC,IAAI,EAAE,CAAC,MAAM,EAAE,KAAK,CAAC,KAAK,CAAC,EAAE,KAAK,CAAC,GAAG;AAC/E,UAAU,MAAM,CAAC,GAAG,QAAQ,GAAG;AAC/B,UAAU,IAAI,CAAC,GAAG,CAAC,EAAE;AACrB,YAAY,OAAO,CAAC,MAAM,CAAC,UAAU,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC;AAChD,UAAU;AACV,QAAQ;AACR,MAAM;AACN,IAAI;AACJ,EAAE,CAAC;AACH;;AAEA,MAAM,WAAW,CAAC;AAClB;AACA;AACA;AACA,EAAE,WAAW,CAAC,CAAC,IAAI,EAAE;AACrB,IAAI,IAAI,CAAC,CAAC,GAAG;AACb;AACA;AACA;AACA,IAAI,IAAI,CAAC,IAAI,GAAG;AAChB,EAAE;AACF;;AAEO,MAAM,SAAS,CAAC;AACvB,EAAE,WAAW,CAAC,GAAG;AACjB;AACA;AACA;AACA,IAAI,IAAI,CAAC,OAAO,GAAG,GAAG,CAAC,MAAM;AAC7B,EAAE;AACF;;ACvHA;AACA;AACA;AACA;AACO,MAAM,eAAe,CAAC;AAC7B;AACA;AACA;AACA;AACA,EAAE,WAAW,CAAC,CAAC,IAAI,EAAE,GAAG,EAAE;AAC1B,IAAI,IAAI,CAAC,IAAI,GAAG;AAChB,IAAI,IAAI,CAAC,GAAG,GAAG;AACf,EAAE;;AAEF,EAAE,IAAI,CAAC,GAAG;AACV,IAAI,MAAM,OAAO,GAAG,QAAQ,CAAC,aAAa;AAC1C,IAAI,QAAQ,CAAC,cAAc,CAAC,OAAO,EAAE,IAAI,CAAC,IAAI;AAC9C,IAAI,QAAQ,CAAC,QAAQ,CAAC,OAAO,sBAAsB,IAAI,CAAC,GAAG;AAC3D,IAAI,OAAOA,MAAG,CAAC,QAAQ,CAAC,KAAK,CAAC,WAAW,CAAC,KAAK,CAAC,sBAAsB,EAAE,QAAQ,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC;AACvG,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,qBAAqB,GAAG,CAAC,IAAI,EAAE,GAAG,KAAK,IAAI,eAAe,CAAC,IAAI,EAAE,GAAG;;AAEjF;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,aAAa,GAAG,CAAC,KAAK,EAAE,IAAI,KAAK,KAAK,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,KAAK,IAAI;;AAEjE;AACA;AACA;AACA;AACA;AACY,MAAC,eAAe,GAAG,CAAC,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,MAAM,KAAK,CAAC,CAAC,MAAM,IAAI,CAAC,CAAC,KAAK,CAAC,CAAC,IAAI,aAAa,CAAC,CAAC,EAAE,CAAC,CAAC;;AAElG;AACA;AACA;AACA;AACA;AACA,MAAM,kBAAkB,GAAG,CAAC,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,IAAI,CAAC,aAAa,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC;;AAEvF;AACA;AACA;AACO,MAAM,SAAS,CAAC;AACvB;AACA;AACA;AACA;AACA;AACA,EAAE,WAAW,CAAC,CAAC,KAAK,EAAE,GAAG,EAAE,KAAK,EAAE;AAClC;AACA;AACA;AACA,IAAI,IAAI,CAAC,KAAK,GAAG;AACjB;AACA;AACA;AACA,IAAI,IAAI,CAAC,GAAG,GAAG;AACf;AACA;AACA;AACA,IAAI,IAAI,CAAC,KAAK,GAAG;AACjB,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE,QAAQ,CAAC,CAAC,KAAK,EAAE,GAAG,EAAE;AACxB,IAAI,OAAO,IAAI,SAAS,CAAC,KAAK,EAAE,GAAG,EAAE,IAAI,CAAC,KAAK;AAC/C,EAAE;AACF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,oBAAoB,GAAG,CAAC,KAAK,EAAE,GAAG,EAAE,KAAK,KAAK,IAAI,SAAS,CAAC,KAAK,EAAE,GAAG,sBAAsB,KAAK;;AAE9G;AACA;AACA;AACA;AACA;AACO,MAAM,UAAU,CAAC;AACxB;AACA;AACA;AACA,EAAE,WAAW,CAAC,CAAC,GAAG,EAAE;AACpB,IAAI,IAAI,CAAC,MAAM,GAAG;AAClB;AACA;AACA;AACA,IAAI,IAAI,CAAC,IAAI,GAAG;AAChB,EAAE;;AAEF,EAAE,IAAI,CAAC,GAAG;AACV,IAAI,OAAO,IAAI,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE;AAC3C,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE,GAAG,CAAC,CAAC,KAAK,EAAE,MAAM,EAAE,KAAK,EAAE;AAC7B,IAAI,IAAI,MAAM,KAAK,CAAC,EAAE;AACtB,IAAI,IAAI,CAAC,MAAM,GAAG;AAClB,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,SAAS,CAAC,KAAK,EAAE,MAAM,EAAE,KAAK,CAAC;AACtD,EAAE;;AAEF;AACA;AACA;AACA,EAAE,MAAM,CAAC,GAAG;AACZ,IAAI,MAAM,GAAG,GAAG,IAAI,CAAC;AACrB,IAAI,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE;AACtB,MAAM,IAAI,CAAC,MAAM,GAAG;AACpB,MAAM,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,KAAK,GAAG,CAAC,CAAC,KAAK;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,MAAM,GAAG,CAAC,GAAG;AAC3C,QAAQ,MAAM,KAAK,GAAG,GAAG,CAAC,CAAC;AAC3B,QAAQ,MAAM,SAAS,GAAG,GAAG,CAAC,CAAC,GAAG,CAAC;AACnC;AACA;AACA;AACA;AACA,QAAQ,IAAI,KAAK,CAAC,KAAK,GAAG,SAAS,CAAC,KAAK,EAAE;AAC3C,UAAU,IAAI,KAAK,CAAC,KAAK,GAAG,KAAK,CAAC,GAAG,GAAG,SAAS,CAAC,KAAK,EAAE;AACzD;AACA,YAAY,MAAM,IAAI,GAAG,SAAS,CAAC,KAAK,GAAG,KAAK,CAAC;AACjD,YAAY,GAAG,CAAC,CAAC,CAAC,GAAG,IAAI,SAAS,CAAC,KAAK,CAAC,KAAK,EAAE,IAAI,EAAE,KAAK,CAAC,KAAK;AACjE,YAAY,GAAG,CAAC,MAAM,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,IAAI,SAAS,CAAC,SAAS,CAAC,KAAK,EAAE,KAAK,CAAC,GAAG,GAAG,IAAI,EAAE,KAAK,CAAC,KAAK,CAAC;AAC9F,UAAU;AACV,UAAU,CAAC;AACX,UAAU;AACV,QAAQ;AACR;AACA;AACA,QAAQ,MAAM,WAAW,GAAG,KAAK,CAAC,GAAG,GAAG,SAAS,CAAC,GAAG,GAAG,KAAK,GAAG;AAChE,QAAQ,MAAM,UAAU,GAAG,KAAK,CAAC,GAAG,GAAG,SAAS,CAAC,GAAG,GAAG,KAAK,CAAC,GAAG,GAAG,SAAS,CAAC;AAC7E,QAAQ,GAAG,CAAC,CAAC,CAAC,GAAG,IAAI,SAAS,CAAC,KAAK,CAAC,KAAK,EAAE,UAAU,EAAE,kBAAkB,CAAC,KAAK,CAAC,KAAK,EAAE,SAAS,CAAC,KAAK,CAAC;AACxG,QAAQ,IAAI,KAAK,CAAC,GAAG,KAAK,SAAS,CAAC,GAAG,EAAE;AACzC,UAAU,GAAG,CAAC,MAAM,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC;AAC7B,QAAQ,CAAC,MAAM;AACf,UAAU,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,IAAI,SAAS,CAAC,KAAK,CAAC,KAAK,GAAG,UAAU,EAAE,WAAW,CAAC,GAAG,GAAG,UAAU,EAAE,WAAW,CAAC,KAAK;AAC9G,UAAU,KAAK,CAAC,cAAc,CAAC,GAAG,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,KAAK,GAAG,CAAC,CAAC,KAAK;AACtE,QAAQ;AACR,QAAQ,IAAI,UAAU,KAAK,CAAC,EAAE,CAAC;AAC/B,MAAM;AACN,MAAM,OAAO,GAAG,CAAC,MAAM,GAAG,CAAC,IAAI,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC,EAAE;AACjD,QAAQ,GAAG,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC;AACvB,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM,IAAI,CAAC,EAAE;AACb,MAAM,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AAC9C,QAAQ,MAAM,IAAI,GAAG,GAAG,CAAC,CAAC,GAAG,CAAC;AAC9B,QAAQ,MAAM,KAAK,GAAG,GAAG,CAAC,CAAC;AAC3B,QAAQ,IAAI,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,GAAG,KAAK,KAAK,CAAC,KAAK,IAAI,eAAe,CAAC,IAAI,CAAC,KAAK,EAAE,KAAK,CAAC,KAAK,CAAC,EAAE;AAC/F,UAAU,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,IAAI,SAAS,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,GAAG,GAAG,KAAK,CAAC,GAAG,EAAE,IAAI,CAAC,KAAK;AACjF,QAAQ,CAAC,MAAM,IAAI,KAAK,CAAC,GAAG,KAAK,CAAC,EAAE;AACpC,UAAU,IAAI,CAAC,GAAG,CAAC,EAAE;AACrB,YAAY,GAAG,CAAC,CAAC,CAAC,GAAG;AACrB,UAAU;AACV,UAAU,CAAC;AACX,QAAQ;AACR,MAAM;AACN,MAAM,GAAG,CAAC,MAAM,GAAG,GAAG,CAAC,MAAM,KAAK,CAAC,GAAG,CAAC,IAAI,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC;AAC3E,IAAI;AACJ,IAAI,OAAO;AACX,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,WAAW,GAAG,GAAG,IAAI;AAClC;AACA;AACA;AACA;AACA;AACA,EAAE,MAAM,UAAU,GAAG,IAAI,GAAG;AAC5B,EAAE,MAAM,MAAM,GAAG,WAAW;AAC5B,EAAE,KAAK,IAAI,IAAI,GAAG,CAAC,EAAE,IAAI,GAAG,GAAG,CAAC,MAAM,EAAE,IAAI,EAAE,EAAE;AAChD,IAAI,GAAG,CAAC,IAAI,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,UAAU,EAAE,MAAM,KAAK;AACtD,MAAM,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE;AACvC;AACA;AACA,QAAQ,IAAI,GAAG,GAAG,UAAU,CAAC,MAAM,EAAE,CAAC,KAAK;AAC3C,QAAQ,KAAK,IAAI,CAAC,GAAG,IAAI,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AACpD,UAAU,MAAM,OAAO,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM;AACnD,UAAU,IAAI,OAAO,EAAE;AACvB,YAAY,KAAK,CAAC,QAAQ,CAAC,GAAG,EAAE,OAAO,CAAC,MAAM,EAAE;AAChD,UAAU;AACV,QAAQ;AACR,QAAQ,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,EAAE,IAAI,IAAI,SAAS,CAAC,EAAE,CAAC,KAAK,EAAE,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI;AAC7E,UAAU,GAAG,CAAC,cAAc,CAAC,UAAU,EAAE,IAAI,EAAE;AAC/C,YAAY,YAAY,CAAC,MAAM,EAAE,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;AAC1C;AACA,SAAS,CAAC;AACV,QAAQ,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,EAAE,IAAI,UAAU,CAAC,GAAG,CAAC;AACtD,MAAM;AACN,IAAI,CAAC;AACL,EAAE;AACF,EAAE,OAAO;AACT;;AAEA;AACA;AACA;AACA;AACY,MAAC,oBAAoB,GAAG,CAAC,KAAK,EAAE,KAAK,KAAK;AACtD,EAAE,MAAM,KAAK,GAAG,WAAW;AAC3B;AACA,EAAE,KAAK,GAAG,YAAY,CAAC,KAAK,EAAE,KAAK;AACnC;AACA;AACA;AACA;AACA,EAAE,MAAM,YAAY,GAAG;AACvB,EAAE,KAAK,CAAC,OAAO,CAAC,IAAI,IAAI;AACxB,IAAI,IAAI,CAAC,aAAa,CAAC,YAAY,EAAE,IAAI,CAAC,EAAE;AAC5C,MAAM,YAAY,CAAC,IAAI,CAAC,IAAI;AAC5B,IAAI;AACJ,EAAE,CAAC;AACH,EAAE,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,MAAM,EAAE,MAAM,KAAK;AAC5C,IAAI,MAAM,UAAU,GAAG,IAAI,UAAU,CAAC,MAAM,CAAC,MAAM,EAAE,CAAC,GAAG,CAAC,KAAK,IAAI,IAAI,SAAS,CAAC,KAAK,CAAC,KAAK,EAAE,KAAK,CAAC,GAAG,EAAE,YAAY,CAAC,CAAC;AACvH,IAAI,UAAU,CAAC,MAAM,GAAG,KAAI;AAC5B,IAAI,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,EAAE,UAAU;AACxC,EAAE,CAAC;AACH,EAAE,OAAO;AACT;;AAEA;AACA;AACA;AACO,MAAM,KAAK,CAAC;AACnB,EAAE,WAAW,CAAC,GAAG;AACjB;AACA;AACA;AACA,IAAI,IAAI,CAAC,OAAO,GAAG,IAAI,GAAG;AAC1B;AACA;AACA;AACA,IAAI,IAAI,CAAC,MAAM,GAAG,IAAI,GAAG;AACzB;AACA;AACA;AACA,IAAI,IAAI,CAAC,KAAK,GAAG,IAAI,GAAG;AACxB,EAAE;;AAEF;AACA;AACA;AACA,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE;AACd,IAAI,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,MAAM,EAAE,MAAM,KAAK;AAC7C,MAAM,MAAM,CAAC,MAAM,EAAE,CAAC,OAAO,CAAC,CAAC,KAAK,KAAK;AACzC,QAAQ,CAAC,CAAC,KAAK,EAAE,MAAM;AACvB,MAAM,CAAC;AACP,IAAI,CAAC;AACL,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE,KAAK,CAAC,CAAC,EAAE,EAAE;AACb,IAAI,OAAO,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,MAAM,EAAE,EAAE,CAAC,KAAK;AACvC,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE,GAAG,CAAC,CAAC,MAAM,EAAE,KAAK,EAAE;AACtB,IAAI,MAAM,EAAE,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM;AACtC,IAAI,IAAI,EAAE,EAAE;AACZ,MAAM,OAAO,mBAAmB,CAAC,EAAE,CAAC,MAAM,EAAE,EAAE,KAAK,CAAC,KAAK;AACzD,IAAI;AACJ,IAAI,OAAO;AACX,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,OAAO,CAAC,CAAC,EAAE,EAAE,GAAG,EAAE;AACpB,IAAI,OAAO,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,MAAM,EAAE,EAAE,CAAC,KAAK,EAAE,GAAG;AAC9C,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,KAAK,CAAC,CAAC,MAAM,EAAE,KAAK,EAAE,GAAG,EAAE;AAC7B,IAAI,MAAM,EAAE,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM;AACtC;AACA;AACA;AACA,IAAI,MAAM,GAAG,GAAG;AAChB,IAAI,IAAI,EAAE,EAAE;AACZ;AACA;AACA;AACA,MAAM,MAAM,MAAM,GAAG,EAAE,CAAC,MAAM;AAC9B,MAAM,IAAI,KAAK,GAAG,wBAAwB,CAAC,MAAM,EAAE,KAAK;AACxD,MAAM,IAAI,KAAK,KAAK,IAAI,EAAE;AAC1B,QAAQ,IAAI,IAAI,GAAG;AACnB,QAAQ,OAAO,KAAK,GAAG,MAAM,CAAC,MAAM,EAAE;AACtC,UAAU,IAAI,CAAC,GAAG,MAAM,CAAC,KAAK;AAC9B,UAAU,IAAI,CAAC,CAAC,KAAK,GAAG,KAAK,EAAE;AAC/B,YAAY,CAAC,GAAG,IAAI,SAAS,CAAC,KAAK,EAAE,CAAC,CAAC,GAAG,IAAI,KAAK,GAAG,CAAC,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC,KAAK;AACvE,UAAU;AACV,UAAU,IAAI,CAAC,CAAC,KAAK,GAAG,CAAC,CAAC,GAAG,GAAG,KAAK,GAAG,GAAG,EAAE;AAC7C,YAAY,CAAC,GAAG,IAAI,SAAS,CAAC,CAAC,CAAC,KAAK,EAAE,KAAK,GAAG,GAAG,GAAG,CAAC,CAAC,KAAK,EAAE,CAAC,CAAC,KAAK;AACrE,UAAU;AACV,UAAU,IAAI,CAAC,CAAC,GAAG,IAAI,CAAC,EAAE;AAC1B,UAAU,MAAM,OAAO,GAAG,IAAI,IAAI,IAAI,GAAG,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,GAAG,GAAG;AACjE,UAAU,IAAI,OAAO,GAAG,CAAC,CAAC,KAAK,EAAE;AACjC,YAAY,GAAG,CAAC,IAAI,CAAC,oBAAoB,CAAC,OAAO,EAAE,CAAC,CAAC,KAAK,GAAG,OAAO,EAAE,IAAI,CAAC;AAC3E,UAAU;AACV,UAAU,IAAI,GAAG;AACjB,UAAU,GAAG,CAAC,IAAI,CAAC,CAAC;AACpB,UAAU,KAAK;AACf,QAAQ;AACR,MAAM;AACN,IAAI;AACJ,IAAI,IAAI,GAAG,CAAC,MAAM,GAAG,CAAC,EAAE;AACxB,MAAM,MAAM,IAAI,GAAG,GAAG,CAAC,GAAG,CAAC,MAAM,GAAG,CAAC;AACrC,MAAM,MAAM,GAAG,GAAG,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;AACpC,MAAM,IAAI,GAAG,GAAG,KAAK,GAAG,GAAG,EAAE;AAC7B,QAAQ,GAAG,CAAC,IAAI,CAAC,oBAAoB,CAAC,GAAG,EAAE,KAAK,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,CAAC;AACnE,MAAM;AACN,IAAI,CAAC,MAAM;AACX,MAAM,GAAG,CAAC,IAAI,CAAC,oBAAoB,CAAC,KAAK,EAAE,GAAG,EAAE,IAAI,CAAC;AACrD,IAAI;AACJ,IAAI,OAAO;AACX,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,GAAG,CAAC,CAAC,MAAM,EAAE,KAAK,EAAE,GAAG,EAAE,KAAK,EAAE;AAClC,IAAI,IAAI,GAAG,KAAK,CAAC,EAAE;AACnB,IAAI,KAAK,GAAG,YAAY,CAAC,IAAI,EAAE,KAAK;AACpC,IAAI,MAAM,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM;AAC1C,IAAI,IAAI,MAAM,IAAI,IAAI,EAAE;AACxB,MAAM,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,EAAE,IAAI,UAAU,CAAC,CAAC,IAAI,SAAS,CAAC,KAAK,EAAE,GAAG,EAAE,KAAK,CAAC,CAAC,CAAC;AACjF,IAAI,CAAC,MAAM;AACX,MAAM,MAAM,CAAC,GAAG,CAAC,KAAK,EAAE,GAAG,EAAE,KAAK;AAClC,IAAI;AACJ,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE,MAAM,CAAC,CAAC,MAAM,EAAE,KAAK,EAAE,GAAG,EAAE;AAC9B,IAAI,qBAAqB,CAAC,IAAI,EAAE,MAAM,EAAE,KAAK,EAAE,GAAG;AAClD,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,UAAU,GAAG,CAAC,OAAO,EAAE,KAAK,KAAK;AAC9C,EAAE,QAAQ,CAAC,YAAY,CAAC,OAAO,CAAC,WAAW,EAAE,KAAK,CAAC,OAAO,CAAC,IAAI;AAC/D,EAAE,IAAI,mBAAmB,GAAG;AAC5B;AACA;AACA;AACA,EAAE,MAAM,mBAAmB,GAAG,GAAG,CAAC,MAAM;AACxC;AACA;AACA;AACA,EAAE,MAAM,gBAAgB,GAAG,GAAG,CAAC,MAAM;AACrC;AACA,EAAE,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,OAAO,EAAE;AACpC,KAAK,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;AAC/B,KAAK,OAAO,CAAC,CAAC,CAAC,MAAM,EAAE,SAAS,CAAC,KAAK;AACtC,MAAM,MAAM,UAAU,GAAG,SAAS,CAAC,MAAM;AACzC,MAAM,OAAO,CAAC,gBAAgB;AAC9B,MAAM,MAAM,IAAI,GAAG,MAAM,GAAG;AAC5B,MAAM,QAAQ,CAAC,YAAY,CAAC,OAAO,CAAC,WAAW,EAAE,IAAI;AACrD,MAAM,mBAAmB,GAAG;AAC5B,MAAM,MAAM,GAAG,GAAG,UAAU,CAAC;AAC7B,MAAM,QAAQ,CAAC,YAAY,CAAC,OAAO,CAAC,WAAW,EAAE,GAAG;AACpD,MAAM,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;AACpC,QAAQ,MAAM,IAAI,GAAG,UAAU,CAAC,CAAC;AACjC,QAAQ,MAAM,KAAK,GAAG,IAAI,CAAC;AAC3B,QAAQ,MAAM,OAAO,GAAG,KAAK,CAAC;AAC9B,QAAQ,OAAO,CAAC,eAAe,CAAC,IAAI,CAAC,KAAK;AAC1C,QAAQ,OAAO,CAAC,aAAa,CAAC,IAAI,CAAC,GAAG;AACtC,QAAQ,QAAQ,CAAC,YAAY,CAAC,OAAO,CAAC,WAAW,EAAE,OAAO;AAC1D,QAAQ,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,EAAE,CAAC,EAAE,EAAE;AAC1C,UAAU,MAAM,IAAI,GAAG,KAAK,CAAC,CAAC;AAC9B,UAAU,MAAM,MAAM,GAAG,mBAAmB,CAAC,GAAG,CAAC,IAAI;AACrD,UAAU,IAAI,MAAM,IAAI,IAAI,EAAE;AAC9B,YAAY,QAAQ,CAAC,YAAY,CAAC,OAAO,CAAC,WAAW,EAAE,MAAM;AAC7D,UAAU,CAAC,MAAM;AACjB,YAAY,MAAM,SAAS,GAAG,mBAAmB,CAAC;AAClD,YAAY,mBAAmB,CAAC,GAAG,CAAC,IAAI,EAAE,SAAS;AACnD,YAAY,QAAQ,CAAC,YAAY,CAAC,OAAO,CAAC,WAAW,EAAE,SAAS;AAChE,YAAY,MAAM,UAAU,GAAG,gBAAgB,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI;AAC7D;AACA,YAAY,IAAI,UAAU,IAAI,IAAI,EAAE;AACpC,cAAc,QAAQ,CAAC,YAAY,CAAC,OAAO,CAAC,WAAW,EAAE,UAAU;AACnE,YAAY,CAAC,MAAM;AACnB,cAAc,MAAM,aAAa,GAAG,gBAAgB,CAAC;AACrD,cAAc,QAAQ,CAAC,YAAY,CAAC,OAAO,CAAC,WAAW,EAAE,aAAa;AACtE,cAAc,QAAQ,CAAC,cAAc,CAAC,OAAO,CAAC,WAAW,EAAE,IAAI,CAAC,IAAI;AACpE,cAAc,gBAAgB,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,EAAE,aAAa;AAC3D,YAAY;AACZ,YAAY,QAAQ,CAAC,QAAQ,CAAC,OAAO,CAAC,WAAW,sBAAsB,IAAI,CAAC,GAAG;AAC/E,UAAU;AACV,QAAQ;AACR,MAAM;AACN,IAAI,CAAC;AACL;;AAEA;AACA;AACA;AACY,MAAC,WAAW,GAAG,KAAK,IAAI;AACpC,EAAE,MAAM,OAAO,GAAG,IAAI,cAAc;AACpC,EAAE,UAAU,CAAC,OAAO,EAAE,KAAK;AAC3B,EAAE,OAAO,OAAO,CAAC,YAAY;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,SAAS,GAAG,OAAO,IAAI;AACpC,EAAE,MAAM,KAAK,GAAG,IAAI,KAAK;AACzB,EAAE,MAAM,UAAU,GAAG,QAAQ,CAAC,WAAW,CAAC,OAAO,CAAC,WAAW;AAC7D;AACA;AACA;AACA,EAAE,MAAM,mBAAmB,GAAG;AAC9B;AACA;AACA;AACA,EAAE,MAAM,gBAAgB,GAAG;AAC3B,EAAE,IAAI,YAAY,GAAG;AACrB,EAAE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,UAAU,EAAE,CAAC,EAAE,EAAE;AACvC,IAAI,OAAO,CAAC,aAAa;AACzB,IAAI,MAAM,MAAM,GAAG,YAAY,GAAG,QAAQ,CAAC,WAAW,CAAC,OAAO,CAAC,WAAW;AAC1E,IAAI,YAAY,GAAG;AACnB,IAAI,MAAM,eAAe,GAAG,QAAQ,CAAC,WAAW,CAAC,OAAO,CAAC,WAAW;AACpE;AACA;AACA;AACA,IAAI,MAAM,UAAU,GAAG;AACvB,IAAI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,eAAe,EAAE,CAAC,EAAE,EAAE;AAC9C,MAAM,MAAM,UAAU,GAAG,OAAO,CAAC,WAAW;AAC5C,MAAM,MAAM,QAAQ,GAAG,OAAO,CAAC,SAAS;AACxC;AACA;AACA;AACA,MAAM,MAAM,KAAK,GAAG;AACpB,MAAM,MAAM,QAAQ,GAAG,QAAQ,CAAC,WAAW,CAAC,OAAO,CAAC,WAAW;AAC/D,MAAM,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,EAAE,CAAC,EAAE,EAAE;AACzC,QAAQ,MAAM,MAAM,GAAG,QAAQ,CAAC,WAAW,CAAC,OAAO,CAAC,WAAW;AAC/D,QAAQ,IAAI,MAAM,IAAI,mBAAmB,CAAC,MAAM,EAAE;AAClD;AACA,UAAU,MAAM,UAAU,GAAG,QAAQ,CAAC,WAAW,CAAC,OAAO,CAAC,WAAW;AACrE,UAAU,IAAI,UAAU,IAAI,gBAAgB,CAAC,MAAM,EAAE;AACrD,YAAY,gBAAgB,CAAC,IAAI,CAAC,QAAQ,CAAC,aAAa,CAAC,OAAO,CAAC,WAAW,CAAC;AAC7E,UAAU;AACV,UAAU,mBAAmB,CAAC,IAAI,CAAC,IAAI,eAAe,CAAC,gBAAgB,CAAC,UAAU,CAAC,EAAE,QAAQ,CAAC,OAAO,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC;AAC3H,QAAQ;AACR,QAAQ,KAAK,CAAC,IAAI,CAAC,mBAAmB,CAAC,MAAM,CAAC;AAC9C,MAAM;AACN,MAAM,UAAU,CAAC,IAAI,CAAC,IAAI,SAAS,CAAC,UAAU,EAAE,QAAQ,EAAE,KAAK,CAAC;AAChE,IAAI;AACJ,IAAI,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,EAAE,IAAI,UAAU,CAAC,UAAU,CAAC;AACxD,EAAE;AACF,EAAE,mBAAmB,CAAC,OAAO,CAAC,IAAI,IAAI;AACtC,IAAI,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI;AACxB,IAAI,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,EAAE,EAAE,IAAI;AACtC,EAAE,CAAC;AACH,EAAE,OAAO;AACT;;AAEA;AACA;AACA;AACA;AACY,MAAC,WAAW,GAAG,IAAI,IAAI,SAAS,CAAC,IAAI,WAAW,CAAC,QAAQ,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;;AAE1F;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,YAAY,GAAG,CAAC,KAAK,EAAE,KAAK,KAAK,KAAK,CAAC,GAAG,CAAC,IAAI;AACrD,EAAE,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI;AACtB,MAAM;AACN,MAAM,GAAG,CAAC,cAAc,CAAC,KAAK,CAAC,MAAM,EAAE,IAAI,CAAC,IAAI,EAAE,EAAE,MAAM;AAC1D,MAAM,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI;AAC1B,MAAM,OAAO;AACb,IAAI,CAAC,CAAC;;AAEM,MAAC,WAAW,GAAG,MAAM,IAAI,KAAK;;AAE1C;AACA;AACA;AACA;AACA;AACY,MAAC,eAAe,GAAG;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,SAAS,GAAG,CAAC,GAAG,EAAE,OAAO,KAAK;AAC3C,EAAE,MAAM,MAAM,GAAG,QAAQ,CAAC,GAAG,EAAE,OAAO;AACtC,EAAE,MAAM,CAAC,KAAK,GAAG,GAAG,CAAC;AACrB,EAAE,MAAM,CAAC,MAAM,GAAG,GAAG,CAAC;AACtB,EAAE,OAAO;AACT;;AAEY,MAAC,aAAa,GAAG;;ACvkBjB,MAAC,qBAAqB,GAAG,CAAC,CAAC,OAAO,CAAC;AAC/C,EAAE,MAAM,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,QAAQ;AACtC,EAAE,UAAU,EAAE,CAAC,CAAC,OAAO,CAAC,QAAQ;AAChC,EAAE,MAAM,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,QAAQ;AACtC,EAAE,SAAS,EAAE,CAAC,CAAC,OAAO,CAAC,QAAQ;AAC/B,EAAE,MAAM,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,OAAO,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,QAAQ;AAC5D,EAAE,QAAQ,EAAE,CAAC,CAAC,OAAO,CAAC;AACtB,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,qCAAqC,GAAG,CAAC,KAAK,EAAE,OAAO,KAAK;AACzE,EAAE,IAAI,KAAK,IAAI,IAAI,EAAE;AACrB,IAAI,OAAO;AACX,EAAE;AACF;AACA;AACA;AACA,EAAE,MAAM,WAAW,GAAG;AACtB,EAAE,IAAI,OAAO,EAAE;AACf,IAAI,WAAW,CAAC,MAAM,GAAG,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,IAAI,CAAC,EAAE;AACpD,EAAE,CAAC,MAAM;AACT,IAAI,WAAW,CAAC,MAAM,GAAG;AACzB,EAAE;AACF,EAAE,KAAK,CAAC,OAAO,CAAC,IAAI,IAAI;AACxB,IAAI,QAAQ,IAAI,CAAC,IAAI;AACrB;AACA,MAAM,KAAK,QAAQ;AACnB,MAAM,KAAK,QAAQ,EAAE;AACrB,QAAQ,MAAM,EAAE,oDAAoD,WAAW;AAC/E,QAAQ,MAAM,EAAE,GAAG,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI;AACpD,QAAQ,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG;AACxB,QAAQ;AACR,MAAM;AACN,MAAM,SAAS;AACf,QAAQ,IAAI,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;AAClC,6BAA6B,CAAC,WAAW,EAAE,IAAI,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC;AAC7D,QAAQ;AACR,MAAM;AACN;AACA,EAAE,CAAC;AACH,EAAE,OAAO;AACT;;AAEA;AACA;AACA;AACO,MAAM,iBAAiB,CAAC;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,WAAW,CAAC,CAAC,OAAO,EAAE,KAAK,EAAE,OAAO,EAAE,KAAK,EAAE,cAAc,EAAE;AAC/D,IAAI,IAAI,CAAC,OAAO,GAAG;AACnB,IAAI,IAAI,CAAC,KAAK,GAAG;AACjB,IAAI,IAAI,CAAC,OAAO,GAAG;AACnB,IAAI,IAAI,CAAC,KAAK,GAAG;AACjB,IAAI,IAAI,CAAC,MAAM,GAAG,cAAc,KAAK,CAAC,GAAG,KAAK,IAAI,cAAc,KAAK,CAAC,IAAI,CAAC,OAAO,IAAI,KAAK,IAAI,IAAI,IAAI,IAAI;AAC3G,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,MAAM,0BAA0B,SAAS,YAAY,CAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,WAAW,CAAC,CAAC,SAAS,EAAE,OAAO,EAAE,MAAM,EAAE,QAAQ,EAAE,QAAQ,EAAE,aAAa,EAAE;AAC9E,IAAI,KAAK,CAAC,mBAAmB;AAC7B,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,aAAa,CAAC,CAAC,KAAK,EAAE;AACxB,IAAI,KAAK,CAAC,mBAAmB;AAC7B,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACO,MAAM,wBAAwB,SAAS,YAAY,CAAC;AAC3D;AACA;AACA;AACA;AACA,EAAE,WAAW,CAAC,CAAC,OAAO,EAAE,OAAO,EAAE;AACjC,IAAI,KAAK;AACT,IAAI,IAAI,CAAC,OAAO,GAAG;AACnB,IAAI,IAAI,CAAC,OAAO,GAAG;AACnB,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,WAAW,CAAC,CAAC,QAAQ,EAAE,MAAM,EAAE,KAAK,EAAE,OAAO,EAAE,OAAO,EAAE,YAAY,EAAE;AACxE,IAAI,MAAM,KAAK,GAAG,CAAC,OAAO,GAAG,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,OAAO,EAAE,KAAK,CAAC,MAAM,EAAE,KAAK,EAAE,OAAO,CAAC,SAAS,EAAE;AAClG,IAAI,OAAO,GAAG,KAAK,CAAC,MAAM,KAAK,CAAC,GAAG,OAAO,GAAG,OAAO,CAAC,IAAI;AACzD,IAAI,KAAK,CAAC,OAAO,CAAC,CAAC,IAAI;AACvB,MAAM,MAAM,CAAC,GAAG;AAChB,MAAM,IAAI,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC,SAAS,EAAE,EAAE;AACjC,QAAQ,OAAO,GAAG,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,GAAG;AAChC,MAAM;AACN,MAAM,IAAI,CAAC,OAAO,IAAI,CAAC,CAAC,KAAK,IAAI,IAAI,IAAI,YAAY,EAAE;AACvD,QAAQ,QAAQ,CAAC,IAAI,CAAC,IAAI,iBAAiB,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,EAAE,OAAO,EAAE,CAAC,CAAC,KAAK,EAAE,YAAY,CAAC;AACvF,MAAM;AACN,IAAI,CAAC;AACL,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE,aAAa,CAAC,CAAC,IAAI,EAAE;AACvB,IAAI,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,WAAW,EAAE,EAAE;AACrC,MAAM,OAAO;AACb,IAAI,CAAC,MAAM,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE;AAC9B,MAAM,OAAO,IAAI,CAAC;AAClB,IAAI,CAAC,MAAM;AACX,MAAM,OAAO,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,CAAC,KAAK,CAAC,CAAC,KAAK,IAAI,IAAI,GAAG,GAAG,GAAG,CAAC,CAAC,GAAG,GAAG,GAAG,EAAE,CAAC;AACjH,IAAI;AACJ,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,MAAM,qBAAqB,SAAS,YAAY,CAAC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,WAAW,CAAC,CAAC,QAAQ,EAAE,OAAO,EAAE,KAAK,EAAE,OAAO,EAAE,OAAO,EAAE,YAAY,EAAE;AACzE,IAAI,IAAI,CAAC,OAAO,IAAI,YAAY,EAAE;AAClC,MAAM,QAAQ,CAAC,IAAI,CAAC,IAAI,iBAAiB,CAAC,OAAO,EAAE,KAAK,EAAE,OAAO,EAAE,IAAI,EAAE,YAAY,CAAC;AACtF,IAAI;AACJ,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE,aAAa,CAAC,CAAC,IAAI,EAAE;AACvB,IAAI,OAAO,CAAC,IAAI,CAAC,OAAO,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,WAAW,EAAE,IAAI,CAAC,GAAG,IAAI,CAAC;AACpE,EAAE;AACF;;AAEY,MAAC,qBAAqB,GAAG,IAAI,qBAAqB;;AAE9D;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,cAAc,GAAG,CAAC,KAAK,EAAE,MAAM,EAAE,KAAK,EAAE,GAAG,KAAK;AACtD;AACA,EAAE,MAAM,QAAQ,GAAG,OAAO,CAAC,KAAK,EAAE,QAAQ,CAAC,MAAM,EAAE,KAAK,CAAC;AACzD,EAAE,MAAM,SAAS,GAAG,KAAK,GAAG,QAAQ,CAAC,EAAE,CAAC;AACxC,EAAE,IAAI,OAAO,GAAG,QAAQ,CAAC,MAAM,GAAG,CAAC,GAAG,QAAQ,CAAC,OAAO,CAAC,IAAI,EAAE,GAAG,QAAQ,CAAC;AACzE;AACA,EAAE,IAAI,SAAS,GAAG,CAAC,EAAE;AACrB,IAAI,OAAO,GAAG,OAAO,CAAC,MAAM,CAAC,SAAS;AACtC,EAAE;AACF,EAAE,IAAI,GAAG,GAAG,OAAO,CAAC,SAAS,EAAE,EAAE;AACjC,IAAI,OAAO,CAAC,MAAM,CAAC,GAAG;AACtB,EAAE;AACF,EAAE,OAAO;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,uBAAuB,GAAG,CAAC,EAAE,EAAE,EAAE,EAAE,KAAK,EAAE,GAAG,EAAE,UAAU,KAAK;AACpE,EAAE,MAAM,OAAO,GAAG,WAAW;AAC7B,EAAE,MAAM,OAAO,GAAG,WAAW;AAC7B,EAAE,MAAM,KAAK,GAAG,EAAE,CAAC,QAAQ,CAAC;AAC5B;AACA;AACA;AACA;AACA,EAAE,MAAM,sBAAsB,GAAG,IAAI,GAAG;AACxC;AACA;AACA;AACA,EAAE,IAAI,IAAI,GAAG,OAAO,CAAC,KAAK,EAAE,KAAK;AACjC,EAAE,MAAM,OAAO,GAAG,KAAK,KAAK,GAAG,GAAG,IAAI,IAAI,GAAG,IAAI,IAAI,GAAG,IAAI,GAAG,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC;;AAElF;AACA,EAAE,OAAO,IAAI,CAAC,IAAI,IAAI,IAAI,EAAE;AAC5B,IAAI,IAAI,GAAG,IAAI,CAAC;AAChB,IAAI,IAAI,IAAI,CAAC,OAAO,YAAY,aAAa,IAAI,IAAI,CAAC,OAAO,CAAC,KAAK,IAAI,IAAI,EAAE;AAC7E,MAAM,IAAI,GAAG,IAAI,CAAC;AAClB,MAAM;AACN,IAAI;AACJ,IAAI,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE;AACvB,MAAM,MAAM,KAAK,GAAG,EAAE,CAAC,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE,CAAC,MAAM,EAAE,IAAI,CAAC,EAAE,CAAC,KAAK,EAAE,IAAI,CAAC,MAAM;AAC/E,MAAM,IAAI,KAAK,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC,KAAK,KAAK,IAAI,CAAC,EAAE;AAC7C,QAAQ,KAAK,IAAI,CAAC,GAAG,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE;AACpD,UAAU,MAAM,CAAC,GAAG,KAAK,CAAC,CAAC;AAC3B,UAAU,IAAI,CAAC,CAAC,KAAK,IAAI,IAAI,EAAE;AAC/B,UAAU,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,MAAM,EAAE,CAAC,CAAC,KAAK,EAAE,CAAC,CAAC,GAAG;AACpD,QAAQ;AACR,QAAQ,IAAI,GAAG,IAAI,CAAC;AACpB,QAAQ;AACR,MAAM;AACN,IAAI;AACJ,EAAE;AACF,EAAE,IAAI,YAAY,GAAG;AACrB;AACA,EAAE,QAAQ,EAAE,OAAO,IAAI,IAAI,IAAI,EAAE;AACjC,IAAI,MAAM,UAAU,GAAG,IAAI,CAAC,EAAE,CAAC;AAC/B,IAAI,MAAM,KAAK,GAAG,CAAC,IAAI,CAAC,OAAO,GAAG,EAAE,CAAC,OAAO,GAAG,EAAE,CAAC,OAAO,EAAE,KAAK,CAAC,UAAU,EAAE,IAAI,CAAC,EAAE,CAAC,KAAK,EAAE,IAAI,CAAC,MAAM;AACvG,IAAI,YAAY,KAAK,IAAI,KAAK;AAC9B,IAAI,IAAI,IAAI,CAAC,OAAO,EAAE;AACtB;AACA,MAAM,KAAK,IAAI,CAAC,GAAG,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE;AAClD,QAAQ,MAAM,CAAC,GAAG,KAAK,CAAC,CAAC;AACzB,QAAQ,IAAI,CAAC,CAAC,KAAK,IAAI,IAAI,IAAI,UAAU,EAAE;AAC3C,UAAU,OAAO,CAAC,GAAG,CAAC,UAAU,EAAE,CAAC,CAAC,KAAK,EAAE,CAAC,CAAC,GAAG;AAChD,UAAU,IAAI,UAAU,EAAE;AAC1B;AACA;AACA,YAAY,OAAO,CAAC,GAAG,CAAC,UAAU,EAAE,CAAC,CAAC,KAAK,EAAE,CAAC,CAAC,GAAG;AAClD,UAAU;AACV,QAAQ;AACR,QAAQ,IAAI,EAAE,IAAI,IAAI,EAAE;AACxB,UAAU,MAAM,WAAW,GAAG,iBAAiB,CAAC,EAAE,EAAE,QAAQ,CAAC,UAAU,EAAE,CAAC,CAAC,KAAK,CAAC;AACjF,UAAU,IAAI,CAAC,CAAC,KAAK,IAAI,IAAI,EAAE;AAC/B,YAAY,WAAW,CAAC,OAAO,GAAG,cAAc,CAAC,EAAE,CAAC,aAAa,EAAE,UAAU,EAAE,CAAC,CAAC,KAAK,EAAE,CAAC,CAAC,GAAG;AAC7F,UAAU;AACV,QAAQ;AACR,MAAM;AACN,IAAI,CAAC,MAAM;AACX,MAAM,IAAI,IAAI,CAAC,OAAO,YAAY,aAAa,EAAE;AACjD,QAAQ,MAAM,EAAE,GAAG,EAAE,KAAK,EAAE,GAAG,IAAI,CAAC;AACpC,QAAQ,IAAI,KAAK,IAAI,IAAI,EAAE;AAC3B,UAAU,sBAAsB,CAAC,MAAM,CAAC,GAAG;AAC3C,QAAQ,CAAC,MAAM;AACf,UAAU,sBAAsB,CAAC,GAAG,CAAC,GAAG;AACxC,QAAQ;AACR,MAAM;AACN,MAAM,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AAC7C,QAAQ,MAAM,CAAC,GAAG,KAAK,CAAC,CAAC;AACzB,QAAQ,IAAI,CAAC,CAAC,KAAK,IAAI,IAAI,EAAE;AAC7B,UAAU,OAAO,CAAC,GAAG,CAAC,UAAU,EAAE,CAAC,CAAC,KAAK,EAAE,CAAC,CAAC,GAAG;AAChD,QAAQ,CAAC,MAAM,IAAI,YAAY,IAAI,sBAAsB,CAAC,IAAI,KAAK,CAAC,EAAE;AACtE;AACA,UAAU,MAAM;AAChB,QAAQ;AACR,MAAM;AACN,IAAI;AACJ,IAAI,IAAI,GAAG,IAAI,CAAC;AAChB,EAAE;AACF,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO;AAC3B;;AAEA;AACA;AACA;AACA;AACA;AACO,MAAM,sBAAsB,SAAS,YAAY,CAAC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,WAAW,CAAC,CAAC,OAAO,EAAE,OAAO,EAAE,EAAE,KAAK,GAAG,EAAE,EAAE,GAAG,EAAE,EAAE;AACtD,IAAI,KAAK;AACT,IAAI,MAAM,eAAe,GAAG,8BAA8B,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,EAAC;AAChF,IAAI,MAAM,eAAe,GAAG,8BAA8B,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,EAAC;AAChF,IAAI,MAAM,cAAc,GAAG,8BAA8B,CAAC,OAAO,CAAC,KAAK,EAAC;AACxE,IAAI,MAAM,cAAc,GAAG,8BAA8B,CAAC,OAAO,CAAC,KAAK,EAAC;AACxE,IAAI,IAAI,CAAC,OAAO,GAAG,oBAAoB,CAAC,SAAS,CAAC,eAAe,EAAE,eAAe,CAAC,EAAE,KAAK;AAC1F,IAAI,IAAI,CAAC,OAAO,GAAG,oBAAoB,CAAC,SAAS,CAAC,cAAc,EAAE,cAAc,CAAC,EAAE,KAAK;AACxF,IAAI,IAAI,CAAC,QAAQ,GAAG;AACpB,IAAI,IAAI,CAAC,aAAa,GAAG,OAAO,CAAC;AACjC,IAAI,IAAI,CAAC,QAAQ,GAAG;AACpB;AACA,IAAI,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC,EAAE,CAAC,qBAAqB,EAAE,EAAE,IAAI;AAC5D;AACA,MAAM,MAAM,WAAW,GAAG,SAAS,CAAC,EAAE,CAAC,SAAS,EAAE,eAAe;AACjE,MAAM,eAAe,CAAC,IAAI,CAAC,OAAO,EAAE,oBAAoB,CAAC,WAAW,EAAE,KAAK,CAAC;AAC5E;AACA,MAAM,MAAM,WAAW,GAAG,SAAS,CAAC,SAAS,CAAC,EAAE,CAAC,SAAS,EAAE,cAAc,CAAC,EAAE,IAAI,CAAC,OAAO;AACzF,MAAM,eAAe,CAAC,IAAI,CAAC,OAAO,EAAE,oBAAoB,CAAC,WAAW,EAAE,KAAK,CAAC;AAC5E;AACA,IAAI,CAAC;AACL,IAAI,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC,EAAE,CAAC,qBAAqB,EAAE,EAAE,IAAI;AAC5D,MAAM,eAAe,CAAC,eAAe,EAAE,EAAE,CAAC,SAAS;AACnD,MAAM,eAAe,CAAC,cAAc,EAAE,EAAE,CAAC,SAAS;AAClD;AACA,MAAM,IAAI,EAAE,CAAC,SAAS,CAAC,OAAO,CAAC,IAAI,GAAG,CAAC,EAAE;AACzC,QAAQ,EAAE,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC,SAAS,EAAE,MAAM,KAAK;AACpD,UAAU,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,MAAM,EAAE,SAAS,CAAC,KAAK,EAAE,SAAS,CAAC,GAAG;AACpE,QAAQ,CAAC;AACT,MAAM,CAAC,MAAM;AACb,QAAQ,IAAI,CAAC,OAAO,GAAG,SAAS,CAAC,IAAI,CAAC,OAAO,EAAE,EAAE,CAAC,SAAS;AAC3D,MAAM;AACN;AACA,MAAM,IAAI,EAAE,CAAC,SAAS,CAAC,OAAO,CAAC,IAAI,GAAG,CAAC,EAAE;AACzC,QAAQ,EAAE,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC,SAAS,EAAE,MAAM,KAAK;AACpD,UAAU,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,MAAM,EAAE,SAAS,CAAC,KAAK,EAAE,SAAS,CAAC,GAAG;AACpE,QAAQ,CAAC;AACT,MAAM,CAAC,MAAM;AACb,QAAQ,IAAI,CAAC,OAAO,GAAG,SAAS,CAAC,IAAI,CAAC,OAAO,EAAE,EAAE,CAAC,SAAS;AAC3D,MAAM;AACN;AACA;AACA,MAAM,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC,SAAS,CAAC,WAAW,CAAC,CAAC,EAAE,CAAC,SAAS,EAAE,EAAE,CAAC,SAAS,CAAC,CAAC,EAAE,aAAa,CAAC,EAAE,CAAC,SAAS,EAAE,EAAE,CAAC,SAAS,CAAC,CAAC,EAAE,EAAE,CAAC,MAAM,EAAE,EAAE,CAAC,KAAK,CAAC;AAChJ,IAAI,CAAC;AACL;AACA;AACA,IAAI,IAAI,CAAC,mBAAmB,GAAG,OAAO,CAAC,EAAE,CAAC,QAAQ,EAAE,CAAC,MAAM,EAAE,MAAM,KAAK;AACxE,MAAM,MAAM,KAAK,IAAI,IAAI,WAAW,CAAC,OAAO,EAAE,MAAM;AACpD,IAAI,CAAC;AACL,IAAI,IAAI,CAAC,iBAAiB,GAAG,OAAO,CAAC,EAAE,CAAC,QAAQ,EAAE,CAAC,MAAM,EAAE,MAAM,EAAE,IAAI,EAAE,EAAE,KAAK;AAChF;AACA,MAAM,IAAI,CAAC,IAAI,CAAC,cAAc,IAAI,EAAE,CAAC,KAAK,KAAK,IAAI,CAAC,iBAAiB,IAAI,IAAI,IAAI,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,KAAK,MAAM,CAAC,CAAC,EAAE;AAClI,QAAQ,WAAW,CAAC,OAAO,EAAE,MAAM,EAAE,IAAI;AACzC,MAAM;AACN,IAAI,CAAC;AACL,IAAI,IAAI,CAAC,gBAAgB,GAAG,OAAO,CAAC,EAAE,CAAC,kBAAkB,EAAE,CAAC,EAAE,KAAK;AACnE;AACA;AACA,MAAM,IAAI,CAAC,IAAI,CAAC,cAAc,IAAI,EAAE,CAAC,KAAK,KAAK,IAAI,CAAC,iBAAiB,IAAI,IAAI,IAAI,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,KAAK,EAAE,CAAC,MAAM,CAAC,CAAC,EAAE;AACrI,QAAQ,MAAM,iBAAiB,GAAG,EAAE,CAAC,IAAI,CAAC,GAAG,CAAC,mBAAmB;AACjE,QAAQ,IAAI,iBAAiB,IAAI,IAAI,EAAE;AACvC,UAAU,QAAQ,CAAC,OAAO,EAAE,MAAM;AAClC;AACA,YAAY,MAAM,EAAE,GAAG,IAAI,eAAe;AAC1C,YAAY,QAAQ,CAAC,YAAY,CAAC,EAAE,CAAC,WAAW,EAAE,CAAC,EAAC;AACpD,YAAY,UAAU,CAAC,EAAE,EAAE,iBAAiB;AAC5C,YAAY,WAAW,CAAC,OAAO,EAAE,EAAE,CAAC,YAAY,EAAE;AAClD,UAAU,CAAC,EAAE,IAAI;AACjB,QAAQ;AACR,MAAM;AACN,IAAI,CAAC;AACL,IAAI,IAAI,CAAC,cAAc,GAAG;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,IAAI,CAAC,iBAAiB,GAAG;AAC7B,IAAI,IAAI,CAAC,eAAe,GAAG,OAAO,CAAC,EAAE,CAAC,SAAS,EAAE,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC;AACxE,IAAI,OAAO,CAAC,EAAE,CAAC,SAAS,EAAE,IAAI,CAAC,eAAe;AAC9C,EAAE;;AAEF,EAAE,OAAO,CAAC,GAAG;AACb,IAAI,KAAK,CAAC,OAAO;AACjB,IAAI,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,SAAS,EAAE,IAAI,CAAC,eAAe;AACrD,IAAI,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,SAAS,EAAE,IAAI,CAAC,eAAe;AACrD,IAAI,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,qBAAqB,EAAE,IAAI,CAAC,QAAQ;AAC1D,IAAI,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,qBAAqB,EAAE,IAAI,CAAC,QAAQ;AAC1D,IAAI,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,QAAQ,EAAE,IAAI,CAAC,mBAAmB;AACxD,IAAI,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,QAAQ,EAAE,IAAI,CAAC,iBAAiB;AACtD,IAAI,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,kBAAkB,EAAE,IAAI,CAAC,gBAAgB;AAC/D,EAAE;;AAEF,EAAE,gBAAgB,CAAC,GAAG;AACtB,IAAI,WAAW,CAAC,IAAI,CAAC,QAAQ,EAAE,mBAAmB,CAAC,IAAI,CAAC,QAAQ,CAAC;AACjE,EAAE;;AAEF,EAAE,gBAAgB,CAAC,GAAG;AACtB,IAAI,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,EAAE,IAAI;AACjC,MAAM,WAAW,CAAC,IAAI,CAAC,QAAQ,EAAE,mBAAmB,CAAC,IAAI,CAAC,QAAQ,CAAC;AACnE,MAAM,MAAM,EAAE,GAAG,IAAI,WAAW,CAAC,IAAI,CAAC,QAAQ;AAC9C,MAAM,EAAE,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,SAAS,CAAC,EAAE,CAAC,SAAS,EAAE,EAAE,CAAC,SAAS,CAAC;AACjE,MAAM,EAAE,CAAC,IAAI;AACb,MAAM,EAAE,CAAC,OAAO;AAChB,IAAI,CAAC;AACL,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE,aAAa,CAAC,CAAC,KAAK,EAAE,GAAG,GAAG,KAAK,EAAE;AACrC,IAAI,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE,GAAG,uBAAuB,CAAC,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,EAAE,IAAI;AACrF,IAAI,MAAM,OAAO,GAAG,IAAI,eAAe;AACvC,IAAI,qBAAqB,CAAC,OAAO,EAAE,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,OAAO;AAC/D,IAAI,UAAU,CAAC,OAAO,EAAE,OAAO;AAC/B,IAAI,WAAW,CAAC,IAAI,CAAC,QAAQ,EAAE,OAAO,CAAC,YAAY,EAAE;AACrD,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE,aAAa,CAAC,CAAC,KAAK,EAAE,GAAG,GAAG,KAAK,EAAE;AACrC,IAAI,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,EAAE,IAAI;AACjC,MAAM,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE,GAAG,uBAAuB,CAAC,EAAE,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,EAAE,KAAK;AACtF,MAAM,MAAM,OAAO,GAAG,IAAI,eAAe;AACzC,MAAM,qBAAqB,CAAC,OAAO,EAAE,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,OAAO;AACjE,MAAM,UAAU,CAAC,OAAO,EAAE,OAAO;AACjC,MAAM,MAAM,EAAE,GAAG,IAAI,WAAW,CAAC,IAAI,CAAC,QAAQ;AAC9C,MAAM,EAAE,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,SAAS,CAAC,OAAO,EAAE,OAAO,CAAC;AACvD,MAAM,EAAE,CAAC,IAAI;AACb,MAAM,EAAE,CAAC,OAAO;AAChB,IAAI,CAAC;AACL,IAAI,IAAI,CAAC,aAAa,CAAC,KAAK,EAAE,GAAG;AACjC,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,WAAW,CAAC,CAAC,QAAQ,EAAE,MAAM,EAAE,KAAK,EAAE,OAAO,EAAE,QAAQ,EAAE,YAAY,EAAE;AACzE,IAAI,MAAM,KAAK,GAAG,CAAC,OAAO,GAAG,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,OAAO,EAAE,KAAK,CAAC,MAAM,EAAE,KAAK,EAAE,QAAQ,CAAC,SAAS,EAAE;AACnG;AACA;AACA;AACA,IAAI,IAAI,OAAO,GAAG,KAAK,CAAC,MAAM,KAAK,CAAC,GAAG,QAAQ,GAAG,QAAQ,CAAC,IAAI;AAC/D,IAAI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AAC3C,MAAM,MAAM,CAAC,GAAG,KAAK,CAAC,CAAC;AACvB,MAAM,IAAI,OAAO,IAAI,IAAI,IAAI,OAAO,YAAY,cAAc,EAAE;AAChE,QAAQ,IAAI,CAAC,CAAC,YAAY,IAAI,CAAC,CAAC,KAAK,IAAI,IAAI,KAAK,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,EAAE,CAAC,CAAC,KAAK,CAAC,EAAE;AACrF,UAAU;AACV,QAAQ;AACR;AACA,QAAQ,MAAM,QAAQ,GAAG,OAAO,CAAC,IAAI,CAAC,aAAa,EAAE,QAAQ,CAAC,MAAM,EAAE,CAAC,CAAC,KAAK,CAAC;AAC9E,QAAQ,MAAM,SAAS,GAAG,CAAC,CAAC,KAAK,GAAG,QAAQ,CAAC,EAAE,CAAC;AAChD,QAAQ,OAAO,GAAG,QAAQ,CAAC,MAAM,GAAG,CAAC,GAAG,QAAQ,CAAC,OAAO,CAAC,IAAI,EAAE,GAAG,QAAQ,CAAC;AAC3E;AACA,QAAQ,IAAI,SAAS,GAAG,CAAC,EAAE;AAC3B,UAAU,OAAO,GAAG,OAAO,CAAC,MAAM,CAAC,SAAS;AAC5C,QAAQ;AACR,MAAM;AACN,MAAM,MAAM,CAAC,mCAAmC,OAAO;AACvD,MAAM,MAAM,IAAI,GAAG,CAAC,CAAC,SAAS;AAC9B,MAAM,IAAI,IAAI,GAAG,CAAC,CAAC,GAAG,EAAE;AACxB,QAAQ,KAAK,CAAC,MAAM,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,oBAAoB,CAAC,CAAC,CAAC,KAAK,GAAG,IAAI,EAAE,CAAC,CAAC,GAAG,GAAG,IAAI,EAAE,CAAC,CAAC,KAAK,CAAC;AAC1F,QAAQ,CAAC,CAAC,GAAG,GAAG;AAChB,MAAM;AACN,MAAM,OAAO,GAAG,CAAC,CAAC,GAAG,GAAG,IAAI,GAAG,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG;AACjD,MAAM,IAAI,YAAY,IAAI,CAAC,OAAO,IAAI,CAAC,CAAC,KAAK,IAAI,IAAI,EAAE;AACvD,QAAQ,QAAQ,CAAC,IAAI,CAAC,IAAI,iBAAiB,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,EAAE,OAAO,EAAE,CAAC,CAAC,KAAK,EAAE,YAAY,CAAC;AACvF,MAAM;AACN,IAAI;AACJ,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE,aAAa,CAAC,CAAC,IAAI,EAAE;AACvB,IAAI,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE;AACvB,MAAM,OAAO,IAAI,CAAC,OAAO,CAAC,WAAW,EAAE,GAAG,IAAI,CAAC,MAAM,GAAG;AACxD,IAAI;AACJ;AACA;AACA;AACA,IAAI,MAAM,EAAE,GAAG;AACf,IAAI,IAAI,CAAC,WAAW,CAAC,EAAE,EAAE,IAAI,CAAC,EAAE,CAAC,MAAM,EAAE,IAAI,CAAC,EAAE,CAAC,KAAK,EAAE,IAAI,EAAE,IAAI,CAAC,OAAO,EAAE,CAAC;AAC7E,IAAI,OAAO,EAAE,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,CAAC,KAAK,GAAG,IAAI,CAAC,CAAC,CAAC,KAAK,IAAI,IAAI,IAAI,CAAC,CAAC,OAAO,CAAC,WAAW,EAAE,IAAI,CAAC,CAAC,OAAO,CAAC,SAAS,EAAE,GAAG,CAAC,CAAC,EAAE,CAAC;AACpH,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,gCAAgC,GAAG,CAAC,OAAO,EAAE,OAAO,EAAE,OAAO,KAAK,IAAI,sBAAsB,CAAC,OAAO,EAAE,OAAO,EAAE,OAAO;;AAEnI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,MAAM,0BAA0B,SAAS,YAAY,CAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,WAAW,CAAC,CAAC,YAAY,EAAE,YAAY,EAAE,EAAE,KAAK,GAAG,EAAE,EAAE,GAAG,EAAE,EAAE;AAChE,IAAI,KAAK;AACT,IAAI,IAAI,CAAC,YAAY,GAAG;AACxB,IAAI,IAAI,CAAC,YAAY,GAAG;AACxB,IAAI,MAAM,OAAO,GAAG,WAAW;AAC/B,IAAI,MAAM,OAAO,GAAG,oBAAoB,CAAC,SAAS,CAAC,YAAY,CAAC,EAAE,EAAE,YAAY,CAAC,EAAE,CAAC,EAAE,KAAK;AAC3F,IAAI,YAAY,CAAC,EAAE,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,MAAM,KAAK;AAC/C,MAAM,MAAM,SAAS,GAAG,YAAY,CAAC,EAAE,CAAC,GAAG,CAAC,MAAM,CAAC,IAAI;AACvD,MAAM,OAAO,CAAC,GAAG,CAAC,MAAM,EAAE,CAAC,EAAE,SAAS,EAAE,EAAE,EAAC;AAC3C,MAAM,OAAO,CAAC,GAAG,CAAC,MAAM,EAAE,SAAS,EAAE,KAAK,GAAG,SAAS,EAAE,KAAK,EAAC;AAC9D,IAAI,CAAC;AACL,IAAI,IAAI,CAAC,KAAK,GAAG,WAAW,CAAC,CAAC,SAAS,CAAC,OAAO,EAAE,YAAY,CAAC,EAAE,CAAC,EAAE,OAAO,CAAC;AAC3E,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,WAAW,CAAC,CAAC,QAAQ,EAAE,MAAM,EAAE,KAAK,EAAE,QAAQ,EAAE,OAAO,EAAE,YAAY,EAAE;AACzE,IAAI,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,EAAE,CAAC,GAAG,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,KAAK,EAAE,MAAM;AAChE,IAAI,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,MAAM,EAAE,KAAK,EAAE,OAAO,CAAC,SAAS,EAAE;AACrE,IAAI,OAAO,GAAG,KAAK,CAAC,MAAM,KAAK,CAAC,GAAG,OAAO,GAAG,OAAO,CAAC,IAAI;AACzD,IAAI,KAAK,CAAC,OAAO,CAAC,CAAC,IAAI;AACvB,MAAM,MAAM,OAAO,GAAG,IAAI,CAAC,YAAY,CAAC,EAAE,CAAC,GAAG,CAAC,MAAM,EAAE,CAAC,CAAC,KAAK;AAC9D,MAAM,MAAM,WAAW,GAAG,CAAC,IAAI,CAAC,YAAY,CAAC,EAAE,CAAC,GAAG,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;AACvE,MAAM,MAAM,CAAC,GAAG;AAChB,MAAM,IAAI,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC,SAAS,EAAE,EAAE;AACjC,QAAQ,OAAO,GAAG,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,GAAG;AAChC,MAAM;AACN,MAAM,IAAI,WAAW,EAAE;AACvB,MAAM,IAAI,YAAY,IAAI,CAAC,OAAO,KAAK,CAAC,CAAC,KAAK,IAAI,IAAI,IAAI,CAAC,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,EAAE;AAC/E,QAAQ,IAAI,kBAAkB,GAAG,CAAC,CAAC,KAAK,EAAE,MAAM,CAAC,IAAI,IAAI,IAAI,CAAC,IAAI,KAAK,QAAQ,CAAC,IAAI;AACpF,QAAQ,IAAI,CAAC,CAAC,KAAK,EAAE,MAAM,KAAK,CAAC,EAAE;AACnC,UAAU,kBAAkB,GAAG;AAC/B,QAAQ;AACR,QAAQ,QAAQ,CAAC,IAAI,CAAC,IAAI,iBAAiB,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,EAAE,OAAO,EAAE,kBAAkB,EAAE,YAAY,CAAC;AAClG,MAAM;AACN,IAAI,CAAC;AACL,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE,aAAa,CAAC,CAAC,IAAI,EAAE;AACvB,IAAI,OAAO,IAAI,CAAC,OAAO,CAAC,WAAW;AACnC,SAAS,IAAI,CAAC;AACd,YAAY,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,CAAC,KAAK,CAAC,CAAC,KAAK,IAAI,IAAI,GAAG,GAAG,GAAG,CAAC,CAAC,GAAG,GAAG,GAAG,EAAE,CAAC;AAC9G,YAAY,IAAI,CAAC;AACjB;AACA,QAAQ;AACR,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,qCAAqC,GAAG,CAAC,YAAY,EAAE,YAAY,GAAG,YAAY,EAAE,OAAO,KAAK,IAAI,0BAA0B,CAAC,YAAY,EAAE,YAAY,EAAE,OAAO;;AClnB/K;AACA;AACA;AACA;AACA;AACY,MAAC,eAAe,GAAG,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,gCAAgC,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,GAAG,EAAE,KAAK;AACnG,EAAE,MAAM,CAAC,GAAG,KAAK,CAAC,MAAM;AACxB,EAAE,EAAE,CAAC,QAAQ,CAAC,EAAE,IAAI;AACpB,IAAI,EAAE,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,QAAQ,KAAK;AACzC,MAAM,MAAM,UAAU,GAAG,SAAS,CAAC,8BAA8B,CAAC,EAAE,CAAC,KAAK,EAAE,KAAK,CAAC,EAAE,8BAA8B,CAAC,EAAE,CAAC,KAAK,EAAE,KAAK,CAAC;AACnI,MAAM,MAAM,UAAU,GAAG,SAAS,CAAC,8BAA8B,CAAC,EAAE,CAAC,KAAK,CAAC,EAAE,8BAA8B,CAAC,EAAE,CAAC,KAAK,CAAC;AACrH;AACA,MAAM,MAAM,WAAW,GAAG,SAAS,CAAC,UAAU,EAAE,UAAU;AAC1D,MAAM,MAAM,WAAW,GAAG,SAAS,CAAC,UAAU,EAAE,UAAU;AAC1D,MAAM,MAAM,aAAa,GAAG,WAAW,CAAC,CAAC,WAAW,EAAE,UAAU,CAAC;AACjE;AACA;AACA;AACA,MAAM,MAAM,YAAY,GAAG,IAAI,GAAG;AAClC,MAAM,qBAAqB,CAAC,EAAE,EAAE,aAAa,2BAA2B,IAAI,IAAI;AAChF,QAAQ,OAAO,IAAI,YAAY,IAAI,EAAE;AACrC,UAAU,MAAM,MAAM,gCAAgC,IAAI,CAAC,MAAM;AACjE,UAAU,MAAM,IAAI,GAAG,GAAG,CAAC,cAAc,CAAC,YAAY,EAAE,MAAM,EAAE,GAAG,CAAC,MAAM;AAC1E,UAAU,IAAI,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,SAAS,CAAC,EAAE,KAAK;AAC7C,UAAU,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,SAAS;AACjC,UAAU,IAAI,GAAG,MAAM,CAAC;AACxB,QAAQ;AACR,MAAM,CAAC;AACP,MAAM,MAAM,QAAQ,GAAG,YAAY,CAAC,GAAG,CAAC,IAAI;AAC5C,MAAM,IAAI,QAAQ,EAAE;AACpB;AACA,QAAQ,MAAM,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC,EAAE,EAAE;AAC/C,UAAU,aAAa,EAAE,aAAa,EAAE,IAAI,EAAE,YAAY,EAAE,WAAW,EAAE,QAAQ,EAAE,YAAY,EAAE,IAAI,EAAE;AACvG,SAAS;AACT,QAAQ,CAAC,CAAC,MAAM,CAAC,QAAQ,EAAE,UAAU;AACrC,MAAM;AACN,IAAI,CAAC;AACL,EAAE,CAAC;AACH,EAAE,OAAO;AACT;;ACnBA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACY,MAAC,mBAAmB,GAAG,MAAM,EAAEC,OAAG,CAAC,IAAI,CAAC,iEAAiE,EAAC,CAAC;;AAEvH,MAAM,eAAe,GAAG;;AAExB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,2BAA2B,GAAG;;AAE3B,MAAM,iBAAiB,CAAC;AAC/B;AACA;AACA;AACA;AACA,EAAE,WAAW,CAAC,CAAC,CAAC,EAAE,KAAK,EAAE;AACzB,IAAI,CAAC,CAAC,MAAM,GAAG;AACf,IAAI,IAAI,CAAC,CAAC,GAAG;AACb,IAAI,IAAI,CAAC,KAAK,GAAG;AACjB,IAAI,IAAI,CAAC,SAAS,GAAG,2BAA2B;AAChD,EAAE;AACF;;AAEA;AACA;AACA;AACA,MAAM,sBAAsB,GAAG,MAAM,IAAI,EAAE,MAAM,CAAC,SAAS,GAAG,2BAA2B,GAAE,CAAC;;AAE5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,eAAe,GAAG,CAAC,MAAM,EAAE,CAAC,EAAE,KAAK,KAAK;AAC9C,EAAE,MAAM,CAAC,CAAC,CAAC,MAAM,GAAG;AACpB,EAAE,MAAM,CAAC,CAAC,GAAG;AACb,EAAE,CAAC,CAAC,MAAM,GAAG;AACb,EAAE,MAAM,CAAC,KAAK,GAAG;AACjB,EAAE,MAAM,CAAC,SAAS,GAAG,2BAA2B;AAChD;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM,YAAY,GAAG,CAAC,YAAY,EAAE,CAAC,EAAE,KAAK,KAAK;AACjD,EAAE,IAAI,YAAY,CAAC,MAAM,IAAI,eAAe,EAAE;AAC9C;AACA,IAAI,MAAM,MAAM,GAAG,YAAY,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,SAAS,GAAG,CAAC,CAAC,SAAS,GAAG,CAAC,GAAG,CAAC;AAClF,IAAI,eAAe,CAAC,MAAM,EAAE,CAAC,EAAE,KAAK;AACpC,IAAI,OAAO;AACX,EAAE,CAAC,MAAM;AACT;AACA,IAAI,MAAM,EAAE,GAAG,IAAI,iBAAiB,CAAC,CAAC,EAAE,KAAK;AAC7C,IAAI,YAAY,CAAC,IAAI,CAAC,EAAE;AACxB,IAAI,OAAO;AACX,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,UAAU,GAAG,CAAC,MAAM,EAAE,KAAK,KAAK;AAC7C,EAAE,IAAI,MAAM,CAAC,MAAM,KAAK,IAAI,IAAI,KAAK,KAAK,CAAC,IAAI,MAAM,CAAC,aAAa,KAAK,IAAI,EAAE;AAC9E,IAAI,OAAO;AACX,EAAE;AACF,EAAE,MAAM,MAAM,GAAG,MAAM,CAAC,aAAa,CAAC,MAAM,KAAK,CAAC,GAAG,IAAI,GAAG,MAAM,CAAC,aAAa,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,KAAK,IAAI,CAAC,GAAG,CAAC,KAAK,GAAG,CAAC,CAAC,KAAK,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,GAAG,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC;AAC/J,EAAE,IAAI,CAAC,GAAG,MAAM,CAAC;AACjB,EAAE,IAAI,MAAM,GAAG;AACf,EAAE,IAAI,MAAM,KAAK,IAAI,EAAE;AACvB,IAAI,CAAC,GAAG,MAAM,CAAC;AACf,IAAI,MAAM,GAAG,MAAM,CAAC;AACpB,IAAI,sBAAsB,CAAC,MAAM,EAAC;AAClC,EAAE;AACF;AACA,EAAE,OAAO,CAAC,CAAC,KAAK,KAAK,IAAI,IAAI,MAAM,GAAG,KAAK,EAAE;AAC7C,IAAI,IAAI,CAAC,CAAC,CAAC,OAAO,IAAI,CAAC,CAAC,SAAS,EAAE;AACnC,MAAM,IAAI,KAAK,GAAG,MAAM,GAAG,CAAC,CAAC,MAAM,EAAE;AACrC,QAAQ;AACR,MAAM;AACN,MAAM,MAAM,IAAI,CAAC,CAAC;AAClB,IAAI;AACJ,IAAI,CAAC,GAAG,CAAC,CAAC;AACV,EAAE;AACF;AACA,EAAE,OAAO,CAAC,CAAC,IAAI,KAAK,IAAI,IAAI,MAAM,GAAG,KAAK,EAAE;AAC5C,IAAI,CAAC,GAAG,CAAC,CAAC;AACV,IAAI,IAAI,CAAC,CAAC,CAAC,OAAO,IAAI,CAAC,CAAC,SAAS,EAAE;AACnC,MAAM,MAAM,IAAI,CAAC,CAAC;AAClB,IAAI;AACJ,EAAE;AACF;AACA;AACA;AACA,EAAE,OAAO,CAAC,CAAC,IAAI,KAAK,IAAI,IAAI,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,MAAM,KAAK,CAAC,CAAC,EAAE,CAAC,MAAM,IAAI,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,KAAK,GAAG,CAAC,CAAC,IAAI,CAAC,MAAM,KAAK,CAAC,CAAC,EAAE,CAAC,KAAK,EAAE;AAChH,IAAI,CAAC,GAAG,CAAC,CAAC;AACV,IAAI,IAAI,CAAC,CAAC,CAAC,OAAO,IAAI,CAAC,CAAC,SAAS,EAAE;AACnC,MAAM,MAAM,IAAI,CAAC,CAAC;AAClB,IAAI;AACJ,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,IAAI,MAAM,KAAK,IAAI,IAAI,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,KAAK,GAAG,MAAM,CAAC,sBAAsB,CAAC,CAAC,CAAC,MAAM,EAAE,MAAM,GAAG,eAAe,EAAE;AACnH;AACA,IAAI,eAAe,CAAC,MAAM,EAAE,CAAC,EAAE,MAAM;AACrC,IAAI,OAAO;AACX,EAAE,CAAC,MAAM;AACT;AACA,IAAI,OAAO,YAAY,CAAC,MAAM,CAAC,aAAa,EAAE,CAAC,EAAE,MAAM;AACvD,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,mBAAmB,GAAG,CAAC,YAAY,EAAE,KAAK,EAAE,GAAG,KAAK;AACjE,EAAE,KAAK,IAAI,CAAC,GAAG,YAAY,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE;AACrD,IAAI,MAAM,CAAC,GAAG,YAAY,CAAC,CAAC;AAC5B,IAAI,IAAI,GAAG,GAAG,CAAC,EAAE;AACjB;AACA;AACA;AACA,MAAM,IAAI,CAAC,GAAG,CAAC,CAAC;AAChB,MAAM,CAAC,CAAC,MAAM,GAAG;AACjB;AACA;AACA;AACA,MAAM,OAAO,CAAC,KAAK,CAAC,CAAC,OAAO,IAAI,CAAC,CAAC,CAAC,SAAS,CAAC,EAAE;AAC/C,QAAQ,CAAC,GAAG,CAAC,CAAC;AACd,QAAQ,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,OAAO,IAAI,CAAC,CAAC,SAAS,EAAE;AAC5C;AACA,UAAU,CAAC,CAAC,KAAK,IAAI,CAAC,CAAC;AACvB,QAAQ;AACR,MAAM;AACN,MAAM,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,CAAC,MAAM,KAAK,IAAI,EAAE;AAC3C;AACA,QAAQ,YAAY,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC;AAChC,QAAQ;AACR,MAAM;AACN,MAAM,CAAC,CAAC,CAAC,GAAG;AACZ,MAAM,CAAC,CAAC,MAAM,GAAG;AACjB,IAAI;AACJ,IAAI,IAAI,KAAK,GAAG,CAAC,CAAC,KAAK,KAAK,GAAG,GAAG,CAAC,IAAI,KAAK,KAAK,CAAC,CAAC,KAAK,CAAC,EAAE;AAC3D,MAAM,CAAC,CAAC,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,EAAE,CAAC,CAAC,KAAK,GAAG,GAAG;AAC7C,IAAI;AACJ,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,eAAe,GAAG,CAAC,IAAI;AACpC,EAAE,CAAC,CAAC,GAAG,IAAI,mBAAmB;AAC9B,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC;AACZ,EAAE,MAAM,GAAG,GAAG;AACd,EAAE,OAAO,CAAC,EAAE;AACZ,IAAI,GAAG,CAAC,IAAI,CAAC,CAAC;AACd,IAAI,CAAC,GAAG,CAAC,CAAC;AACV,EAAE;AACF,EAAE,OAAO;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,iBAAiB,GAAG,CAAC,IAAI,EAAE,WAAW,EAAE,KAAK,KAAK;AAC/D,EAAE,MAAM,WAAW,GAAG;AACtB,EAAE,MAAM,kBAAkB,GAAG,WAAW,CAAC;AACzC,EAAE,OAAO,IAAI,EAAE;AACf;AACA,IAAI,GAAG,CAAC,cAAc,CAAC,kBAAkB,EAAE,IAAI,EAAE,MAAM,EAAE,CAAC,CAAC,IAAI,CAAC,KAAK;AACrE,IAAI,IAAI,IAAI,CAAC,KAAK,KAAK,IAAI,EAAE;AAC7B,MAAM;AACN,IAAI;AACJ,IAAI,IAAI,qDAAqD,IAAI,CAAC,KAAK,CAAC,MAAM;AAC9E,EAAE;AACF,EAAE,yBAAyB,qBAAqB,WAAW,CAAC,GAAG,GAAG,KAAK,EAAE,WAAW;AACpF;;AAEA;AACA;AACA;AACA;AACA;AACO,MAAM,YAAY,CAAC;AAC1B,EAAE,WAAW,CAAC,GAAG;AACjB;AACA;AACA;AACA,IAAI,IAAI,CAAC,KAAK,GAAG;AACjB;AACA;AACA;AACA,IAAI,IAAI,CAAC,IAAI,GAAG,IAAI,GAAG;AACvB;AACA;AACA;AACA,IAAI,IAAI,CAAC,MAAM,GAAG;AAClB;AACA;AACA;AACA,IAAI,IAAI,CAAC,GAAG,GAAG;AACf,IAAI,IAAI,CAAC,OAAO,GAAG;AACnB;AACA;AACA;AACA;AACA,IAAI,IAAI,CAAC,GAAG,GAAG,kBAAkB;AACjC;AACA;AACA;AACA;AACA,IAAI,IAAI,CAAC,IAAI,GAAG,kBAAkB;AAClC;AACA;AACA;AACA,IAAI,IAAI,CAAC,aAAa,GAAG;AACzB;AACA;AACA;AACA,IAAI,IAAI,CAAC,OAAO,GAAG;AACnB,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE,IAAI,MAAM,CAAC,GAAG;AAChB,IAAI,2BAA2B,KAAK,CAAC,MAAM,EAAE;AAC7C,EAAE;;AAEF;AACA;AACA;AACA,EAAE,IAAI,MAAM,CAAC,GAAG;AAChB,IAAI,yDAAyD,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,IAAI;AAClG,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,UAAU,CAAC,CAAC,CAAC,EAAE,IAAI,EAAE;AACvB,IAAI,IAAI,CAAC,GAAG,GAAG;AACf,IAAI,IAAI,CAAC,KAAK,GAAG;AACjB,IAAI,IAAI,IAAI,CAAC,OAAO,EAAE;AACtB,MAAM,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,OAAO;AAClC,MAAM,IAAI,CAAC,OAAO,GAAG;AACrB,IAAI;AACJ,EAAE;;AAEF;AACA;AACA;AACA,EAAE,KAAK,CAAC,GAAG;AACX;AACA,IAAI,OAAO,IAAI,IAAI,CAAC,WAAW;AAC/B,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,KAAK,CAAC,GAAG;AACX;AACA,IAAI,MAAM,KAAK,CAAC,mBAAmB;AACnC,EAAE;;AAEF;AACA;AACA;AACA,EAAE,MAAM,CAAC,CAAC,QAAQ,EAAE,EAAE;;AAEtB;AACA;AACA;AACA,EAAE,IAAI,MAAM,CAAC,GAAG;AAChB,IAAI,IAAI,CAAC,GAAG,IAAI,CAAC;AACjB,IAAI,OAAO,CAAC,KAAK,IAAI,IAAI,CAAC,CAAC,OAAO,EAAE;AACpC,MAAM,CAAC,GAAG,CAAC,CAAC;AACZ,IAAI;AACJ,IAAI,OAAO;AACX,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,aAAa,CAAC,CAAC,WAAW,EAAE,UAAU,EAAE;AAC1C,IAAI,MAAM,KAAK,GAAG,IAAI,MAAM,qBAAqB,IAAI,GAAG,WAAW,EAAE,UAAU;AAC/E,IAAI,iBAAiB,qBAAqB,IAAI,GAAG,WAAW,EAAE,KAAK;AACnE,IAAI,IAAI,CAAC,WAAW,CAAC,KAAK,IAAI,IAAI,CAAC,aAAa,EAAE;AAClD,MAAM,IAAI,CAAC,aAAa,CAAC,MAAM,GAAG;AAClC,IAAI;AACJ,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE;AACd,IAAI,uBAAuB,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC;AACvC,IAAI,OAAO;AACX,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,WAAW,CAAC,CAAC,CAAC,EAAE;AAClB,IAAI,uBAAuB,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC;AACxC,IAAI,OAAO;AACX,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE,SAAS,CAAC,CAAC,CAAC,EAAE;AAChB,IAAI,0BAA0B,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC;AAC1C,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE,aAAa,CAAC,CAAC,CAAC,EAAE;AACpB,IAAI,0BAA0B,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC;AAC3C,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE,MAAM,CAAC,GAAG,CAAC;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,UAAU,CAAC,CAAC,EAAE,GAAG,qBAAqB,EAAE,IAAI,GAAG,EAAE,EAAE;AACrD,IAAI,MAAM,EAAE,aAAa,GAAG,IAAI,EAAE,aAAa,GAAG,KAAK,EAAE,aAAa,GAAG,KAAK,EAAE,YAAY,GAAG,IAAI,EAAE,QAAQ,GAAG,IAAI,EAAE,IAAI,GAAG,KAAK,EAAE,GAAG;AACvI,IAAI,MAAM,WAAW,GAAG,QAAQ,EAAE,GAAG,CAAC,IAAI,CAAC,IAAI;AAC/C,IAAI,MAAM,cAAc,IAAI,QAAQ,IAAI,IAAI,IAAI,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,GAAG,CAAC,IAAI,CAAC;AAClF;AACA;AACA;AACA,IAAI,MAAM,CAAC,uBAAuB,KAAK,CAAC,MAAM,oBAAoB,CAAC,IAAI,EAAE,QAAQ,IAAI,IAAI,CAAC;AAC1F,IAAI,MAAM,OAAO,GAAG,QAAQ,IAAI,IAAI,GAAG,IAAI,GAAG,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,IAAI,EAAE,EAAE,QAAQ,EAAE,IAAI,EAAE;AACxF,IAAI,eAAe,CAAC,CAAC,sBAAsB,IAAI,GAAG,WAAW,EAAE,EAAE,EAAE,IAAI,EAAE,QAAQ,EAAE,YAAY,EAAE,aAAa,EAAE,IAAI,EAAE,OAAO;AAC7H,IAAI,IAAI,cAAc,EAAE;AACxB;AACA;AACA;AACA,MAAM,IAAI,iBAAiB,GAAG,GAAE;AAChC,MAAM,IAAI,sBAAsB,GAAG;AACnC;AACA;AACA;AACA,MAAM,IAAI,iBAAiB,GAAG,GAAE;AAChC,MAAM,IAAI,sBAAsB,GAAG;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,MAAM,8BAA8B,GAAG,GAAE;AAC/C;AACA;AACA;AACA,MAAM,MAAM,kBAAkB,GAAG,GAAE;AACnC;AACA;AACA;AACA,MAAM,MAAM,EAAE,GAAG;AACjB,MAAM,KAAK,IAAI,IAAI,GAAG,IAAI,CAAC,MAAM,EAAE,IAAI,KAAK,IAAI,EAAE,EAAE,CAAC,MAAM,GAAG,CAAC,EAAE;AACjE,QAAQ,IAAI,aAAa,IAAI,IAAI,EAAE;AACnC,UAAU,OAAO,IAAI,KAAK,IAAI,IAAI,EAAE,CAAC,MAAM,GAAG,EAAE,EAAE,IAAI,GAAG,IAAI,CAAC,KAAK,EAAE;AACrE,YAAY,MAAM,MAAM,GAAG,aAAa,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE,CAAC,MAAM,EAAE,IAAI,CAAC,EAAE,CAAC,KAAK,EAAE,IAAI,CAAC,MAAM;AACzF,YAAY,IAAI,WAAW,GAAG,MAAM,CAAC,MAAM,GAAG,CAAC,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE,GAAG,IAAI,CAAC;AAC7E,YAAY,KAAK,IAAI,EAAE,GAAG,CAAC,EAAE,EAAE,GAAG,MAAM,CAAC,MAAM,EAAE,EAAE,EAAE,EAAE;AACvD,cAAc,MAAM,OAAO,GAAG,MAAM,CAAC,EAAE;AACvC,cAAc,MAAM,OAAO,GAAG;AAC9B,cAAc,IAAI,EAAE,KAAK,MAAM,CAAC,MAAM,GAAG,CAAC,EAAE;AAC5C,gBAAgB,WAAW,GAAG,WAAW,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG;AAC5D,cAAc;AACd,cAAc,EAAE,CAAC,WAAW,CAAC,EAAE,EAAE,IAAI,CAAC,EAAE,CAAC,MAAM,EAAE,OAAO,CAAC,KAAK,EAAE,IAAI,CAAC,OAAO,EAAE,OAAO,EAAE,OAAO,CAAC,MAAM,GAAG,CAAC,GAAG,CAAC;AAC7G,YAAY;AACZ,UAAU;AACV,QAAQ,CAAC,MAAM;AACf,UAAU,OAAO,IAAI,KAAK,IAAI,IAAI,EAAE,CAAC,MAAM,GAAG,EAAE,EAAE,IAAI,GAAG,IAAI,CAAC,KAAK,EAAE;AACrE,YAAY,EAAE,CAAC,WAAW,CAAC,EAAE,EAAE,IAAI,CAAC,EAAE,CAAC,MAAM,EAAE,IAAI,CAAC,EAAE,CAAC,KAAK,EAAE,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,OAAO,EAAE,CAAC;AAC3F,UAAU;AACV,QAAQ;AACR,QAAQ,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AAC5C,UAAU,MAAM,CAAC,GAAG,EAAE,CAAC,CAAC;AACxB;AACA,UAAU,MAAM,aAAa,GAAG,CAAC,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC,OAAO,IAAI,CAAC,CAAC,KAAK,IAAI,IAAI;AAC1E;AACA;AACA,UAAU,MAAM,YAAY,GAAG,CAAC,CAAC,MAAM,IAAI,CAAC,CAAC;AAC7C;AACA,UAAU,MAAM,aAAa,GAAG,CAAC,CAAC,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC,OAAO,IAAI,CAAC,CAAC,KAAK,IAAI,IAAI;AAC3E,UAAU,MAAM,WAAW,GAAG,CAAC,aAAa,IAAI,CAAC,CAAC,OAAO,CAAC,WAAW,KAAK,aAAa,IAAI,qCAAqC,CAAC,CAAC,CAAC,KAAK,EAAE,CAAC,CAAC,OAAO,CAAC,GAAG;AACvJ,UAAU,QAAQ,CAAC,CAAC,OAAO,CAAC,WAAW;AACvC,YAAY,KAAK,cAAc,EAAE;AACjC,cAAc,IAAI,YAAY,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,OAAO,CAAC,SAAS,EAAE;AAC9D,cAAc;AACd,YAAY;AACZ,YAAY,KAAK,aAAa;AAC9B,cAAc,IAAI,aAAa,EAAE;AACjC,gBAAgB,CAAC,CAAC,cAAc,GAAG;AACnC,gBAAgB,sBAAsB,GAAG;AACzC,gBAAgB,IAAI,CAAC,CAAC,OAAO,GAAG,aAAa,GAAG,aAAa,EAAE;AAC/D,kBAAkB,CAAC,CAAC,MAAM,8BAA8B,CAAC,CAAC,CAAC,OAAO,EAAE,GAAG,CAAC,MAAM,EAAE,IAAI,EAAE,WAAW,IAAI,EAAE;AACvG,gBAAgB,CAAC,MAAM;AACvB,kBAAkB,CAAC,CAAC,MAAM,8BAA8B,CAAC,CAAC,CAAC,OAAO,EAAE,GAAG,EAAE,IAAI,EAAE,WAAW;AAC1F,gBAAgB;AAChB,cAAc,CAAC,MAAM,IAAI,YAAY,EAAE;AACvC,gBAAgB,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,OAAO,CAAC,SAAS,EAAE;AAC9C,cAAc,CAAC,MAAM,IAAI,aAAa,EAAE;AACxC,gBAAgB,CAAC,CAAC,cAAc,GAAG;AACnC,gBAAgB,sBAAsB,GAAG;AACzC,gBAAgB,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,OAAO,CAAC,SAAS,EAAE;AAC9C,cAAc;AACd,cAAc;AACd,YAAY,KAAK,YAAY;AAC7B,YAAY,KAAK,UAAU;AAC3B,YAAY,KAAK,WAAW;AAC5B,YAAY,KAAK,WAAW;AAC5B,YAAY,KAAK,aAAa;AAC9B,cAAc,IAAI,aAAa,EAAE;AACjC,gBAAgB,CAAC,CAAC,cAAc,GAAG;AACnC,gBAAgB,sBAAsB,GAAG;AACzC,gBAAgB,IAAI,CAAC,CAAC,OAAO,GAAG,aAAa,GAAG,aAAa,EAAE;AAC/D,kBAAkB,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,OAAO,CAAC,SAAS,EAAE,EAAE,IAAI,EAAE,WAAW,IAAI,EAAE;AACzE,gBAAgB,CAAC,MAAM,IAAI,IAAI,IAAI,CAAC,CAAC,OAAO,CAAC,WAAW,KAAK,WAAW,EAAE;AAC1E,kBAAkB,CAAC,CAAC,MAAM,CAAC,mBAAmB,CAAC,CAAC,CAAC,OAAO,EAAE,IAAI,CAAC,UAAU,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,EAAE,IAAI,EAAE,WAAW;AAC1G,gBAAgB,CAAC,MAAM;AACvB,kBAAkB,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,OAAO,CAAC,UAAU,EAAE,EAAE,IAAI,EAAE,WAAW;AACpE,gBAAgB;AAChB,cAAc,CAAC,MAAM,IAAI,YAAY,EAAE;AACvC,gBAAgB,CAAC,CAAC,MAAM,CAAC,CAAC;AAC1B,cAAc,CAAC,MAAM,IAAI,aAAa,EAAE;AACxC,gBAAgB,IAAI,CAAC,CAAC,OAAO,CAAC,WAAW,KAAK,WAAW,IAAI,QAAQ,EAAE,GAAG,4BAA4B,CAAC,CAAC,CAAC,OAAO,EAAE,IAAI,CAAC,EAAE;AACzH;AACA,kBAAkB,CAAC,CAAC,MAAM,oBAAoB,CAAC,CAAC,CAAC,OAAO,EAAE,IAAI,CAAC,UAAU,CAAC,EAAE,EAAE,IAAI,CAAC;AACnF,gBAAgB,CAAC,MAAM;AACvB,kBAAkB,CAAC,CAAC,cAAc,GAAG;AACrC,kBAAkB,sBAAsB,GAAG;AAC3C,kBAAkB,CAAC,CAAC,MAAM,CAAC,CAAC;AAC5B,gBAAgB;AAChB,cAAc;AACd,cAAc;AACd,YAAY,KAAK,aAAa,EAAE;AAChC,cAAc,MAAM,EAAE,GAAG,EAAE,KAAK,EAAE,iCAAiC,CAAC,CAAC,OAAO;AAC5E,cAAc,MAAM,WAAW,GAAG,iBAAiB,CAAC,GAAG,CAAC,IAAI;AAC5D,cAAc,IAAI,WAAW,IAAI,IAAI,KAAK,CAAC,CAAC,OAAO,IAAI,CAAC,MAAM,CAAC,WAAW,CAAC,8BAA8B,EAAE,GAAG,CAAC,CAAC,EAAE;AAClH,gBAAgB,8BAA8B,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,OAAO,GAAG,KAAK,GAAG;AAC1E,cAAc;AACd;AACA;AACA,cAAc,IAAI,aAAa,IAAI,YAAY,EAAE;AACjD;AACA,gBAAgB,IAAI,sBAAsB,EAAE;AAC5C,kBAAkB,iBAAiB,GAAG,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,iBAAiB;AACzE,kBAAkB,sBAAsB,GAAG;AAC3C,gBAAgB;AAChB,gBAAgB,IAAI,sBAAsB,EAAE;AAC5C,kBAAkB,sBAAsB,GAAG;AAC3C,kBAAkB,iBAAiB,GAAG,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,iBAAiB;AACzE,gBAAgB;AAChB,cAAc;AACd,cAAc,IAAI,aAAa,IAAI,YAAY,EAAE;AACjD,gBAAgB,IAAI,CAAC,CAAC,OAAO,EAAE;AAC/B;AACA,kBAAkB,IAAI,CAAC,UAAU,CAAC,KAAK,EAAE,WAAW,CAAC,EAAE;AACvD,oBAAoB,IAAI,UAAU,CAAC,WAAW,EAAE,kBAAkB,CAAC,GAAG,CAAC,IAAI,IAAI,CAAC,IAAI,iBAAiB,CAAC,GAAG,CAAC,KAAK,SAAS,EAAE;AAC1H,sBAAsB,OAAO,iBAAiB,CAAC,GAAG;AAClD,oBAAoB,CAAC,MAAM;AAC3B,sBAAsB,iBAAiB,CAAC,GAAG,CAAC,GAAG;AAC/C,oBAAoB;AACpB;AACA,oBAAoB,kBAAkB,CAAC,GAAG,CAAC,GAAG;AAC9C,kBAAkB;AAClB,gBAAgB,CAAC,MAAM;AACvB;AACA,kBAAkB,IAAI,UAAU,CAAC,KAAK,EAAE,WAAW,CAAC,EAAE,CAEnC,MAAM,IAAI,UAAU,CAAC,KAAK,EAAE,kBAAkB,CAAC,GAAG,CAAC,IAAI,IAAI,CAAC,EAAE;AACjF,oBAAoB,OAAO,iBAAiB,CAAC,GAAG;AAChD,kBAAkB,CAAC,MAAM;AACzB,oBAAoB,iBAAiB,CAAC,GAAG,CAAC,GAAG;AAC7C,kBAAkB;AAClB,kBAAkB,IAAI,KAAK,IAAI,IAAI,EAAE;AACrC,oBAAoB,OAAO,iBAAiB,CAAC,GAAG;AAChD,kBAAkB,CAAC,MAAM;AACzB,oBAAoB,iBAAiB,CAAC,GAAG,CAAC,GAAG;AAC7C,kBAAkB;AAClB,gBAAgB;AAChB,cAAc,CAAC,MAAM,IAAI,aAAa,IAAI,CAAC,CAAC,CAAC,OAAO,EAAE;AACtD;AACA,gBAAgB,IAAI,sBAAsB,EAAE;AAC5C,kBAAkB,iBAAiB,GAAG,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,iBAAiB;AACzE,kBAAkB,sBAAsB,GAAG;AAC3C,gBAAgB;AAChB,gBAAgB,IAAI,sBAAsB,IAAI,iBAAiB,CAAC,GAAG,CAAC,KAAK,SAAS,EAAE;AACpF,kBAAkB,sBAAsB,GAAG;AAC3C,kBAAkB,iBAAiB,GAAG,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,iBAAiB;AACzE,gBAAgB;AAChB,gBAAgB,IAAI,KAAK,IAAI,IAAI,EAAE;AACnC,kBAAkB,OAAO,iBAAiB,CAAC,GAAG;AAC9C,gBAAgB,CAAC,MAAM;AACvB,kBAAkB,iBAAiB,CAAC,GAAG,CAAC,GAAG;AAC3C,gBAAgB;AAChB,gBAAgB,OAAO,iBAAiB,CAAC,GAAG;AAC5C,gBAAgB,kBAAkB,CAAC,GAAG,CAAC,GAAG;AAC1C,cAAc;AACd;AACA,cAAc,IAAI,WAAW,IAAI,IAAI,IAAI,MAAM,CAAC,WAAW,CAAC,8BAA8B,EAAE,GAAG,CAAC,EAAE;AAClG;AACA;AACA;AACA,gBAAgB,MAAM,qBAAqB,GAAG,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,CAAC,CAAC,eAAe;AACjF,gBAAgB,MAAM,2BAA2B,iDAAiD,qBAAqB,CAAC,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,qBAAqB,CAAC,MAAM,IAAI,EAAE,CAAC;AACtL,gBAAgB,IAAI,WAAW,IAAI,IAAI,IAAI,UAAU,CAAC,8BAA8B,CAAC,GAAG,CAAC,EAAE,iBAAiB,CAAC,GAAG,CAAC,IAAI,IAAI,CAAC,EAAE;AAC5H;AACA;AACA,kBAAkB,OAAO,2BAA2B,CAAC,GAAG;AACxD,kBAAkB,OAAO,8BAA8B,CAAC,GAAG;AAC3D,gBAAgB,CAAC,MAAM;AACvB,kBAAkB,MAAM,EAAE,GAAG,2BAA2B,CAAC,GAAG,CAAC,IAAI,2BAA2B,CAAC,GAAG,CAAC,EAAE,KAAK,EAAE,IAAI,EAAE;AAChH,kBAAkB,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,OAAO,GAAG,WAAW,CAAC,MAAM,GAAG,WAAW,CAAC,MAAM,KAAK,EAAE,CAAC;AAC1F,kBAAkB,MAAM,YAAY,IAAI,CAAC,CAAC,OAAO,GAAG,WAAW,CAAC,SAAS,GAAG,WAAW,CAAC,UAAU;AAClG,kBAAkB,IAAI,YAAY,EAAE,qBAAqB,CAAC,QAAQ,GAAG;AACrE,gBAAgB;AAChB,gBAAgB,IAAI,MAAM,CAAC,OAAO,CAAC,2BAA2B,CAAC,EAAE;AACjE,kBAAkB,CAAC,CAAC,cAAc,CAAC,IAAI;AACvC,gBAAgB,CAAC,MAAM,IAAI,WAAW,IAAI,IAAI,EAAE;AAChD,kBAAkB,MAAM,YAAY,IAAI,CAAC,CAAC,OAAO,GAAG,WAAW,CAAC,SAAS,GAAG,WAAW,CAAC,UAAU;AAClG,kBAAkB,IAAI,YAAY,IAAI,IAAI,EAAE,qBAAqB,CAAC,QAAQ,GAAG;AAC7E,kBAAkB,CAAC,CAAC,cAAc,CAAC,qBAAqB;AACxD,gBAAgB;AAChB,cAAc;AACd,cAAc;AACd,YAAY;AACZ;AACA,QAAQ;AACR,MAAM;AACN,IAAI;AACJ,IAAI,2BAA2B,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC;AAC5C,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,cAAc,CAAC,CAAC,EAAE,GAAG,qBAAqB,EAAE;AAC9C,IAAI,2BAA2B,IAAI,CAAC,UAAU,CAAC,EAAE,EAAE,EAAE,IAAI,EAAE,IAAI,EAAE,CAAC;AAClE,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,UAAU,CAAC,CAAC,CAAC,EAAE,EAAE,GAAG,qBAAqB,EAAE;AAC7C,IAAI,IAAI,IAAI,CAAC,GAAG,IAAI,IAAI,EAAE;AAC1B,MAAM,CAAC,IAAI,CAAC,OAAO,KAAK,IAAI,CAAC,OAAO,uBAAuB,KAAK,CAAC,MAAM,EAAE,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC;AACpF,IAAI,CAAC,MAAM;AACX;AACA,MAAM,QAAQ,CAAC,IAAI,CAAC,GAAG,EAAE,WAAW,IAAI;AACxC,QAAQ,MAAM,OAAO,GAAG,IAAI,oBAAoB,CAAC,IAAI,EAAE,IAAI,CAAC,MAAM,EAAE,CAAC,EAAE,IAAI,GAAG,EAAE,EAAE,EAAE;AACpF,QAAQ,KAAK,MAAM,EAAE,IAAI,CAAC,CAAC,QAAQ,EAAE;AACrC,UAAU,IAAI,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;AACvC,YAAY,UAAU,CAAC,WAAW,sBAAsB,IAAI,GAAG,OAAO,EAAE,EAAE,CAAC,MAAM,EAAE,EAAE,CAAC,MAAM,IAAI,EAAE;AAClG,UAAU,CAAC,MAAM,IAAI,KAAK,CAAC,SAAS,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;AAChD,YAAY,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,CAAC,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AACvD,cAAc,IAAI,GAAG,GAAG,EAAE,CAAC,MAAM,CAAC,CAAC;AACnC,cAAc,IAAI,KAAK,CAAC,SAAS,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE;AAC9C,gBAAgB,IAAI,GAAG,CAAC,IAAI,IAAI,IAAI,EAAE;AACtC,kBAAkB,MAAM,CAAC,GAAG,IAAI,WAAW,CAAC,GAAG,CAAC,IAAI;AACpD,kBAAkB,CAAC,CAAC,UAAU,CAAC,GAAG;AAClC,kBAAkB,GAAG,GAAG;AACxB,gBAAgB,CAAC,MAAM;AACvB,kBAAkB,KAAK,CAAC,cAAc;AACtC,gBAAgB;AAChB,cAAc;AACd,cAAc,UAAU,CAAC,WAAW,sBAAsB,IAAI,GAAG,OAAO,EAAE,GAAG,EAAE,EAAE,CAAC,MAAM,IAAI,EAAE;AAC9F,YAAY;AACZ,UAAU,CAAC,MAAM,IAAI,KAAK,CAAC,SAAS,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;AAChD,YAAY,OAAO,CAAC,UAAU,CAAC,WAAW,sBAAsB,IAAI,GAAG,EAAE,CAAC,MAAM,EAAE,EAAE,CAAC,MAAM,IAAI,EAAE;AACjG,UAAU,CAAC,MAAM,IAAI,KAAK,CAAC,SAAS,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;AAChD,YAAY,UAAU,CAAC,WAAW,EAAE,OAAO,EAAE,EAAE,CAAC,MAAM;AACtD,UAAU,CAAC,MAAM,IAAI,KAAK,CAAC,SAAS,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;AAChD,YAAY,IAAI,OAAO,CAAC,KAAK,EAAE;AAC/B,yCAAyC,CAAC,OAAO,CAAC,KAAK,CAAC,OAAO,EAAE,IAAI,CAAC,UAAU,CAAC,EAAE,CAAC,KAAK;AACzF,YAAY,CAAC,MAAM;AACnB,cAAc,KAAK,CAAC,cAAc;AAClC,YAAY;AACZ,YAAY,OAAO,CAAC,UAAU,CAAC,WAAW,sBAAsB,IAAI,GAAG,CAAC,EAAE,EAAE,CAAC,MAAM,IAAI,EAAE;AACzF,UAAU,CAAC,MAAM;AACjB,YAAY,KAAK,CAAC,cAAc;AAChC,UAAU;AACV,QAAQ;AACR,QAAQ,KAAK,MAAM,EAAE,IAAI,CAAC,CAAC,KAAK,EAAE;AAClC,UAAU,IAAI,KAAK,CAAC,SAAS,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;AACzC,YAAY,UAAU,CAAC,WAAW,sBAAsB,IAAI,GAAG,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,KAAK;AAC/E,UAAU,CAAC,MAAM,IAAI,KAAK,CAAC,SAAS,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;AAChD,YAAY,aAAa,CAAC,WAAW,sBAAsB,IAAI,GAAG,EAAE,CAAC,GAAG;AACxE,UAAU,CAAC,MAAM;AACjB,YAAY,MAAM,GAAG,GAAG,UAAU,qBAAqB,IAAI,GAAG,EAAE,CAAC,GAAG;AACpE,YAAY,IAAI,EAAE,GAAG,YAAY,YAAY,CAAC,EAAE;AAChD,cAAc,KAAK,CAAC,cAAc;AAClC,YAAY;AACZ,YAAY,GAAG,CAAC,UAAU,CAAC,EAAE,CAAC,KAAK;AACnC,UAAU;AACV,QAAQ;AACR,MAAM,CAAC;AACP,IAAI;AACJ,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACY,MAAC,UAAU,GAAG,CAAC,CAAC,EAAE,CAAC,KAAK,CAAC,KAAK,CAAC,KAAK,OAAO,CAAC,KAAK,QAAQ,IAAI,OAAO,CAAC,KAAK,QAAQ,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC;;AAElI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,aAAa,GAAG,CAAC,IAAI,EAAE,KAAK,EAAE,GAAG,KAAK;AACnD,EAAE,IAAI,CAAC,GAAG,IAAI,mBAAmB;AACjC,EAAE,IAAI,KAAK,GAAG,CAAC,EAAE;AACjB,IAAI,KAAK,GAAG,IAAI,CAAC,OAAO,GAAG;AAC3B,EAAE;AACF,EAAE,IAAI,GAAG,GAAG,CAAC,EAAE;AACf,IAAI,GAAG,GAAG,IAAI,CAAC,OAAO,GAAG;AACzB,EAAE;AACF,EAAE,IAAI,GAAG,GAAG,GAAG,GAAG;AAClB,EAAE,MAAM,EAAE,GAAG;AACb,EAAE,IAAI,CAAC,GAAG,IAAI,CAAC;AACf,EAAE,OAAO,CAAC,KAAK,IAAI,IAAI,GAAG,GAAG,CAAC,EAAE;AAChC,IAAI,IAAI,CAAC,CAAC,SAAS,IAAI,CAAC,CAAC,CAAC,OAAO,EAAE;AACnC,MAAM,MAAM,CAAC,GAAG,CAAC,CAAC,OAAO,CAAC,UAAU;AACpC,MAAM,IAAI,CAAC,CAAC,MAAM,IAAI,KAAK,EAAE;AAC7B,QAAQ,KAAK,IAAI,CAAC,CAAC;AACnB,MAAM,CAAC,MAAM;AACb,QAAQ,KAAK,IAAI,CAAC,GAAG,KAAK,EAAE,CAAC,GAAG,CAAC,CAAC,MAAM,IAAI,GAAG,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE;AAC1D,UAAU,EAAE,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;AACtB,UAAU,GAAG;AACb,QAAQ;AACR,QAAQ,KAAK,GAAG;AAChB,MAAM;AACN,IAAI;AACJ,IAAI,CAAC,GAAG,CAAC,CAAC;AACV,EAAE;AACF,EAAE,OAAO;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,eAAe,GAAG,IAAI,IAAI;AACvC,EAAE,IAAI,CAAC,GAAG,IAAI,mBAAmB;AACjC,EAAE,MAAM,EAAE,GAAG;AACb,EAAE,IAAI,CAAC,GAAG,IAAI,CAAC;AACf,EAAE,OAAO,CAAC,KAAK,IAAI,EAAE;AACrB,IAAI,IAAI,CAAC,CAAC,SAAS,IAAI,CAAC,CAAC,CAAC,OAAO,EAAE;AACnC,MAAM,MAAM,CAAC,GAAG,CAAC,CAAC,OAAO,CAAC,UAAU;AACpC,MAAM,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AACzC,QAAQ,EAAE,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;AACpB,MAAM;AACN,IAAI;AACJ,IAAI,CAAC,GAAG,CAAC,CAAC;AACV,EAAE;AACF,EAAE,OAAO;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,uBAAuB,GAAG,CAAC,IAAI,EAAE,QAAQ,KAAK;AAC3D,EAAE,MAAM,EAAE,GAAG;AACb,EAAE,IAAI,CAAC,GAAG,IAAI,CAAC;AACf,EAAE,OAAO,CAAC,KAAK,IAAI,EAAE;AACrB,IAAI,IAAI,CAAC,CAAC,SAAS,IAAI,SAAS,CAAC,CAAC,EAAE,QAAQ,CAAC,EAAE;AAC/C,MAAM,MAAM,CAAC,GAAG,CAAC,CAAC,OAAO,CAAC,UAAU;AACpC,MAAM,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AACzC,QAAQ,EAAE,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;AACpB,MAAM;AACN,IAAI;AACJ,IAAI,CAAC,GAAG,CAAC,CAAC;AACV,EAAE;AACF,EAAE,OAAO;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,eAAe,GAAG,CAAC,IAAI,EAAE,CAAC,KAAK;AAC5C,EAAE,IAAI,KAAK,GAAG;AACd,EAAE,IAAI,CAAC,GAAG,IAAI,CAAC;AACf,EAAE,IAAI,CAAC,GAAG,IAAI,mBAAmB;AACjC,EAAE,OAAO,CAAC,KAAK,IAAI,EAAE;AACrB,IAAI,IAAI,CAAC,CAAC,SAAS,IAAI,CAAC,CAAC,CAAC,OAAO,EAAE;AACnC,MAAM,MAAM,CAAC,GAAG,CAAC,CAAC,OAAO,CAAC,UAAU;AACpC,MAAM,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AACzC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,KAAK,EAAE,EAAE,IAAI;AAC7B,MAAM;AACN,IAAI;AACJ,IAAI,CAAC,GAAG,CAAC,CAAC;AACV,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,WAAW,GAAG,CAAC,IAAI,EAAE,CAAC,KAAK;AACxC;AACA;AACA;AACA,EAAE,MAAM,MAAM,GAAG;AACjB,EAAE,eAAe,CAAC,IAAI,EAAE,CAAC,CAAC,EAAE,CAAC,KAAK;AAClC,IAAI,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,IAAI,CAAC;AAC7B,EAAE,CAAC;AACH,EAAE,OAAO;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,sBAAsB,GAAG,IAAI,IAAI;AAC9C,EAAE,IAAI,CAAC,GAAG,IAAI,CAAC;AACf;AACA;AACA;AACA,EAAE,IAAI,cAAc,GAAG;AACvB,EAAE,IAAI,mBAAmB,GAAG;AAC5B,EAAE,OAAO;AACT,IAAI,CAAC,MAAM,CAAC,QAAQ,EAAE,GAAG;AACzB,MAAM,OAAO;AACb,IAAI,CAAC;AACL,IAAI,IAAI,EAAE,MAAM;AAChB;AACA,MAAM,IAAI,cAAc,KAAK,IAAI,EAAE;AACnC,QAAQ,OAAO,CAAC,KAAK,IAAI,IAAI,CAAC,CAAC,OAAO,EAAE;AACxC,UAAU,CAAC,GAAG,CAAC,CAAC;AAChB,QAAQ;AACR;AACA,QAAQ,IAAI,CAAC,KAAK,IAAI,EAAE;AACxB,UAAU,OAAO;AACjB,YAAY,IAAI,EAAE,IAAI;AACtB,YAAY,KAAK,EAAE;AACnB;AACA,QAAQ;AACR;AACA,QAAQ,cAAc,GAAG,CAAC,CAAC,OAAO,CAAC,UAAU;AAC7C,QAAQ,mBAAmB,GAAG;AAC9B,QAAQ,CAAC,GAAG,CAAC,CAAC,MAAK;AACnB,MAAM;AACN,MAAM,MAAM,KAAK,GAAG,cAAc,CAAC,mBAAmB,EAAE;AACxD;AACA,MAAM,IAAI,cAAc,CAAC,MAAM,IAAI,mBAAmB,EAAE;AACxD,QAAQ,cAAc,GAAG;AACzB,MAAM;AACN,MAAM,OAAO;AACb,QAAQ,IAAI,EAAE,KAAK;AACnB,QAAQ;AACR;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,uBAAuB,GAAG,CAAC,IAAI,EAAE,CAAC,EAAE,QAAQ,KAAK;AAC9D,EAAE,IAAI,KAAK,GAAG;AACd,EAAE,IAAI,CAAC,GAAG,IAAI,CAAC;AACf,EAAE,OAAO,CAAC,KAAK,IAAI,EAAE;AACrB,IAAI,IAAI,CAAC,CAAC,SAAS,IAAI,SAAS,CAAC,CAAC,EAAE,QAAQ,CAAC,EAAE;AAC/C,MAAM,MAAM,CAAC,GAAG,CAAC,CAAC,OAAO,CAAC,UAAU;AACpC,MAAM,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AACzC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,KAAK,EAAE,EAAE,IAAI;AAC7B,MAAM;AACN,IAAI;AACJ,IAAI,CAAC,GAAG,CAAC,CAAC;AACV,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,WAAW,GAAG,CAAC,IAAI,EAAE,KAAK,KAAK;AAC5C,EAAE,IAAI,CAAC,GAAG,IAAI,mBAAmB;AACjC,EAAE,MAAM,MAAM,GAAG,UAAU,CAAC,IAAI,EAAE,KAAK;AACvC,EAAE,IAAI,CAAC,GAAG,IAAI,CAAC;AACf,EAAE,IAAI,MAAM,KAAK,IAAI,EAAE;AACvB,IAAI,CAAC,GAAG,MAAM,CAAC;AACf,IAAI,KAAK,IAAI,MAAM,CAAC;AACpB,EAAE;AACF,EAAE,OAAO,CAAC,KAAK,IAAI,EAAE,CAAC,GAAG,CAAC,CAAC,KAAK,EAAE;AAClC,IAAI,IAAI,CAAC,CAAC,CAAC,OAAO,IAAI,CAAC,CAAC,SAAS,EAAE;AACnC,MAAM,IAAI,KAAK,GAAG,CAAC,CAAC,MAAM,EAAE;AAC5B,QAAQ,OAAO,CAAC,CAAC,OAAO,CAAC,UAAU,EAAE,CAAC,KAAK;AAC3C,MAAM;AACN,MAAM,KAAK,IAAI,CAAC,CAAC;AACjB,IAAI;AACJ,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,2BAA2B,GAAG,CAAC,WAAW,EAAE,MAAM,EAAE,aAAa,EAAE,OAAO,KAAK;AAC5F,EAAE,IAAI,IAAI,GAAG;AACb,EAAE,MAAM,GAAG,GAAG,WAAW,CAAC;AAC1B,EAAE,MAAM,WAAW,GAAG,GAAG,CAAC;AAC1B,EAAE,MAAM,KAAK,GAAG,GAAG,CAAC;AACpB,EAAE,MAAM,KAAK,GAAG,aAAa,KAAK,IAAI,GAAG,MAAM,CAAC,MAAM,GAAG,aAAa,CAAC;AACvE;AACA;AACA;AACA,EAAE,IAAI,WAAW,GAAG;AACpB,EAAE,MAAM,eAAe,GAAG,MAAM;AAChC,IAAI,IAAI,WAAW,CAAC,MAAM,GAAG,CAAC,EAAE;AAChC,MAAM,IAAI,GAAG,IAAI,IAAI,CAAC,QAAQ,CAAC,WAAW,EAAE,QAAQ,CAAC,KAAK,EAAE,WAAW,CAAC,CAAC,EAAE,IAAI,EAAE,IAAI,IAAI,IAAI,CAAC,MAAM,EAAE,KAAK,EAAE,KAAK,IAAI,KAAK,CAAC,EAAE,EAAE,MAAM,EAAE,IAAI,EAAE,IAAI,UAAU,CAAC,WAAW,CAAC;AACzK,MAAM,IAAI,CAAC,SAAS,CAAC,WAAW,EAAE,CAAC;AACnC,MAAM,WAAW,GAAG;AACpB,IAAI;AACJ,EAAE;AACF,EAAE,OAAO,CAAC,OAAO,CAAC,CAAC,IAAI;AACvB,IAAI,IAAI,CAAC,KAAK,IAAI,EAAE;AACpB,MAAM,WAAW,CAAC,IAAI,CAAC,CAAC;AACxB,IAAI,CAAC,MAAM;AACX,MAAM,QAAQ,CAAC,CAAC,WAAW;AAC3B,QAAQ,KAAK,MAAM;AACnB,QAAQ,KAAK,MAAM;AACnB,QAAQ,KAAK,SAAS;AACtB,QAAQ,KAAK,OAAO;AACpB,QAAQ,KAAK,KAAK;AAClB,QAAQ,KAAK,MAAM;AACnB,QAAQ,KAAK,MAAM;AACnB,QAAQ,KAAK,IAAI;AACjB,UAAU,WAAW,CAAC,IAAI,CAAC,CAAC;AAC5B,UAAU;AACV,QAAQ;AACR,UAAU,eAAe;AACzB,UAAU,QAAQ,CAAC,CAAC,WAAW;AAC/B,YAAY,KAAK,UAAU;AAC3B,YAAY,KAAK,WAAW;AAC5B,cAAc,IAAI,GAAG,IAAI,IAAI,CAAC,QAAQ,CAAC,WAAW,EAAE,QAAQ,CAAC,KAAK,EAAE,WAAW,CAAC,CAAC,EAAE,IAAI,EAAE,IAAI,IAAI,IAAI,CAAC,MAAM,EAAE,KAAK,EAAE,KAAK,IAAI,KAAK,CAAC,EAAE,EAAE,MAAM,EAAE,IAAI,EAAE,IAAI,aAAa,CAAC,IAAI,UAAU,4BAA4B,CAAC,EAAE,CAAC;AACtN,cAAc,IAAI,CAAC,SAAS,CAAC,WAAW,EAAE,CAAC;AAC3C,cAAc;AACd,YAAY,KAAK,GAAG;AACpB,cAAc,IAAI,GAAG,IAAI,IAAI,CAAC,QAAQ,CAAC,WAAW,EAAE,QAAQ,CAAC,KAAK,EAAE,WAAW,CAAC,CAAC,EAAE,IAAI,EAAE,IAAI,IAAI,IAAI,CAAC,MAAM,EAAE,KAAK,EAAE,KAAK,IAAI,KAAK,CAAC,EAAE,EAAE,MAAM,EAAE,IAAI,EAAE,IAAI,UAAU,qBAAqB,CAAC,EAAE;AAC5L,cAAc,IAAI,CAAC,SAAS,CAAC,WAAW,EAAE,CAAC;AAC3C,cAAc;AACd,YAAY;AACZ,cAAc,IAAI,CAAC,YAAY,YAAY,EAAE;AAC7C,gBAAgB,IAAI,GAAG,IAAI,IAAI,CAAC,QAAQ,CAAC,WAAW,EAAE,QAAQ,CAAC,KAAK,EAAE,WAAW,CAAC,CAAC,EAAE,IAAI,EAAE,IAAI,IAAI,IAAI,CAAC,MAAM,EAAE,KAAK,EAAE,KAAK,IAAI,KAAK,CAAC,EAAE,EAAE,MAAM,EAAE,IAAI,EAAE,IAAI,WAAW,qBAAqB,CAAC,EAAE;AAC/L,gBAAgB,IAAI,CAAC,SAAS,CAAC,WAAW,EAAE,CAAC;AAC7C,cAAc,CAAC,MAAM;AACrB,gBAAgB,MAAM,IAAI,KAAK,CAAC,6CAA6C;AAC7E,cAAc;AACd;AACA;AACA,IAAI;AACJ,EAAE,CAAC;AACH,EAAE,eAAe;AACjB;;AAEA,MAAM,cAAc,GAAG,MAAM,KAAK,CAAC,MAAM,CAAC,kBAAkB;;AAE5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,sBAAsB,GAAG,CAAC,WAAW,EAAE,MAAM,EAAE,KAAK,EAAE,OAAO,KAAK;AAC/E,EAAE,IAAI,KAAK,GAAG,MAAM,CAAC,OAAO,EAAE;AAC9B,IAAI,MAAM,cAAc;AACxB,EAAE;AACF,EAAE,IAAI,KAAK,KAAK,CAAC,EAAE;AACnB,IAAI,IAAI,MAAM,CAAC,aAAa,EAAE;AAC9B,MAAM,mBAAmB,CAAC,MAAM,CAAC,aAAa,EAAE,KAAK,EAAE,OAAO,CAAC,MAAM;AACrE,IAAI;AACJ,IAAI,OAAO,2BAA2B,CAAC,WAAW,EAAE,MAAM,EAAE,IAAI,EAAE,OAAO;AACzE,EAAE;AACF,EAAE,MAAM,UAAU,GAAG;AACrB,EAAE,MAAM,MAAM,GAAG,UAAU,CAAC,MAAM,EAAE,KAAK;AACzC,EAAE,IAAI,CAAC,GAAG,MAAM,CAAC;AACjB,EAAE,IAAI,MAAM,KAAK,IAAI,EAAE;AACvB,IAAI,CAAC,GAAG,MAAM,CAAC;AACf,IAAI,KAAK,IAAI,MAAM,CAAC;AACpB;AACA,IAAI,IAAI,KAAK,KAAK,CAAC,EAAE;AACrB;AACA,MAAM,CAAC,GAAG,CAAC,CAAC,KAAI;AAChB,MAAM,KAAK,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC,SAAS,IAAI,CAAC,CAAC,CAAC,OAAO,IAAI,CAAC,CAAC,MAAM,GAAG;AAC7D,IAAI;AACJ,EAAE;AACF,EAAE,OAAO,CAAC,KAAK,IAAI,EAAE,CAAC,GAAG,CAAC,CAAC,KAAK,EAAE;AAClC,IAAI,IAAI,CAAC,CAAC,CAAC,OAAO,IAAI,CAAC,CAAC,SAAS,EAAE;AACnC,MAAM,IAAI,KAAK,IAAI,CAAC,CAAC,MAAM,EAAE;AAC7B,QAAQ,IAAI,KAAK,GAAG,CAAC,CAAC,MAAM,EAAE;AAC9B;AACA,UAAU,iBAAiB,CAAC,WAAW,EAAE,QAAQ,CAAC,CAAC,CAAC,EAAE,CAAC,MAAM,EAAE,CAAC,CAAC,EAAE,CAAC,KAAK,GAAG,KAAK,CAAC;AAClF,QAAQ;AACR,QAAQ;AACR,MAAM;AACN,MAAM,KAAK,IAAI,CAAC,CAAC;AACjB,IAAI;AACJ,EAAE;AACF,EAAE,IAAI,MAAM,CAAC,aAAa,EAAE;AAC5B,IAAI,mBAAmB,CAAC,MAAM,CAAC,aAAa,EAAE,UAAU,EAAE,OAAO,CAAC,MAAM;AACxE,EAAE;AACF,EAAE,OAAO,2BAA2B,CAAC,WAAW,EAAE,MAAM,EAAE,CAAC,EAAE,OAAO;AACpE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,oBAAoB,GAAG,CAAC,WAAW,EAAE,MAAM,EAAE,OAAO,KAAK;AACtE;AACA,EAAE,MAAM,MAAM,GAAG,CAAC,MAAM,CAAC,aAAa,IAAI,EAAE,EAAE,MAAM,CAAC,CAAC,SAAS,EAAE,UAAU,KAAK,UAAU,CAAC,KAAK,GAAG,SAAS,CAAC,KAAK,GAAG,UAAU,GAAG,SAAS,EAAE,EAAE,KAAK,EAAE,CAAC,EAAE,CAAC,EAAE,MAAM,CAAC,MAAM,EAAE;AAC3K,EAAE,IAAI,CAAC,GAAG,MAAM,CAAC;AACjB,EAAE,IAAI,CAAC,EAAE;AACT,IAAI,OAAO,CAAC,CAAC,KAAK,EAAE;AACpB,MAAM,CAAC,GAAG,CAAC,CAAC;AACZ,IAAI;AACJ,EAAE;AACF,EAAE,OAAO,2BAA2B,CAAC,WAAW,EAAE,MAAM,EAAE,CAAC,EAAE,OAAO;AACpE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,cAAc,GAAG,CAAC,WAAW,EAAE,MAAM,EAAE,KAAK,EAAE,MAAM,KAAK;AACtE,EAAE,IAAI,MAAM,KAAK,CAAC,EAAE,EAAE,MAAM,CAAC;AAC7B,EAAE,MAAM,UAAU,GAAG;AACrB,EAAE,MAAM,WAAW,GAAG;AACtB,EAAE,MAAM,MAAM,GAAG,UAAU,CAAC,MAAM,EAAE,KAAK;AACzC,EAAE,IAAI,CAAC,GAAG,MAAM,CAAC;AACjB,EAAE,IAAI,MAAM,KAAK,IAAI,EAAE;AACvB,IAAI,CAAC,GAAG,MAAM,CAAC;AACf,IAAI,KAAK,IAAI,MAAM,CAAC;AACpB,EAAE;AACF;AACA,EAAE,OAAO,CAAC,KAAK,IAAI,IAAI,KAAK,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,KAAK,EAAE;AAC/C,IAAI,IAAI,CAAC,CAAC,CAAC,OAAO,IAAI,CAAC,CAAC,SAAS,EAAE;AACnC,MAAM,IAAI,KAAK,GAAG,CAAC,CAAC,MAAM,EAAE;AAC5B,QAAQ,iBAAiB,CAAC,WAAW,EAAE,QAAQ,CAAC,CAAC,CAAC,EAAE,CAAC,MAAM,EAAE,CAAC,CAAC,EAAE,CAAC,KAAK,GAAG,KAAK,CAAC;AAChF,MAAM;AACN,MAAM,KAAK,IAAI,CAAC,CAAC;AACjB,IAAI;AACJ,EAAE;AACF;AACA,EAAE,OAAO,MAAM,GAAG,CAAC,IAAI,CAAC,KAAK,IAAI,EAAE;AACnC,IAAI,IAAI,CAAC,CAAC,CAAC,OAAO,EAAE;AACpB,MAAM,IAAI,MAAM,GAAG,CAAC,CAAC,MAAM,EAAE;AAC7B,QAAQ,iBAAiB,CAAC,WAAW,EAAE,QAAQ,CAAC,CAAC,CAAC,EAAE,CAAC,MAAM,EAAE,CAAC,CAAC,EAAE,CAAC,KAAK,GAAG,MAAM,CAAC;AACjF,MAAM;AACN,MAAM,CAAC,CAAC,MAAM,CAAC,WAAW;AAC1B,MAAM,MAAM,IAAI,CAAC,CAAC;AAClB,IAAI;AACJ,IAAI,CAAC,GAAG,CAAC,CAAC;AACV,EAAE;AACF,EAAE,IAAI,MAAM,GAAG,CAAC,EAAE;AAClB,IAAI,MAAM,cAAc;AACxB,EAAE;AACF,EAAE,IAAI,MAAM,CAAC,aAAa,EAAE;AAC5B,IAAI,mBAAmB,CAAC,MAAM,CAAC,aAAa,EAAE,UAAU,EAAE,CAAC,WAAW,GAAG,MAAM;AAC/E,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,aAAa,GAAG,CAAC,WAAW,EAAE,MAAM,EAAE,GAAG,KAAK;AAC3D,EAAE,MAAM,CAAC,GAAG,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG;AAC/B,EAAE,IAAI,CAAC,KAAK,SAAS,EAAE;AACvB,IAAI,CAAC,CAAC,MAAM,CAAC,WAAW;AACxB,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,UAAU,GAAG,CAAC,WAAW,EAAE,MAAM,EAAE,GAAG,EAAE,KAAK,KAAK;AAC/D,EAAE,MAAM,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI;AACvC,EAAE,MAAM,GAAG,GAAG,WAAW,CAAC;AAC1B,EAAE,MAAM,WAAW,GAAG,GAAG,CAAC;AAC1B,EAAE,IAAI;AACN,EAAE,IAAI,KAAK,IAAI,IAAI,EAAE;AACrB,IAAI,OAAO,GAAG,IAAI,UAAU,CAAC,CAAC,KAAK,CAAC;AACpC,EAAE,CAAC,MAAM;AACT,IAAI,QAAQ,KAAK,CAAC,WAAW;AAC7B,MAAM,KAAK,MAAM;AACjB,MAAM,KAAK,MAAM;AACjB,MAAM,KAAK,OAAO;AAClB,MAAM,KAAK,KAAK;AAChB,MAAM,KAAK,MAAM;AACjB,MAAM,KAAK,IAAI;AACf,MAAM,KAAK,MAAM;AACjB,QAAQ,OAAO,GAAG,IAAI,UAAU,CAAC,CAAC,KAAK,CAAC;AACxC,QAAQ;AACR,MAAM,KAAK,UAAU;AACrB,QAAQ,OAAO,GAAG,IAAI,aAAa,4BAA4B,KAAK;AACpE,QAAQ;AACR,MAAM,KAAK,GAAG;AACd,QAAQ,OAAO,GAAG,IAAI,UAAU,qBAAqB,KAAK;AAC1D,QAAQ;AACR,MAAM;AACN,QAAQ,IAAI,KAAK,YAAY,YAAY,EAAE;AAC3C,UAAU,OAAO,GAAG,IAAI,WAAW,qBAAqB,KAAK;AAC7D,QAAQ,CAAC,MAAM;AACf,UAAU,MAAM,IAAI,KAAK,CAAC,yBAAyB;AACnD,QAAQ;AACR;AACA,EAAE;AACF,EAAE,IAAI,IAAI,CAAC,QAAQ,CAAC,WAAW,EAAE,QAAQ,CAAC,GAAG,CAAC,KAAK,EAAE,WAAW,CAAC,CAAC,EAAE,IAAI,EAAE,IAAI,IAAI,IAAI,CAAC,MAAM,EAAE,IAAI,EAAE,IAAI,EAAE,MAAM,EAAE,GAAG,EAAE,OAAO,CAAC,CAAC,SAAS,CAAC,WAAW,EAAE,CAAC;AACzJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,UAAU,GAAG,CAAC,MAAM,EAAE,GAAG,KAAK;AAC3C,EAAE,MAAM,CAAC,GAAG,IAAI,mBAAmB;AACnC,EAAE,MAAM,GAAG,GAAG,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG;AACjC,EAAE,OAAO,GAAG,KAAK,SAAS,IAAI,CAAC,GAAG,CAAC,OAAO,GAAG,GAAG,CAAC,OAAO,CAAC,UAAU,EAAE,CAAC,GAAG,CAAC,MAAM,GAAG,CAAC,CAAC,GAAG;AACxF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,aAAa,GAAG,CAAC,MAAM,KAAK;AACzC;AACA;AACA;AACA,EAAE,MAAM,GAAG,GAAG;AACd,EAAE,MAAM,CAAC,GAAG,IAAI,mBAAmB;AACnC,EAAE,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,GAAG,KAAK;AACtC,IAAI,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE;AACxB,MAAM,GAAG,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC,OAAO,CAAC,UAAU,EAAE,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC;AAC5D,IAAI;AACJ,EAAE,CAAC;AACH,EAAE,OAAO;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,eAAe,GAAG,CAAC,CAAC,EAAE,MAAM,EAAE,aAAa,EAAE,EAAE,EAAE,IAAI,EAAE,QAAQ,EAAE,YAAY,EAAE,aAAa,EAAE,IAAI,EAAE,OAAO,KAAK;AAC7H;AACA;AACA;AACA;AACA;AACA,EAAE,MAAM,WAAW,GAAG,CAAC,IAAI,EAAE,GAAG,KAAK;AACrC;AACA;AACA;AACA,IAAI,MAAM,EAAE,GAAG;AACf,IAAI,EAAE,CAAC,WAAW,CAAC,EAAE,EAAE,IAAI,CAAC,EAAE,CAAC,MAAM,EAAE,IAAI,CAAC,EAAE,CAAC,KAAK,EAAE,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,OAAO,EAAE,CAAC;AACnF,IAAI,MAAM,EAAE,OAAO,EAAE,KAAK,EAAE,OAAO,EAAE,GAAG,EAAE,CAAC,EAAE,CAAC,MAAM,GAAG,CAAC;AACxD,IAAI,MAAM,WAAW,GAAG,qCAAqC,CAAC,KAAK,EAAE,OAAO;AAC5E,IAAI,IAAI,CAAC,GAAG,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC,UAAU,EAAE;AAC3C,IAAI,IAAI,OAAO,EAAE;AACjB,MAAM,IAAI,aAAa,IAAI,IAAI,IAAI,aAAa,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE;AACrE,QAAQ,CAAC,CAAC,KAAK,CAAC,GAAG,EAAE,WAAW,EAAE,CAAC;AACnC,MAAM;AACN,IAAI,CAAC,MAAM,IAAI,IAAI,IAAI,CAAC,YAAY,YAAY,IAAI,QAAQ,EAAE,GAAG,CAAC,CAAC,CAAC,EAAE;AACtE,MAAM,CAAC,CAAC,MAAM,CAAC,GAAG,EAAE,CAAC,CAAC,UAAU,CAAC,EAAE,EAAE,IAAI,CAAC;AAC1C,IAAI,CAAC,MAAM;AACX;AACA,MAAM,IAAI,eAAe,GAAG;AAC5B;AACA,MAAM,OAAO,eAAe,CAAC,IAAI,KAAK,IAAI,IAAI,YAAY,EAAE,KAAK,CAAC,eAAe,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE,eAAe,GAAG,eAAe,CAAC,IAAI,EAAE;AACxI;AACA,MAAM;AACN,MAAM,MAAM,SAAS,GAAG,CAAC,eAAe,KAAK,IAAI,IAAI,aAAa,EAAE,KAAK,CAAC,eAAe,CAAC,MAAM,CAAC,IAAI,KAAK,CAAC,IAAI,CAAC,eAAe,CAAC,OAAO,CAAC,UAAU,EAAE,CAAC,GAAG;AACxJ,MAAM,IAAI,IAAI,IAAI,CAAC,YAAY,YAAY,EAAE;AAC7C,QAAQ,CAAC,qBAAqB,CAAC,CAAC,EAAE,UAAU,CAAC,EAAE,EAAE,OAAO;AACxD,MAAM;AACN,MAAM,CAAC,CAAC,GAAG,CAAC,GAAG,EAAE,CAAC,EAAE,WAAW,EAAE,SAAS;AAC1C,IAAI;AACJ,EAAE;AACF,EAAE,IAAI,aAAa,IAAI,IAAI,EAAE;AAC7B,IAAI,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,WAAW;AACnC,EAAE,CAAC,MAAM;AACT,IAAI,aAAa,CAAC,OAAO,CAAC,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,WAAW,sBAAsB,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,GAAG,CAAC;AAC5G,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,UAAU,GAAG,CAAC,MAAM,EAAE,GAAG,KAAK;AAC3C,EAAE,MAAM,CAAC,GAAG,IAAI,mBAAmB;AACnC,EAAE,MAAM,GAAG,GAAG,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG;AACjC,EAAE,OAAO,GAAG,KAAK,SAAS,IAAI,CAAC,GAAG,CAAC;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,kBAAkB,GAAG,CAAC,MAAM,EAAE,GAAG,EAAE,QAAQ,KAAK;AAC7D,EAAE,IAAI,CAAC,GAAG,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI;AAClC,EAAE,OAAO,CAAC,KAAK,IAAI,KAAK,CAAC,QAAQ,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,KAAK,KAAK,QAAQ,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE;AAC7G,IAAI,CAAC,GAAG,CAAC,CAAC;AACV,EAAE;AACF,EAAE,OAAO,CAAC,KAAK,IAAI,IAAI,SAAS,CAAC,CAAC,EAAE,QAAQ,CAAC,GAAG,CAAC,CAAC,OAAO,CAAC,UAAU,EAAE,CAAC,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC,GAAG;AACvF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,qBAAqB,GAAG,CAAC,MAAM,EAAE,QAAQ,KAAK;AAC3D;AACA;AACA;AACA,EAAE,MAAM,GAAG,GAAG;AACd,EAAE,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,GAAG,KAAK;AACtC;AACA;AACA;AACA,IAAI,IAAI,CAAC,GAAG;AACZ,IAAI,OAAO,CAAC,KAAK,IAAI,KAAK,CAAC,QAAQ,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,KAAK,KAAK,QAAQ,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE;AAC/G,MAAM,CAAC,GAAG,CAAC,CAAC;AACZ,IAAI;AACJ,IAAI,IAAI,CAAC,KAAK,IAAI,IAAI,SAAS,CAAC,CAAC,EAAE,QAAQ,CAAC,EAAE;AAC9C,MAAM,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,OAAO,CAAC,UAAU,EAAE,CAAC,CAAC,CAAC,MAAM,GAAG,CAAC;AACpD,IAAI;AACJ,EAAE,CAAC;AACH,EAAE,OAAO;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,iBAAiB,GAAG,IAAI,IAAI;AACzC,EAAE,IAAI,CAAC,GAAG,IAAI,mBAAmB;AACjC,EAAE,OAAO,QAAQ,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,4BAA4B,KAAK,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,OAAO;AAC1G;;AC75CA;AACA;AACA;;;AAsBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,MAAM,MAAM,SAAS,YAAY,CAAC;AACzC,EAAE,WAAW,CAAC,GAAG;AACjB,IAAI,KAAK;AACT;AACA;AACA;AACA;AACA,IAAI,IAAI,CAAC,cAAc,GAAG;AAC1B;AACA;AACA;AACA,IAAI,IAAI,CAAC,aAAa,GAAG;AACzB,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,OAAO,IAAI,CAAC,CAAC,KAAK,EAAE;AACtB;AACA;AACA;AACA,IAAI,MAAM,CAAC,GAAG,IAAI,MAAM;AACxB,IAAI,CAAC,CAAC,IAAI,CAAC,KAAK;AAChB,IAAI,OAAO;AACX,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,UAAU,CAAC,CAAC,CAAC,EAAE,IAAI,EAAE;AACvB,IAAI,KAAK,CAAC,UAAU,CAAC,CAAC,EAAE,IAAI;AAC5B,IAAI,IAAI,CAAC,MAAM,CAAC,CAAC,6BAA6B,IAAI,CAAC,cAAc;AACjE,IAAI,IAAI,CAAC,cAAc,GAAG;AAC1B,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,KAAK,CAAC,GAAG;AACX;AACA;AACA;AACA,IAAI,MAAM,GAAG,wBAAwB,IAAI,MAAM,EAAE;AACjD,IAAI,GAAG,CAAC,MAAM,CAAC,CAAC,EAAE,IAAI,CAAC,OAAO,EAAE,CAAC,GAAG,CAAC,EAAE;AACvC;AACA,MAAM,EAAE,YAAY,YAAY,uBAAuB,EAAE,CAAC,KAAK,EAAE,IAAI;AACrE,KAAK;AACL,IAAI,OAAO;AACX,EAAE;;AAEF,EAAE,IAAI,MAAM,CAAC,GAAG;AAChB,IAAI,IAAI,CAAC,GAAG,IAAI,mBAAmB;AACnC,IAAI,OAAO,IAAI,CAAC;AAChB,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,MAAM,CAAC,CAAC,KAAK,EAAE,OAAO,EAAE;AAC1B,IAAI,IAAI,IAAI,CAAC,GAAG,KAAK,IAAI,EAAE;AAC3B,MAAM,QAAQ,CAAC,IAAI,CAAC,GAAG,EAAE,WAAW,IAAI;AACxC,QAAQ,sBAAsB,CAAC,WAAW,EAAE,IAAI,EAAE,KAAK,sBAAsB,OAAO;AACpF,MAAM,CAAC;AACP,IAAI,CAAC,MAAM;AACX,gCAAgC,CAAC,IAAI,CAAC,cAAc,EAAE,MAAM,CAAC,KAAK,EAAE,CAAC,EAAE,GAAG,OAAO;AACjF,IAAI;AACJ,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,IAAI,CAAC,CAAC,OAAO,EAAE;AACjB,IAAI,IAAI,IAAI,CAAC,GAAG,KAAK,IAAI,EAAE;AAC3B,MAAM,QAAQ,CAAC,IAAI,CAAC,GAAG,EAAE,WAAW,IAAI;AACxC,QAAQ,oBAAoB,CAAC,WAAW,EAAE,IAAI,sBAAsB,OAAO;AAC3E,MAAM,CAAC;AACP,IAAI,CAAC,MAAM;AACX,gCAAgC,CAAC,IAAI,CAAC,cAAc,EAAE,IAAI,CAAC,GAAG,OAAO;AACrE,IAAI;AACJ,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE,OAAO,CAAC,CAAC,OAAO,EAAE;AACpB,IAAI,IAAI,CAAC,MAAM,CAAC,CAAC,EAAE,OAAO;AAC1B,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,MAAM,CAAC,CAAC,KAAK,EAAE,MAAM,GAAG,CAAC,EAAE;AAC7B,IAAI,IAAI,IAAI,CAAC,GAAG,KAAK,IAAI,EAAE;AAC3B,MAAM,QAAQ,CAAC,IAAI,CAAC,GAAG,EAAE,WAAW,IAAI;AACxC,QAAQ,cAAc,CAAC,WAAW,EAAE,IAAI,EAAE,KAAK,EAAE,MAAM;AACvD,MAAM,CAAC;AACP,IAAI,CAAC,MAAM;AACX,gCAAgC,CAAC,IAAI,CAAC,cAAc,EAAE,MAAM,CAAC,KAAK,EAAE,MAAM;AAC1E,IAAI;AACJ,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,GAAG,CAAC,CAAC,KAAK,EAAE;AACd,IAAI,OAAO,WAAW,CAAC,IAAI,EAAE,KAAK;AAClC,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE,OAAO,CAAC,GAAG;AACb,IAAI,OAAO,eAAe,CAAC,IAAI;AAC/B,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,cAAc,CAAC,CAAC,EAAE,GAAG,qBAAqB,EAAE;AAC9C,IAAI,OAAO,KAAK,CAAC,cAAc,CAAC,EAAE;AAClC,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,KAAK,CAAC,CAAC,KAAK,GAAG,CAAC,EAAE,GAAG,GAAG,IAAI,CAAC,MAAM,EAAE;AACvC,IAAI,OAAO,aAAa,CAAC,IAAI,EAAE,KAAK,EAAE,GAAG;AACzC,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE,MAAM,CAAC,GAAG;AACZ,IAAI,OAAO,IAAI,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,YAAY,YAAY,GAAG,CAAC,CAAC,MAAM,EAAE,GAAG,CAAC;AACnE,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,GAAG,CAAC,CAAC,CAAC,EAAE;AACV,IAAI,OAAO,WAAW,CAAC,IAAI,sBAAsB,CAAC;AAClD,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE;AACd,IAAI,eAAe,CAAC,IAAI,EAAE,CAAC;AAC3B,EAAE;;AAEF;AACA;AACA;AACA,EAAE,CAAC,MAAM,CAAC,QAAQ,EAAE,GAAG;AACvB,IAAI,OAAO,sBAAsB,CAAC,IAAI;AACtC,EAAE;;AAEF;AACA;AACA;AACA,EAAE,MAAM,CAAC,CAAC,OAAO,EAAE;AACnB,IAAI,OAAO,CAAC,YAAY,CAAC,WAAW;AACpC,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,UAAU,GAAG,QAAQ,IAAI,IAAI,MAAM;;AC7QhD;AACA;AACA;;;AAkBA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,MAAM,IAAI,SAAS,YAAY,CAAC;AACvC;AACA;AACA;AACA;AACA,EAAE,WAAW,CAAC,CAAC,OAAO,EAAE;AACxB,IAAI,KAAK;AACT;AACA;AACA;AACA;AACA,IAAI,IAAI,CAAC,cAAc,GAAG;;AAE1B,IAAI,IAAI,OAAO,KAAK,SAAS,EAAE;AAC/B,MAAM,IAAI,CAAC,cAAc,GAAG,IAAI,GAAG;AACnC,IAAI,CAAC,MAAM;AACX,MAAM,IAAI,CAAC,cAAc,GAAG,IAAI,GAAG,CAAC,OAAO;AAC3C,IAAI;AACJ,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,UAAU,CAAC,CAAC,CAAC,EAAE,IAAI,EAAE;AACvB,IAAI,KAAK,CAAC,UAAU,CAAC,CAAC,EAAE,IAAI;AAC5B,KAAK,gCAAgC,CAAC,IAAI,CAAC,cAAc,EAAE,OAAO,CAAC,CAAC,KAAK,EAAE,GAAG,KAAK;AACnF,MAAM,IAAI,CAAC,GAAG,CAAC,GAAG,EAAE,KAAK;AACzB,IAAI,CAAC;AACL,IAAI,IAAI,CAAC,cAAc,GAAG;AAC1B,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,KAAK,CAAC,GAAG;AACX,IAAI,MAAM,GAAG,GAAG,IAAI,CAAC,KAAK;AAC1B,IAAI,IAAI,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,GAAG,KAAK;AACjC,MAAM,GAAG,CAAC,GAAG,CAAC,GAAG,EAAE,KAAK,YAAY,YAAY,gCAAgC,KAAK,CAAC,KAAK,EAAE,IAAI,KAAK;AACtG,IAAI,CAAC;AACL,IAAI,OAAO;AACX,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE,MAAM,CAAC,GAAG;AACZ,IAAI,IAAI,CAAC,GAAG,IAAI,mBAAmB;AACnC;AACA;AACA;AACA,IAAI,MAAM,GAAG,GAAG;AAChB,IAAI,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,GAAG,KAAK;AACrC,MAAM,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE;AACzB,QAAQ,MAAM,CAAC,GAAG,IAAI,CAAC,OAAO,CAAC,UAAU,EAAE,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC;AAC3D,QAAQ,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,YAAY,YAAY,GAAG,CAAC,CAAC,MAAM,EAAE,GAAG;AAC5D,MAAM;AACN,IAAI,CAAC;AACL,IAAI,OAAO;AACX,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE,IAAI,IAAI,CAAC,GAAG;AACd,IAAI,OAAO,CAAC,GAAG,iBAAiB,CAAC,IAAI,CAAC,CAAC,CAAC;AACxC,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE,IAAI,CAAC,GAAG;AACV,IAAI,OAAO,QAAQ,CAAC,WAAW,CAAC,iBAAiB,CAAC,IAAI,CAAC,wBAAwB,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;AACxF,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE,MAAM,CAAC,GAAG;AACZ,IAAI,OAAO,QAAQ,CAAC,WAAW,CAAC,iBAAiB,CAAC,IAAI,CAAC,wBAAwB,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,UAAU,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC;AAC9H,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE,OAAO,CAAC,GAAG;AACb,IAAI,OAAO,QAAQ,CAAC,WAAW,CAAC,iBAAiB,CAAC,IAAI,CAAC,wBAAwB,CAAC,wBAAwB,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,UAAU,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;AAC3J,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE;AACd,IAAI,IAAI,CAAC,GAAG,IAAI,mBAAmB;AACnC,IAAI,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,GAAG,KAAK;AACrC,MAAM,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE;AACzB,QAAQ,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,UAAU,EAAE,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,EAAE,GAAG,EAAE,IAAI;AAC/D,MAAM;AACN,IAAI,CAAC;AACL,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE,CAAC,MAAM,CAAC,QAAQ,EAAE,GAAG;AACvB,IAAI,OAAO,IAAI,CAAC,OAAO;AACvB,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE,MAAM,CAAC,CAAC,GAAG,EAAE;AACf,IAAI,IAAI,IAAI,CAAC,GAAG,KAAK,IAAI,EAAE;AAC3B,MAAM,QAAQ,CAAC,IAAI,CAAC,GAAG,EAAE,WAAW,IAAI;AACxC,QAAQ,aAAa,CAAC,WAAW,EAAE,IAAI,EAAE,GAAG;AAC5C,MAAM,CAAC;AACP,IAAI,CAAC,MAAM;AACX,sCAAsC,CAAC,IAAI,CAAC,cAAc,EAAE,MAAM,CAAC,GAAG;AACtE,IAAI;AACJ,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,GAAG,CAAC,CAAC,GAAG,EAAE,KAAK,EAAE;AACnB,IAAI,IAAI,IAAI,CAAC,GAAG,KAAK,IAAI,EAAE;AAC3B,MAAM,QAAQ,CAAC,IAAI,CAAC,GAAG,EAAE,WAAW,IAAI;AACxC,QAAQ,UAAU,CAAC,WAAW,EAAE,IAAI,EAAE,GAAG,sBAAsB,KAAK;AACpE,MAAM,CAAC;AACP,IAAI,CAAC,MAAM;AACX,sCAAsC,CAAC,IAAI,CAAC,cAAc,EAAE,GAAG,CAAC,GAAG,EAAE,KAAK;AAC1E,IAAI;AACJ,IAAI,OAAO;AACX,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,GAAG,CAAC,CAAC,GAAG,EAAE;AACZ,IAAI,2BAA2B,UAAU,CAAC,IAAI,EAAE,GAAG,CAAC;AACpD,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,GAAG,CAAC,CAAC,GAAG,EAAE;AACZ,IAAI,OAAO,UAAU,CAAC,IAAI,EAAE,GAAG;AAC/B,EAAE;;AAEF;AACA;AACA;AACA,EAAE,KAAK,CAAC,GAAG;AACX,IAAI,IAAI,IAAI,CAAC,GAAG,KAAK,IAAI,EAAE;AAC3B,MAAM,QAAQ,CAAC,IAAI,CAAC,GAAG,EAAE,WAAW,IAAI;AACxC,QAAQ,IAAI,CAAC,OAAO,CAAC,UAAU,MAAM,EAAE,GAAG,EAAE,GAAG,EAAE;AACjD,UAAU,aAAa,CAAC,WAAW,EAAE,GAAG,EAAE,GAAG;AAC7C,QAAQ,CAAC;AACT,MAAM,CAAC;AACP,IAAI,CAAC,MAAM;AACX,sCAAsC,CAAC,IAAI,CAAC,cAAc,EAAE,KAAK;AACjE,IAAI;AACJ,EAAE;;AAEF;AACA;AACA;AACA,EAAE,MAAM,CAAC,CAAC,OAAO,EAAE;AACnB,IAAI,OAAO,CAAC,YAAY,CAAC,SAAS;AAClC,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,QAAQ,GAAG,QAAQ,IAAI,IAAI,IAAI;;ACnP5C;AACA;AACA;;;AAgCO,MAAM,oBAAoB,CAAC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,WAAW,CAAC,CAAC,IAAI,EAAE,KAAK,EAAE,KAAK,EAAE,iBAAiB,EAAE,EAAE,EAAE;AAC1D,IAAI,IAAI,CAAC,IAAI,GAAG;AAChB,IAAI,IAAI,CAAC,KAAK,GAAG;AACjB,IAAI,IAAI,CAAC,KAAK,GAAG;AACjB,IAAI,IAAI,CAAC,iBAAiB,GAAG;AAC7B,IAAI,IAAI,CAAC,EAAE,GAAG;AACd,EAAE;;AAEF;AACA;AACA;AACA,EAAE,OAAO,CAAC,GAAG;AACb,IAAI,IAAI,IAAI,CAAC,KAAK,KAAK,IAAI,EAAE;AAC7B,MAAM,KAAK,CAAC,cAAc;AAC1B,IAAI;AACJ,IAAI,QAAQ,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,WAAW;AAC1C,MAAM,KAAK,aAAa;AACxB,QAAQ,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE;AACjC,UAAU,uBAAuB,CAAC,IAAI,CAAC,iBAAiB,gCAAgC,IAAI,CAAC,KAAK,CAAC,OAAO;AAC1G,QAAQ;AACR,QAAQ;AACR,MAAM;AACN,QAAQ,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,EAAE,CAAC,aAAa,CAAC,IAAI,CAAC,KAAK;AACtD,QAAQ;AACR;AACA,IAAI,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;AACrB,IAAI,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;AAC5B,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,UAAU,CAAC,CAAC,WAAW,EAAE,MAAM,EAAE,MAAM,EAAE,UAAU,EAAE;AACvD,IAAI,MAAM,GAAG,GAAG,WAAW,CAAC;AAC5B,IAAI,MAAM,WAAW,GAAG,GAAG,CAAC;AAC5B,IAAI,wBAAwB,CAAC,IAAI,EAAE,UAAU;AAC7C,IAAI,MAAM,iBAAiB,GAAG,gBAAgB,CAAC,WAAW,EAAE,MAAM,EAAE,IAAI,EAAE,UAAU;AACpF;AACA;AACA;AACA;AACA,IAAI,aAAa,EAAE;AACnB,MAAM,IAAI,CAAC,KAAK,KAAK,IAAI;AACzB,OAAO,MAAM,GAAG,CAAC;AACjB;AACA,UAAU,iBAAiB,CAAC,IAAI,GAAG,CAAC;AACpC,WAAW,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO,IAAI,IAAI,CAAC,EAAE,CAAC,aAAa,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,WAAW,KAAK,aAAa;AAC9H;AACA;AACA,MAAM;AACN,MAAM,QAAQ,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,WAAW;AAC5C,QAAQ,KAAK,aAAa,EAAE;AAC5B,UAAU,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE;AACnC,YAAY,MAAM,EAAE,GAAG,EAAE,KAAK,EAAE,iCAAiC,IAAI,CAAC,KAAK,CAAC,OAAO;AACnF,YAAY,MAAM,IAAI,GAAG,UAAU,CAAC,GAAG;AACvC,YAAY,IAAI,IAAI,KAAK,SAAS,EAAE;AACpC,cAAc,IAAI,UAAU,CAAC,IAAI,EAAE,KAAK,CAAC,EAAE;AAC3C,gBAAgB,iBAAiB,CAAC,MAAM,CAAC,GAAG;AAC5C,cAAc,CAAC,MAAM;AACrB,gBAAgB,IAAI,MAAM,KAAK,CAAC,EAAE;AAClC;AACA;AACA,kBAAkB,MAAM;AACxB,gBAAgB;AAChB,gBAAgB,iBAAiB,CAAC,GAAG,CAAC,GAAG,EAAE,KAAK;AAChD,cAAc;AACd,cAAc,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,WAAW;AAC3C,YAAY,CAAC,MAAM;AACnB,cAAc,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,GAAG,EAAE,KAAK;AACnD,YAAY;AACZ,UAAU;AACV,UAAU;AACV,QAAQ;AACR,QAAQ,SAAS;AACjB,UAAU,MAAM,IAAI,GAAG,IAAI,CAAC;AAC5B,UAAU,MAAM,QAAQ,GAAG,IAAI,CAAC,EAAE,CAAC,aAAa,CAAC,IAAI;AACrD,UAAU,IAAI,MAAM,GAAG,QAAQ,EAAE;AACjC;AACA;AACA;AACA,YAAY,MAAM,QAAQ,GAAG;AAC7B,YAAY,IAAI,CAAC,EAAE,CAAC,WAAW,CAAC,QAAQ,EAAE,IAAI,CAAC,EAAE,CAAC,MAAM,EAAE,IAAI,CAAC,EAAE,CAAC,KAAK,EAAE,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,OAAO,EAAE,CAAC;AACtG,YAAY,IAAI,CAAC,GAAG;AACpB,YAAY,OAAO,CAAC,GAAG,QAAQ,CAAC,MAAM,IAAI,MAAM,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE;AAC3D,cAAc,MAAM,CAAC,GAAG,QAAQ,CAAC,CAAC;AAClC,cAAc,IAAI,CAAC,CAAC,CAAC,CAAC,OAAO,IAAI,CAAC,CAAC,KAAK,IAAI,IAAI,KAAK,CAAC,CAAC,OAAO,CAAC,WAAW,EAAE,EAAE;AAC9E,gBAAgB,MAAM,IAAI,CAAC,CAAC,OAAO,CAAC,SAAS;AAC7C,cAAc;AACd,YAAY;AACZ,YAAY,IAAI,MAAM,GAAG,CAAC,KAAK,MAAM,KAAK,CAAC,IAAI,CAAC,KAAK,QAAQ,CAAC,MAAM,CAAC,EAAE;AACvE,cAAc,MAAM,CAAC,GAAG,QAAQ,CAAC,EAAE,CAAC;AACpC,cAAc,iBAAiB,CAAC,WAAW,EAAE,QAAQ,CAAC,IAAI,CAAC,EAAE,CAAC,MAAM,EAAE,CAAC,CAAC,KAAK,GAAG,CAAC,CAAC,OAAO,CAAC,SAAS,EAAE,GAAG,MAAM,CAAC;AAC/G,YAAY;AACZ,UAAU,CAAC,MAAM;AACjB,YAAY,MAAM,IAAI;AACtB,UAAU;AACV,UAAU;AACV,QAAQ;AACR;AACA,MAAM,IAAI,CAAC,OAAO;AAClB,IAAI;AACJ;AACA;AACA;AACA,IAAI,IAAI,MAAM,GAAG,CAAC,EAAE;AACpB,MAAM,IAAI,QAAQ,GAAG;AACrB,MAAM,OAAO,MAAM,GAAG,CAAC,EAAE,MAAM,EAAE,EAAE;AACnC,QAAQ,QAAQ,IAAI;AACpB,MAAM;AACN,MAAM,IAAI,CAAC,KAAK,GAAG,IAAI,IAAI,CAAC,QAAQ,CAAC,WAAW,EAAE,QAAQ,CAAC,GAAG,CAAC,KAAK,EAAE,WAAW,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,EAAE,MAAM,EAAE,IAAI,EAAE,IAAI,aAAa,CAAC,QAAQ,CAAC;AACjN,MAAM,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,WAAW,EAAE,CAAC;AACzC,MAAM,IAAI,CAAC,OAAO;AAClB,IAAI;AACJ,IAAI,uBAAuB,CAAC,WAAW,EAAE,MAAM,EAAE,IAAI,EAAE,iBAAiB;AACxE,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,gBAAgB,GAAG,CAAC,WAAW,EAAE,GAAG,EAAE,KAAK,KAAK;AACtD,EAAE,OAAO,GAAG,CAAC,KAAK,KAAK,IAAI,IAAI,KAAK,GAAG,CAAC,EAAE;AAC1C,IAAI,QAAQ,GAAG,CAAC,KAAK,CAAC,OAAO,CAAC,WAAW;AACzC,MAAM,KAAK,aAAa;AACxB,QAAQ,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,OAAO,EAAE;AAChC,UAAU,uBAAuB,CAAC,GAAG,CAAC,iBAAiB,gCAAgC,GAAG,CAAC,KAAK,CAAC,OAAO;AACxG,QAAQ;AACR,QAAQ;AACR,MAAM;AACN,QAAQ,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,OAAO,EAAE;AAChC,UAAU,IAAI,KAAK,GAAG,GAAG,CAAC,KAAK,CAAC,MAAM,EAAE;AACxC;AACA,YAAY,iBAAiB,CAAC,WAAW,EAAE,QAAQ,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE,CAAC,MAAM,EAAE,GAAG,CAAC,KAAK,CAAC,EAAE,CAAC,KAAK,GAAG,KAAK,CAAC;AACpG,UAAU;AACV,UAAU,GAAG,CAAC,KAAK,IAAI,GAAG,CAAC,KAAK,CAAC;AACjC,UAAU,KAAK,IAAI,GAAG,CAAC,KAAK,CAAC;AAC7B,QAAQ;AACR,QAAQ;AACR;AACA,IAAI,GAAG,CAAC,IAAI,GAAG,GAAG,CAAC;AACnB,IAAI,GAAG,CAAC,KAAK,GAAG,GAAG,CAAC,KAAK,CAAC;AAC1B;AACA,EAAE;AACF,EAAE,OAAO;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,YAAY,GAAG,CAAC,WAAW,EAAE,MAAM,EAAE,KAAK,EAAE,eAAe,KAAK;AACtE,EAAE,MAAM,iBAAiB,GAAG,IAAI,GAAG;AACnC,EAAE,MAAM,MAAM,GAAG,eAAe,GAAG,UAAU,CAAC,MAAM,EAAE,KAAK,CAAC,GAAG;AAC/D,EAAE,IAAI,MAAM,EAAE;AACd,IAAI,MAAM,GAAG,GAAG,IAAI,oBAAoB,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC,EAAE,MAAM,CAAC,KAAK,EAAE,iBAAiB,EAAE,qBAAqB;AACxH,IAAI,OAAO,gBAAgB,CAAC,WAAW,EAAE,GAAG,EAAE,KAAK,GAAG,MAAM,CAAC,KAAK;AAClE,EAAE,CAAC,MAAM;AACT,IAAI,MAAM,GAAG,GAAG,IAAI,oBAAoB,CAAC,IAAI,EAAE,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,iBAAiB,EAAE,qBAAqB;AACzG,IAAI,OAAO,gBAAgB,CAAC,WAAW,EAAE,GAAG,EAAE,KAAK;AACnD,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,uBAAuB,GAAG,CAAC,WAAW,EAAE,MAAM,EAAE,OAAO,EAAE,iBAAiB,KAAK;AACrF;AACA,EAAE;AACF,IAAI,OAAO,CAAC,KAAK,KAAK,IAAI;AAC1B,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,OAAO,KAAK,OAAO,CAAC,EAAE,KAAK,qBAAqB,IAAI,OAAO,CAAC,EAAE,CAAC,aAAa,CAAC,OAAO,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;AACvH,QAAQ,OAAO,CAAC,KAAK,CAAC,OAAO,CAAC,WAAW,KAAK,aAAa;AAC3D,QAAQ,UAAU,CAAC,iBAAiB,CAAC,GAAG,8BAA8B,CAAC,OAAO,CAAC,KAAK,CAAC,OAAO,EAAE,GAAG,CAAC,+BAA+B,CAAC,OAAO,CAAC,KAAK,CAAC,OAAO,EAAE,KAAK;AAC9J;AACA;AACA,IAAI;AACJ,IAAI,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,OAAO,EAAE;AAChC,MAAM,iBAAiB,CAAC,MAAM,8BAA8B,CAAC,OAAO,CAAC,KAAK,CAAC,OAAO,EAAE,GAAG;AACvF,IAAI;AACJ,IAAI,OAAO,CAAC,OAAO;AACnB,EAAE;AACF,EAAE,MAAM,GAAG,GAAG,WAAW,CAAC;AAC1B,EAAE,MAAM,WAAW,GAAG,GAAG,CAAC;AAC1B,EAAE,iBAAiB,CAAC,OAAO,CAAC,CAAC,GAAG,EAAE,GAAG,KAAK;AAC1C,IAAI,MAAM,IAAI,GAAG,OAAO,CAAC;AACzB,IAAI,MAAM,KAAK,GAAG,OAAO,CAAC;AAC1B,IAAI,MAAM,UAAU,GAAG,IAAI,IAAI,CAAC,QAAQ,CAAC,WAAW,EAAE,QAAQ,CAAC,GAAG,CAAC,KAAK,EAAE,WAAW,CAAC,CAAC,EAAE,IAAI,EAAE,IAAI,IAAI,IAAI,CAAC,MAAM,EAAE,KAAK,EAAE,KAAK,IAAI,KAAK,CAAC,EAAE,EAAE,MAAM,EAAE,IAAI,EAAE,IAAI,aAAa,CAAC,GAAG,EAAE,GAAG,CAAC;AACvL,IAAI,UAAU,CAAC,SAAS,CAAC,WAAW,EAAE,CAAC;AACvC,IAAI,OAAO,CAAC,KAAK,GAAG;AACpB,IAAI,OAAO,CAAC,OAAO;AACnB,EAAE,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,uBAAuB,GAAG,CAAC,iBAAiB,EAAE,MAAM,KAAK;AAC/D,EAAE,MAAM,EAAE,GAAG,EAAE,KAAK,EAAE,GAAG;AACzB,EAAE,IAAI,KAAK,KAAK,IAAI,EAAE;AACtB,IAAI,iBAAiB,CAAC,MAAM,CAAC,GAAG;AAChC,EAAE,CAAC,MAAM;AACT,IAAI,iBAAiB,CAAC,GAAG,CAAC,GAAG,EAAE,KAAK;AACpC,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,wBAAwB,GAAG,CAAC,OAAO,EAAE,UAAU,KAAK;AAC1D;AACA,EAAE,OAAO,IAAI,EAAE;AACf,IAAI,IAAI,OAAO,CAAC,KAAK,KAAK,IAAI,EAAE;AAChC,MAAM;AACN,IAAI,CAAC,MAAM,IAAI,OAAO,CAAC,KAAK,CAAC,OAAO,IAAI,OAAO,CAAC,EAAE,CAAC,aAAa,CAAC,OAAO,CAAC,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,OAAO,IAAI,OAAO,CAAC,KAAK,CAAC,OAAO,CAAC,WAAW,KAAK,aAAa,IAAI,UAAU,CAAC,UAAU,CAAC,+BAA+B,OAAO,CAAC,KAAK,CAAC,OAAO,GAAG,GAAG,CAAC,IAAI,IAAI,+BAA+B,CAAC,OAAO,CAAC,KAAK,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC,EAAE,CAE/T,MAAM;AACX,MAAM;AACN,IAAI;AACJ,IAAI,OAAO,CAAC,OAAO;AACnB,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,gBAAgB,GAAG,CAAC,WAAW,EAAE,MAAM,EAAE,OAAO,EAAE,UAAU,KAAK;AACvE,EAAE,MAAM,GAAG,GAAG,WAAW,CAAC;AAC1B,EAAE,MAAM,WAAW,GAAG,GAAG,CAAC;AAC1B,EAAE,MAAM,iBAAiB,GAAG,IAAI,GAAG;AACnC;AACA,EAAE,KAAK,MAAM,GAAG,IAAI,UAAU,EAAE;AAChC,IAAI,MAAM,GAAG,GAAG,UAAU,CAAC,GAAG;AAC9B,IAAI,MAAM,UAAU,GAAG,OAAO,CAAC,iBAAiB,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI;AAC7D,IAAI,IAAI,CAAC,UAAU,CAAC,UAAU,EAAE,GAAG,CAAC,EAAE;AACtC;AACA,MAAM,iBAAiB,CAAC,GAAG,CAAC,GAAG,EAAE,UAAU;AAC3C,MAAM,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG;AAC9B,MAAM,OAAO,CAAC,KAAK,GAAG,IAAI,IAAI,CAAC,QAAQ,CAAC,WAAW,EAAE,QAAQ,CAAC,GAAG,CAAC,KAAK,EAAE,WAAW,CAAC,CAAC,EAAE,IAAI,EAAE,IAAI,IAAI,IAAI,CAAC,MAAM,EAAE,KAAK,EAAE,KAAK,IAAI,KAAK,CAAC,EAAE,EAAE,MAAM,EAAE,IAAI,EAAE,IAAI,aAAa,CAAC,GAAG,EAAE,GAAG,CAAC;AACtL,MAAM,OAAO,CAAC,KAAK,CAAC,SAAS,CAAC,WAAW,EAAE,CAAC;AAC5C,MAAM,OAAO,CAAC,OAAO;AACrB,IAAI;AACJ,EAAE;AACF,EAAE,OAAO;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,UAAU,GAAG,CAAC,WAAW,EAAE,MAAM,EAAE,OAAO,EAAE,IAAI,EAAE,UAAU,KAAK;AAC9E,EAAE,OAAO,CAAC,iBAAiB,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,GAAG,KAAK;AACnD,IAAI,IAAI,UAAU,CAAC,GAAG,CAAC,KAAK,SAAS,EAAE;AACvC,MAAM,UAAU,CAAC,GAAG,CAAC,GAAG;AACxB,IAAI;AACJ,EAAE,CAAC;AACH,EAAE,MAAM,GAAG,GAAG,WAAW,CAAC;AAC1B,EAAE,MAAM,WAAW,GAAG,GAAG,CAAC;AAC1B,EAAE,wBAAwB,CAAC,OAAO,EAAE,UAAU;AAC9C,EAAE,MAAM,iBAAiB,GAAG,gBAAgB,CAAC,WAAW,EAAE,MAAM,EAAE,OAAO,EAAE,UAAU;AACrF;AACA,EAAE,MAAM,OAAO,GAAG,IAAI,CAAC,WAAW,KAAK,MAAM,GAAG,IAAI,aAAa,wBAAwB,IAAI,EAAE,IAAI,IAAI,YAAY,YAAY,GAAG,IAAI,WAAW,CAAC,IAAI,CAAC,GAAG,IAAI,YAAY,CAAC,IAAI,CAAC;AAChL,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,KAAK,EAAE,GAAG;AAC/B,EAAE,IAAI,MAAM,CAAC,aAAa,EAAE;AAC5B,IAAI,mBAAmB,CAAC,MAAM,CAAC,aAAa,EAAE,OAAO,CAAC,KAAK,EAAE,OAAO,CAAC,SAAS,EAAE;AAChF,EAAE;AACF,EAAE,KAAK,GAAG,IAAI,IAAI,CAAC,QAAQ,CAAC,WAAW,EAAE,QAAQ,CAAC,GAAG,CAAC,KAAK,EAAE,WAAW,CAAC,CAAC,EAAE,IAAI,EAAE,IAAI,IAAI,IAAI,CAAC,MAAM,EAAE,KAAK,EAAE,KAAK,IAAI,KAAK,CAAC,EAAE,EAAE,MAAM,EAAE,IAAI,EAAE,OAAO;AACtJ,EAAE,KAAK,CAAC,SAAS,CAAC,WAAW,EAAE,CAAC;AAChC,EAAE,OAAO,CAAC,KAAK,GAAG;AAClB,EAAE,OAAO,CAAC,KAAK,GAAG;AAClB,EAAE,OAAO,CAAC,OAAO;AACjB,EAAE,uBAAuB,CAAC,WAAW,EAAE,MAAM,EAAE,OAAO,EAAE,iBAAiB;AACzE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,oBAAoB,GAAG,CAAC,WAAW,EAAE,KAAK,EAAE,IAAI,EAAE,eAAe,EAAE,cAAc,KAAK;AAC5F,EAAE,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,iBAAiB,EAAE,OAAO;AACjD;AACA;AACA;AACA,EAAE,IAAI,GAAG,GAAG;AACZ;AACA;AACA;AACA,EAAE,MAAM,UAAU,GAAG,GAAG,CAAC,MAAM;AAC/B,EAAE,OAAO,GAAG,KAAK,CAAC,GAAG,CAAC,SAAS,IAAI,GAAG,CAAC,OAAO,CAAC,EAAE;AACjD,IAAI,IAAI,CAAC,GAAG,CAAC,OAAO,IAAI,GAAG,CAAC,OAAO,CAAC,WAAW,KAAK,aAAa,EAAE;AACnE,MAAM,MAAM,EAAE,iCAAiC,GAAG,CAAC,OAAO;AAC1D,MAAM,UAAU,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,EAAE;AAC/B,IAAI;AACJ,IAAI,GAAG,GAAG,GAAG,CAAC;AACd,EAAE;AACF,EAAE,IAAI,QAAQ,GAAG;AACjB,EAAE,IAAI,WAAW,GAAG;AACpB,EAAE,OAAO,KAAK,KAAK,GAAG,EAAE;AACxB,IAAI,IAAI,IAAI,KAAK,KAAK,EAAE;AACxB,MAAM,WAAW,GAAG;AACpB,IAAI;AACJ,IAAI,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE;AACxB,MAAM,MAAM,OAAO,GAAG,KAAK,CAAC;AAC5B,MAAM,QAAQ,OAAO,CAAC,WAAW;AACjC,QAAQ,KAAK,aAAa,EAAE;AAC5B,UAAU,MAAM,EAAE,GAAG,EAAE,KAAK,EAAE,iCAAiC,OAAO;AACtE,UAAU,MAAM,cAAc,GAAG,eAAe,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI;AAC7D,UAAU,IAAI,UAAU,CAAC,GAAG,CAAC,GAAG,CAAC,KAAK,OAAO,IAAI,cAAc,KAAK,KAAK,EAAE;AAC3E;AACA,YAAY,KAAK,CAAC,MAAM,CAAC,WAAW;AACpC,YAAY,WAAW,CAAC,QAAQ,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE,CAAC,MAAM,EAAE,KAAK,CAAC,EAAE,CAAC,KAAK,EAAE,KAAK,CAAC,MAAM;AAClF,YAAY,QAAQ;AACpB,YAAY,IAAI,CAAC,WAAW,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,IAAI,MAAM,KAAK,IAAI,cAAc,KAAK,KAAK,EAAE;AACzG,cAAc,IAAI,cAAc,KAAK,IAAI,EAAE;AAC3C,gBAAgB,cAAc,CAAC,MAAM,CAAC,GAAG;AACzC,cAAc,CAAC,MAAM;AACrB,gBAAgB,cAAc,CAAC,GAAG,CAAC,GAAG,EAAE,cAAc;AACtD,cAAc;AACd,YAAY;AACZ,UAAU;AACV,UAAU,IAAI,CAAC,WAAW,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE;AAC9C,YAAY,uBAAuB,CAAC,cAAc,gCAAgC,OAAO;AACzF,UAAU;AACV,UAAU;AACV,QAAQ;AACR;AACA,IAAI;AACJ,IAAI,KAAK,wBAAwB,KAAK,CAAC,KAAK;AAC5C,EAAE;AACF,EAAE,OAAO;AACT;;AAEA;AACA;AACA;AACA;AACA,MAAM,+BAA+B,GAAG,CAAC,WAAW,EAAE,IAAI,KAAK;AAC/D,EAAE,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,iBAAiB,EAAE,OAAO;AACjD;AACA,EAAE,OAAO,IAAI,IAAI,IAAI,CAAC,KAAK,KAAK,IAAI,CAAC,KAAK,CAAC,OAAO,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,EAAE;AAC9E,IAAI,IAAI,GAAG,IAAI,CAAC;AAChB,EAAE;AACF,EAAE,MAAM,KAAK,GAAG,IAAI,GAAG;AACvB;AACA,EAAE,OAAO,IAAI,KAAK,IAAI,CAAC,OAAO,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,EAAE;AACpD,IAAI,IAAI,CAAC,IAAI,CAAC,OAAO,IAAI,IAAI,CAAC,OAAO,CAAC,WAAW,KAAK,aAAa,EAAE;AACrE,MAAM,MAAM,GAAG,gCAAgC,CAAC,IAAI,CAAC,OAAO,EAAE;AAC9D,MAAM,IAAI,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;AAC1B,QAAQ,IAAI,CAAC,MAAM,CAAC,WAAW;AAC/B,QAAQ,WAAW,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,MAAM,EAAE,IAAI,CAAC,EAAE,CAAC,KAAK,EAAE,IAAI,CAAC,MAAM;AAC3E,MAAM,CAAC,MAAM;AACb,QAAQ,KAAK,CAAC,GAAG,CAAC,GAAG;AACrB,MAAM;AACN,IAAI;AACJ,IAAI,IAAI,GAAG,IAAI,CAAC;AAChB,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,sBAAsB,GAAG,IAAI,IAAI;AAC9C,EAAE,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE,iBAAiB,EAAE,OAAO;AAC3C,EAAE,IAAI,GAAG,GAAG;AACZ,EAAE,QAAQ,qBAAqB,IAAI,CAAC,GAAG,GAAG,WAAW,IAAI;AACzD,IAAI,IAAI,KAAK,wBAAwB,IAAI,CAAC,MAAM;AAChD,IAAI,IAAI,GAAG,GAAG,IAAI,CAAC;AACnB,IAAI,IAAI,eAAe,GAAG,GAAG,CAAC,MAAM;AACpC,IAAI,MAAM,iBAAiB,GAAG,GAAG,CAAC,IAAI,CAAC,eAAe;AACtD,IAAI,OAAO,GAAG,EAAE;AAChB,MAAM,IAAI,GAAG,CAAC,OAAO,KAAK,KAAK,EAAE;AACjC,QAAQ,QAAQ,GAAG,CAAC,OAAO,CAAC,WAAW;AACvC,UAAU,KAAK,aAAa;AAC5B,YAAY,uBAAuB,CAAC,iBAAiB,gCAAgC,GAAG,CAAC,OAAO;AAChG,YAAY;AACZ,UAAU;AACV,YAAY,GAAG,IAAI,oBAAoB,CAAC,WAAW,EAAE,KAAK,EAAE,GAAG,EAAE,eAAe,EAAE,iBAAiB;AACnG,YAAY,eAAe,GAAG,GAAG,CAAC,IAAI,CAAC,iBAAiB;AACxD,YAAY,KAAK,GAAG;AACpB,YAAY;AACZ;AACA,MAAM;AACN,MAAM,GAAG,GAAG,GAAG,CAAC;AAChB,IAAI;AACJ,EAAE,CAAC;AACH,EAAE,OAAO;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,4BAA4B,GAAG,WAAW,IAAI;AAC3D;AACA;AACA;AACA,EAAE,MAAM,eAAe,GAAG,IAAI,GAAG;AACjC;AACA,EAAE,MAAM,GAAG,GAAG,WAAW,CAAC;AAC1B,EAAE,qBAAqB,CAAC,WAAW,EAAE,WAAW,CAAC,SAAS,EAAE,CAAC,IAAI,KAAK;AACtE,IAAI;AACJ,MAAM,CAAC,IAAI,CAAC,OAAO,wBAAwB,CAAC,IAAI,EAAE,OAAO,CAAC,WAAW,KAAK,aAAa,IAAI,IAAI,CAAC,WAAW,KAAK;AAChH,MAAM;AACN,MAAM,eAAe,CAAC,GAAG,oBAAoB,CAAC,IAAI,EAAE,MAAM;AAC1D,IAAI;AACJ,EAAE,CAAC;AACH;AACA,EAAE,QAAQ,CAAC,GAAG,EAAE,CAAC,CAAC,KAAK;AACvB,IAAI,qBAAqB,CAAC,WAAW,EAAE,WAAW,CAAC,SAAS,EAAE,IAAI,IAAI;AACtE,MAAM,IAAI,IAAI,YAAY,EAAE,IAAI,4BAA4B,CAAC,IAAI,CAAC,MAAM,EAAE,cAAc,CAAC,IAAI,eAAe,CAAC,GAAG,4BAA4B,IAAI,CAAC,MAAM,EAAE,EAAE;AAC3J,QAAQ;AACR,MAAM;AACN,MAAM,MAAM,MAAM,8BAA8B,IAAI,CAAC,MAAM;AAC3D,MAAM,IAAI,IAAI,CAAC,OAAO,CAAC,WAAW,KAAK,aAAa,EAAE;AACtD,QAAQ,eAAe,CAAC,GAAG,CAAC,MAAM;AAClC,MAAM,CAAC,MAAM;AACb;AACA;AACA;AACA,QAAQ,+BAA+B,CAAC,CAAC,EAAE,IAAI;AAC/C,MAAM;AACN,IAAI,CAAC;AACL;AACA;AACA,IAAI,KAAK,MAAM,KAAK,IAAI,eAAe,EAAE;AACzC,MAAM,sBAAsB,CAAC,KAAK;AAClC,IAAI;AACJ,EAAE,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,UAAU,GAAG,CAAC,WAAW,EAAE,OAAO,EAAE,MAAM,KAAK;AAC5D,EAAE,MAAM,WAAW,GAAG;AACtB,EAAE,MAAM,UAAU,GAAG,GAAG,CAAC,IAAI,CAAC,OAAO,CAAC,iBAAiB;AACvD,EAAE,MAAM,KAAK,GAAG,OAAO,CAAC;AACxB,EAAE,OAAO,MAAM,GAAG,CAAC,IAAI,OAAO,CAAC,KAAK,KAAK,IAAI,EAAE;AAC/C,IAAI,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,OAAO,EAAE;AAChC,MAAM,QAAQ,OAAO,CAAC,KAAK,CAAC,OAAO,CAAC,WAAW;AAC/C,QAAQ,KAAK,WAAW;AACxB,QAAQ,KAAK,YAAY;AACzB,QAAQ,KAAK,aAAa;AAC1B,UAAU,IAAI,MAAM,GAAG,OAAO,CAAC,KAAK,CAAC,MAAM,EAAE;AAC7C,YAAY,iBAAiB,CAAC,WAAW,EAAE,QAAQ,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE,CAAC,MAAM,EAAE,OAAO,CAAC,KAAK,CAAC,EAAE,CAAC,KAAK,GAAG,MAAM,CAAC;AAC7G,UAAU;AACV,UAAU,MAAM,IAAI,OAAO,CAAC,KAAK,CAAC;AAClC,UAAU,OAAO,CAAC,KAAK,CAAC,MAAM,CAAC,WAAW;AAC1C,UAAU;AACV;AACA,IAAI,CAAC,MAAM,IAAI,OAAO,CAAC,EAAE,KAAK,qBAAqB,EAAE;AACrD,MAAM,MAAM,IAAI,GAAG,OAAO,CAAC;AAC3B;AACA;AACA;AACA,MAAM,MAAM,QAAQ,GAAG;AACvB,MAAM,OAAO,CAAC,EAAE,CAAC,WAAW,CAAC,QAAQ,EAAE,IAAI,CAAC,EAAE,CAAC,MAAM,EAAE,IAAI,CAAC,EAAE,CAAC,KAAK,EAAE,IAAI,EAAE,IAAI,CAAC,OAAO,EAAE,CAAC;AAC3F,MAAM,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AAChD,QAAQ,MAAM,CAAC,GAAG,QAAQ,CAAC,CAAC;AAC5B,QAAQ,IAAI,CAAC,CAAC,OAAO,CAAC,WAAW,EAAE,IAAI,CAAC,CAAC,KAAK,IAAI,IAAI,EAAE;AACxD;AACA;AACA,UAAU,MAAM,UAAU,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,OAAO,CAAC,SAAS,EAAE,EAAE,MAAM;AACnE,UAAU,GAAG,CAAC,cAAc,CAAC,WAAW,CAAC,IAAI,EAAE,mBAAmB,EAAE,WAAW,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,MAAM,EAAE,CAAC,CAAC,KAAK,EAAE,UAAU;AACxH,UAAU,MAAM,IAAI;AACpB,QAAQ;AACR,MAAM;AACN,MAAM,MAAM,WAAW,GAAG,QAAQ,CAAC,MAAM,GAAG,CAAC,GAAG,QAAQ,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC,GAAG;AAChF,MAAM,MAAM,aAAa,GAAG,IAAI,CAAC,EAAE,CAAC,KAAK,GAAG,IAAI,CAAC;AACjD,MAAM,MAAM,gBAAgB,GAAG,WAAW,IAAI,IAAI,GAAG,WAAW,CAAC,KAAK,GAAG,WAAW,CAAC,OAAO,CAAC,SAAS,EAAE,GAAG;AAC3G,MAAM,IAAI,gBAAgB,GAAG,aAAa,EAAE;AAC5C,QAAQ,iBAAiB,CAAC,WAAW,EAAE,QAAQ,CAAC,IAAI,CAAC,EAAE,CAAC,MAAM,EAAE,gBAAgB,CAAC;AACjF,MAAM;AACN,IAAI;AACJ,IAAI,OAAO,CAAC,OAAO;AACnB,EAAE;AACF,EAAE,IAAI,KAAK,EAAE;AACb,IAAI,oBAAoB,CAAC,WAAW,EAAE,KAAK,EAAE,OAAO,CAAC,KAAK,EAAE,UAAU,EAAE,OAAO,CAAC,iBAAiB;AACjG,EAAE;AACF,EAAE,MAAM,MAAM,yDAAyD,CAAC,OAAO,CAAC,IAAI,IAAI,OAAO,CAAC,KAAK,EAAE,MAAM;AAC7G,EAAE,IAAI,MAAM,CAAC,aAAa,EAAE;AAC5B,IAAI,mBAAmB,CAAC,MAAM,CAAC,aAAa,EAAE,OAAO,CAAC,KAAK,EAAE,CAAC,WAAW,GAAG,MAAM;AAClF,EAAE;AACF,EAAE,OAAO;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,MAAM,KAAK,SAAS,YAAY,CAAC;AACxC;AACA;AACA;AACA,EAAE,WAAW,CAAC,CAAC,MAAM,EAAE;AACvB,IAAI,KAAK;AACT;AACA;AACA;AACA;AACA,IAAI,IAAI,CAAC,QAAQ,GAAG,MAAM,KAAK,SAAS,GAAG,CAAC,MAAM,IAAI,CAAC,MAAM,CAAC,CAAC,EAAE,MAAM,CAAC,CAAC,GAAG;AAC5E;AACA;AACA;AACA,IAAI,IAAI,CAAC,aAAa,GAAG;AACzB;AACA;AACA;AACA;AACA,IAAI,IAAI,CAAC,cAAc,GAAG;AAC1B,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE,IAAI,MAAM,CAAC,GAAG;AAChB,IAAI,IAAI,CAAC,GAAG,IAAI,mBAAmB;AACnC,IAAI,OAAO,IAAI,CAAC;AAChB,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE,UAAU,CAAC,CAAC,CAAC,EAAE,IAAI,EAAE;AACvB,IAAI,KAAK,CAAC,UAAU,CAAC,CAAC,EAAE,IAAI;AAC5B,IAAI,IAAI;AACR,qCAAqC,CAAC,IAAI,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC,IAAI,CAAC,EAAE;AACrE,IAAI,CAAC,CAAC,OAAO,CAAC,EAAE;AAChB,MAAM,OAAO,CAAC,KAAK,CAAC,CAAC;AACrB,IAAI;AACJ,IAAI,IAAI,CAAC,QAAQ,GAAG;AACpB,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,KAAK,CAAC,GAAG;AACX;AACA;AACA;AACA,IAAI,MAAM,IAAI,uBAAuB,IAAI,KAAK,EAAE;AAChD,IAAI,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,UAAU,EAAE;AACrC,IAAI,OAAO;AACX,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,aAAa,CAAC,CAAC,WAAW,EAAE,UAAU,EAAE;AAC1C,IAAI,KAAK,CAAC,aAAa,CAAC,WAAW,EAAE,UAAU;AAC/C;AACA,IAAI,IAAI,CAAC,WAAW,CAAC,KAAK,IAAI,IAAI,CAAC,cAAc,EAAE;AACnD,MAAM,WAAW,CAAC,sBAAsB,GAAG;AAC3C,IAAI;AACJ,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE,QAAQ,CAAC,GAAG;AACd,IAAI,IAAI,CAAC,GAAG,IAAI,mBAAmB;AACnC,IAAI,IAAI,GAAG,GAAG;AACd;AACA;AACA;AACA,IAAI,IAAI,CAAC,GAAG,IAAI,CAAC;AACjB,IAAI,OAAO,CAAC,KAAK,IAAI,EAAE;AACvB,MAAM,IAAI,CAAC,CAAC,CAAC,OAAO,IAAI,CAAC,CAAC,SAAS,IAAI,CAAC,CAAC,OAAO,CAAC,WAAW,KAAK,aAAa,EAAE;AAChF,QAAQ,GAAG,iCAAiC,CAAC,CAAC,CAAC,OAAO,EAAE;AACxD,MAAM;AACN,MAAM,CAAC,GAAG,CAAC,CAAC;AACZ,IAAI;AACJ,IAAI,OAAO;AACX,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,MAAM,CAAC,GAAG;AACZ,IAAI,OAAO,IAAI,CAAC,QAAQ;AACxB,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,MAAM,CAAC,CAAC,KAAK,EAAE,IAAI,EAAE,UAAU,EAAE;AACnC,IAAI,IAAI,IAAI,CAAC,MAAM,IAAI,CAAC,EAAE;AAC1B,MAAM;AACN,IAAI;AACJ,IAAI,MAAM,CAAC,GAAG,IAAI,CAAC;AACnB,IAAI,IAAI,CAAC,KAAK,IAAI,EAAE;AACpB,MAAM,QAAQ,CAAC,CAAC,EAAE,WAAW,IAAI;AACjC,QAAQ,MAAM,GAAG,GAAG,YAAY,CAAC,WAAW,EAAE,IAAI,EAAE,KAAK,EAAE,CAAC,UAAU;AACtE,QAAQ,IAAI,CAAC,UAAU,EAAE;AACzB,UAAU,UAAU,GAAG;AACvB;AACA,UAAU,GAAG,CAAC,iBAAiB,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,KAAK,EAAE,UAAU,CAAC,CAAC,CAAC,GAAG,EAAC,CAAC,CAAC;AACvE,QAAQ;AACR,QAAQ,UAAU,CAAC,WAAW,EAAE,IAAI,EAAE,GAAG,EAAE,IAAI,EAAE,UAAU;AAC3D,MAAM,CAAC;AACP,IAAI,CAAC,MAAM;AACX,qCAAqC,CAAC,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,MAAM,IAAI,CAAC,MAAM,CAAC,KAAK,EAAE,IAAI,EAAE,UAAU,CAAC;AACpG,IAAI;AACJ,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,WAAW,CAAC,CAAC,KAAK,EAAE,KAAK,EAAE,UAAU,EAAE;AACzC,IAAI,MAAM,CAAC,GAAG,IAAI,CAAC;AACnB,IAAI,IAAI,CAAC,KAAK,IAAI,EAAE;AACpB,MAAM,QAAQ,CAAC,CAAC,EAAE,WAAW,IAAI;AACjC,QAAQ,MAAM,GAAG,GAAG,YAAY,CAAC,WAAW,EAAE,IAAI,EAAE,KAAK,EAAE,CAAC,UAAU;AACtE,QAAQ,UAAU,CAAC,WAAW,EAAE,IAAI,EAAE,GAAG,EAAE,KAAK,EAAE,UAAU,IAAI,EAAE;AAClE,MAAM,CAAC;AACP,IAAI,CAAC,MAAM;AACX,qCAAqC,CAAC,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,MAAM,IAAI,CAAC,WAAW,CAAC,KAAK,EAAE,KAAK,EAAE,UAAU,IAAI,EAAE,CAAC;AAChH,IAAI;AACJ,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,MAAM,CAAC,CAAC,KAAK,EAAE,MAAM,EAAE;AACzB,IAAI,IAAI,MAAM,KAAK,CAAC,EAAE;AACtB,MAAM;AACN,IAAI;AACJ,IAAI,MAAM,CAAC,GAAG,IAAI,CAAC;AACnB,IAAI,IAAI,CAAC,KAAK,IAAI,EAAE;AACpB,MAAM,QAAQ,CAAC,CAAC,EAAE,WAAW,IAAI;AACjC,QAAQ,UAAU,CAAC,WAAW,EAAE,YAAY,CAAC,WAAW,EAAE,IAAI,EAAE,KAAK,EAAE,IAAI,CAAC,EAAE,MAAM;AACpF,MAAM,CAAC;AACP,IAAI,CAAC,MAAM;AACX,qCAAqC,CAAC,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,MAAM,IAAI,CAAC,MAAM,CAAC,KAAK,EAAE,MAAM,CAAC;AAC1F,IAAI;AACJ,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,MAAM,CAAC,CAAC,KAAK,EAAE,MAAM,EAAE,UAAU,EAAE;AACrC,IAAI,IAAI,MAAM,KAAK,CAAC,EAAE;AACtB,MAAM;AACN,IAAI;AACJ,IAAI,MAAM,CAAC,GAAG,IAAI,CAAC;AACnB,IAAI,IAAI,CAAC,KAAK,IAAI,EAAE;AACpB,MAAM,QAAQ,CAAC,CAAC,EAAE,WAAW,IAAI;AACjC,QAAQ,MAAM,GAAG,GAAG,YAAY,CAAC,WAAW,EAAE,IAAI,EAAE,KAAK,EAAE,KAAK;AAChE,QAAQ,IAAI,GAAG,CAAC,KAAK,KAAK,IAAI,EAAE;AAChC,UAAU;AACV,QAAQ;AACR,QAAQ,GAAG,CAAC,UAAU,CAAC,WAAW,EAAE,IAAI,EAAE,MAAM,EAAE,UAAU;AAC5D,MAAM,CAAC;AACP,IAAI,CAAC,MAAM;AACX,qCAAqC,CAAC,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,MAAM,IAAI,CAAC,MAAM,CAAC,KAAK,EAAE,MAAM,EAAE,UAAU,CAAC;AACtG,IAAI;AACJ,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,eAAe,CAAC,CAAC,aAAa,EAAE;AAClC,IAAI,IAAI,IAAI,CAAC,GAAG,KAAK,IAAI,EAAE;AAC3B,MAAM,QAAQ,CAAC,IAAI,CAAC,GAAG,EAAE,WAAW,IAAI;AACxC,QAAQ,aAAa,CAAC,WAAW,EAAE,IAAI,EAAE,aAAa;AACtD,MAAM,CAAC;AACP,IAAI,CAAC,MAAM;AACX,qCAAqC,CAAC,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,MAAM,IAAI,CAAC,eAAe,CAAC,aAAa,CAAC;AACnG,IAAI;AACJ,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,YAAY,CAAC,CAAC,aAAa,EAAE,cAAc,EAAE;AAC/C,IAAI,IAAI,IAAI,CAAC,GAAG,KAAK,IAAI,EAAE;AAC3B,MAAM,QAAQ,CAAC,IAAI,CAAC,GAAG,EAAE,WAAW,IAAI;AACxC,QAAQ,UAAU,CAAC,WAAW,EAAE,IAAI,EAAE,aAAa,EAAE,cAAc;AACnE,MAAM,CAAC;AACP,IAAI,CAAC,MAAM;AACX,qCAAqC,CAAC,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,MAAM,IAAI,CAAC,YAAY,CAAC,aAAa,EAAE,cAAc,CAAC;AAChH,IAAI;AACJ,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,YAAY,CAAC,CAAC,aAAa,EAAE;AAC/B,IAAI,2BAA2B,UAAU,CAAC,IAAI,EAAE,aAAa,CAAC;AAC9D,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,aAAa,CAAC,GAAG;AACnB,IAAI,OAAO,aAAa,CAAC,IAAI;AAC7B,EAAE;;AAEF;AACA;AACA;AACA,EAAE,MAAM,CAAC,CAAC,OAAO,EAAE;AACnB,IAAI,OAAO,CAAC,YAAY,CAAC,UAAU;AACnC,EAAE;;AAEF;AACA;AACA;AACA,EAAE,CAAC,MAAM,CAAC,mBAAmB,EAAE,CAAC,KAAK,EAAE;AACvC,IAAI,OAAO,IAAI,CAAC,UAAU,EAAE,CAAC,MAAM,CAAC,KAAK,CAAC,UAAU,EAAE;AACtD,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,SAAS,GAAG,QAAQ,IAAI,IAAI,KAAK;;ACr6B9C;AACA;AACA;;;AAqBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,MAAM,YAAY,SAAS,YAAY,CAAC;AAC/C,EAAE,WAAW,CAAC,GAAG;AACjB,IAAI,KAAK;AACT;AACA;AACA;AACA;AACA,IAAI,IAAI,CAAC,cAAc,GAAG;AAC1B,EAAE;;AAEF;AACA;AACA;AACA,EAAE,IAAI,UAAU,CAAC,GAAG;AACpB,IAAI,MAAM,KAAK,GAAG,IAAI,CAAC;AACvB,IAAI,OAAO,KAAK,GAAG,KAAK,CAAC,OAAO,CAAC,UAAU,EAAE,CAAC,CAAC,CAAC,GAAG;AACnD,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,UAAU,CAAC,CAAC,CAAC,EAAE,IAAI,EAAE;AACvB,IAAI,KAAK,CAAC,UAAU,CAAC,CAAC,EAAE,IAAI;AAC5B,IAAI,IAAI,CAAC,MAAM,CAAC,CAAC,6BAA6B,IAAI,CAAC,cAAc;AACjE,IAAI,IAAI,CAAC,cAAc,GAAG;AAC1B,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,KAAK,CAAC,GAAG;AACX,IAAI,MAAM,EAAE,GAAG,IAAI,CAAC,KAAK;AACzB,IAAI,EAAE,CAAC,MAAM,CAAC,CAAC,EAAE,IAAI,CAAC,OAAO,EAAE,CAAC,GAAG,CAAC,IAAI,IAAI,IAAI,YAAY,YAAY,GAAG,IAAI,CAAC,KAAK,EAAE,GAAG,IAAI,CAAC;AAC/F,IAAI,OAAO;AACX,EAAE;;AAEF,EAAE,IAAI,MAAM,CAAC,GAAG;AAChB,IAAI,IAAI,CAAC,GAAG,IAAI,mBAAmB;AACnC,IAAI,OAAO,IAAI,CAAC,cAAc,KAAK,IAAI,GAAG,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,cAAc,CAAC;AAC7E,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE,QAAQ,CAAC,GAAG;AACd,IAAI,OAAO,WAAW,CAAC,IAAI,EAAE,GAAG,IAAI,GAAG,CAAC,QAAQ,EAAE,CAAC,CAAC,IAAI,CAAC,EAAE;AAC3D,EAAE;;AAEF;AACA;AACA;AACA,EAAE,MAAM,CAAC,GAAG;AACZ,IAAI,OAAO,IAAI,CAAC,QAAQ;AACxB,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,MAAM,CAAC,CAAC,KAAK,EAAE,OAAO,EAAE;AAC1B,IAAI,IAAI,IAAI,CAAC,GAAG,KAAK,IAAI,EAAE;AAC3B,MAAM,QAAQ,CAAC,IAAI,CAAC,GAAG,EAAE,WAAW,IAAI;AACxC,QAAQ,sBAAsB,CAAC,WAAW,EAAE,IAAI,EAAE,KAAK,EAAE,OAAO;AAChE,MAAM,CAAC;AACP,IAAI,CAAC,MAAM;AACX;AACA,MAAM,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC,EAAE,GAAG,OAAO;AACrD,IAAI;AACJ,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,WAAW,CAAC,CAAC,GAAG,EAAE,OAAO,EAAE;AAC7B,IAAI,IAAI,IAAI,CAAC,GAAG,KAAK,IAAI,EAAE;AAC3B,MAAM,QAAQ,CAAC,IAAI,CAAC,GAAG,EAAE,WAAW,IAAI;AACxC,QAAQ,MAAM,OAAO,GAAG,CAAC,GAAG,IAAI,GAAG,YAAY,YAAY,IAAI,GAAG,CAAC,KAAK,GAAG;AAC3E,QAAQ,2BAA2B,CAAC,WAAW,EAAE,IAAI,EAAE,OAAO,EAAE,OAAO;AACvE,MAAM,CAAC;AACP,IAAI,CAAC,MAAM;AACX,MAAM,MAAM,EAAE,8BAA8B,IAAI,CAAC,cAAc;AAC/D,MAAM,MAAM,KAAK,GAAG,GAAG,KAAK,IAAI,GAAG,CAAC,GAAG,EAAE,CAAC,SAAS,CAAC,EAAE,IAAI,EAAE,KAAK,GAAG,CAAC,GAAG;AACxE,MAAM,IAAI,KAAK,KAAK,CAAC,IAAI,GAAG,KAAK,IAAI,EAAE;AACvC,QAAQ,MAAM,KAAK,CAAC,MAAM,CAAC,0BAA0B;AACrD,MAAM;AACN,MAAM,EAAE,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC,EAAE,GAAG,OAAO;AACpC,IAAI;AACJ,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,MAAM,CAAC,CAAC,KAAK,EAAE,MAAM,GAAG,CAAC,EAAE;AAC7B,IAAI,IAAI,IAAI,CAAC,GAAG,KAAK,IAAI,EAAE;AAC3B,MAAM,QAAQ,CAAC,IAAI,CAAC,GAAG,EAAE,WAAW,IAAI;AACxC,QAAQ,cAAc,CAAC,WAAW,EAAE,IAAI,EAAE,KAAK,EAAE,MAAM;AACvD,MAAM,CAAC;AACP,IAAI,CAAC,MAAM;AACX;AACA,MAAM,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC,KAAK,EAAE,MAAM;AAC9C,IAAI;AACJ,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE,OAAO,CAAC,GAAG;AACb,IAAI,OAAO,eAAe,CAAC,IAAI;AAC/B,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE,IAAI,CAAC,CAAC,OAAO,EAAE;AACjB,IAAI,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,EAAE,OAAO;AACpC,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE,OAAO,CAAC,CAAC,OAAO,EAAE;AACpB,IAAI,IAAI,CAAC,MAAM,CAAC,CAAC,EAAE,OAAO;AAC1B,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,GAAG,CAAC,CAAC,KAAK,EAAE;AACd,IAAI,OAAO,WAAW,CAAC,IAAI,EAAE,KAAK;AAClC,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,KAAK,CAAC,CAAC,KAAK,GAAG,CAAC,EAAE,GAAG,GAAG,IAAI,CAAC,MAAM,EAAE;AACvC,IAAI,OAAO,aAAa,CAAC,IAAI,EAAE,KAAK,EAAE,GAAG;AACzC,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE;AACd,IAAI,eAAe,CAAC,IAAI,EAAE,CAAC;AAC3B,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,MAAM,CAAC,CAAC,OAAO,EAAE;AACnB,IAAI,OAAO,CAAC,YAAY,CAAC,iBAAiB;AAC1C,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,gBAAgB,GAAG,QAAQ,IAAI,IAAI,YAAY;;AC1P5D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,MAAM,WAAW,SAAS,YAAY,CAAC;AAC9C,EAAE,WAAW,CAAC,CAAC,QAAQ,GAAG,WAAW,EAAE;AACvC,IAAI,KAAK;AACT,IAAI,IAAI,CAAC,QAAQ,GAAG;AACpB;AACA;AACA;AACA,IAAI,IAAI,CAAC,YAAY,GAAG,IAAI,GAAG;AAC/B,EAAE;;AAEF;AACA;AACA;AACA,EAAE,IAAI,WAAW,CAAC,GAAG;AACrB,IAAI,MAAM,CAAC,GAAG,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,GAAG;AAC7C,IAAI,OAAO,CAAC,mEAAmE,CAAC,CAAC,CAAC,OAAO,EAAE,IAAI,IAAI;AACnG,EAAE;;AAEF;AACA;AACA;AACA,EAAE,IAAI,WAAW,CAAC,GAAG;AACrB,IAAI,MAAM,CAAC,GAAG,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,GAAG;AAC7C,IAAI,OAAO,CAAC,mEAAmE,CAAC,CAAC,CAAC,OAAO,EAAE,IAAI,IAAI;AACnG,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,UAAU,CAAC,CAAC,CAAC,EAAE,IAAI,EAAE;AACvB,IAAI,KAAK,CAAC,UAAU,CAAC,CAAC,EAAE,IAAI;AAC5B,KAAK,kCAAkC,IAAI,CAAC,YAAY,GAAG,OAAO,CAAC,CAAC,KAAK,EAAE,GAAG,KAAK;AACnF,MAAM,IAAI,CAAC,YAAY,CAAC,GAAG,EAAE,KAAK;AAClC,IAAI,CAAC;AACL,IAAI,IAAI,CAAC,YAAY,GAAG;AACxB,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE,KAAK,CAAC,GAAG;AACX,IAAI,2BAA2B,IAAI,WAAW,CAAC,IAAI,CAAC,QAAQ,CAAC;AAC7D,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,KAAK,CAAC,GAAG;AACX,IAAI,MAAM,EAAE,GAAG,IAAI,CAAC,KAAK;AACzB,IAAI,MAAM,KAAK,GAAG,IAAI,CAAC,aAAa;AACpC,IAAI,MAAM,CAAC,OAAO,CAAC,KAAK,EAAE,CAAC,KAAK,EAAE,GAAG,KAAK;AAC1C,MAAM,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE;AACrC,QAAQ,EAAE,CAAC,YAAY,CAAC,GAAG,EAAE,KAAK;AAClC,MAAM;AACN,IAAI,CAAC;AACL;AACA,IAAI,EAAE,CAAC,MAAM,CAAC,CAAC,EAAE,IAAI,CAAC,OAAO,EAAE,CAAC,GAAG,CAAC,IAAI,IAAI,IAAI,YAAY,YAAY,GAAG,IAAI,CAAC,KAAK,EAAE,GAAG,IAAI,CAAC;AAC/F,IAAI,OAAO;AACX,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,QAAQ,CAAC,GAAG;AACd,IAAI,MAAM,KAAK,GAAG,IAAI,CAAC,aAAa;AACpC,IAAI,MAAM,aAAa,GAAG;AAC1B,IAAI,MAAM,IAAI,GAAG;AACjB,IAAI,KAAK,MAAM,GAAG,IAAI,KAAK,EAAE;AAC7B,MAAM,IAAI,CAAC,IAAI,CAAC,GAAG;AACnB,IAAI;AACJ,IAAI,IAAI,CAAC,IAAI;AACb,IAAI,MAAM,OAAO,GAAG,IAAI,CAAC;AACzB,IAAI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,EAAE,CAAC,EAAE,EAAE;AACtC,MAAM,MAAM,GAAG,GAAG,IAAI,CAAC,CAAC;AACxB,MAAM,aAAa,CAAC,IAAI,CAAC,GAAG,GAAG,IAAI,GAAG,KAAK,CAAC,GAAG,CAAC,GAAG,GAAG;AACtD,IAAI;AACJ,IAAI,MAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC,iBAAiB;AACpD,IAAI,MAAM,WAAW,GAAG,aAAa,CAAC,MAAM,GAAG,CAAC,GAAG,GAAG,GAAG,aAAa,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG;AACnF,IAAI,OAAO,CAAC,CAAC,EAAE,QAAQ,CAAC,EAAE,WAAW,CAAC,CAAC,EAAE,KAAK,CAAC,QAAQ,EAAE,CAAC,EAAE,EAAE,QAAQ,CAAC,CAAC;AACxE,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,eAAe,CAAC,CAAC,aAAa,EAAE;AAClC,IAAI,IAAI,IAAI,CAAC,GAAG,KAAK,IAAI,EAAE;AAC3B,MAAM,QAAQ,CAAC,IAAI,CAAC,GAAG,EAAE,WAAW,IAAI;AACxC,QAAQ,aAAa,CAAC,WAAW,EAAE,IAAI,EAAE,aAAa;AACtD,MAAM,CAAC;AACP,IAAI,CAAC,MAAM;AACX,qCAAqC,CAAC,IAAI,CAAC,YAAY,EAAE,MAAM,CAAC,aAAa;AAC7E,IAAI;AACJ,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,YAAY,CAAC,CAAC,aAAa,EAAE,cAAc,EAAE;AAC/C,IAAI,IAAI,IAAI,CAAC,GAAG,KAAK,IAAI,EAAE;AAC3B,MAAM,QAAQ,CAAC,IAAI,CAAC,GAAG,EAAE,WAAW,IAAI;AACxC,QAAQ,UAAU,CAAC,WAAW,EAAE,IAAI,EAAE,aAAa,sBAAsB,cAAc;AACvF,MAAM,CAAC;AACP,IAAI,CAAC,MAAM;AACX,sCAAsC,CAAC,IAAI,CAAC,YAAY,EAAE,GAAG,CAAC,aAAa,EAAE,cAAc;AAC3F,IAAI;AACJ,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,YAAY,CAAC,CAAC,aAAa,EAAE;AAC/B,IAAI,2BAA2B,UAAU,CAAC,IAAI,EAAE,aAAa,CAAC;AAC9D,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,YAAY,CAAC,CAAC,aAAa,EAAE;AAC/B,IAAI,2BAA2B,UAAU,CAAC,IAAI,EAAE,aAAa,CAAC;AAC9D,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,aAAa,CAAC,CAAC,QAAQ,EAAE;AAC3B,IAAI,2BAA2B,QAAQ,GAAG,qBAAqB,CAAC,IAAI,EAAE,QAAQ,CAAC,GAAG,aAAa,CAAC,IAAI,CAAC;AACrG,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,MAAM,CAAC,CAAC,OAAO,EAAE;AACnB,IAAI,OAAO,CAAC,YAAY,CAAC,gBAAgB;AACzC,IAAI,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAC,QAAQ;AAClC,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,eAAe,GAAG,OAAO,IAAI,IAAI,WAAW,CAAC,OAAO,CAAC,OAAO,EAAE;;AC5N3E;AACA;AACA;AACA;AACA;AACO,MAAM,QAAQ,SAAS,IAAI,CAAC;AACnC;AACA;AACA;AACA,EAAE,WAAW,CAAC,CAAC,QAAQ,EAAE;AACzB,IAAI,KAAK;AACT;AACA;AACA;AACA,IAAI,IAAI,CAAC,QAAQ,GAAG;AACpB,EAAE;;AAEF;AACA;AACA;AACA,EAAE,KAAK,CAAC,GAAG;AACX,IAAI,4BAA4B,IAAI,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC;AAC3D,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,KAAK,CAAC,GAAG;AACX,IAAI,MAAM,EAAE,GAAG,IAAI,CAAC,KAAK;AACzB,IAAI,IAAI,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,GAAG,KAAK;AACjC,MAAM,EAAE,CAAC,GAAG,CAAC,GAAG,EAAE,KAAK;AACvB,IAAI,CAAC;AACL,IAAI,OAAO;AACX,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,MAAM,CAAC,CAAC,OAAO,EAAE;AACnB,IAAI,OAAO,CAAC,YAAY,CAAC,aAAa;AACtC,IAAI,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAC,QAAQ;AAClC,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,YAAY,GAAG,OAAO;AACnC,EAAE,IAAI,QAAQ,CAAC,OAAO,CAAC,OAAO,EAAE;;AC7DhC;AACA;AACA;AACA;AACA;AACA;AACA;AACO,MAAM,QAAQ,SAAS,KAAK,CAAC;AACpC;AACA;AACA;AACA,EAAE,IAAI,WAAW,CAAC,GAAG;AACrB,IAAI,MAAM,CAAC,GAAG,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,GAAG;AAC7C,IAAI,OAAO,CAAC,mEAAmE,CAAC,CAAC,CAAC,OAAO,EAAE,IAAI,IAAI;AACnG,EAAE;;AAEF;AACA;AACA;AACA,EAAE,IAAI,WAAW,CAAC,GAAG;AACrB,IAAI,MAAM,CAAC,GAAG,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,GAAG;AAC7C,IAAI,OAAO,CAAC,mEAAmE,CAAC,CAAC,CAAC,OAAO,EAAE,IAAI,IAAI;AACnG,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,KAAK,CAAC,GAAG;AACX,IAAI,MAAM,IAAI,wBAAwB,IAAI,CAAC,KAAK,EAAE;AAClD,IAAI,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,UAAU,EAAE;AACrC,IAAI,OAAO;AACX,EAAE;;AAEF;AACA;AACA;AACA,EAAE,MAAM,CAAC,GAAG;AACZ,IAAI,OAAO,IAAI,CAAC,QAAQ;AACxB,EAAE;;AAEF;AACA;AACA;AACA,EAAE,MAAM,CAAC,CAAC,OAAO,EAAE;AACnB,IAAI,OAAO,CAAC,YAAY,CAAC,aAAa;AACtC,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,YAAY,GAAG,QAAQ,IAAI,IAAI,QAAQ;;AC3D7C,MAAM,cAAc,CAAC;AAC5B;AACA;AACA;AACA;AACA,EAAE,WAAW,CAAC,CAAC,EAAE,EAAE,MAAM,EAAE;AAC3B,IAAI,IAAI,CAAC,EAAE,GAAG;AACd,IAAI,IAAI,CAAC,MAAM,GAAG;AAClB,EAAE;;AAEF;AACA;AACA;AACA,EAAE,IAAI,OAAO,CAAC,GAAG;AACjB,IAAI,MAAM,KAAK,CAAC,mBAAmB;AACnC,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,SAAS,CAAC,CAAC,KAAK,EAAE;AACpB,IAAI,OAAO;AACX,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE,KAAK,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,WAAW,EAAE;AACvC,IAAI,MAAM,KAAK,CAAC,mBAAmB;AACnC,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE,SAAS,CAAC,CAAC,WAAW,EAAE,MAAM,EAAE;AAClC,IAAI,MAAM,KAAK,CAAC,mBAAmB;AACnC,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE,MAAM,CAAC,CAAC,IAAI,EAAE;AAChB,IAAI,MAAM,KAAK,CAAC,mBAAmB;AACnC,EAAE;AACF;;ACjDY,MAAC,iBAAiB,GAAG;;AAEjC;AACA;AACA;AACO,MAAM,EAAE,SAAS,cAAc,CAAC;AACvC,EAAE,IAAI,OAAO,CAAC,GAAG;AACjB,IAAI,OAAO;AACX,EAAE;;AAEF,EAAE,MAAM,CAAC,GAAG,CAAC;;AAEb;AACA;AACA;AACA;AACA,EAAE,SAAS,CAAC,CAAC,KAAK,EAAE;AACpB,IAAI,IAAI,IAAI,CAAC,WAAW,KAAK,KAAK,CAAC,WAAW,EAAE;AAChD,MAAM,OAAO;AACb,IAAI;AACJ,IAAI,IAAI,CAAC,MAAM,IAAI,KAAK,CAAC;AACzB,IAAI,OAAO;AACX,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE,SAAS,CAAC,CAAC,WAAW,EAAE,MAAM,EAAE;AAClC,IAAI,IAAI,MAAM,GAAG,CAAC,EAAE;AACpB,MAAM,IAAI,CAAC,EAAE,CAAC,KAAK,IAAI;AACvB,MAAM,IAAI,CAAC,MAAM,IAAI;AACrB,IAAI;AACJ,IAAI,UAAU,CAAC,WAAW,CAAC,SAAS,EAAE,IAAI,CAAC,EAAE,CAAC,MAAM,EAAE,IAAI,CAAC,EAAE,CAAC,KAAK,EAAE,IAAI,CAAC,MAAM;AAChF,IAAI,gBAAgB,CAAC,WAAW,CAAC,SAAS,EAAE,IAAI;AAChD,IAAI,SAAS,CAAC,WAAW,CAAC,GAAG,CAAC,KAAK,EAAE,IAAI;AACzC,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE,KAAK,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,SAAS,EAAE;AACrC,IAAI,OAAO,CAAC,SAAS,CAAC,iBAAiB;AACvC,IAAI,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAC,MAAM,GAAG,MAAM,GAAG,SAAS;AACrD,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE,UAAU,CAAC,CAAC,YAAY,EAAE,MAAM,EAAE;AACpC,IAAI,OAAO;AACX,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,MAAM,CAAC,CAAC,IAAI,EAAE;AAChB,IAAI,MAAM,KAAK,GAAG,IAAI,EAAE,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE,CAAC,MAAM,EAAE,IAAI,CAAC,EAAE,CAAC,KAAK,GAAG,IAAI,CAAC,EAAE,IAAI,CAAC,MAAM,GAAG,IAAI;AAC3F,IAAI,IAAI,CAAC,MAAM,GAAG;AAClB,IAAI,OAAO;AACX,EAAE;AACF;;ACzEO,MAAM,aAAa,CAAC;AAC3B;AACA;AACA;AACA,EAAE,WAAW,CAAC,CAAC,OAAO,EAAE;AACxB,IAAI,IAAI,CAAC,OAAO,GAAG;AACnB,EAAE;;AAEF;AACA;AACA;AACA,EAAE,SAAS,CAAC,GAAG;AACf,IAAI,OAAO;AACX,EAAE;;AAEF;AACA;AACA;AACA,EAAE,UAAU,CAAC,GAAG;AAChB,IAAI,OAAO,CAAC,IAAI,CAAC,OAAO;AACxB,EAAE;;AAEF;AACA;AACA;AACA,EAAE,WAAW,CAAC,GAAG;AACjB,IAAI,OAAO;AACX,EAAE;;AAEF;AACA;AACA;AACA,EAAE,IAAI,CAAC,GAAG;AACV,IAAI,OAAO,IAAI,aAAa,CAAC,IAAI,CAAC,OAAO;AACzC,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE,MAAM,CAAC,CAAC,MAAM,EAAE;AAClB,IAAI,MAAM,KAAK,CAAC,mBAAmB;AACnC,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE,SAAS,CAAC,CAAC,KAAK,EAAE;AACpB,IAAI,OAAO;AACX,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE,SAAS,CAAC,CAAC,WAAW,EAAE,IAAI,EAAE,CAAC;AACjC;AACA;AACA;AACA,EAAE,MAAM,CAAC,CAAC,WAAW,EAAE,CAAC;AACxB;AACA;AACA;AACA,EAAE,EAAE,CAAC,CAAC,GAAG,EAAE,CAAC;AACZ;AACA;AACA;AACA;AACA;AACA,EAAE,KAAK,CAAC,CAAC,OAAO,EAAE,OAAO,EAAE,UAAU,EAAE;AACvC,IAAI,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAC,OAAO;AACjC,EAAE;;AAEF;AACA;AACA;AACA,EAAE,MAAM,CAAC,GAAG;AACZ,IAAI,OAAO;AACX,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACY,MAAC,iBAAiB,GAAG,OAAO,IAAI,IAAI,aAAa,CAAC,OAAO,CAAC,OAAO,EAAE;;ACvFxE,MAAM,cAAc,CAAC;AAC5B;AACA;AACA;AACA,EAAE,WAAW,CAAC,CAAC,GAAG,EAAE;AACpB,IAAI,IAAI,CAAC,GAAG,GAAG;AACf,EAAE;;AAEF;AACA;AACA;AACA,EAAE,SAAS,CAAC,GAAG;AACf,IAAI,OAAO,IAAI,CAAC;AAChB,EAAE;;AAEF;AACA;AACA;AACA,EAAE,UAAU,CAAC,GAAG;AAChB,IAAI,OAAO;AACX,EAAE;;AAEF;AACA;AACA;AACA,EAAE,WAAW,CAAC,GAAG;AACjB,IAAI,OAAO;AACX,EAAE;;AAEF;AACA;AACA;AACA,EAAE,IAAI,CAAC,GAAG;AACV,IAAI,OAAO,IAAI,cAAc,CAAC,IAAI,CAAC,GAAG;AACtC,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE,MAAM,CAAC,CAAC,MAAM,EAAE;AAClB,IAAI,MAAM,KAAK,GAAG,IAAI,cAAc,CAAC,IAAI,CAAC,GAAG,GAAG,MAAM;AACtD,IAAI,IAAI,CAAC,GAAG,GAAG;AACf,IAAI,OAAO;AACX,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE,SAAS,CAAC,CAAC,KAAK,EAAE;AACpB,IAAI,IAAI,CAAC,GAAG,IAAI,KAAK,CAAC;AACtB,IAAI,OAAO;AACX,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE,SAAS,CAAC,CAAC,WAAW,EAAE,IAAI,EAAE;AAChC,IAAI,UAAU,CAAC,WAAW,CAAC,SAAS,EAAE,IAAI,CAAC,EAAE,CAAC,MAAM,EAAE,IAAI,CAAC,EAAE,CAAC,KAAK,EAAE,IAAI,CAAC,GAAG;AAC7E,IAAI,IAAI,CAAC,WAAW;AACpB,EAAE;;AAEF;AACA;AACA;AACA,EAAE,MAAM,CAAC,CAAC,YAAY,EAAE,CAAC;AACzB;AACA;AACA;AACA,EAAE,EAAE,CAAC,CAAC,GAAG,EAAE,CAAC;AACZ;AACA;AACA;AACA;AACA;AACA,EAAE,KAAK,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,SAAS,EAAE;AACrC,IAAI,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAC,GAAG,GAAG,MAAM,GAAG,SAAS;AAClD,EAAE;;AAEF;AACA;AACA;AACA,EAAE,MAAM,CAAC,GAAG;AACZ,IAAI,OAAO;AACX,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,kBAAkB,GAAG,OAAO,IAAI,IAAI,cAAc,CAAC,OAAO,CAAC,OAAO,EAAE;;AC9FjF;AACA;AACA;AACA;AACA,MAAM,iBAAiB,GAAG,CAAC,IAAI,EAAE,IAAI,KAAK,IAAI,GAAG,CAAC,EAAE,IAAI,EAAE,GAAG,IAAI,EAAE,UAAU,EAAE,IAAI,CAAC,UAAU,IAAI,IAAI,CAAC,QAAQ,IAAI,KAAK,EAAE;;AAE1H;AACA;AACA;AACO,MAAM,UAAU,CAAC;AACxB;AACA;AACA;AACA,EAAE,WAAW,CAAC,CAAC,GAAG,EAAE;AACpB,IAAI,IAAI,GAAG,CAAC,KAAK,EAAE;AACnB,MAAM,OAAO,CAAC,KAAK,CAAC,yHAAyH;AAC7I,IAAI;AACJ;AACA;AACA;AACA,IAAI,IAAI,CAAC,GAAG,GAAG;AACf;AACA;AACA;AACA,IAAI,MAAM,IAAI,GAAG;AACjB,IAAI,IAAI,CAAC,IAAI,GAAG;AAChB,IAAI,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE;AACjB,MAAM,IAAI,CAAC,EAAE,GAAG;AAChB,IAAI;AACJ,IAAI,IAAI,GAAG,CAAC,QAAQ,EAAE;AACtB,MAAM,IAAI,CAAC,QAAQ,GAAG;AACtB,IAAI;AACJ,IAAI,IAAI,GAAG,CAAC,IAAI,KAAK,IAAI,EAAE;AAC3B,MAAM,IAAI,CAAC,IAAI,GAAG,GAAG,CAAC;AACtB,IAAI;AACJ,EAAE;;AAEF;AACA;AACA;AACA,EAAE,SAAS,CAAC,GAAG;AACf,IAAI,OAAO;AACX,EAAE;;AAEF;AACA;AACA;AACA,EAAE,UAAU,CAAC,GAAG;AAChB,IAAI,OAAO,CAAC,IAAI,CAAC,GAAG;AACpB,EAAE;;AAEF;AACA;AACA;AACA,EAAE,WAAW,CAAC,GAAG;AACjB,IAAI,OAAO;AACX,EAAE;;AAEF;AACA;AACA;AACA,EAAE,IAAI,CAAC,GAAG;AACV,IAAI,OAAO,IAAI,UAAU,CAAC,iBAAiB,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,IAAI,CAAC;AACrE,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE,MAAM,CAAC,CAAC,MAAM,EAAE;AAClB,IAAI,MAAM,KAAK,CAAC,mBAAmB;AACnC,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE,SAAS,CAAC,CAAC,KAAK,EAAE;AACpB,IAAI,OAAO;AACX,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE,SAAS,CAAC,CAAC,WAAW,EAAE,IAAI,EAAE;AAChC;AACA,IAAI,IAAI,CAAC,GAAG,CAAC,KAAK,GAAG;AACrB,IAAI,WAAW,CAAC,YAAY,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG;AACzC,IAAI,IAAI,IAAI,CAAC,GAAG,CAAC,UAAU,EAAE;AAC7B,MAAM,WAAW,CAAC,aAAa,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG;AAC5C,IAAI;AACJ,EAAE;;AAEF;AACA;AACA;AACA,EAAE,MAAM,CAAC,CAAC,WAAW,EAAE;AACvB,IAAI,IAAI,WAAW,CAAC,YAAY,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE;AAChD,MAAM,WAAW,CAAC,YAAY,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG;AAC9C,IAAI,CAAC,MAAM;AACX,MAAM,WAAW,CAAC,cAAc,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG;AAC7C,IAAI;AACJ,EAAE;;AAEF;AACA;AACA;AACA,EAAE,EAAE,CAAC,CAAC,GAAG,EAAE,CAAC;;AAEZ;AACA;AACA;AACA;AACA;AACA,EAAE,KAAK,CAAC,CAAC,OAAO,EAAE,OAAO,EAAE,UAAU,EAAE;AACvC,IAAI,OAAO,CAAC,WAAW,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI;AACrC,IAAI,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI;AAC9B,EAAE;;AAEF;AACA;AACA;AACA,EAAE,MAAM,CAAC,GAAG;AACZ,IAAI,OAAO;AACX,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,cAAc,GAAG,OAAO,IAAI,IAAI,UAAU,CAAC,iBAAiB,CAAC,OAAO,CAAC,UAAU,EAAE,EAAE,OAAO,CAAC,OAAO,EAAE,CAAC;;ACtIlH;AACA;AACA;AACO,MAAM,YAAY,CAAC;AAC1B;AACA;AACA;AACA,EAAE,WAAW,CAAC,CAAC,KAAK,EAAE;AACtB,IAAI,IAAI,CAAC,KAAK,GAAG;AACjB,EAAE;;AAEF;AACA;AACA;AACA,EAAE,SAAS,CAAC,GAAG;AACf,IAAI,OAAO;AACX,EAAE;;AAEF;AACA;AACA;AACA,EAAE,UAAU,CAAC,GAAG;AAChB,IAAI,OAAO,CAAC,IAAI,CAAC,KAAK;AACtB,EAAE;;AAEF;AACA;AACA;AACA,EAAE,WAAW,CAAC,GAAG;AACjB,IAAI,OAAO;AACX,EAAE;;AAEF;AACA;AACA;AACA,EAAE,IAAI,CAAC,GAAG;AACV,IAAI,OAAO,IAAI,YAAY,CAAC,IAAI,CAAC,KAAK;AACtC,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE,MAAM,CAAC,CAAC,MAAM,EAAE;AAClB,IAAI,MAAM,KAAK,CAAC,mBAAmB;AACnC,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE,SAAS,CAAC,CAAC,KAAK,EAAE;AACpB,IAAI,OAAO;AACX,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE,SAAS,CAAC,CAAC,WAAW,EAAE,IAAI,EAAE,CAAC;AACjC;AACA;AACA;AACA,EAAE,MAAM,CAAC,CAAC,WAAW,EAAE,CAAC;AACxB;AACA;AACA;AACA,EAAE,EAAE,CAAC,CAAC,GAAG,EAAE,CAAC;AACZ;AACA;AACA;AACA;AACA;AACA,EAAE,KAAK,CAAC,CAAC,OAAO,EAAE,OAAO,EAAE,UAAU,EAAE;AACvC,IAAI,OAAO,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK;AAChC,EAAE;;AAEF;AACA;AACA;AACA,EAAE,MAAM,CAAC,GAAG;AACZ,IAAI,OAAO;AACX,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,gBAAgB,GAAG,OAAO,IAAI,IAAI,YAAY,CAAC,OAAO,CAAC,QAAQ,EAAE;;AC3F9E;AACA;AACA;AACO,MAAM,aAAa,CAAC;AAC3B;AACA;AACA;AACA;AACA,EAAE,WAAW,CAAC,CAAC,GAAG,EAAE,KAAK,EAAE;AAC3B,IAAI,IAAI,CAAC,GAAG,GAAG;AACf,IAAI,IAAI,CAAC,KAAK,GAAG;AACjB,EAAE;;AAEF;AACA;AACA;AACA,EAAE,SAAS,CAAC,GAAG;AACf,IAAI,OAAO;AACX,EAAE;;AAEF;AACA;AACA;AACA,EAAE,UAAU,CAAC,GAAG;AAChB,IAAI,OAAO;AACX,EAAE;;AAEF;AACA;AACA;AACA,EAAE,WAAW,CAAC,GAAG;AACjB,IAAI,OAAO;AACX,EAAE;;AAEF;AACA;AACA;AACA,EAAE,IAAI,CAAC,GAAG;AACV,IAAI,OAAO,IAAI,aAAa,CAAC,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,KAAK;AACjD,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE,MAAM,CAAC,CAAC,OAAO,EAAE;AACnB,IAAI,MAAM,KAAK,CAAC,mBAAmB;AACnC,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE,SAAS,CAAC,CAAC,MAAM,EAAE;AACrB,IAAI,OAAO;AACX,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE,SAAS,CAAC,CAAC,YAAY,EAAE,IAAI,EAAE;AACjC;AACA,IAAI,MAAM,CAAC,8BAA8B,IAAI,CAAC,MAAM;AACpD,IAAI,CAAC,CAAC,aAAa,GAAG;AACtB,IAAI,CAAC,CAAC,cAAc,GAAG;AACvB,EAAE;;AAEF;AACA;AACA;AACA,EAAE,MAAM,CAAC,CAAC,YAAY,EAAE,CAAC;AACzB;AACA;AACA;AACA,EAAE,EAAE,CAAC,CAAC,GAAG,EAAE,CAAC;AACZ;AACA;AACA;AACA;AACA;AACA,EAAE,KAAK,CAAC,CAAC,OAAO,EAAE,OAAO,EAAE,UAAU,EAAE;AACvC,IAAI,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAC,GAAG;AAC7B,IAAI,OAAO,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK;AAChC,EAAE;;AAEF;AACA;AACA;AACA,EAAE,MAAM,CAAC,GAAG;AACZ,IAAI,OAAO;AACX,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACY,MAAC,iBAAiB,GAAG,OAAO,IAAI,IAAI,aAAa,CAAC,OAAO,CAAC,OAAO,EAAE,EAAE,OAAO,CAAC,QAAQ,EAAE;;ACpGnG;AACA;AACA;AACO,MAAM,WAAW,CAAC;AACzB;AACA;AACA;AACA,EAAE,WAAW,CAAC,CAAC,GAAG,EAAE;AACpB;AACA;AACA;AACA,IAAI,IAAI,CAAC,GAAG,GAAG;AACf,EAAE;;AAEF;AACA;AACA;AACA,EAAE,SAAS,CAAC,GAAG;AACf,IAAI,OAAO,IAAI,CAAC,GAAG,CAAC;AACpB,EAAE;;AAEF;AACA;AACA;AACA,EAAE,UAAU,CAAC,GAAG;AAChB,IAAI,OAAO,IAAI,CAAC;AAChB,EAAE;;AAEF;AACA;AACA;AACA,EAAE,WAAW,CAAC,GAAG;AACjB,IAAI,OAAO;AACX,EAAE;;AAEF;AACA;AACA;AACA,EAAE,IAAI,CAAC,GAAG;AACV,IAAI,OAAO,IAAI,WAAW,CAAC,IAAI,CAAC,GAAG;AACnC,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE,MAAM,CAAC,CAAC,MAAM,EAAE;AAClB,IAAI,MAAM,KAAK,GAAG,IAAI,WAAW,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,MAAM,CAAC;AACxD,IAAI,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE,MAAM;AACvC,IAAI,OAAO;AACX,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE,SAAS,CAAC,CAAC,KAAK,EAAE;AACpB,IAAI,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,KAAK,CAAC,GAAG;AACxC,IAAI,OAAO;AACX,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE,SAAS,CAAC,CAAC,WAAW,EAAE,IAAI,EAAE,CAAC;AACjC;AACA;AACA;AACA,EAAE,MAAM,CAAC,CAAC,WAAW,EAAE,CAAC;AACxB;AACA;AACA;AACA,EAAE,EAAE,CAAC,CAAC,GAAG,EAAE,CAAC;AACZ;AACA;AACA;AACA;AACA;AACA,EAAE,KAAK,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,SAAS,EAAE;AACrC,IAAI,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,MAAM,GAAG;AAClC,IAAI,OAAO,CAAC,QAAQ,CAAC,GAAG,GAAG,MAAM;AACjC,IAAI,KAAK,IAAI,CAAC,GAAG,MAAM,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;AACvC,MAAM,MAAM,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC;AAC1B,MAAM,OAAO,CAAC,WAAW,CAAC,CAAC,KAAK,SAAS,GAAG,WAAW,GAAG,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;AAC3E,IAAI;AACJ,EAAE;;AAEF;AACA;AACA;AACA,EAAE,MAAM,CAAC,GAAG;AACZ,IAAI,OAAO;AACX,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,eAAe,GAAG,OAAO,IAAI;AAC1C,EAAE,MAAM,GAAG,GAAG,OAAO,CAAC,OAAO;AAC7B,EAAE,MAAM,EAAE,GAAG;AACb,EAAE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;AAChC,IAAI,MAAM,CAAC,GAAG,OAAO,CAAC,UAAU;AAChC,IAAI,IAAI,CAAC,KAAK,WAAW,EAAE;AAC3B,MAAM,EAAE,CAAC,IAAI,CAAC,SAAS;AACvB,IAAI,CAAC,MAAM;AACX,MAAM,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;AAC3B,IAAI;AACJ,EAAE;AACF,EAAE,OAAO,IAAI,WAAW,CAAC,EAAE;AAC3B;;AC/GA,MAAM,SAAS,GAAG,GAAG,CAAC,WAAW,CAAC,UAAU,CAAC,KAAK;;AAE3C,MAAM,UAAU,CAAC;AACxB;AACA;AACA;AACA,EAAE,WAAW,CAAC,CAAC,GAAG,EAAE;AACpB;AACA;AACA;AACA,IAAI,IAAI,CAAC,GAAG,GAAG;AACf,IAAI,SAAS,IAAI,MAAM,CAAC,UAAU,CAAC,GAAG;AACtC,EAAE;;AAEF;AACA;AACA;AACA,EAAE,SAAS,CAAC,GAAG;AACf,IAAI,OAAO,IAAI,CAAC,GAAG,CAAC;AACpB,EAAE;;AAEF;AACA;AACA;AACA,EAAE,UAAU,CAAC,GAAG;AAChB,IAAI,OAAO,IAAI,CAAC;AAChB,EAAE;;AAEF;AACA;AACA;AACA,EAAE,WAAW,CAAC,GAAG;AACjB,IAAI,OAAO;AACX,EAAE;;AAEF;AACA;AACA;AACA,EAAE,IAAI,CAAC,GAAG;AACV,IAAI,OAAO,IAAI,UAAU,CAAC,IAAI,CAAC,GAAG;AAClC,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE,MAAM,CAAC,CAAC,MAAM,EAAE;AAClB,IAAI,MAAM,KAAK,GAAG,IAAI,UAAU,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,MAAM,CAAC;AACvD,IAAI,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE,MAAM;AACvC,IAAI,OAAO;AACX,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE,SAAS,CAAC,CAAC,KAAK,EAAE;AACpB,IAAI,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,KAAK,CAAC,GAAG;AACxC,IAAI,OAAO;AACX,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE,SAAS,CAAC,CAAC,WAAW,EAAE,IAAI,EAAE,CAAC;AACjC;AACA;AACA;AACA,EAAE,MAAM,CAAC,CAAC,WAAW,EAAE,CAAC;AACxB;AACA;AACA;AACA,EAAE,EAAE,CAAC,CAAC,GAAG,EAAE,CAAC;AACZ;AACA;AACA;AACA;AACA;AACA,EAAE,KAAK,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,SAAS,EAAE;AACrC,IAAI,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,MAAM,GAAG;AAClC,IAAI,OAAO,CAAC,QAAQ,CAAC,GAAG,GAAG,MAAM;AACjC,IAAI,KAAK,IAAI,CAAC,GAAG,MAAM,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;AACvC,MAAM,MAAM,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC;AAC1B,MAAM,OAAO,CAAC,QAAQ,CAAC,CAAC;AACxB,IAAI;AACJ,EAAE;;AAEF;AACA;AACA;AACA,EAAE,MAAM,CAAC,GAAG;AACZ,IAAI,OAAO;AACX,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACY,MAAC,cAAc,GAAG,OAAO,IAAI;AACzC,EAAE,MAAM,GAAG,GAAG,OAAO,CAAC,OAAO;AAC7B,EAAE,MAAM,EAAE,GAAG;AACb,EAAE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;AAChC,IAAI,EAAE,CAAC,IAAI,CAAC,OAAO,CAAC,OAAO,EAAE;AAC7B,EAAE;AACF,EAAE,OAAO,IAAI,UAAU,CAAC,EAAE;AAC1B;;AC9GA;AACA;AACA;AACO,MAAM,aAAa,CAAC;AAC3B;AACA;AACA;AACA,EAAE,WAAW,CAAC,CAAC,GAAG,EAAE;AACpB;AACA;AACA;AACA,IAAI,IAAI,CAAC,GAAG,GAAG;AACf,EAAE;;AAEF;AACA;AACA;AACA,EAAE,SAAS,CAAC,GAAG;AACf,IAAI,OAAO,IAAI,CAAC,GAAG,CAAC;AACpB,EAAE;;AAEF;AACA;AACA;AACA,EAAE,UAAU,CAAC,GAAG;AAChB,IAAI,OAAO,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE;AAC5B,EAAE;;AAEF;AACA;AACA;AACA,EAAE,WAAW,CAAC,GAAG;AACjB,IAAI,OAAO;AACX,EAAE;;AAEF;AACA;AACA;AACA,EAAE,IAAI,CAAC,GAAG;AACV,IAAI,OAAO,IAAI,aAAa,CAAC,IAAI,CAAC,GAAG;AACrC,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE,MAAM,CAAC,CAAC,MAAM,EAAE;AAClB,IAAI,MAAM,KAAK,GAAG,IAAI,aAAa,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,MAAM,CAAC;AAC1D,IAAI,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE,MAAM;;AAEvC;AACA,IAAI,MAAM,aAAa,GAAG,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC;AACxD,IAAI,IAAI,aAAa,IAAI,MAAM,IAAI,aAAa,IAAI,MAAM,EAAE;AAC5D;AACA;AACA;AACA,MAAM,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE,MAAM,GAAG,CAAC,CAAC,GAAG;AACjD;AACA,MAAM,KAAK,CAAC,GAAG,GAAG,GAAG,GAAG,KAAK,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;AACzC,IAAI;AACJ,IAAI,OAAO;AACX,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE,SAAS,CAAC,CAAC,KAAK,EAAE;AACpB,IAAI,IAAI,CAAC,GAAG,IAAI,KAAK,CAAC;AACtB,IAAI,OAAO;AACX,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE,SAAS,CAAC,CAAC,WAAW,EAAE,IAAI,EAAE,CAAC;AACjC;AACA;AACA;AACA,EAAE,MAAM,CAAC,CAAC,WAAW,EAAE,CAAC;AACxB;AACA;AACA;AACA,EAAE,EAAE,CAAC,CAAC,GAAG,EAAE,CAAC;AACZ;AACA;AACA;AACA;AACA;AACA,EAAE,KAAK,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,SAAS,EAAE;AACrC,IAAI,OAAO,CAAC,WAAW,CAAC,CAAC,MAAM,KAAK,CAAC,IAAI,SAAS,KAAK,CAAC,IAAI,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,MAAM,EAAE,IAAI,CAAC,GAAG,CAAC,MAAM,GAAG,SAAS,CAAC;AAC1H,EAAE;;AAEF;AACA;AACA;AACA,EAAE,MAAM,CAAC,GAAG;AACZ,IAAI,OAAO;AACX,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,iBAAiB,GAAG,OAAO,IAAI,IAAI,aAAa,CAAC,OAAO,CAAC,UAAU,EAAE;;AC/FlF;AACA;AACA;AACA;AACY,MAAC,QAAQ,GAAG;AACxB,EAAE,UAAU;AACZ,EAAE,QAAQ;AACV,EAAE,SAAS;AACX,EAAE,eAAe;AACjB,EAAE,gBAAgB;AAClB,EAAE,YAAY;AACd,EAAE;AACF;;AAEY,MAAC,WAAW,GAAG;AACf,MAAC,SAAS,GAAG;AACb,MAAC,UAAU,GAAG;AACd,MAAC,gBAAgB,GAAG;AACpB,MAAC,iBAAiB,GAAG;AACrB,MAAC,aAAa,GAAG;AACjB,MAAC,aAAa,GAAG;;AAE7B;AACA;AACA;AACO,MAAM,WAAW,CAAC;AACzB;AACA;AACA;AACA,EAAE,WAAW,CAAC,CAAC,IAAI,EAAE;AACrB;AACA;AACA;AACA,IAAI,IAAI,CAAC,IAAI,GAAG;AAChB,EAAE;;AAEF;AACA;AACA;AACA,EAAE,SAAS,CAAC,GAAG;AACf,IAAI,OAAO;AACX,EAAE;;AAEF;AACA;AACA;AACA,EAAE,UAAU,CAAC,GAAG;AAChB,IAAI,OAAO,CAAC,IAAI,CAAC,IAAI;AACrB,EAAE;;AAEF;AACA;AACA;AACA,EAAE,WAAW,CAAC,GAAG;AACjB,IAAI,OAAO;AACX,EAAE;;AAEF;AACA;AACA;AACA,EAAE,IAAI,CAAC,GAAG;AACV,IAAI,OAAO,IAAI,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE;AAC5C,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE,MAAM,CAAC,CAAC,OAAO,EAAE;AACnB,IAAI,MAAM,KAAK,CAAC,mBAAmB;AACnC,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE,SAAS,CAAC,CAAC,MAAM,EAAE;AACrB,IAAI,OAAO;AACX,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE,SAAS,CAAC,CAAC,WAAW,EAAE,IAAI,EAAE;AAChC,IAAI,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,GAAG,EAAE,IAAI;AAC9C,EAAE;;AAEF;AACA;AACA;AACA,EAAE,MAAM,CAAC,CAAC,WAAW,EAAE;AACvB,IAAI,IAAI,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;AACzB,IAAI,OAAO,IAAI,KAAK,IAAI,EAAE;AAC1B,MAAM,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE;AACzB,QAAQ,IAAI,CAAC,MAAM,CAAC,WAAW;AAC/B,MAAM,CAAC,MAAM,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE;AACxD;AACA;AACA;AACA;AACA,QAAQ,WAAW,CAAC,aAAa,CAAC,IAAI,CAAC,IAAI;AAC3C,MAAM;AACN,MAAM,IAAI,GAAG,IAAI,CAAC;AAClB,IAAI;AACJ,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,IAAI;AACnC,MAAM,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE;AACzB,QAAQ,IAAI,CAAC,MAAM,CAAC,WAAW;AAC/B,MAAM,CAAC,MAAM,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE;AACxD;AACA,QAAQ,WAAW,CAAC,aAAa,CAAC,IAAI,CAAC,IAAI;AAC3C,MAAM;AACN,IAAI,CAAC;AACL,IAAI,WAAW,CAAC,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI;AACxC,EAAE;;AAEF;AACA;AACA;AACA,EAAE,EAAE,CAAC,CAAC,EAAE,EAAE;AACV,IAAI,IAAI,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;AACzB,IAAI,OAAO,IAAI,KAAK,IAAI,EAAE;AAC1B,MAAM,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE,IAAI;AACtB,MAAM,IAAI,GAAG,IAAI,CAAC;AAClB,IAAI;AACJ,IAAI,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG;AACvB,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,kCAAkC,CAAC,IAAI,KAAK;AACtE,MAAM,OAAO,IAAI,KAAK,IAAI,EAAE;AAC5B,QAAQ,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE,IAAI;AACxB,QAAQ,IAAI,GAAG,IAAI,CAAC;AACpB,MAAM;AACN,IAAI,CAAC;AACL,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,GAAG,IAAI,GAAG;AAC5B,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE,KAAK,CAAC,CAAC,OAAO,EAAE,OAAO,EAAE,UAAU,EAAE;AACvC,IAAI,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,OAAO;AAC5B,EAAE;;AAEF;AACA;AACA;AACA,EAAE,MAAM,CAAC,GAAG;AACZ,IAAI,OAAO;AACX,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,eAAe,GAAG,OAAO,IAAI,IAAI,WAAW,CAAC,QAAQ,CAAC,OAAO,CAAC,WAAW,EAAE,CAAC,CAAC,OAAO,CAAC;;AChJlG;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,YAAY,GAAG,CAAC,KAAK,EAAE,EAAE,KAAK;AAC3C;AACA;AACA;AACA,EAAE,IAAI,MAAM,GAAG;AACf,EAAE,IAAI,IAAI,GAAG;AACb,EAAE,IAAI;AACN,EAAE,GAAG;AACL,IAAI,IAAI,IAAI,GAAG,CAAC,EAAE;AAClB,MAAM,MAAM,GAAG,QAAQ,CAAC,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,KAAK,GAAG,IAAI;AAC1D,IAAI;AACJ,IAAI,IAAI,GAAG,OAAO,CAAC,KAAK,EAAE,MAAM;AAChC,IAAI,IAAI,GAAG,MAAM,CAAC,KAAK,GAAG,IAAI,CAAC,EAAE,CAAC;AAClC,IAAI,MAAM,GAAG,IAAI,CAAC;AAClB,EAAE,CAAC,QAAQ,MAAM,KAAK,IAAI,IAAI,IAAI,YAAY,IAAI;AAClD,EAAE,OAAO;AACT,IAAI,IAAI,EAAE;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,QAAQ,GAAG,CAAC,IAAI,EAAE,IAAI,KAAK;AACxC,EAAE,OAAO,IAAI,KAAK,IAAI,IAAI,IAAI,CAAC,IAAI,KAAK,IAAI,EAAE;AAC9C,IAAI,IAAI,CAAC,IAAI,GAAG;AAChB,IAAI,IAAI,0BAA0B,CAAC,IAAI,CAAC,MAAM,EAAE;AAChD,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,SAAS,GAAG,CAAC,WAAW,EAAE,QAAQ,EAAE,IAAI,KAAK;AAC1D;AACA,EAAE,MAAM,EAAE,MAAM,EAAE,KAAK,EAAE,GAAG,QAAQ,CAAC;AACrC,EAAE,MAAM,SAAS,GAAG,IAAI,IAAI;AAC5B,IAAI,QAAQ,CAAC,MAAM,EAAE,KAAK,GAAG,IAAI,CAAC;AAClC,IAAI,QAAQ;AACZ,IAAI,QAAQ,CAAC,MAAM,EAAE,KAAK,GAAG,IAAI,GAAG,CAAC,CAAC;AACtC,IAAI,QAAQ,CAAC,KAAK;AAClB,IAAI,QAAQ,CAAC,WAAW;AACxB,IAAI,QAAQ,CAAC,MAAM;AACnB,IAAI,QAAQ,CAAC,SAAS;AACtB,IAAI,QAAQ,CAAC,OAAO,CAAC,MAAM,CAAC,IAAI;AAChC;AACA,EAAE,IAAI,QAAQ,CAAC,OAAO,EAAE;AACxB,IAAI,SAAS,CAAC,WAAW;AACzB,EAAE;AACF,EAAE,IAAI,QAAQ,CAAC,IAAI,EAAE;AACrB,IAAI,SAAS,CAAC,IAAI,GAAG;AACrB,EAAE;AACF,EAAE,IAAI,QAAQ,CAAC,MAAM,KAAK,IAAI,EAAE;AAChC,IAAI,SAAS,CAAC,MAAM,GAAG,QAAQ,CAAC,QAAQ,CAAC,MAAM,CAAC,MAAM,EAAE,QAAQ,CAAC,MAAM,CAAC,KAAK,GAAG,IAAI;AACpF,EAAE;AACF,EAAE,IAAI,WAAW,IAAI,IAAI,EAAE;AAC3B;AACA,IAAI,QAAQ,CAAC,KAAK,GAAG;AACrB;AACA,IAAI,IAAI,SAAS,CAAC,KAAK,KAAK,IAAI,EAAE;AAClC,MAAM,SAAS,CAAC,KAAK,CAAC,IAAI,GAAG;AAC7B,IAAI;AACJ;AACA,IAAI,WAAW,CAAC,aAAa,CAAC,IAAI,CAAC,SAAS;AAC5C;AACA,IAAI,IAAI,SAAS,CAAC,SAAS,KAAK,IAAI,IAAI,SAAS,CAAC,KAAK,KAAK,IAAI,EAAE;AAClE,6BAA6B,CAAC,SAAS,CAAC,MAAM,EAAE,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,SAAS,EAAE,SAAS;AACvF,IAAI;AACJ,EAAE,CAAC,MAAM;AACT,IAAI,SAAS,CAAC,IAAI,GAAG;AACrB,IAAI,SAAS,CAAC,KAAK,GAAG;AACtB,EAAE;AACF,EAAE,QAAQ,CAAC,MAAM,GAAG;AACpB,EAAE,OAAO;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,WAAW,GAAG,CAAC,WAAW,EAAE,UAAU,EAAE,IAAI,KAAK;AAC9D,EAAE,IAAI,UAAU,YAAY,IAAI,EAAE;AAClC,IAAI,OAAO,SAAS,CAAC,WAAW,EAAE,UAAU,EAAE,IAAI;AAClD,EAAE,CAAC,MAAM;AACT,IAAI,MAAM,SAAS,GAAG,UAAU,CAAC,MAAM,CAAC,IAAI;AAC5C,IAAI,WAAW,EAAE,aAAa,CAAC,IAAI,CAAC,SAAS;AAC7C,IAAI,OAAO;AACX,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA,MAAM,oBAAoB,GAAG,CAAC,KAAK,EAAE,EAAE,KAAK,KAAK,CAAC,IAAI,CAAC,KAAK,8BAA8B,CAAC,IAAI,CAAC,CAAC,SAAS,CAAC,KAAK,CAAC,EAAE,CAAC;;AAEpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,QAAQ,GAAG,CAAC,WAAW,EAAE,IAAI,EAAE,SAAS,EAAE,aAAa,EAAE,sBAAsB,EAAE,EAAE,KAAK;AACrG,EAAE,MAAM,GAAG,GAAG,WAAW,CAAC;AAC1B,EAAE,MAAM,KAAK,GAAG,GAAG,CAAC;AACpB,EAAE,MAAM,WAAW,GAAG,GAAG,CAAC;AAC1B,EAAE,MAAM,MAAM,GAAG,IAAI,CAAC;AACtB,EAAE,IAAI,MAAM,KAAK,IAAI,EAAE;AACvB,IAAI,OAAO,iBAAiB,CAAC,WAAW,EAAE,MAAM;AAChD,EAAE;AACF,EAAE,IAAI,UAAU,0BAA0B,CAAC,IAAI,CAAC,MAAM,EAAE;AACxD;AACA;AACA;AACA,EAAE,IAAI,IAAI,GAAG;AACb;AACA;AACA;AACA,EAAE,IAAI;AACN;AACA,EAAE,IAAI,UAAU,KAAK,IAAI,IAAI,UAAU,CAAC,OAAO,KAAK,IAAI,EAAE;AAC1D;AACA,IAAI,IAAI,UAAU,CAAC,MAAM,KAAK,IAAI,KAAK,CAAC,SAAS,CAAC,GAAG,CAAC,UAAU,CAAC,IAAI,QAAQ,CAAC,WAAW,EAAE,UAAU,EAAE,SAAS,EAAE,aAAa,EAAE,sBAAsB,EAAE,EAAE,CAAC,KAAK,IAAI,CAAC,EAAE;AACxK,MAAM,OAAO;AACb,IAAI;AACJ,IAAI,OAAO,UAAU,CAAC,MAAM,KAAK,IAAI,EAAE;AACvC,MAAM,UAAU,GAAG,iBAAiB,CAAC,WAAW,EAAE,UAAU,CAAC,MAAM;AACnE,IAAI;AACJ,EAAE;AACF;AACA;AACA;AACA,EAAE,MAAM,UAAU,2BAA2B,UAAU,KAAK,IAAI,GAAG,IAAI,CAAC,MAAM,8BAA8B,CAAC,UAAU,CAAC,OAAO,EAAE,IAAI;;AAErI,EAAE,IAAI,IAAI,CAAC,SAAS,KAAK,IAAI,EAAE;AAC/B;AACA,IAAI,IAAI,GAAG,IAAI,CAAC;AAChB,IAAI,KAAK,GAAG;AACZ;AACA,IAAI,OAAO,IAAI,KAAK,IAAI,EAAE;AAC1B;AACA;AACA;AACA,MAAM,IAAI,SAAS,GAAG;AACtB;AACA,MAAM,OAAO,SAAS,KAAK,IAAI,2BAA2B,CAAC,SAAS,CAAC,MAAM,EAAE,KAAK,KAAK,UAAU,EAAE;AACnG,QAAQ,SAAS,GAAG,SAAS,CAAC,MAAM,KAAK,IAAI,GAAG,IAAI,GAAG,iBAAiB,CAAC,WAAW,EAAE,SAAS,CAAC,MAAM;AACtG,MAAM;AACN,MAAM,IAAI,SAAS,KAAK,IAAI,2BAA2B,CAAC,SAAS,CAAC,MAAM,EAAE,KAAK,KAAK,UAAU,EAAE;AAChG,QAAQ,IAAI,GAAG;AACf,QAAQ;AACR,MAAM;AACN,MAAM,IAAI,GAAG,IAAI,CAAC;AAClB,IAAI;AACJ,IAAI,OAAO,KAAK,KAAK,IAAI,EAAE;AAC3B;AACA;AACA;AACA,MAAM,IAAI,UAAU,GAAG;AACvB;AACA,MAAM,OAAO,UAAU,KAAK,IAAI,2BAA2B,CAAC,UAAU,CAAC,MAAM,EAAE,KAAK,KAAK,UAAU,EAAE;AACrG,QAAQ,UAAU,GAAG,UAAU,CAAC,MAAM,KAAK,IAAI,GAAG,IAAI,GAAG,iBAAiB,CAAC,WAAW,EAAE,UAAU,CAAC,MAAM;AACzG,MAAM;AACN,MAAM,IAAI,UAAU,KAAK,IAAI,2BAA2B,CAAC,UAAU,CAAC,MAAM,EAAE,KAAK,KAAK,UAAU,EAAE;AAClG,QAAQ,KAAK,GAAG;AAChB,QAAQ;AACR,MAAM;AACN,MAAM,KAAK,GAAG,KAAK,CAAC;AACpB,IAAI;AACJ,EAAE,CAAC,MAAM;AACT,IAAI,KAAK,GAAG;AACZ,IAAI,IAAI,IAAI,CAAC,KAAK,IAAI,CAAC,sBAAsB,EAAE;AAC/C,MAAM,IAAI,GAAG;AACb;AACA;AACA,MAAM,OAAO,IAAI,KAAK,IAAI,IAAI,IAAI,CAAC,KAAK,KAAK,IAAI,KAAK,IAAI,CAAC,KAAK,CAAC,MAAM,IAAI,aAAa,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,IAAI,oBAAoB,CAAC,EAAE,CAAC,SAAS,EAAE,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,IAAI,oBAAoB,CAAC,EAAE,CAAC,SAAS,EAAE,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC,EAAE;AAC1N,QAAQ,IAAI,GAAG,IAAI,CAAC;AACpB;AACA,QAAQ,OAAO,IAAI,CAAC,MAAM,EAAE,IAAI,GAAG,iBAAiB,CAAC,WAAW,EAAE,IAAI,CAAC,MAAM;AAC7E,MAAM;AACN,MAAM,IAAI,IAAI,IAAI,IAAI,CAAC,KAAK,KAAK,IAAI,EAAE;AACvC;AACA;AACA,QAAQ,OAAO;AACf,MAAM;AACN,IAAI,CAAC,MAAM;AACX,MAAM,IAAI,GAAG,UAAU,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI;AACpD,IAAI;AACJ,EAAE;AACF,EAAE,MAAM,SAAS,GAAG,QAAQ,CAAC,KAAK,EAAE,WAAW;AAC/C,EAAE,MAAM,MAAM,GAAG,QAAQ,CAAC,WAAW,EAAE,SAAS;AAChD,EAAE,MAAM,UAAU,GAAG,IAAI,IAAI;AAC7B,IAAI,MAAM;AACV,IAAI,IAAI,EAAE,IAAI,IAAI,IAAI,CAAC,MAAM;AAC7B,IAAI,KAAK,EAAE,KAAK,IAAI,KAAK,CAAC,EAAE;AAC5B,IAAI,UAAU;AACd,IAAI,IAAI,CAAC,SAAS;AAClB,IAAI,IAAI,CAAC,OAAO,CAAC,IAAI;AACrB;AACA,EAAE,IAAI,CAAC,MAAM,GAAG;AAChB,EAAE,QAAQ,CAAC,UAAU,EAAE,IAAI;AAC3B,EAAE,UAAU,CAAC,SAAS,CAAC,WAAW,EAAE,CAAC;AACrC,EAAE,OAAO;AACT;;AAEA;AACA;AACA;AACO,MAAM,IAAI,SAAS,cAAc,CAAC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,WAAW,CAAC,CAAC,EAAE,EAAE,IAAI,EAAE,MAAM,EAAE,KAAK,EAAE,WAAW,EAAE,MAAM,EAAE,SAAS,EAAE,OAAO,EAAE;AACjF,IAAI,KAAK,CAAC,EAAE,EAAE,OAAO,CAAC,SAAS,EAAE;AACjC;AACA;AACA;AACA;AACA,IAAI,IAAI,CAAC,MAAM,GAAG;AAClB;AACA;AACA;AACA;AACA,IAAI,IAAI,CAAC,IAAI,GAAG;AAChB;AACA;AACA;AACA;AACA,IAAI,IAAI,CAAC,KAAK,GAAG;AACjB;AACA;AACA;AACA;AACA,IAAI,IAAI,CAAC,WAAW,GAAG;AACvB;AACA;AACA;AACA,IAAI,IAAI,CAAC,MAAM,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,IAAI,CAAC,SAAS,GAAG;AACrB;AACA;AACA;AACA;AACA;AACA,IAAI,IAAI,CAAC,MAAM,GAAG;AAClB;AACA;AACA;AACA,IAAI,IAAI,CAAC,OAAO,GAAG;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,OAAO,CAAC,WAAW,EAAE,GAAG,MAAM,CAAC,IAAI,GAAG;AAC3D,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE,IAAI,MAAM,CAAC,CAAC,QAAQ,EAAE;AACxB,IAAI,IAAI,CAAC,CAAC,IAAI,CAAC,IAAI,GAAG,MAAM,CAAC,IAAI,IAAI,CAAC,MAAM,QAAQ,EAAE;AACtD,MAAM,IAAI,CAAC,IAAI,IAAI,MAAM,CAAC;AAC1B,IAAI;AACJ,EAAE;;AAEF,EAAE,IAAI,MAAM,CAAC,GAAG;AAChB,IAAI,OAAO,CAAC,IAAI,CAAC,IAAI,GAAG,MAAM,CAAC,IAAI,IAAI;AACvC,EAAE;;AAEF;AACA;AACA;AACA,EAAE,IAAI,IAAI,CAAC,GAAG;AACd,IAAI,OAAO,CAAC,IAAI,CAAC,IAAI,GAAG,MAAM,CAAC,IAAI,IAAI;AACvC,EAAE;;AAEF,EAAE,IAAI,IAAI,CAAC,CAAC,MAAM,EAAE;AACpB,IAAI,IAAI,IAAI,CAAC,IAAI,KAAK,MAAM,EAAE;AAC9B,MAAM,IAAI,CAAC,IAAI,IAAI,MAAM,CAAC;AAC1B,IAAI;AACJ,EAAE;;AAEF,EAAE,IAAI,SAAS,CAAC,GAAG;AACnB,IAAI,OAAO,CAAC,IAAI,CAAC,IAAI,GAAG,MAAM,CAAC,IAAI,IAAI;AACvC,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE,IAAI,OAAO,CAAC,GAAG;AACjB,IAAI,OAAO,CAAC,IAAI,CAAC,IAAI,GAAG,MAAM,CAAC,IAAI,IAAI;AACvC,EAAE;;AAEF,EAAE,IAAI,OAAO,CAAC,CAAC,QAAQ,EAAE;AACzB,IAAI,IAAI,IAAI,CAAC,OAAO,KAAK,QAAQ,EAAE;AACnC,MAAM,IAAI,CAAC,IAAI,IAAI,MAAM,CAAC;AAC1B,IAAI;AACJ,EAAE;;AAEF,EAAE,WAAW,CAAC,GAAG;AACjB,IAAI,IAAI,CAAC,IAAI,IAAI,MAAM,CAAC;AACxB,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,UAAU,CAAC,CAAC,WAAW,EAAE,KAAK,EAAE;AAClC,IAAI,IAAI,IAAI,CAAC,MAAM,KAAK,IAAI,CAAC,MAAM,CAAC,KAAK,IAAI,QAAQ,CAAC,KAAK,EAAE,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,EAAE;AACrH,MAAM,OAAO,IAAI,CAAC,MAAM,CAAC;AACzB,IAAI;AACJ,IAAI,IAAI,IAAI,CAAC,WAAW,KAAK,IAAI,CAAC,WAAW,CAAC,KAAK,IAAI,QAAQ,CAAC,KAAK,EAAE,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,IAAI,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,EAAE;AACzI,MAAM,OAAO,IAAI,CAAC,WAAW,CAAC;AAC9B,IAAI;AACJ,IAAI,IAAI,IAAI,CAAC,MAAM,IAAI,IAAI,CAAC,MAAM,CAAC,WAAW,KAAK,EAAE,KAAK,IAAI,CAAC,MAAM,CAAC,KAAK,IAAI,QAAQ,CAAC,KAAK,EAAE,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,EAAE;AACvJ,MAAM,OAAO,IAAI,CAAC,MAAM,CAAC;AACzB,IAAI;AACJ;AACA,IAAI,IAAI,IAAI,CAAC,MAAM,EAAE;AACrB,MAAM,IAAI,CAAC,IAAI,GAAG,eAAe,CAAC,WAAW,EAAE,KAAK,EAAE,IAAI,CAAC,MAAM;AACjE,MAAM,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,IAAI,CAAC;AAC9B,IAAI;AACJ,IAAI,IAAI,IAAI,CAAC,WAAW,EAAE;AAC1B,MAAM,IAAI,CAAC,KAAK,GAAG,iBAAiB,CAAC,WAAW,EAAE,IAAI,CAAC,WAAW;AAClE,MAAM,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,KAAK,CAAC;AACpC,IAAI;AACJ,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,IAAI,CAAC,WAAW,KAAK,EAAE,MAAM,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,KAAK,CAAC,WAAW,KAAK,EAAE,CAAC,EAAE;AACtG,MAAM,IAAI,CAAC,MAAM,GAAG;AACpB,IAAI,CAAC,MAAM,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE;AAC7B;AACA,MAAM,IAAI,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,IAAI,CAAC,WAAW,KAAK,IAAI,EAAE;AACvD,QAAQ,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,IAAI,CAAC;AAChC,QAAQ,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,IAAI,CAAC;AACnC,MAAM,CAAC,MAAM,IAAI,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,KAAK,CAAC,WAAW,KAAK,IAAI,EAAE;AAChE,QAAQ,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC;AACjC,QAAQ,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC;AACpC,MAAM;AACN,IAAI,CAAC,MAAM,IAAI,IAAI,CAAC,MAAM,CAAC,WAAW,KAAK,EAAE,EAAE;AAC/C,MAAM,MAAM,UAAU,GAAG,OAAO,CAAC,KAAK,EAAE,IAAI,CAAC,MAAM;AACnD,MAAM,IAAI,UAAU,CAAC,WAAW,KAAK,EAAE,EAAE;AACzC,QAAQ,IAAI,CAAC,MAAM,GAAG;AACtB,MAAM,CAAC,MAAM;AACb,QAAQ,IAAI,CAAC,MAAM,8BAA8B,CAAC,UAAU,CAAC,OAAO,EAAE;AACtE,MAAM;AACN,IAAI;AACJ,IAAI,OAAO;AACX,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE,SAAS,CAAC,CAAC,WAAW,EAAE,MAAM,EAAE;AAClC,IAAI,IAAI,MAAM,GAAG,CAAC,EAAE;AACpB,MAAM,IAAI,CAAC,EAAE,CAAC,KAAK,IAAI;AACvB,MAAM,IAAI,CAAC,IAAI,GAAG,eAAe,CAAC,WAAW,EAAE,WAAW,CAAC,GAAG,CAAC,KAAK,EAAE,QAAQ,CAAC,IAAI,CAAC,EAAE,CAAC,MAAM,EAAE,IAAI,CAAC,EAAE,CAAC,KAAK,GAAG,CAAC,CAAC;AACjH,MAAM,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,IAAI,CAAC;AAC9B,MAAM,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,MAAM;AAC/C,MAAM,IAAI,CAAC,MAAM,IAAI;AACrB,IAAI;;AAEJ,IAAI,IAAI,IAAI,CAAC,MAAM,EAAE;AACrB,MAAM,IAAI,CAAC,CAAC,IAAI,CAAC,IAAI,KAAK,CAAC,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,KAAK,CAAC,IAAI,KAAK,IAAI,CAAC,MAAM,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,IAAI,CAAC,KAAK,KAAK,IAAI,CAAC,KAAK,CAAC,EAAE;AACtH;AACA;AACA;AACA,QAAQ,IAAI,IAAI,GAAG,IAAI,CAAC;;AAExB;AACA;AACA;AACA,QAAQ,IAAI;AACZ;AACA,QAAQ,IAAI,IAAI,KAAK,IAAI,EAAE;AAC3B,UAAU,CAAC,GAAG,IAAI,CAAC;AACnB,QAAQ,CAAC,MAAM,IAAI,IAAI,CAAC,SAAS,KAAK,IAAI,EAAE;AAC5C,UAAU,CAAC,oCAAoC,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI;AACzF,UAAU,OAAO,CAAC,KAAK,IAAI,IAAI,CAAC,CAAC,IAAI,KAAK,IAAI,EAAE;AAChD,YAAY,CAAC,GAAG,CAAC,CAAC;AAClB,UAAU;AACV,QAAQ,CAAC,MAAM;AACf,UAAU,CAAC,oCAAoC,CAAC,IAAI,CAAC,MAAM,EAAE;AAC7D,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ,MAAM,gBAAgB,GAAG,IAAI,GAAG;AACxC;AACA;AACA;AACA,QAAQ,MAAM,iBAAiB,GAAG,IAAI,GAAG;AACzC;AACA;AACA;AACA,QAAQ,OAAO,CAAC,KAAK,IAAI,IAAI,CAAC,KAAK,IAAI,CAAC,KAAK,EAAE;AAC/C,UAAU,iBAAiB,CAAC,GAAG,CAAC,CAAC;AACjC,UAAU,gBAAgB,CAAC,GAAG,CAAC,CAAC;AAChC,UAAU,IAAI,UAAU,CAAC,IAAI,CAAC,MAAM,EAAE,CAAC,CAAC,MAAM,CAAC,EAAE;AACjD;AACA,YAAY,IAAI,CAAC,CAAC,EAAE,CAAC,MAAM,GAAG,IAAI,CAAC,EAAE,CAAC,MAAM,EAAE;AAC9C,cAAc,IAAI,GAAG;AACrB,cAAc,gBAAgB,CAAC,KAAK;AACpC,YAAY,CAAC,MAAM,IAAI,UAAU,CAAC,IAAI,CAAC,WAAW,EAAE,CAAC,CAAC,WAAW,CAAC,EAAE;AACpE;AACA;AACA,cAAc;AACd,YAAY,CAAC;AACb,UAAU,CAAC,MAAM,IAAI,CAAC,CAAC,MAAM,KAAK,IAAI,IAAI,iBAAiB,CAAC,GAAG,CAAC,OAAO,CAAC,WAAW,CAAC,GAAG,CAAC,KAAK,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC,EAAE;AAC3G;AACA,YAAY,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,OAAO,CAAC,WAAW,CAAC,GAAG,CAAC,KAAK,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC,EAAE;AACjF,cAAc,IAAI,GAAG;AACrB,cAAc,gBAAgB,CAAC,KAAK;AACpC,YAAY;AACZ,UAAU,CAAC,MAAM;AACjB,YAAY;AACZ,UAAU;AACV,UAAU,CAAC,GAAG,CAAC,CAAC;AAChB,QAAQ;AACR,QAAQ,IAAI,CAAC,IAAI,GAAG;AACpB,MAAM;AACN;AACA,MAAM,IAAI,IAAI,CAAC,IAAI,KAAK,IAAI,EAAE;AAC9B,QAAQ,MAAM,KAAK,GAAG,IAAI,CAAC,IAAI,CAAC;AAChC,QAAQ,IAAI,CAAC,KAAK,GAAG;AACrB,QAAQ,IAAI,CAAC,IAAI,CAAC,KAAK,GAAG;AAC1B,MAAM,CAAC,MAAM;AACb,QAAQ,IAAI;AACZ,QAAQ,IAAI,IAAI,CAAC,SAAS,KAAK,IAAI,EAAE;AACrC,UAAU,CAAC,oCAAoC,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI;AACzF,UAAU,OAAO,CAAC,KAAK,IAAI,IAAI,CAAC,CAAC,IAAI,KAAK,IAAI,EAAE;AAChD,YAAY,CAAC,GAAG,CAAC,CAAC;AAClB,UAAU;AACV,QAAQ,CAAC,MAAM;AACf,UAAU,CAAC,oCAAoC,CAAC,IAAI,CAAC,MAAM,EAAE;AAC7D,WAAW,iCAAiC,CAAC,IAAI,CAAC,MAAM,EAAE,MAAM,GAAG;AACnE,QAAQ;AACR,QAAQ,IAAI,CAAC,KAAK,GAAG;AACrB,MAAM;AACN,MAAM,IAAI,IAAI,CAAC,KAAK,KAAK,IAAI,EAAE;AAC/B,QAAQ,IAAI,CAAC,KAAK,CAAC,IAAI,GAAG;AAC1B,MAAM,CAAC,MAAM,IAAI,IAAI,CAAC,SAAS,KAAK,IAAI,EAAE;AAC1C;AACA,yCAAyC,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,SAAS,EAAE,IAAI;AACpF,QAAQ,IAAI,IAAI,CAAC,IAAI,KAAK,IAAI,EAAE;AAChC;AACA,UAAU,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,WAAW;AACtC,QAAQ;AACR,MAAM;AACN;AACA,MAAM,IAAI,IAAI,CAAC,SAAS,KAAK,IAAI,IAAI,IAAI,CAAC,SAAS,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE;AACtE,yCAAyC,CAAC,IAAI,CAAC,MAAM,EAAE,OAAO,IAAI,IAAI,CAAC;AACvE,MAAM;AACN,MAAM,gBAAgB,CAAC,WAAW,CAAC,SAAS,EAAE,IAAI;AAClD,MAAM,SAAS,CAAC,WAAW,CAAC,GAAG,CAAC,KAAK,EAAE,IAAI;AAC3C,MAAM,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,WAAW,EAAE,IAAI;AAC9C;AACA,MAAM,2BAA2B,CAAC,WAAW,oDAAoD,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,SAAS;AAC7H,MAAM,IAAI,kCAAkC,CAAC,IAAI,CAAC,MAAM,EAAE,KAAK,KAAK,IAAI,qCAAqC,CAAC,IAAI,CAAC,MAAM,EAAE,KAAK,CAAC,OAAO,MAAM,IAAI,CAAC,SAAS,KAAK,IAAI,IAAI,IAAI,CAAC,KAAK,KAAK,IAAI,CAAC,EAAE;AAC/L;AACA,QAAQ,IAAI,CAAC,MAAM,CAAC,WAAW;AAC/B,MAAM;AACN,IAAI,CAAC,MAAM;AACX;AACA,MAAM,IAAI,EAAE,CAAC,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC,SAAS,CAAC,WAAW,EAAE,CAAC;AAC3D,IAAI;AACJ,EAAE;;AAEF;AACA;AACA;AACA,EAAE,IAAI,IAAI,CAAC,GAAG;AACd,IAAI,IAAI,CAAC,GAAG,IAAI,CAAC;AACjB,IAAI,OAAO,CAAC,KAAK,IAAI,IAAI,CAAC,CAAC,OAAO,EAAE;AACpC,MAAM,CAAC,GAAG,CAAC,CAAC;AACZ,IAAI;AACJ,IAAI,OAAO;AACX,EAAE;;AAEF;AACA;AACA;AACA,EAAE,IAAI,IAAI,CAAC,GAAG;AACd,IAAI,IAAI,CAAC,GAAG,IAAI,CAAC;AACjB,IAAI,OAAO,CAAC,KAAK,IAAI,IAAI,CAAC,CAAC,OAAO,EAAE;AACpC,MAAM,CAAC,GAAG,CAAC,CAAC;AACZ,IAAI;AACJ,IAAI,OAAO;AACX,EAAE;;AAEF;AACA;AACA;AACA,EAAE,IAAI,MAAM,CAAC,GAAG;AAChB;AACA,IAAI,OAAO,IAAI,CAAC,MAAM,KAAK,CAAC,GAAG,IAAI,CAAC,EAAE,GAAG,QAAQ,CAAC,IAAI,CAAC,EAAE,CAAC,MAAM,EAAE,IAAI,CAAC,EAAE,CAAC,KAAK,GAAG,IAAI,CAAC,MAAM,GAAG,CAAC;AACjG,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,SAAS,CAAC,CAAC,KAAK,EAAE;AACpB,IAAI;AACJ,MAAM,IAAI,CAAC,WAAW,KAAK,KAAK,CAAC,WAAW;AAC5C,MAAM,UAAU,CAAC,KAAK,CAAC,MAAM,EAAE,IAAI,CAAC,MAAM,CAAC;AAC3C,MAAM,IAAI,CAAC,KAAK,KAAK,KAAK;AAC1B,MAAM,UAAU,CAAC,IAAI,CAAC,WAAW,EAAE,KAAK,CAAC,WAAW,CAAC;AACrD,MAAM,IAAI,CAAC,EAAE,CAAC,MAAM,KAAK,KAAK,CAAC,EAAE,CAAC,MAAM;AACxC,MAAM,IAAI,CAAC,EAAE,CAAC,KAAK,GAAG,IAAI,CAAC,MAAM,KAAK,KAAK,CAAC,EAAE,CAAC,KAAK;AACpD,MAAM,IAAI,CAAC,OAAO,KAAK,KAAK,CAAC,OAAO;AACpC,MAAM,IAAI,CAAC,MAAM,KAAK,IAAI;AAC1B,MAAM,KAAK,CAAC,MAAM,KAAK,IAAI;AAC3B,MAAM,IAAI,CAAC,OAAO,CAAC,WAAW,KAAK,KAAK,CAAC,OAAO,CAAC,WAAW;AAC5D,MAAM,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,KAAK,CAAC,OAAO;AAC1C,MAAM;AACN,MAAM,MAAM,YAAY,oCAAoC,CAAC,IAAI,CAAC,MAAM,EAAE;AAC1E,MAAM,IAAI,YAAY,EAAE;AACxB,QAAQ,YAAY,CAAC,OAAO,CAAC,MAAM,IAAI;AACvC,UAAU,IAAI,MAAM,CAAC,CAAC,KAAK,KAAK,EAAE;AAClC;AACA,YAAY,MAAM,CAAC,CAAC,GAAG;AACvB;AACA,YAAY,IAAI,CAAC,IAAI,CAAC,OAAO,IAAI,IAAI,CAAC,SAAS,EAAE;AACjD,cAAc,MAAM,CAAC,KAAK,IAAI,IAAI,CAAC;AACnC,YAAY;AACZ,UAAU;AACV,QAAQ,CAAC;AACT,MAAM;AACN,MAAM,IAAI,KAAK,CAAC,IAAI,EAAE;AACtB,QAAQ,IAAI,CAAC,IAAI,GAAG;AACpB,MAAM;AACN,MAAM,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;AACzB,MAAM,IAAI,IAAI,CAAC,KAAK,KAAK,IAAI,EAAE;AAC/B,QAAQ,IAAI,CAAC,KAAK,CAAC,IAAI,GAAG;AAC1B,MAAM;AACN,MAAM,IAAI,CAAC,MAAM,IAAI,KAAK,CAAC;AAC3B,MAAM,OAAO;AACb,IAAI;AACJ,IAAI,OAAO;AACX,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE,MAAM,CAAC,CAAC,WAAW,EAAE;AACvB,IAAI,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE;AACvB,MAAM,MAAM,MAAM,qDAAqD,IAAI,CAAC,MAAM;AAClF;AACA,MAAM,IAAI,IAAI,CAAC,SAAS,IAAI,IAAI,CAAC,SAAS,KAAK,IAAI,EAAE;AACrD,QAAQ,MAAM,CAAC,OAAO,IAAI,IAAI,CAAC;AAC/B,MAAM;AACN,MAAM,IAAI,CAAC,WAAW;AACtB,MAAM,UAAU,CAAC,WAAW,CAAC,SAAS,EAAE,IAAI,CAAC,EAAE,CAAC,MAAM,EAAE,IAAI,CAAC,EAAE,CAAC,KAAK,EAAE,IAAI,CAAC,MAAM;AAClF,MAAM,2BAA2B,CAAC,WAAW,EAAE,MAAM,EAAE,IAAI,CAAC,SAAS;AACrE,MAAM,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,WAAW;AACrC,IAAI;AACJ,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE,EAAE,CAAC,CAAC,EAAE,EAAE,SAAS,EAAE;AACrB,IAAI,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE;AACvB,MAAM,MAAM,KAAK,CAAC,cAAc;AAChC,IAAI;AACJ,IAAI,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,EAAE;AACtB,IAAI,IAAI,SAAS,EAAE;AACnB,MAAM,aAAa,CAAC,EAAE,EAAE,IAAI,EAAE,IAAI,EAAE,CAAC,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC,MAAM,CAAC;AAC1D,IAAI,CAAC,MAAM;AACX,MAAM,IAAI,CAAC,OAAO,GAAG,IAAI,cAAc,CAAC,IAAI,CAAC,MAAM;AACnD,IAAI;AACJ,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,KAAK,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,SAAS,EAAE;AACrC,IAAI,MAAM,MAAM,GAAG,MAAM,GAAG,CAAC,GAAG,QAAQ,CAAC,IAAI,CAAC,EAAE,CAAC,MAAM,EAAE,IAAI,CAAC,EAAE,CAAC,KAAK,GAAG,MAAM,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC;AAC5F,IAAI,MAAM,WAAW,GAAG,IAAI,CAAC;AAC7B,IAAI,MAAM,SAAS,GAAG,IAAI,CAAC;AAC3B,IAAI,MAAM,IAAI,GAAG,CAAC,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,GAAG,MAAM,CAAC,KAAK;AACtD,OAAO,MAAM,KAAK,IAAI,GAAG,CAAC,GAAG,MAAM,CAAC,IAAI,CAAC;AACzC,OAAO,WAAW,KAAK,IAAI,GAAG,CAAC,GAAG,MAAM,CAAC,IAAI,CAAC;AAC9C,OAAO,SAAS,KAAK,IAAI,GAAG,CAAC,GAAG,MAAM,CAAC,IAAI,EAAC;AAC5C,IAAI,OAAO,CAAC,SAAS,CAAC,IAAI;AAC1B,IAAI,IAAI,MAAM,KAAK,IAAI,EAAE;AACzB,MAAM,OAAO,CAAC,WAAW,CAAC,MAAM;AAChC,IAAI;AACJ,IAAI,IAAI,WAAW,KAAK,IAAI,EAAE;AAC9B,MAAM,OAAO,CAAC,YAAY,CAAC,WAAW;AACtC,IAAI;AACJ,IAAI,IAAI,MAAM,KAAK,IAAI,IAAI,WAAW,KAAK,IAAI,EAAE;AACjD,MAAM,MAAM,MAAM,qCAAqC,IAAI,CAAC,MAAM;AAClE,MAAM,IAAI,MAAM,CAAC,KAAK,KAAK,SAAS,EAAE;AACtC,QAAQ,MAAM,UAAU,GAAG,MAAM,CAAC;AAClC,QAAQ,IAAI,UAAU,KAAK,IAAI,EAAE;AACjC;AACA;AACA,UAAU,MAAM,IAAI,GAAG,eAAe,CAAC,MAAM;AAC7C,UAAU,OAAO,CAAC,eAAe,CAAC,IAAI,EAAC;AACvC,UAAU,OAAO,CAAC,WAAW,CAAC,IAAI;AAClC,QAAQ,CAAC,MAAM;AACf,UAAU,OAAO,CAAC,eAAe,CAAC,KAAK,EAAC;AACxC,UAAU,OAAO,CAAC,WAAW,CAAC,UAAU,CAAC,EAAE;AAC3C,QAAQ;AACR,MAAM,CAAC,MAAM,IAAI,MAAM,CAAC,WAAW,KAAK,MAAM,EAAE;AAChD,QAAQ,OAAO,CAAC,eAAe,CAAC,IAAI,EAAC;AACrC,QAAQ,OAAO,CAAC,WAAW,CAAC,MAAM;AAClC,MAAM,CAAC,MAAM,IAAI,MAAM,CAAC,WAAW,KAAK,EAAE,EAAE;AAC5C,QAAQ,OAAO,CAAC,eAAe,CAAC,KAAK,EAAC;AACtC,QAAQ,OAAO,CAAC,WAAW,CAAC,MAAM;AAClC,MAAM,CAAC,MAAM;AACb,QAAQ,KAAK,CAAC,cAAc;AAC5B,MAAM;AACN,MAAM,IAAI,SAAS,KAAK,IAAI,EAAE;AAC9B,QAAQ,OAAO,CAAC,WAAW,CAAC,SAAS;AACrC,MAAM;AACN,IAAI;AACJ,IAAI,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,OAAO,EAAE,MAAM,EAAE,SAAS;AACjD,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACY,MAAC,eAAe,GAAG,CAAC,OAAO,EAAE,IAAI,KAAK,WAAW,CAAC,IAAI,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC,OAAO;;AAE1F;AACA;AACA;AACA;AACA;AACY,MAAC,WAAW,GAAG;AAC3B,EAAE,MAAM,EAAE,KAAK,CAAC,cAAc,GAAE,CAAC,CAAC;AAClC,EAAE,kBAAkB;AACpB,EAAE,eAAe;AACjB,EAAE,iBAAiB;AACnB,EAAE,iBAAiB;AACnB,EAAE,gBAAgB;AAClB,EAAE,iBAAiB;AACnB,EAAE,eAAe;AACjB,EAAE,cAAc;AAChB,EAAE,cAAc;AAChB,EAAE,MAAM,EAAE,KAAK,CAAC,cAAc,GAAE,CAAC,CAAC;AAClC;;AAEA;AACA;AACA;AACO,MAAM,eAAe,CAAC;AAC7B;AACA;AACA;AACA,EAAE,SAAS,CAAC,GAAG;AACf,IAAI,MAAM,KAAK,CAAC,mBAAmB;AACnC,EAAE;;AAEF;AACA;AACA;AACA,EAAE,UAAU,CAAC,GAAG;AAChB,IAAI,MAAM,KAAK,CAAC,mBAAmB;AACnC,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,WAAW,CAAC,GAAG;AACjB,IAAI,MAAM,KAAK,CAAC,mBAAmB;AACnC,EAAE;;AAEF;AACA;AACA;AACA,EAAE,IAAI,CAAC,GAAG;AACV,IAAI,MAAM,KAAK,CAAC,mBAAmB;AACnC,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE,MAAM,CAAC,CAAC,OAAO,EAAE;AACnB,IAAI,MAAM,KAAK,CAAC,mBAAmB;AACnC,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE,SAAS,CAAC,CAAC,MAAM,EAAE;AACrB,IAAI,MAAM,KAAK,CAAC,mBAAmB;AACnC,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE,SAAS,CAAC,CAAC,YAAY,EAAE,KAAK,EAAE;AAClC,IAAI,MAAM,KAAK,CAAC,mBAAmB;AACnC,EAAE;;AAEF;AACA;AACA;AACA,EAAE,MAAM,CAAC,CAAC,YAAY,EAAE;AACxB,IAAI,MAAM,KAAK,CAAC,mBAAmB;AACnC,EAAE;;AAEF;AACA;AACA;AACA,EAAE,EAAE,CAAC,CAAC,YAAY,EAAE;AACpB,IAAI,MAAM,KAAK,CAAC,mBAAmB;AACnC,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE,KAAK,CAAC,CAAC,QAAQ,EAAE,OAAO,EAAE,UAAU,EAAE;AACxC,IAAI,MAAM,KAAK,CAAC,mBAAmB;AACnC,EAAE;;AAEF;AACA;AACA;AACA,EAAE,MAAM,CAAC,GAAG;AACZ,IAAI,MAAM,KAAK,CAAC,mBAAmB;AACnC,EAAE;AACF;;ACl0BY,MAAC,mBAAmB,GAAG;;AAEnC;AACA;AACA;AACO,MAAM,IAAI,SAAS,cAAc,CAAC;AACzC,EAAE,IAAI,OAAO,CAAC,GAAG;AACjB,IAAI,OAAO;AACX,EAAE;;AAEF,EAAE,MAAM,CAAC,GAAG,CAAC;;AAEb;AACA;AACA;AACA;AACA,EAAE,SAAS,CAAC,CAAC,KAAK,EAAE;AACpB,IAAI,IAAI,IAAI,CAAC,WAAW,KAAK,KAAK,CAAC,WAAW,EAAE;AAChD,MAAM,OAAO;AACb,IAAI;AACJ,IAAI,IAAI,CAAC,MAAM,IAAI,KAAK,CAAC;AACzB,IAAI,OAAO;AACX,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE,SAAS,CAAC,CAAC,WAAW,EAAE,MAAM,EAAE;AAClC,IAAI,IAAI,MAAM,GAAG,CAAC,EAAE;AACpB,MAAM,IAAI,CAAC,EAAE,CAAC,KAAK,IAAI;AACvB,MAAM,IAAI,CAAC,MAAM,IAAI;AACrB,IAAI;AACJ,IAAI,UAAU,CAAC,WAAW,CAAC,GAAG,CAAC,KAAK,CAAC,KAAK,EAAE,IAAI,CAAC,EAAE,CAAC,MAAM,EAAE,IAAI,CAAC,EAAE,CAAC,KAAK,EAAE,IAAI,CAAC,MAAM;AACtF,IAAI,SAAS,CAAC,WAAW,CAAC,GAAG,CAAC,KAAK,EAAE,IAAI;AACzC,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE,KAAK,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE;AAC1B,IAAI,OAAO,CAAC,SAAS,CAAC,mBAAmB;AACzC;AACA,IAAI,QAAQ,CAAC,YAAY,CAAC,OAAO,CAAC,WAAW,EAAE,IAAI,CAAC,MAAM,GAAG,MAAM;AACnE,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE,UAAU,CAAC,CAAC,YAAY,EAAE,MAAM,EAAE;AACpC,IAAI,OAAO;AACX,EAAE;;AAEF;AACA;AACA;AACA,EAAE,MAAM,CAAC,CAAC,IAAI,EAAE;AAChB,IAAI,MAAM,KAAK,GAAG,IAAI,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE,CAAC,MAAM,EAAE,IAAI,CAAC,EAAE,CAAC,KAAK,GAAG,IAAI,CAAC,EAAE,IAAI,CAAC,MAAM,GAAG,IAAI;AAC7F,IAAI,IAAI,CAAC,MAAM,GAAG;AAClB,IAAI,OAAO;AACX,EAAE;AACF;;;;"}
\ No newline at end of file
diff --git a/dist/index-BextecLz.js b/dist/index-BextecLz.js
new file mode 100644
index 0000000000000000000000000000000000000000..c88e320d9800ae6c2f8c31c6d8ada726b4ea1100
--- /dev/null
+++ b/dist/index-BextecLz.js
@@ -0,0 +1,166 @@
+import { ah as AbsolutePosition, bG as AbstractAttributionManager, A as AbstractConnector, cz as AbstractStruct, bV as AbstractType, cg as YArray, bm as AttributionItem, cO as ContentAny, cC as ContentBinary, cE as ContentDeleted, cG as ContentDoc, cI as ContentEmbed, cK as ContentFormat, cM as ContentJSON, cQ as ContentString, c_ as ContentType, bK as DiffAttributionManager, D as Doc, cB as GC, a6 as ID, bu as IdMap, b as IdSet, d5 as Item, ci as YMap, ae as RelativePosition, da as Skip, ar as Snapshot, bM as SnapshotAttributionManager, cp as YText, aS as Transaction, bH as TwosetAttributionManager, aZ as UndoManager, U as UpdateDecoderV1, C as UpdateDecoderV2, F as UpdateEncoderV1, H as UpdateEncoderV2, ct as YXmlElement, cr as YXmlFragment, cv as YXmlHook, cx as YXmlText, bh as YEvent, Q as applyUpdate, P as applyUpdateV2, cm as cleanupYTextFormatting, y as cloneDoc, a7 as compareIDs, aq as compareRelativePositions, bf as convertUpdateFormatV1ToV2, bg as convertUpdateFormatV2ToV1, ap as createAbsolutePositionFromRelativePosition, bn as createAttributionItem, bL as createAttributionManagerFromDiff, bN as createAttributionManagerFromSnapshots, q as createDeleteSetFromStructStore, aC as createDocFromSnapshot, a8 as createID, bz as createIdMap, bt as createIdMapFromIdSet, p as createIdSet, s as createInsertSetFromStructStore, ag as createRelativePositionFromJSON, ak as createRelativePositionFromTypeIndex, ax as createSnapshot, by as decodeIdMap, ao as decodeRelativePosition, aw as decodeSnapshot, av as decodeSnapshotV2, W as decodeStateVector, b1 as decodeUpdate, b2 as decodeUpdateV2, bO as diffDocsToDelta, bB as diffIdMap, j as diffIdSet, bb as diffUpdate, ba as diffUpdateV2, ay as emptySnapshot, bw as encodeIdMap, am as encodeRelativePosition, au as encodeSnapshot, at as encodeSnapshotV2, T as encodeStateAsUpdate, S as encodeStateAsUpdateV2, $ as encodeStateVector, b6 as encodeStateVectorFromUpdate, b5 as encodeStateVectorFromUpdateV2, v as equalIdSets, as as equalSnapshots, aK as findIndexSS, ab as findRootTypeKey, aM as getItem, aP as getItemCleanEnd, aO as getItemCleanStart, bi as getPathTo, aH as getState, bT as getTypeChildren, bA as insertIntoIdMap, g as insertIntoIdSet, ac as isParentOf, i as iterateStructsByIdSet, ad as logType, a$ as logUpdate, b0 as logUpdateV2, bs as mergeIdMaps, m as mergeIdSets, b4 as mergeUpdates, b9 as mergeUpdatesV2, bJ as noAttributionsManager, bd as obfuscateUpdate, be as obfuscateUpdateV2, bx as readIdMap, t as readIdSet, O as readUpdate, b8 as readUpdateIdRanges, b7 as readUpdateIdRangesV2, N as readUpdateV2, af as relativePositionToJSON, az as snapshot, aE as snapshotContainsUpdate, aX as transact, aW as tryGc, bZ as typeListToArraySnapshot, ce as typeMapGetAllSnapshot, cd as typeMapGetSnapshot } from './Skip-gsWxt5h3.js';
+import 'lib0/function';
+import 'lib0/decoding';
+import 'lib0/binary';
+import 'lib0/map';
+
+/** eslint-env browser */
+
+
+const glo = /** @type {any} */ (typeof globalThis !== 'undefined'
+  ? globalThis
+  : typeof window !== 'undefined'
+    ? window
+    // @ts-ignore
+    : typeof global !== 'undefined' ? global : {});
+
+const importIdentifier = '__ $YJS14$ __';
+
+if (glo[importIdentifier] === true) {
+  /**
+   * Dear reader of this message. Please take this seriously.
+   *
+   * If you see this message, make sure that you only import one version of Yjs. In many cases,
+   * your package manager installs two versions of Yjs that are used by different packages within your project.
+   * Another reason for this message is that some parts of your project use the commonjs version of Yjs
+   * and others use the EcmaScript version of Yjs.
+   *
+   * This often leads to issues that are hard to debug. We often need to perform constructor checks,
+   * e.g. `struct instanceof GC`. If you imported different versions of Yjs, it is impossible for us to
+   * do the constructor checks anymore - which might break the CRDT algorithm.
+   *
+   * https://github.com/yjs/yjs/issues/438
+   */
+  console.error('Yjs was already imported. This breaks constructor checks and will lead to issues! - https://github.com/yjs/yjs/issues/438');
+}
+glo[importIdentifier] = true;
+
+var Y = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  AbsolutePosition: AbsolutePosition,
+  AbstractAttributionManager: AbstractAttributionManager,
+  AbstractConnector: AbstractConnector,
+  AbstractStruct: AbstractStruct,
+  AbstractType: AbstractType,
+  Array: YArray,
+  Attribution: AttributionItem,
+  ContentAny: ContentAny,
+  ContentBinary: ContentBinary,
+  ContentDeleted: ContentDeleted,
+  ContentDoc: ContentDoc,
+  ContentEmbed: ContentEmbed,
+  ContentFormat: ContentFormat,
+  ContentJSON: ContentJSON,
+  ContentString: ContentString,
+  ContentType: ContentType,
+  DiffAttributionManager: DiffAttributionManager,
+  Doc: Doc,
+  GC: GC,
+  ID: ID,
+  IdMap: IdMap,
+  IdSet: IdSet,
+  Item: Item,
+  Map: YMap,
+  RelativePosition: RelativePosition,
+  Skip: Skip,
+  Snapshot: Snapshot,
+  SnapshotAttributionManager: SnapshotAttributionManager,
+  Text: YText,
+  Transaction: Transaction,
+  TwosetAttributionManager: TwosetAttributionManager,
+  UndoManager: UndoManager,
+  UpdateDecoderV1: UpdateDecoderV1,
+  UpdateDecoderV2: UpdateDecoderV2,
+  UpdateEncoderV1: UpdateEncoderV1,
+  UpdateEncoderV2: UpdateEncoderV2,
+  XmlElement: YXmlElement,
+  XmlFragment: YXmlFragment,
+  XmlHook: YXmlHook,
+  XmlText: YXmlText,
+  YEvent: YEvent,
+  applyUpdate: applyUpdate,
+  applyUpdateV2: applyUpdateV2,
+  cleanupYTextFormatting: cleanupYTextFormatting,
+  cloneDoc: cloneDoc,
+  compareIDs: compareIDs,
+  compareRelativePositions: compareRelativePositions,
+  convertUpdateFormatV1ToV2: convertUpdateFormatV1ToV2,
+  convertUpdateFormatV2ToV1: convertUpdateFormatV2ToV1,
+  createAbsolutePositionFromRelativePosition: createAbsolutePositionFromRelativePosition,
+  createAttributionItem: createAttributionItem,
+  createAttributionManagerFromDiff: createAttributionManagerFromDiff,
+  createAttributionManagerFromSnapshots: createAttributionManagerFromSnapshots,
+  createDeleteSetFromStructStore: createDeleteSetFromStructStore,
+  createDocFromSnapshot: createDocFromSnapshot,
+  createID: createID,
+  createIdMap: createIdMap,
+  createIdMapFromIdSet: createIdMapFromIdSet,
+  createIdSet: createIdSet,
+  createInsertionSetFromStructStore: createInsertSetFromStructStore,
+  createRelativePositionFromJSON: createRelativePositionFromJSON,
+  createRelativePositionFromTypeIndex: createRelativePositionFromTypeIndex,
+  createSnapshot: createSnapshot,
+  decodeIdMap: decodeIdMap,
+  decodeRelativePosition: decodeRelativePosition,
+  decodeSnapshot: decodeSnapshot,
+  decodeSnapshotV2: decodeSnapshotV2,
+  decodeStateVector: decodeStateVector,
+  decodeUpdate: decodeUpdate,
+  decodeUpdateV2: decodeUpdateV2,
+  diffDocsToDelta: diffDocsToDelta,
+  diffIdMap: diffIdMap,
+  diffIdSet: diffIdSet,
+  diffUpdate: diffUpdate,
+  diffUpdateV2: diffUpdateV2,
+  emptySnapshot: emptySnapshot,
+  encodeIdMap: encodeIdMap,
+  encodeRelativePosition: encodeRelativePosition,
+  encodeSnapshot: encodeSnapshot,
+  encodeSnapshotV2: encodeSnapshotV2,
+  encodeStateAsUpdate: encodeStateAsUpdate,
+  encodeStateAsUpdateV2: encodeStateAsUpdateV2,
+  encodeStateVector: encodeStateVector,
+  encodeStateVectorFromUpdate: encodeStateVectorFromUpdate,
+  encodeStateVectorFromUpdateV2: encodeStateVectorFromUpdateV2,
+  equalIdSets: equalIdSets,
+  equalSnapshots: equalSnapshots,
+  findIndexSS: findIndexSS,
+  findRootTypeKey: findRootTypeKey,
+  getItem: getItem,
+  getItemCleanEnd: getItemCleanEnd,
+  getItemCleanStart: getItemCleanStart,
+  getPathTo: getPathTo,
+  getState: getState,
+  getTypeChildren: getTypeChildren,
+  insertIntoIdMap: insertIntoIdMap,
+  insertIntoIdSet: insertIntoIdSet,
+  isParentOf: isParentOf,
+  iterateStructsByIdSet: iterateStructsByIdSet,
+  logType: logType,
+  logUpdate: logUpdate,
+  logUpdateV2: logUpdateV2,
+  mergeIdMaps: mergeIdMaps,
+  mergeIdSets: mergeIdSets,
+  mergeUpdates: mergeUpdates,
+  mergeUpdatesV2: mergeUpdatesV2,
+  noAttributionsManager: noAttributionsManager,
+  obfuscateUpdate: obfuscateUpdate,
+  obfuscateUpdateV2: obfuscateUpdateV2,
+  readIdMap: readIdMap,
+  readIdSet: readIdSet,
+  readUpdate: readUpdate,
+  readUpdateIdRanges: readUpdateIdRanges,
+  readUpdateIdRangesV2: readUpdateIdRangesV2,
+  readUpdateV2: readUpdateV2,
+  relativePositionToJSON: relativePositionToJSON,
+  snapshot: snapshot,
+  snapshotContainsUpdate: snapshotContainsUpdate,
+  transact: transact,
+  tryGc: tryGc,
+  typeListToArraySnapshot: typeListToArraySnapshot,
+  typeMapGetAllSnapshot: typeMapGetAllSnapshot,
+  typeMapGetSnapshot: typeMapGetSnapshot
+});
+
+export { Y };
+//# sourceMappingURL=index-BextecLz.js.map
diff --git a/dist/index-BextecLz.js.map b/dist/index-BextecLz.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..fe13984af60b08ac847d2bc34b513ec1d8b7667d
--- /dev/null
+++ b/dist/index-BextecLz.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"index-BextecLz.js","sources":["../src/index.js"],"sourcesContent":["/** eslint-env browser */\n\nexport {\n  Doc,\n  Transaction,\n  YArray as Array,\n  YMap as Map,\n  YText as Text,\n  YXmlText as XmlText,\n  YXmlHook as XmlHook,\n  YXmlElement as XmlElement,\n  YXmlFragment as XmlFragment,\n  YEvent,\n  Item,\n  AbstractStruct,\n  GC,\n  Skip,\n  ContentBinary,\n  ContentDeleted,\n  ContentDoc,\n  ContentEmbed,\n  ContentFormat,\n  ContentJSON,\n  ContentAny,\n  ContentString,\n  ContentType,\n  AbstractType,\n  getTypeChildren,\n  createRelativePositionFromTypeIndex,\n  createRelativePositionFromJSON,\n  createAbsolutePositionFromRelativePosition,\n  compareRelativePositions,\n  AbsolutePosition,\n  RelativePosition,\n  ID,\n  createID,\n  compareIDs,\n  getState,\n  Snapshot,\n  createSnapshot,\n  cleanupYTextFormatting,\n  snapshot,\n  emptySnapshot,\n  findRootTypeKey,\n  findIndexSS,\n  getItem,\n  getItemCleanStart,\n  getItemCleanEnd,\n  typeListToArraySnapshot,\n  typeMapGetSnapshot,\n  typeMapGetAllSnapshot,\n  createDocFromSnapshot,\n  applyUpdate,\n  applyUpdateV2,\n  readUpdate,\n  readUpdateV2,\n  encodeStateAsUpdate,\n  encodeStateAsUpdateV2,\n  encodeStateVector,\n  UndoManager,\n  decodeSnapshot,\n  encodeSnapshot,\n  decodeSnapshotV2,\n  encodeSnapshotV2,\n  decodeStateVector,\n  logUpdate,\n  logUpdateV2,\n  decodeUpdate,\n  decodeUpdateV2,\n  relativePositionToJSON,\n  isParentOf,\n  equalSnapshots,\n  tryGc,\n  transact,\n  AbstractConnector,\n  logType,\n  mergeUpdates,\n  mergeUpdatesV2,\n  encodeStateVectorFromUpdate,\n  encodeStateVectorFromUpdateV2,\n  encodeRelativePosition,\n  decodeRelativePosition,\n  diffUpdate,\n  diffUpdateV2,\n  convertUpdateFormatV1ToV2,\n  convertUpdateFormatV2ToV1,\n  obfuscateUpdate,\n  obfuscateUpdateV2,\n  UpdateEncoderV1,\n  UpdateEncoderV2,\n  UpdateDecoderV1,\n  UpdateDecoderV2,\n  snapshotContainsUpdate,\n  // idset\n  IdSet,\n  equalIdSets,\n  createDeleteSetFromStructStore,\n  IdMap,\n  createIdMap,\n  createAttributionItem,\n  createInsertSetFromStructStore as createInsertionSetFromStructStore,\n  diffIdMap,\n  diffIdSet,\n  AttributionItem as Attribution,\n  encodeIdMap,\n  createIdMapFromIdSet,\n  TwosetAttributionManager,\n  noAttributionsManager,\n  AbstractAttributionManager,\n  iterateStructsByIdSet,\n  createAttributionManagerFromDiff,\n  DiffAttributionManager,\n  createAttributionManagerFromSnapshots,\n  SnapshotAttributionManager,\n  createIdSet,\n  mergeIdSets,\n  cloneDoc,\n  readUpdateIdRanges,\n  readUpdateIdRangesV2,\n  insertIntoIdMap,\n  insertIntoIdSet,\n  mergeIdMaps,\n  readIdMap,\n  readIdSet,\n  decodeIdMap,\n  diffDocsToDelta,\n  getPathTo\n} from './internals.js'\n\nconst glo = /** @type {any} */ (typeof globalThis !== 'undefined'\n  ? globalThis\n  : typeof window !== 'undefined'\n    ? window\n    // @ts-ignore\n    : typeof global !== 'undefined' ? global : {})\n\nconst importIdentifier = '__ $YJS14$ __'\n\nif (glo[importIdentifier] === true) {\n  /**\n   * Dear reader of this message. Please take this seriously.\n   *\n   * If you see this message, make sure that you only import one version of Yjs. In many cases,\n   * your package manager installs two versions of Yjs that are used by different packages within your project.\n   * Another reason for this message is that some parts of your project use the commonjs version of Yjs\n   * and others use the EcmaScript version of Yjs.\n   *\n   * This often leads to issues that are hard to debug. We often need to perform constructor checks,\n   * e.g. `struct instanceof GC`. If you imported different versions of Yjs, it is impossible for us to\n   * do the constructor checks anymore - which might break the CRDT algorithm.\n   *\n   * https://github.com/yjs/yjs/issues/438\n   */\n  console.error('Yjs was already imported. This breaks constructor checks and will lead to issues! - https://github.com/yjs/yjs/issues/438')\n}\nglo[importIdentifier] = true\n"],"names":[],"mappings":";;;;;;AAAA;;;AAiIA,MAAM,GAAG,uBAAuB,OAAO,UAAU,KAAK;AACtD,IAAI;AACJ,IAAI,OAAO,MAAM,KAAK;AACtB,MAAM;AACN;AACA,MAAM,OAAO,MAAM,KAAK,WAAW,GAAG,MAAM,GAAG,EAAE;;AAEjD,MAAM,gBAAgB,GAAG;;AAEzB,IAAI,GAAG,CAAC,gBAAgB,CAAC,KAAK,IAAI,EAAE;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,OAAO,CAAC,KAAK,CAAC,2HAA2H;AAC3I;AACA,GAAG,CAAC,gBAAgB,CAAC,GAAG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}
\ No newline at end of file
diff --git a/dist/internals.js b/dist/internals.js
index 175da42c84bc86420fcc9d3eb7b9d2272214eb6a..648be3843a4f825a066f50256e773ace7013f9a6 100644
--- a/dist/internals.js
+++ b/dist/internals.js
@@ -1,4 +1,4 @@
-export { ah as AbsolutePosition, bF as AbstractAttributionManager, A as AbstractConnector, d7 as AbstractContent, cy as AbstractStruct, bU as AbstractType, bP as ArraySearchMarker, bo as AttrRange, bq as AttrRanges, bE as AttributedContent, bl as AttributionItem, cN as ContentAny, cB as ContentBinary, cD as ContentDeleted, cF as ContentDoc, cH as ContentEmbed, cJ as ContentFormat, cL as ContentJSON, cP as ContentString, cZ as ContentType, z as DSDecoderV1, B as DSDecoderV2, bJ as DiffAttributionManager, D as Doc, a0 as EventHandler, cA as GC, a6 as ID, bt as IdMap, I as IdRange, a as IdRanges, b as IdSet, E as IdSetEncoderV1, G as IdSetEncoderV2, d4 as Item, cj as ItemTextListPosition, a_ as LazyStructReader, b3 as LazyStructWriter, M as MaybeIdRange, bH as NoAttributionsManager, ae as RelativePosition, d9 as Skip, ar as Snapshot, bL as SnapshotAttributionManager, aY as StackItem, bk as StructSet, aF as StructStore, aS as Transaction, bG as TwosetAttributionManager, aZ as UndoManager, U as UpdateDecoderV1, C as UpdateDecoderV2, F as UpdateEncoderV1, H as UpdateEncoderV2, cf as YArray, cS as YArrayRefID, bh as YEvent, ch as YMap, cT as YMapRefID, co as YText, cU as YTextRefID, cs as YXmlElement, cV as YXmlElementRefID, cq as YXmlFragment, cW as YXmlFragmentRefID, cu as YXmlHook, cX as YXmlHookRefID, cw as YXmlText, cY as YXmlTextRefID, r as _createInsertSliceFromStructs, _ as _deleteRangeFromIdSet, h as _diffSet, e as _insertIntoIdSet, k as _intersectSets, aV as addChangedTypeToTransaction, a2 as addEventHandlerListener, aJ as addStruct, o as addStructToIdSet, n as addToIdSet, Q as applyUpdate, P as applyUpdateV2, bC as attributionJsonSchema, a5 as callEventHandlerListeners, bT as callTypeObservers, cm as cleanupYTextAfterTransaction, cl as cleanupYTextFormatting, y as cloneDoc, a7 as compareIDs, aq as compareRelativePositions, d6 as contentRefs, bc as convertUpdateFormat, bf as convertUpdateFormatV1ToV2, bg as convertUpdateFormatV2ToV1, ai as createAbsolutePosition, ap as createAbsolutePositionFromRelativePosition, bD as createAttributionFromAttributionItems, bm as createAttributionItem, bK as createAttributionManagerFromDiff, bM as createAttributionManagerFromSnapshots, q as createDeleteSetFromStructStore, aC as createDocFromSnapshot, a1 as createEventHandler, a8 as createID, by as createIdMap, bs as createIdMapFromIdSet, p as createIdSet, s as createInsertSetFromStructStore, ce as createMapIterator, bp as createMaybeAttrRange, c as createMaybeIdRange, aj as createRelativePosition, ag as createRelativePositionFromJSON, ak as createRelativePositionFromTypeIndex, ax as createSnapshot, bx as decodeIdMap, ao as decodeRelativePosition, aw as decodeSnapshot, av as decodeSnapshotV2, W as decodeStateVector, b1 as decodeUpdate, b2 as decodeUpdateV2, cn as deleteText, bN as diffDocsToDelta, bA as diffIdMap, j as diffIdSet, bb as diffUpdate, ba as diffUpdateV2, ay as emptySnapshot, bv as encodeIdMap, am as encodeRelativePosition, au as encodeSnapshot, at as encodeSnapshotV2, T as encodeStateAsUpdate, S as encodeStateAsUpdateV2, $ as encodeStateVector, b6 as encodeStateVectorFromUpdate, b5 as encodeStateVectorFromUpdateV2, Z as encodeStateVectorV2, bV as equalAttrs, v as equalIdSets, as as equalSnapshots, aL as find, aN as findIndexCleanStart, f as findIndexInIdRanges, aK as findIndexSS, bQ as findMarker, d as findRangeStartInIdRanges, ab as findRootTypeKey, c$ as followRedone, x as generateNewClientId, aM as getItem, aP as getItemCleanEnd, aO as getItemCleanStart, aH as getState, aG as getStateVector, bS as getTypeChildren, bn as idmapAttrsEqual, bz as insertIntoIdMap, g as insertIntoIdSet, ck as insertText, aI as integrityCheck, bB as intersectMaps, l as intersectSets, ac as isParentOf, aA as isVisible, aR as iterateStructs, i as iterateStructsByIdSet, d0 as keepItem, ad as logType, a$ as logUpdate, b0 as logUpdateV2, br as mergeIdMaps, m as mergeIdSets, b4 as mergeUpdates, b9 as mergeUpdatesV2, aU as nextID, bI as noAttributionsManager, bd as obfuscateUpdate, be as obfuscateUpdateV2, u as readAndApplyDeleteSet, cO as readContentAny, cC as readContentBinary, cE as readContentDeleted, cG as readContentDoc, cI as readContentEmbed, cK as readContentFormat, cM as readContentJSON, cQ as readContentString, c_ as readContentType, aa as readID, bw as readIdMap, t as readIdSet, d5 as readItemContent, an as readRelativePosition, V as readStateVector, bi as readStructSet, O as readUpdate, b8 as readUpdateIdRanges, b7 as readUpdateIdRangesV2, N as readUpdateV2, cg as readYArray, ci as readYMap, cp as readYText, ct as readYXmlElement, cr as readYXmlFragment, cv as readYXmlHook, cx as readYXmlText, d3 as redoItem, af as relativePositionToJSON, a4 as removeAllEventHandlerListeners, a3 as removeEventHandlerListener, bj as removeRangesFromStructSet, aQ as replaceStruct, az as snapshot, aE as snapshotContainsUpdate, aD as snapshotContainsUpdateV2, d1 as splitItem, aB as splitSnapshotAffectedStructs, d2 as splitStruct, cz as structGCRefNumber, d8 as structSkipRefNumber, aX as transact, aW as tryGc, b$ as typeListCreateIterator, c5 as typeListDelete, bZ as typeListForEach, c0 as typeListForEachSnapshot, c1 as typeListGet, c3 as typeListInsertGenerics, c2 as typeListInsertGenericsAfter, b_ as typeListMap, c4 as typeListPushGenerics, bW as typeListSlice, bX as typeListToArray, bY as typeListToArraySnapshot, c6 as typeMapDelete, c8 as typeMapGet, c9 as typeMapGetAll, cd as typeMapGetAllSnapshot, ca as typeMapGetDelta, cc as typeMapGetSnapshot, cb as typeMapHas, c7 as typeMapSet, cR as typeRefs, bR as updateMarkerChanges, bO as warnPrematureAccess, J as writeClientsStructs, Y as writeDocumentStateVector, a9 as writeID, bu as writeIdMap, w as writeIdSet, al as writeRelativePosition, R as writeStateAsUpdate, X as writeStateVector, K as writeStructsFromIdSet, L as writeStructsFromTransaction, aT as writeUpdateMessageFromTransaction } from './Skip-CE05BUF8.js';
+export { ah as AbsolutePosition, bG as AbstractAttributionManager, A as AbstractConnector, d8 as AbstractContent, cz as AbstractStruct, bV as AbstractType, bQ as ArraySearchMarker, bp as AttrRange, br as AttrRanges, bF as AttributedContent, bm as AttributionItem, cO as ContentAny, cC as ContentBinary, cE as ContentDeleted, cG as ContentDoc, cI as ContentEmbed, cK as ContentFormat, cM as ContentJSON, cQ as ContentString, c_ as ContentType, z as DSDecoderV1, B as DSDecoderV2, bK as DiffAttributionManager, D as Doc, a0 as EventHandler, cB as GC, a6 as ID, bu as IdMap, I as IdRange, a as IdRanges, b as IdSet, E as IdSetEncoderV1, G as IdSetEncoderV2, d5 as Item, ck as ItemTextListPosition, a_ as LazyStructReader, b3 as LazyStructWriter, M as MaybeIdRange, bI as NoAttributionsManager, ae as RelativePosition, da as Skip, ar as Snapshot, bM as SnapshotAttributionManager, aY as StackItem, bl as StructSet, aF as StructStore, aS as Transaction, bH as TwosetAttributionManager, aZ as UndoManager, U as UpdateDecoderV1, C as UpdateDecoderV2, F as UpdateEncoderV1, H as UpdateEncoderV2, cg as YArray, cT as YArrayRefID, bh as YEvent, ci as YMap, cU as YMapRefID, cp as YText, cV as YTextRefID, ct as YXmlElement, cW as YXmlElementRefID, cr as YXmlFragment, cX as YXmlFragmentRefID, cv as YXmlHook, cY as YXmlHookRefID, cx as YXmlText, cZ as YXmlTextRefID, r as _createInsertSliceFromStructs, _ as _deleteRangeFromIdSet, h as _diffSet, e as _insertIntoIdSet, k as _intersectSets, aV as addChangedTypeToTransaction, a2 as addEventHandlerListener, aJ as addStruct, o as addStructToIdSet, n as addToIdSet, Q as applyUpdate, P as applyUpdateV2, bD as attributionJsonSchema, a5 as callEventHandlerListeners, bU as callTypeObservers, cn as cleanupYTextAfterTransaction, cm as cleanupYTextFormatting, y as cloneDoc, a7 as compareIDs, aq as compareRelativePositions, d7 as contentRefs, bc as convertUpdateFormat, bf as convertUpdateFormatV1ToV2, bg as convertUpdateFormatV2ToV1, ai as createAbsolutePosition, ap as createAbsolutePositionFromRelativePosition, bE as createAttributionFromAttributionItems, bn as createAttributionItem, bL as createAttributionManagerFromDiff, bN as createAttributionManagerFromSnapshots, q as createDeleteSetFromStructStore, aC as createDocFromSnapshot, a1 as createEventHandler, a8 as createID, bz as createIdMap, bt as createIdMapFromIdSet, p as createIdSet, s as createInsertSetFromStructStore, cf as createMapIterator, bq as createMaybeAttrRange, c as createMaybeIdRange, aj as createRelativePosition, ag as createRelativePositionFromJSON, ak as createRelativePositionFromTypeIndex, ax as createSnapshot, by as decodeIdMap, ao as decodeRelativePosition, aw as decodeSnapshot, av as decodeSnapshotV2, W as decodeStateVector, b1 as decodeUpdate, b2 as decodeUpdateV2, co as deleteText, bO as diffDocsToDelta, bB as diffIdMap, j as diffIdSet, bb as diffUpdate, ba as diffUpdateV2, ay as emptySnapshot, bw as encodeIdMap, am as encodeRelativePosition, au as encodeSnapshot, at as encodeSnapshotV2, T as encodeStateAsUpdate, S as encodeStateAsUpdateV2, $ as encodeStateVector, b6 as encodeStateVectorFromUpdate, b5 as encodeStateVectorFromUpdateV2, Z as encodeStateVectorV2, bW as equalAttrs, v as equalIdSets, as as equalSnapshots, aL as find, aN as findIndexCleanStart, f as findIndexInIdRanges, aK as findIndexSS, bR as findMarker, d as findRangeStartInIdRanges, ab as findRootTypeKey, d0 as followRedone, x as generateNewClientId, aM as getItem, aP as getItemCleanEnd, aO as getItemCleanStart, bi as getPathTo, aH as getState, aG as getStateVector, bT as getTypeChildren, bo as idmapAttrsEqual, bA as insertIntoIdMap, g as insertIntoIdSet, cl as insertText, aI as integrityCheck, bC as intersectMaps, l as intersectSets, ac as isParentOf, aA as isVisible, aR as iterateStructs, i as iterateStructsByIdSet, d1 as keepItem, ad as logType, a$ as logUpdate, b0 as logUpdateV2, bs as mergeIdMaps, m as mergeIdSets, b4 as mergeUpdates, b9 as mergeUpdatesV2, aU as nextID, bJ as noAttributionsManager, bd as obfuscateUpdate, be as obfuscateUpdateV2, u as readAndApplyDeleteSet, cP as readContentAny, cD as readContentBinary, cF as readContentDeleted, cH as readContentDoc, cJ as readContentEmbed, cL as readContentFormat, cN as readContentJSON, cR as readContentString, c$ as readContentType, aa as readID, bx as readIdMap, t as readIdSet, d6 as readItemContent, an as readRelativePosition, V as readStateVector, bj as readStructSet, O as readUpdate, b8 as readUpdateIdRanges, b7 as readUpdateIdRangesV2, N as readUpdateV2, ch as readYArray, cj as readYMap, cq as readYText, cu as readYXmlElement, cs as readYXmlFragment, cw as readYXmlHook, cy as readYXmlText, d4 as redoItem, af as relativePositionToJSON, a4 as removeAllEventHandlerListeners, a3 as removeEventHandlerListener, bk as removeRangesFromStructSet, aQ as replaceStruct, az as snapshot, aE as snapshotContainsUpdate, aD as snapshotContainsUpdateV2, d2 as splitItem, aB as splitSnapshotAffectedStructs, d3 as splitStruct, cA as structGCRefNumber, d9 as structSkipRefNumber, aX as transact, aW as tryGc, c0 as typeListCreateIterator, c6 as typeListDelete, b_ as typeListForEach, c1 as typeListForEachSnapshot, c2 as typeListGet, c4 as typeListInsertGenerics, c3 as typeListInsertGenericsAfter, b$ as typeListMap, c5 as typeListPushGenerics, bX as typeListSlice, bY as typeListToArray, bZ as typeListToArraySnapshot, c7 as typeMapDelete, c9 as typeMapGet, ca as typeMapGetAll, ce as typeMapGetAllSnapshot, cb as typeMapGetDelta, cd as typeMapGetSnapshot, cc as typeMapHas, c8 as typeMapSet, cS as typeRefs, bS as updateMarkerChanges, bP as warnPrematureAccess, J as writeClientsStructs, Y as writeDocumentStateVector, a9 as writeID, bv as writeIdMap, w as writeIdSet, al as writeRelativePosition, R as writeStateAsUpdate, X as writeStateVector, K as writeStructsFromIdSet, L as writeStructsFromTransaction, aT as writeUpdateMessageFromTransaction } from './Skip-gsWxt5h3.js';
 import 'lib0/observable';
 import 'lib0/array';
 import 'lib0/math';
diff --git a/dist/src/index.d.ts b/dist/src/index.d.ts
index 43cfd258a7517eeaf94de5937d440cf610503dcf..f68b63749854092db47cb49747b13f162aa94cb1 100644
--- a/dist/src/index.d.ts
+++ b/dist/src/index.d.ts
@@ -1,2 +1,2 @@
-export { Doc, Transaction, YArray as Array, YMap as Map, YText as Text, YXmlText as XmlText, YXmlHook as XmlHook, YXmlElement as XmlElement, YXmlFragment as XmlFragment, YEvent, Item, AbstractStruct, GC, Skip, ContentBinary, ContentDeleted, ContentDoc, ContentEmbed, ContentFormat, ContentJSON, ContentAny, ContentString, ContentType, AbstractType, getTypeChildren, createRelativePositionFromTypeIndex, createRelativePositionFromJSON, createAbsolutePositionFromRelativePosition, compareRelativePositions, AbsolutePosition, RelativePosition, ID, createID, compareIDs, getState, Snapshot, createSnapshot, cleanupYTextFormatting, snapshot, emptySnapshot, findRootTypeKey, findIndexSS, getItem, getItemCleanStart, getItemCleanEnd, typeListToArraySnapshot, typeMapGetSnapshot, typeMapGetAllSnapshot, createDocFromSnapshot, applyUpdate, applyUpdateV2, readUpdate, readUpdateV2, encodeStateAsUpdate, encodeStateAsUpdateV2, encodeStateVector, UndoManager, decodeSnapshot, encodeSnapshot, decodeSnapshotV2, encodeSnapshotV2, decodeStateVector, logUpdate, logUpdateV2, decodeUpdate, decodeUpdateV2, relativePositionToJSON, isParentOf, equalSnapshots, tryGc, transact, AbstractConnector, logType, mergeUpdates, mergeUpdatesV2, encodeStateVectorFromUpdate, encodeStateVectorFromUpdateV2, encodeRelativePosition, decodeRelativePosition, diffUpdate, diffUpdateV2, convertUpdateFormatV1ToV2, convertUpdateFormatV2ToV1, obfuscateUpdate, obfuscateUpdateV2, UpdateEncoderV1, UpdateEncoderV2, UpdateDecoderV1, UpdateDecoderV2, snapshotContainsUpdate, IdSet, equalIdSets, createDeleteSetFromStructStore, IdMap, createIdMap, createAttributionItem, createInsertSetFromStructStore as createInsertionSetFromStructStore, diffIdMap, diffIdSet, AttributionItem as Attribution, encodeIdMap, createIdMapFromIdSet, TwosetAttributionManager, noAttributionsManager, AbstractAttributionManager, iterateStructsByIdSet, createAttributionManagerFromDiff, DiffAttributionManager, createIdSet, mergeIdSets, cloneDoc, readUpdateIdRanges, readUpdateIdRangesV2, insertIntoIdMap, insertIntoIdSet, mergeIdMaps, readIdMap, readIdSet, decodeIdMap, diffDocsToDelta } from "./internals.js";
+export { Doc, Transaction, YArray as Array, YMap as Map, YText as Text, YXmlText as XmlText, YXmlHook as XmlHook, YXmlElement as XmlElement, YXmlFragment as XmlFragment, YEvent, Item, AbstractStruct, GC, Skip, ContentBinary, ContentDeleted, ContentDoc, ContentEmbed, ContentFormat, ContentJSON, ContentAny, ContentString, ContentType, AbstractType, getTypeChildren, createRelativePositionFromTypeIndex, createRelativePositionFromJSON, createAbsolutePositionFromRelativePosition, compareRelativePositions, AbsolutePosition, RelativePosition, ID, createID, compareIDs, getState, Snapshot, createSnapshot, cleanupYTextFormatting, snapshot, emptySnapshot, findRootTypeKey, findIndexSS, getItem, getItemCleanStart, getItemCleanEnd, typeListToArraySnapshot, typeMapGetSnapshot, typeMapGetAllSnapshot, createDocFromSnapshot, applyUpdate, applyUpdateV2, readUpdate, readUpdateV2, encodeStateAsUpdate, encodeStateAsUpdateV2, encodeStateVector, UndoManager, decodeSnapshot, encodeSnapshot, decodeSnapshotV2, encodeSnapshotV2, decodeStateVector, logUpdate, logUpdateV2, decodeUpdate, decodeUpdateV2, relativePositionToJSON, isParentOf, equalSnapshots, tryGc, transact, AbstractConnector, logType, mergeUpdates, mergeUpdatesV2, encodeStateVectorFromUpdate, encodeStateVectorFromUpdateV2, encodeRelativePosition, decodeRelativePosition, diffUpdate, diffUpdateV2, convertUpdateFormatV1ToV2, convertUpdateFormatV2ToV1, obfuscateUpdate, obfuscateUpdateV2, UpdateEncoderV1, UpdateEncoderV2, UpdateDecoderV1, UpdateDecoderV2, snapshotContainsUpdate, IdSet, equalIdSets, createDeleteSetFromStructStore, IdMap, createIdMap, createAttributionItem, createInsertSetFromStructStore as createInsertionSetFromStructStore, diffIdMap, diffIdSet, AttributionItem as Attribution, encodeIdMap, createIdMapFromIdSet, TwosetAttributionManager, noAttributionsManager, AbstractAttributionManager, iterateStructsByIdSet, createAttributionManagerFromDiff, DiffAttributionManager, createAttributionManagerFromSnapshots, SnapshotAttributionManager, createIdSet, mergeIdSets, cloneDoc, readUpdateIdRanges, readUpdateIdRangesV2, insertIntoIdMap, insertIntoIdSet, mergeIdMaps, readIdMap, readIdSet, decodeIdMap, diffDocsToDelta, getPathTo } from "./internals.js";
 //# sourceMappingURL=index.d.ts.map
\ No newline at end of file
diff --git a/dist/src/types/AbstractType.d.ts.map b/dist/src/types/AbstractType.d.ts.map
index a6cfbfdfc8827463ffcb79ac569eac2612b60c57..58afb9814c74638048c42f56871790d3384adebb 100644
--- a/dist/src/types/AbstractType.d.ts.map
+++ b/dist/src/types/AbstractType.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"AbstractType.d.ts","sourceRoot":"","sources":["../../../src/types/AbstractType.js"],"names":[],"mappings":"AA4CO,4CAAiH;AAaxH;IACE;;;OAGG;IACH,eAHW,IAAI,SACJ,MAAM,EAOhB;IAHC,QAAU;IACV,cAAkB;IAClB,kBAA8C;CAEjD;AAqDM,mCAHI,OAAO,mBAAmB,EAAE,KAAK,SACjC,MAAM,4BAyEhB;AAWM,kDAJI,KAAK,CAAC,iBAAiB,CAAC,SACxB,MAAM,OACN,MAAM,QAiChB;AAQM,mCAHI,OAAO,mBAAmB,EAAE,KAAK,GAChC,KAAK,CAAC,IAAI,CAAC,CAWtB;AAUM,wCAJI,OAAO,mBAAmB,EAAE,KAAK,eACjC,WAAW,SACV,MAAM,CAAC,GAAG,CAAC,QActB;AAED;;;;GAIG;AACH,0BAHiD,UAAU,SAA7C,KAAK,CAAC,KAAK,CAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,CAAE,QACT,IAAI,SAA5B,YAAY,CAAC,GAAG,EAAC,GAAG,CAAE;IAIhC;;OAEG;IACH,OAFU,IAAI,GAAC,IAAI,CAEF;IACjB;;OAEG;IACH,MAFU,GAAG,CAAC,MAAM,EAAC,IAAI,CAAC,CAEL;IACrB;;OAEG;IACH,QAFU,IAAI,GAAC,IAAI,CAED;IAClB;;OAEG;IACH,KAFU,GAAG,GAAC,IAAI,CAEH;IACf,gBAAgB;IAChB;;;OAGG;IACH,KAFU,YAAY,CAAC,MAAM,CAAC,IAAI,CAAC,EAAC,WAAW,CAAC,CAEjB;IAC/B;;;OAGG;IACH,MAFU,YAAY,CAAC,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,EAAC,WAAW,CAAC,CAEtB;IAChC;;OAEG;IACH,eAFU,IAAI,GAAG,KAAK,CAAC,iBAAiB,CAAC,CAEhB;IACzB;;OAEG;IACH,SAFU,UAAU,OAAC,CAEF;IAGrB;;;OAGG;IACH,cAFU,UAAU,CAInB;IAED;;OAEG;IACH,cAFY,OAAO,mBAAmB,EAAE,KAAK,GAAC,IAAI,CAIjD;IAED;;;;;;;;;OASG;IACH,cAHW,GAAG,QACH,IAAI,GAAC,IAAI,QASnB;IAED;;OAEG;IACH,SAFY,IAAI,CAKf;IAED;;;;;;OAMG;IACH,SAFY,IAAI,CAKf;IAED;;OAEG;IACH,iBAFW,eAAe,GAAG,eAAe,QAEvB;IAErB;;OAEG;IACH,0BAMC;IAED;;;;;;OAMG;IACH,2BAHW,WAAW,cACX,GAAG,CAAC,IAAI,GAAC,MAAM,CAAC,QAQ1B;IAED;;;;;;OAMG;IACH,QAJ+D,CAAC,SAAnD,CAAE,MAAM,EAAE,MAAM,CAAC,IAAI,CAAC,EAAE,EAAE,EAAE,WAAW,KAAK,IAAK,KACnD,CAAC,GACA,CAAC,CAKZ;IAED;;;;;;OAMG;IACH,YAJ6D,CAAC,SAAjD,CAAU,IAAkB,EAAlB,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,EAAC,IAAW,EAAX,WAAW,KAAE,IAAK,KACjD,CAAC,GACA,CAAC,CAKZ;IAED;;;;OAIG;IACH,aAFW,CAAC,IAAI,EAAC,MAAM,CAAC,IAAI,CAAC,EAAC,EAAE,EAAC,WAAW,KAAG,IAAI,QAIlD;IAED;;;;OAIG;IACH,iBAFW,CAAS,IAAkB,EAAlB,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,EAAC,IAAW,EAAX,WAAW,KAAE,IAAI,QAIvD;IAED;;;OAGG;IACH,UAFY,GAAG,CAEH;IAEZ;;;;;;;;;;;;;;;;;;;;OAoBG;IACH,kBAdwB,IAAI,SAAf,OAAS,eAEX,0BAA0B,SAElC;QAAkD,aAAa;QACxC,aAAa;QACb,aAAa;QACc,YAAY;QACc,QAAQ;QAChE,IAAI;KACxB,GAAS,IAAI,SAAS,IAAI,GAAG,gBAAgB,CAAC,UAAU,CAAC,GAAG,UAAU,CA2NxE;IAED;;;;;;OAMG;IACH,oBAHW,0BAA0B,GACzB,gBAAgB,CAAC,UAAU,CAAC,CAIvC;IAED;;;;;;;OAOG;IACH,qBALW,KAAK,CAAC,KAAK,CAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,CAAC,OAChC,0BAA0B,QAsDpC;CACF;AAOM,8BAJI,GAAG,KACH,GAAG,GACF,OAAO,CAEgH;AA6B5H,oCARI,YAAY,CAAC,GAAG,CAAC,SACjB,MAAM,OACN,MAAM,GACL,KAAK,CAAC,GAAG,CAAC,CAgCrB;AASM,sCANI,OAAO,mBAAmB,EAAE,KAAK,GAChC,KAAK,CAAC,GAAG,CAAC,CAmBrB;AAUM,8CAPI,YAAY,CAAC,GAAG,CAAC,YACjB,QAAQ,GACP,KAAK,CAAC,GAAG,CAAC,CAkBrB;AAWM,sCANI,YAAY,CAAC,GAAG,CAAC,KACjB,CAAS,IAAG,EAAH,GAAG,EAAC,IAAM,EAAN,MAAM,EAAC,IAAG,EAAH,GAAG,KAAE,IAAI,QAkBvC;AAWM,4BARM,CAAC,EAAC,CAAC,QACL,YAAY,CAAC,GAAG,CAAC,KACjB,CAAS,IAAC,EAAD,CAAC,EAAC,IAAM,EAAN,MAAM,EAAC,IAAiB,EAAjB,YAAY,CAAC,GAAG,CAAC,KAAE,CAAC,GACrC,KAAK,CAAC,CAAC,CAAC,CAcnB;AASM,6CANI,YAAY,GACX,gBAAgB,CAAC,GAAG,CAAC,CA6ChC;AAaM,8CAPI,YAAY,KACZ,CAAS,IAAG,EAAH,GAAG,EAAC,IAAM,EAAN,MAAM,EAAC,IAAY,EAAZ,YAAY,KAAE,IAAI,YACtC,QAAQ,QAiBlB;AAUM,kCAPI,OAAO,mBAAmB,EAAE,KAAK,SACjC,MAAM,GACL,GAAG,CAqBd;AAWM,yDARI,WAAW,UACX,MAAM,iBACN,IAAI,OAAC,WACL,KAAK,CAAC,OAAO,CAAC,QA6DxB;AAaM,oDARI,WAAW,UACX,MAAM,SACN,MAAM,WACN,KAAK,CAAC;QAAO,MAAM,GAAC,GAAG;CAAC,GAAC,KAAK,CAAC,GAAG,CAAC,GAAC,MAAM,GAAC,IAAI,GAAC,MAAM,GAAC,UAAU,CAAC,QA4C5E;AAaM,kDAPI,WAAW,UACX,MAAM,WACN,KAAK,CAAC;QAAO,MAAM,GAAC,GAAG;CAAC,GAAC,KAAK,CAAC,GAAG,CAAC,GAAC,MAAM,GAAC,IAAI,GAAC,MAAM,GAAC,UAAU,CAAC,QAe5E;AAWM,4CARI,WAAW,UACX,OAAO,mBAAmB,EAAE,KAAK,SACjC,MAAM,UACN,MAAM,QAyChB;AAUM,2CAPI,WAAW,UACX,MAAM,OACN,MAAM,QAUhB;AAWM,wCARI,WAAW,UACX,YAAY,OACZ,MAAM,SACN,OAAO,QAsCjB;AAUM,mCAPI,YAAY,CAAC,GAAG,EAAC,GAAG,CAAC,OACrB,MAAM,GACL;QAAO,MAAM,GAAC,GAAG;CAAC,GAAC,MAAM,GAAC,IAAI,GAAC,KAAK,CAAC,GAAG,CAAC,GAAC,MAAM,GAAC,UAAU,GAAC,YAAY,CAAC,GAAG,CAAC,GAAC,SAAS,CASlG;AASM,sCANI,YAAY,CAAC,GAAG,CAAC;;;;EAkB3B;AA0BM,gCAf4C,SAAS,SAA9C,KAAK,CAAC,YAAY,CAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,CAAE,KACvC,SAAS,UACT,MAAM,iBACN,GAAG,CAAC,MAAM,GAAC,IAAI,CAAC,OAAC,MACjB,OAAO,iBAAiB,EAAE,0BAA0B,QACpD,OAAO,aACP,GAAG,CAAC,OAAO,mBAAmB,EAAE,KAAK,CAAC,GAAC,GAAG,CAAC,OAAO,mBAAmB,EAAE,KAAK,EAAC,GAAG,CAAC,GAAC,IAAI,iBACtF,OAAO,mBAAmB,EAAE,KAAK,OAAC,kBAClC,OAAO,mBAAmB,EAAE,KAAK,OAAC,SAClC,GAAG,YACH,GAAG,QA6Cb;AAUM,mCAPI,YAAY,CAAC,GAAG,CAAC,OACjB,MAAM,GACL,OAAO,CASlB;AAWM,2CARI,YAAY,CAAC,GAAG,CAAC,OACjB,MAAM,YACN,QAAQ,GACP;QAAO,MAAM,GAAC,GAAG;CAAC,GAAC,MAAM,GAAC,IAAI,GAAC,KAAK,CAAC,GAAG,CAAC,GAAC,MAAM,GAAC,UAAU,GAAC,YAAY,CAAC,GAAG,CAAC,GAAC,SAAS,CAWlG;AAUM,8CAPI,YAAY,CAAC,GAAG,CAAC,YACjB,QAAQ;;;;EAwBlB;AASM,wCANI,YAAY,CAAC,GAAG,CAAC,GAAG;IAAE,IAAI,EAAE,GAAG,CAAC,MAAM,EAAE,IAAI,CAAC,CAAA;CAAE,GAC9C,gBAAgB,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAQvC;qBAt3CY,OAAO,mBAAmB,EAAE,KAAK;sBAGjC,OAAO,mBAAmB,EAAE,MAAM;6BA4tBC,CAAC,SAAnC,KAAK,CAAC,KAAK,CAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,CAAE,IAClC,CAAC,SAAS,KAAK,CAAC,KAAK,CAAC,MAAM,CAAC,EAAC,MAAM,KAAK,EAAC,MAAM,EAAE,EAAC,MAAM,IAAI,EAAC,GAAG,CAAC,GACxE,KAAK,CAAC,KAAK,CACT,CAAC,EACT,GAAW,CAAC,IAAI,MAAM,KAAK,GAAG,WAAW,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,GAAE,EAC7C,WAAW,CAAC,EAAE,CAAC,EACf,IAAI,CACL,GACD,CAAC;wBAKW,CAAC,oBACP,CAAC,OAAO,CAAC,CAAC,EAAC,YAAY,CAAC,GAAG,CAAC,CAAC,SAAS,YAAY,CAAC,MAAM,CAAC,CAAC,GAAG,CAAC,OAAO,SAAS,CAAC,GAAG,KAAK,GAAG,gBAAgB,CAAC,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC,GAAG,OAAO,CAAC,CAAC,EAAC,YAAY,CAAC,GAAG,CAAC,CAAC;qBAzvB7J,iBAAiB;4BAAjB,iBAAiB;uBAAjB,iBAAiB;uBAED,YAAY;oBAF5B,iBAAiB;6BAAjB,iBAAiB;gCAAjB,iBAAiB;gCAAjB,iBAAiB;2CAAjB,iBAAiB;yBAAjB,iBAAiB"}
\ No newline at end of file
+{"version":3,"file":"AbstractType.d.ts","sourceRoot":"","sources":["../../../src/types/AbstractType.js"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/src/utils/AttributionManager.d.ts b/dist/src/utils/AttributionManager.d.ts
index 55e391948d156f8c9d3c1738b3348934de753bea..341d3e08b1c5c1eafb8685a03e755cecd8b04009 100644
--- a/dist/src/utils/AttributionManager.d.ts
+++ b/dist/src/utils/AttributionManager.d.ts
@@ -152,6 +152,8 @@ export class DiffAttributionManager extends ObservableV2<{
      */
     suggestionOrigins: Array<any> | null;
     _destroyHandler: (arg0: Doc) => void;
+    acceptAllChanges(): void;
+    rejectAllChanges(): void;
     /**
      * @param {ID} start
      * @param {ID} end
diff --git a/dist/src/utils/AttributionManager.d.ts.map b/dist/src/utils/AttributionManager.d.ts.map
index 908a1236df3999841df2e33cec26907e136d89b1..6db07a8158ce0aab2ee427b9369bc041cf3303cb 100644
--- a/dist/src/utils/AttributionManager.d.ts.map
+++ b/dist/src/utils/AttributionManager.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"AttributionManager.d.ts","sourceRoot":"","sources":["../../../src/utils/AttributionManager.js"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"AttributionManager.d.ts","sourceRoot":"","sources":["../../../src/utils/AttributionManager.js"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/src/utils/YEvent.d.ts b/dist/src/utils/YEvent.d.ts
index 8203d8db75ab8426f1aefc708b9a3b6106c74db6..8ead45d5701569aac5419880fc259f4955eeec98 100644
--- a/dist/src/utils/YEvent.d.ts
+++ b/dist/src/utils/YEvent.d.ts
@@ -111,6 +111,7 @@ export class YEvent<Target extends AbstractType<any, any>> {
      */
     public get deltaDeep(): Target extends AbstractType<infer D, any> ? D : delta.Delta<any, any, any, any, any>;
 }
+export function getPathTo(parent: _YType, child: _YType, am?: AbstractAttributionManager): Array<string | number>;
 export type _YType = import("./types.js").YType;
 import { AbstractType } from '../internals.js';
 import { Transaction } from '../internals.js';
diff --git a/dist/src/utils/YEvent.d.ts.map b/dist/src/utils/YEvent.d.ts.map
index bd0f3086856cde99fbd743edc9b524ef11ef7fc6..1f7bc97f4851ed6b435007a48f97c307dc7e4d50 100644
--- a/dist/src/utils/YEvent.d.ts.map
+++ b/dist/src/utils/YEvent.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"YEvent.d.ts","sourceRoot":"","sources":["../../../src/utils/YEvent.js"],"names":[],"mappings":"AAWA;;GAEG;AAEH;;;GAGG;AACH,oBAHqC,MAAM,SAA7B,YAAY,CAAC,GAAG,EAAC,GAAG,CAAE;IAIlC;;;;OAIG;IACH,oBAJW,MAAM,eACN,WAAW,QACX,GAAG,CAAC,GAAG,CAAC,OAAC,EAgDnB;IA7CC;;;OAGG;IACH,QAFU,MAAM,CAEI;IACpB;;;OAGG;IACH,eAFU,MAAM,CAEW;IAC3B;;;OAGG;IACH,aAFU,WAAW,CAES;IAC9B;;OAEG;IACH,QAFU,CAAC,MAAM,SAAS,YAAY,CAAC,MAAM,CAAC,EAAC,GAAG,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC,KAAK,CAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,CAAC,CAAC,GAAC,IAAI,CAE9E;IAClB;;OAEG;IACH,YAFU,CAAC,MAAM,SAAS,YAAY,CAAC,MAAM,CAAC,EAAC,GAAG,CAAC,GAAG,OAAO,iBAAiB,EAAE,gBAAgB,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC,KAAK,CAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,CAAC,CAAC,GAAC,IAAI,CAEtH;IACtB;;OAEG;IACH,OAFU,KAAK,CAAC,MAAM,GAAC,MAAM,CAAC,GAAC,IAAI,CAElB;IACjB;;;;OAIG;IACH,yBAA6B;IAC7B;;;OAGG;IACH,aAFU,GAAG,CAAC,MAAM,CAAC,CAEO;IAU9B;;;;;;;;;;;;OAYG;IACH,gCAEC;IAED;;;;;;;OAOG;IACH,gBAHW,cAAc,GACb,OAAO,CAIlB;IAED;;;;;;;OAOG;IACH,aAHW,cAAc,GACb,OAAO,CAIlB;IAED;;;;;;;;OAQG;IACH,gBARwB,IAAI,SAAf,OAAS,eACX,0BAA0B,aAElC;QAAoB,IAAI;KACxB,GAAS,MAAM,SAAS,YAAY,CAAC,MAAM,CAAC,EAAC,GAAG,CAAC,GAAG,CAAC,IAAI,SAAS,IAAI,GAAG,OAAO,iBAAiB,EAAE,gBAAgB,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,KAAK,CAAC,KAAK,CAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,CAAC,CAiC5J;IAED;;;;;;OAMG;IACH,oBAHU,MAAM,SAAS,YAAY,CAAC,MAAM,CAAC,EAAC,GAAG,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC,KAAK,CAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,CAAC,CAKxF;IAED;;;;;;OAMG;IACH,wBAHU,MAAM,SAAS,YAAY,CAAC,MAAM,CAAC,EAAC,GAAG,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC,KAAK,CAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,CAAC,CAKxF;CACF;qBAnKY,OAAO,YAAY,EAAE,KAAK;6BAPhC,iBAAiB;4BAAjB,iBAAiB;uBAGD,YAAY;+BAH5B,iBAAiB;2CAAjB,iBAAiB"}
\ No newline at end of file
+{"version":3,"file":"YEvent.d.ts","sourceRoot":"","sources":["../../../src/utils/YEvent.js"],"names":[],"mappings":"AAcA;;GAEG;AAEH;;;GAGG;AACH,oBAHqC,MAAM,SAA7B,YAAY,CAAC,GAAG,EAAC,GAAG,CAAE;IAIlC;;;;OAIG;IACH,oBAJW,MAAM,eACN,WAAW,QACX,GAAG,CAAC,GAAG,CAAC,OAAC,EAgDnB;IA7CC;;;OAGG;IACH,QAFU,MAAM,CAEI;IACpB;;;OAGG;IACH,eAFU,MAAM,CAEW;IAC3B;;;OAGG;IACH,aAFU,WAAW,CAES;IAC9B;;OAEG;IACH,QAFU,CAAC,MAAM,SAAS,YAAY,CAAC,MAAM,CAAC,EAAC,GAAG,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC,KAAK,CAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,CAAC,CAAC,GAAC,IAAI,CAE9E;IAClB;;OAEG;IACH,YAFU,CAAC,MAAM,SAAS,YAAY,CAAC,MAAM,CAAC,EAAC,GAAG,CAAC,GAAG,OAAO,iBAAiB,EAAE,gBAAgB,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC,KAAK,CAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,CAAC,CAAC,GAAC,IAAI,CAEtH;IACtB;;OAEG;IACH,OAFU,KAAK,CAAC,MAAM,GAAC,MAAM,CAAC,GAAC,IAAI,CAElB;IACjB;;;;OAIG;IACH,yBAA6B;IAC7B;;;OAGG;IACH,aAFU,GAAG,CAAC,MAAM,CAAC,CAEO;IAU9B;;;;;;;;;;;;OAYG;IACH,gCAEC;IAED;;;;;;;OAOG;IACH,gBAHW,cAAc,GACb,OAAO,CAIlB;IAED;;;;;;;OAOG;IACH,aAHW,cAAc,GACb,OAAO,CAIlB;IAED;;;;;;;;OAQG;IACH,gBARwB,IAAI,SAAf,OAAS,eACX,0BAA0B,aAElC;QAAoB,IAAI;KACxB,GAAS,MAAM,SAAS,YAAY,CAAC,MAAM,CAAC,EAAC,GAAG,CAAC,GAAG,CAAC,IAAI,SAAS,IAAI,GAAG,OAAO,iBAAiB,EAAE,gBAAgB,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,KAAK,CAAC,KAAK,CAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,CAAC,CAiC5J;IAED;;;;;;OAMG;IACH,oBAHU,MAAM,SAAS,YAAY,CAAC,MAAM,CAAC,EAAC,GAAG,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC,KAAK,CAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,CAAC,CAKxF;IAED;;;;;;OAMG;IACH,wBAHU,MAAM,SAAS,YAAY,CAAC,MAAM,CAAC,EAAC,GAAG,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC,KAAK,CAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,CAAC,CAKxF;CACF;AAoBM,kCARI,MAAM,SACN,MAAM,OACN,0BAA0B,GACzB,KAAK,CAAC,MAAM,GAAC,MAAM,CAAC,CAqB/B;qBAvMY,OAAO,YAAY,EAAE,KAAK;6BAPhC,iBAAiB;4BAAjB,iBAAiB;uBAGD,YAAY;+BAH5B,iBAAiB;2CAAjB,iBAAiB"}
\ No newline at end of file
diff --git a/dist/testHelper.js b/dist/testHelper.js
index 8d5f0db7131b99420806c0669795c99fc83648d8..ce30c3dacf6e64cba875d662ce219108ed049de0 100644
--- a/dist/testHelper.js
+++ b/dist/testHelper.js
@@ -5,12 +5,12 @@ import * as decoding from 'lib0/decoding';
 import * as syncProtocol from '@y/protocols/sync';
 import * as object from 'lib0/object';
 import * as map from 'lib0/map';
-import { Y } from './index-C21sDQ5u.js';
+import { Y } from './index-BextecLz.js';
 import * as math from 'lib0/math';
 import * as list from 'lib0/list';
 import * as delta from 'lib0/delta';
-import { bb as diffUpdate, a$ as logUpdate, Q as applyUpdate, b4 as mergeUpdates, T as encodeStateAsUpdate, ba as diffUpdateV2, b0 as logUpdateV2, P as applyUpdateV2, b9 as mergeUpdatesV2, S as encodeStateAsUpdateV2, a7 as compareIDs, D as Doc, cs as YXmlElement, by as createIdMap, n as addToIdSet, p as createIdSet, bm as createAttributionItem, bv as encodeIdMap, bU as AbstractType, $ as encodeStateVector, v as equalIdSets, q as createDeleteSetFromStructStore, au as encodeSnapshot, az as snapshot, d4 as Item } from './Skip-CE05BUF8.js';
-export { ah as AbsolutePosition, bF as AbstractAttributionManager, A as AbstractConnector, cy as AbstractStruct, cf as Array, bl as Attribution, cN as ContentAny, cB as ContentBinary, cD as ContentDeleted, cF as ContentDoc, cH as ContentEmbed, cJ as ContentFormat, cL as ContentJSON, cP as ContentString, cZ as ContentType, bJ as DiffAttributionManager, cA as GC, a6 as ID, bt as IdMap, b as IdSet, ch as Map, ae as RelativePosition, d9 as Skip, ar as Snapshot, co as Text, aS as Transaction, bG as TwosetAttributionManager, aZ as UndoManager, U as UpdateDecoderV1, C as UpdateDecoderV2, F as UpdateEncoderV1, H as UpdateEncoderV2, cq as XmlFragment, cu as XmlHook, cw as XmlText, bh as YEvent, cl as cleanupYTextFormatting, y as cloneDoc, aq as compareRelativePositions, bf as convertUpdateFormatV1ToV2, bg as convertUpdateFormatV2ToV1, ap as createAbsolutePositionFromRelativePosition, bK as createAttributionManagerFromDiff, aC as createDocFromSnapshot, a8 as createID, bs as createIdMapFromIdSet, s as createInsertionSetFromStructStore, ag as createRelativePositionFromJSON, ak as createRelativePositionFromTypeIndex, ax as createSnapshot, bx as decodeIdMap, ao as decodeRelativePosition, aw as decodeSnapshot, av as decodeSnapshotV2, W as decodeStateVector, b1 as decodeUpdate, b2 as decodeUpdateV2, bN as diffDocsToDelta, bA as diffIdMap, j as diffIdSet, ay as emptySnapshot, am as encodeRelativePosition, at as encodeSnapshotV2, b6 as encodeStateVectorFromUpdate, b5 as encodeStateVectorFromUpdateV2, as as equalSnapshots, aK as findIndexSS, ab as findRootTypeKey, aM as getItem, aP as getItemCleanEnd, aO as getItemCleanStart, aH as getState, bS as getTypeChildren, bz as insertIntoIdMap, g as insertIntoIdSet, ac as isParentOf, i as iterateStructsByIdSet, ad as logType, br as mergeIdMaps, m as mergeIdSets, bI as noAttributionsManager, bd as obfuscateUpdate, be as obfuscateUpdateV2, bw as readIdMap, t as readIdSet, O as readUpdate, b8 as readUpdateIdRanges, b7 as readUpdateIdRangesV2, N as readUpdateV2, af as relativePositionToJSON, aE as snapshotContainsUpdate, aX as transact, aW as tryGc, bY as typeListToArraySnapshot, cd as typeMapGetAllSnapshot, cc as typeMapGetSnapshot } from './Skip-CE05BUF8.js';
+import { bb as diffUpdate, a$ as logUpdate, Q as applyUpdate, b4 as mergeUpdates, T as encodeStateAsUpdate, ba as diffUpdateV2, b0 as logUpdateV2, P as applyUpdateV2, b9 as mergeUpdatesV2, S as encodeStateAsUpdateV2, a7 as compareIDs, D as Doc, ct as YXmlElement, bz as createIdMap, n as addToIdSet, p as createIdSet, bn as createAttributionItem, bw as encodeIdMap, bV as AbstractType, $ as encodeStateVector, v as equalIdSets, q as createDeleteSetFromStructStore, au as encodeSnapshot, az as snapshot, d5 as Item } from './Skip-gsWxt5h3.js';
+export { ah as AbsolutePosition, bG as AbstractAttributionManager, A as AbstractConnector, cz as AbstractStruct, cg as Array, bm as Attribution, cO as ContentAny, cC as ContentBinary, cE as ContentDeleted, cG as ContentDoc, cI as ContentEmbed, cK as ContentFormat, cM as ContentJSON, cQ as ContentString, c_ as ContentType, bK as DiffAttributionManager, cB as GC, a6 as ID, bu as IdMap, b as IdSet, ci as Map, ae as RelativePosition, da as Skip, ar as Snapshot, bM as SnapshotAttributionManager, cp as Text, aS as Transaction, bH as TwosetAttributionManager, aZ as UndoManager, U as UpdateDecoderV1, C as UpdateDecoderV2, F as UpdateEncoderV1, H as UpdateEncoderV2, cr as XmlFragment, cv as XmlHook, cx as XmlText, bh as YEvent, cm as cleanupYTextFormatting, y as cloneDoc, aq as compareRelativePositions, bf as convertUpdateFormatV1ToV2, bg as convertUpdateFormatV2ToV1, ap as createAbsolutePositionFromRelativePosition, bL as createAttributionManagerFromDiff, bN as createAttributionManagerFromSnapshots, aC as createDocFromSnapshot, a8 as createID, bt as createIdMapFromIdSet, s as createInsertionSetFromStructStore, ag as createRelativePositionFromJSON, ak as createRelativePositionFromTypeIndex, ax as createSnapshot, by as decodeIdMap, ao as decodeRelativePosition, aw as decodeSnapshot, av as decodeSnapshotV2, W as decodeStateVector, b1 as decodeUpdate, b2 as decodeUpdateV2, bO as diffDocsToDelta, bB as diffIdMap, j as diffIdSet, ay as emptySnapshot, am as encodeRelativePosition, at as encodeSnapshotV2, b6 as encodeStateVectorFromUpdate, b5 as encodeStateVectorFromUpdateV2, as as equalSnapshots, aK as findIndexSS, ab as findRootTypeKey, aM as getItem, aP as getItemCleanEnd, aO as getItemCleanStart, bi as getPathTo, aH as getState, bT as getTypeChildren, bA as insertIntoIdMap, g as insertIntoIdSet, ac as isParentOf, i as iterateStructsByIdSet, ad as logType, bs as mergeIdMaps, m as mergeIdSets, bJ as noAttributionsManager, bd as obfuscateUpdate, be as obfuscateUpdateV2, bx as readIdMap, t as readIdSet, O as readUpdate, b8 as readUpdateIdRanges, b7 as readUpdateIdRangesV2, N as readUpdateV2, af as relativePositionToJSON, aE as snapshotContainsUpdate, aX as transact, aW as tryGc, bZ as typeListToArraySnapshot, ce as typeMapGetAllSnapshot, cd as typeMapGetSnapshot } from './Skip-gsWxt5h3.js';
 import 'lib0/function';
 import 'lib0/binary';
 import 'lib0/observable';
diff --git a/dist/yjs.js b/dist/yjs.js
index b8d1a09c2c4b289bb049e2fb73c6cc1ca4a284be..399f4876999639ddf19854b37a49aa874e68bd81 100644
--- a/dist/yjs.js
+++ b/dist/yjs.js
@@ -1,9 +1,9 @@
-export { ah as AbsolutePosition, bF as AbstractAttributionManager, A as AbstractConnector, cy as AbstractStruct, bU as AbstractType, cf as Array, bl as Attribution, cN as ContentAny, cB as ContentBinary, cD as ContentDeleted, cF as ContentDoc, cH as ContentEmbed, cJ as ContentFormat, cL as ContentJSON, cP as ContentString, cZ as ContentType, bJ as DiffAttributionManager, D as Doc, cA as GC, a6 as ID, bt as IdMap, b as IdSet, d4 as Item, ch as Map, ae as RelativePosition, d9 as Skip, ar as Snapshot, co as Text, aS as Transaction, bG as TwosetAttributionManager, aZ as UndoManager, U as UpdateDecoderV1, C as UpdateDecoderV2, F as UpdateEncoderV1, H as UpdateEncoderV2, cs as XmlElement, cq as XmlFragment, cu as XmlHook, cw as XmlText, bh as YEvent, Q as applyUpdate, P as applyUpdateV2, cl as cleanupYTextFormatting, y as cloneDoc, a7 as compareIDs, aq as compareRelativePositions, bf as convertUpdateFormatV1ToV2, bg as convertUpdateFormatV2ToV1, ap as createAbsolutePositionFromRelativePosition, bm as createAttributionItem, bK as createAttributionManagerFromDiff, q as createDeleteSetFromStructStore, aC as createDocFromSnapshot, a8 as createID, by as createIdMap, bs as createIdMapFromIdSet, p as createIdSet, s as createInsertionSetFromStructStore, ag as createRelativePositionFromJSON, ak as createRelativePositionFromTypeIndex, ax as createSnapshot, bx as decodeIdMap, ao as decodeRelativePosition, aw as decodeSnapshot, av as decodeSnapshotV2, W as decodeStateVector, b1 as decodeUpdate, b2 as decodeUpdateV2, bN as diffDocsToDelta, bA as diffIdMap, j as diffIdSet, bb as diffUpdate, ba as diffUpdateV2, ay as emptySnapshot, bv as encodeIdMap, am as encodeRelativePosition, au as encodeSnapshot, at as encodeSnapshotV2, T as encodeStateAsUpdate, S as encodeStateAsUpdateV2, $ as encodeStateVector, b6 as encodeStateVectorFromUpdate, b5 as encodeStateVectorFromUpdateV2, v as equalIdSets, as as equalSnapshots, aK as findIndexSS, ab as findRootTypeKey, aM as getItem, aP as getItemCleanEnd, aO as getItemCleanStart, aH as getState, bS as getTypeChildren, bz as insertIntoIdMap, g as insertIntoIdSet, ac as isParentOf, i as iterateStructsByIdSet, ad as logType, a$ as logUpdate, b0 as logUpdateV2, br as mergeIdMaps, m as mergeIdSets, b4 as mergeUpdates, b9 as mergeUpdatesV2, bI as noAttributionsManager, bd as obfuscateUpdate, be as obfuscateUpdateV2, bw as readIdMap, t as readIdSet, O as readUpdate, b8 as readUpdateIdRanges, b7 as readUpdateIdRangesV2, N as readUpdateV2, af as relativePositionToJSON, az as snapshot, aE as snapshotContainsUpdate, aX as transact, aW as tryGc, bY as typeListToArraySnapshot, cd as typeMapGetAllSnapshot, cc as typeMapGetSnapshot } from './Skip-CE05BUF8.js';
+export { ah as AbsolutePosition, bG as AbstractAttributionManager, A as AbstractConnector, cz as AbstractStruct, bV as AbstractType, cg as Array, bm as Attribution, cO as ContentAny, cC as ContentBinary, cE as ContentDeleted, cG as ContentDoc, cI as ContentEmbed, cK as ContentFormat, cM as ContentJSON, cQ as ContentString, c_ as ContentType, bK as DiffAttributionManager, D as Doc, cB as GC, a6 as ID, bu as IdMap, b as IdSet, d5 as Item, ci as Map, ae as RelativePosition, da as Skip, ar as Snapshot, bM as SnapshotAttributionManager, cp as Text, aS as Transaction, bH as TwosetAttributionManager, aZ as UndoManager, U as UpdateDecoderV1, C as UpdateDecoderV2, F as UpdateEncoderV1, H as UpdateEncoderV2, ct as XmlElement, cr as XmlFragment, cv as XmlHook, cx as XmlText, bh as YEvent, Q as applyUpdate, P as applyUpdateV2, cm as cleanupYTextFormatting, y as cloneDoc, a7 as compareIDs, aq as compareRelativePositions, bf as convertUpdateFormatV1ToV2, bg as convertUpdateFormatV2ToV1, ap as createAbsolutePositionFromRelativePosition, bn as createAttributionItem, bL as createAttributionManagerFromDiff, bN as createAttributionManagerFromSnapshots, q as createDeleteSetFromStructStore, aC as createDocFromSnapshot, a8 as createID, bz as createIdMap, bt as createIdMapFromIdSet, p as createIdSet, s as createInsertionSetFromStructStore, ag as createRelativePositionFromJSON, ak as createRelativePositionFromTypeIndex, ax as createSnapshot, by as decodeIdMap, ao as decodeRelativePosition, aw as decodeSnapshot, av as decodeSnapshotV2, W as decodeStateVector, b1 as decodeUpdate, b2 as decodeUpdateV2, bO as diffDocsToDelta, bB as diffIdMap, j as diffIdSet, bb as diffUpdate, ba as diffUpdateV2, ay as emptySnapshot, bw as encodeIdMap, am as encodeRelativePosition, au as encodeSnapshot, at as encodeSnapshotV2, T as encodeStateAsUpdate, S as encodeStateAsUpdateV2, $ as encodeStateVector, b6 as encodeStateVectorFromUpdate, b5 as encodeStateVectorFromUpdateV2, v as equalIdSets, as as equalSnapshots, aK as findIndexSS, ab as findRootTypeKey, aM as getItem, aP as getItemCleanEnd, aO as getItemCleanStart, bi as getPathTo, aH as getState, bT as getTypeChildren, bA as insertIntoIdMap, g as insertIntoIdSet, ac as isParentOf, i as iterateStructsByIdSet, ad as logType, a$ as logUpdate, b0 as logUpdateV2, bs as mergeIdMaps, m as mergeIdSets, b4 as mergeUpdates, b9 as mergeUpdatesV2, bJ as noAttributionsManager, bd as obfuscateUpdate, be as obfuscateUpdateV2, bx as readIdMap, t as readIdSet, O as readUpdate, b8 as readUpdateIdRanges, b7 as readUpdateIdRangesV2, N as readUpdateV2, af as relativePositionToJSON, az as snapshot, aE as snapshotContainsUpdate, aX as transact, aW as tryGc, bZ as typeListToArraySnapshot, ce as typeMapGetAllSnapshot, cd as typeMapGetSnapshot } from './Skip-gsWxt5h3.js';
 import 'lib0/function';
 import 'lib0/decoding';
 import 'lib0/binary';
 import 'lib0/map';
-import './index-C21sDQ5u.js';
+import './index-BextecLz.js';
 import 'lib0/observable';
 import 'lib0/array';
 import 'lib0/math';
diff --git a/package.json b/package.json
index 78bf71ceec3cd9d2e7828f11bb9aabd6e17d26e7..09abec044095b05e59106dbc5ee9dce71a51bfb7 100644
--- a/package.json
+++ b/package.json
@@ -73,12 +73,11 @@
   },
   "homepage": "https://docs.yjs.dev",
   "dependencies": {
-    "lib0": "^0.2.115"
+    "lib0": "^0.2.117"
   },
   "devDependencies": {
     "@types/node": "^22.14.1",
     "@y/protocols": "^1.0.6-1",
-    "concurrently": "^9.2.1",
     "markdownlint-cli": "^0.45.0",
     "rollup": "^4.52.5",
     "standard": "^17.1.2",
