---
title: Low-level APIs
description: Advanced APIs for direct editor state manipulation and ProseMirror integration
imageTitle: Low-level APIs
---

BlockNote provides low-level APIs for advanced use cases that require direct access to the editor's internal state or ProseMirror functionality.

## When to Use Low-level APIs

Use these APIs when you need:

- Direct access to ProseMirror state and commands
- Custom transaction logic
- Advanced selection manipulation
- Integration with ProseMirror plugins
- Performance-critical operations

**Note:** Prefer high-level APIs when possible. Low-level APIs require more careful handling and can be more error-prone.

## BlockNote Transactions

The `transact` method provides a safe way to perform multiple operations as a single atomic change.

### Basic Usage

```typescript
transact<T>(callback: (tr: Transaction) => T): T;

// Usage
const result = editor.transact((tr) => {
  // Perform operations using the transaction
  return "operation completed";
});
```

### Grouping Operations

```typescript
// Multiple operations as a single undo/redo step
editor.transact(() => {
  editor.insertBlocks([newBlock], referenceBlock);
  editor.updateBlock(blockId, { type: "heading" });
  editor.removeBlocks([oldBlockId]);
});
```

### Reading State

```typescript
// Read editor state within a transaction
const isSelectionEmpty = editor.transact((tr) => {
  return tr.selection.empty;
});

const documentSize = editor.transact((tr) => {
  return tr.doc.content.size;
});
```

### Performing Changes

```typescript
// Direct transaction manipulation
editor.transact((tr) => {
  // Insert text at current cursor position
  tr.insertText("Hello World");

  // Apply the transaction
  // (automatically done when transact returns)
});
```

## ProseMirror Commands

BlockNote provides access to ProseMirror commands for advanced functionality.

### Executing Commands

```typescript
exec(command: (state: EditorState, dispatch?: (tr: Transaction) => void, view?: EditorView) => boolean): boolean;

// Usage
const success = editor.exec((state, dispatch, view) => {
  if (dispatch) {
    const tr = state.tr;
    tr.insertText("Custom text");
    dispatch(tr);
  }
  return true;
});
```

### Checking Command Availability

```typescript
canExec(command: (state: EditorState, dispatch?: (tr: Transaction) => void, view?: EditorView) => boolean): boolean;

// Usage
const canInsertText = editor.canExec((state, dispatch) => {
  if (state.selection.empty) {
    return false;
  }

  if (dispatch) {
    dispatch(state.tr.insertText("Replacement"));
  }
  return true;
});
```

## Advanced Selection Manipulation

### Custom Selection Logic

```typescript
editor.transact((tr) => {
  // Create custom text selection
  const from = 10;
  const to = 20;
  tr.setSelection(TextSelection.create(tr.doc, from, to));
});
```

### Node Selection

```typescript
editor.transact((tr) => {
  // Select entire block
  const pos = 5; // Position of the block
  tr.setSelection(NodeSelection.create(tr.doc, pos));
});
```

## State Access and Manipulation

### Reading Document State

```typescript
editor.transact((tr) => {
  // Get document structure
  const doc = tr.doc;
  const docSize = doc.content.size;

  // Traverse document nodes
  doc.descendants((node, pos) => {
    console.log(`Node at ${pos}:`, node.type.name);
  });
});
```

### Custom Node Manipulation

```typescript
editor.transact((tr) => {
  // Find specific node
  const pos = 10;
  const node = tr.doc.nodeAt(pos);

  if (node && node.type.name === "paragraph") {
    // Modify node attributes
    tr.setNodeMarkup(pos, undefined, {
      ...node.attrs,
      customAttr: "value",
    });
  }
});
```

## Performance Optimizations

### Batch Operations

```typescript
// Efficient batch processing
editor.transact((tr) => {
  const changes = [];

  // Collect all changes
  tr.doc.descendants((node, pos) => {
    if (node.type.name === "paragraph") {
      changes.push({ pos, node });
    }
  });

  // Apply changes in reverse order to maintain positions
  changes.reverse().forEach(({ pos, node }) => {
    tr.setNodeMarkup(pos, undefined, {
      ...node.attrs,
      processed: true,
    });
  });
});
```

### Memory Management

```typescript
// Clean up references when done
let transaction: Transaction | null = null;

editor.transact((tr) => {
  transaction = tr;
  // Perform operations
});

// Clear reference
transaction = null;
```

## Error Handling

### Safe Transaction Execution

```typescript
try {
  editor.transact((tr) => {
    // Validate state before operations
    if (!tr.doc.nodeAt(0)) {
      throw new Error("Invalid document state");
    }

    // Perform operations
    tr.insertText("Safe operation");
  });
} catch (error) {
  console.error("Transaction failed:", error);
  // Handle error appropriately
}
```

### Command Validation

```typescript
const canExecute = editor.canExec((state, dispatch) => {
  // Validate command can be executed
  if (!state.selection || state.selection.empty) {
    return false;
  }

  // Check if operation is safe
  const { from, to } = state.selection;
  if (from === to) {
    return false;
  }

  if (dispatch) {
    dispatch(state.tr.insertText("Valid operation"));
  }
  return true;
});

if (canExecute) {
  editor.exec(/* same command */);
}
```

## Integration Examples

### Custom Plugin Integration

```typescript
// Integrate with ProseMirror plugins
editor.transact((tr) => {
  // Access plugin state
  const pluginState = somePluginKey.getState(tr.state);

  // Modify plugin state
  tr.setMeta(somePluginKey, {
    ...pluginState,
    customData: "value",
  });
});
```

### External Tool Integration

```typescript
// Integrate with external tools
editor.transact((tr) => {
  // Get current state for external processing
  const currentState = {
    doc: tr.doc.toJSON(),
    selection: tr.selection.toJSON(),
  };

  // Send to external tool
  externalTool.process(currentState).then((result) => {
    // Apply results back to editor
    editor.transact((newTr) => {
      // Apply external changes
      applyExternalChanges(newTr, result);
    });
  });
});
```

## Best Practices

1. **Use sparingly** - Prefer high-level APIs when possible
2. **Group operations** - Use `transact()` for multiple related changes
3. **Validate state** - Check document state before operations
4. **Handle errors** - Always wrap operations in try-catch blocks
5. **Clean up references** - Avoid holding transaction references
6. **Test thoroughly** - Low-level APIs can have unexpected side effects

## Related APIs

- **[Manipulating Blocks](./manipulating-blocks)** - High-level block operations
- **[Cursor & Selections](./cursor-selections)** - Selection management
- **[Events](./events)** - Editor lifecycle events
