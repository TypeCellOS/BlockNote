import { getPmSchema, UnreachableCaseError } from "@blocknote/core";
import { Slice } from "prosemirror-model";
import { TextSelection, Transaction } from "prosemirror-state";
import {
  Mapping,
  ReplaceAroundStep,
  ReplaceStep,
  Step,
  Transform,
} from "prosemirror-transform";
import { getFirstChar } from "./fragmentUtil.js";

export type AgentStep = {
  prosemirrorSteps: Step[];
  selection:
    | {
        anchor: number;
        head: number;
      }
    | undefined;
  type: "select" | "replace" | "insert";
};

/**
 * Takes an array of ReplaceSteps and applies them as a human-like agent.
 * Every step is split into 3 phases:
 * - select the text to be replaced (1 transaction per ReplaceStep)
 * - replace the text with the first character of the replacement (if any) (1 transaction per ReplaceStep)
 * - insert the replacement character by character (strlen-1 transactions per ReplaceStep)
 */
export function getStepsAsAgent(inputTr: Transform) {
  const pmSchema = getPmSchema(inputTr);

  const { modification } = pmSchema.marks;

  const agentSteps: AgentStep[] = [];

  const tr = new Transform(inputTr.before);

  for (let i = 0; i < inputTr.steps.length; i++) {
    const step = inputTr.steps[i];
    const invertMap = new Mapping(inputTr.mapping.maps.slice(0, i)).invert();

    if ((step as any).structure) {
      // Note: for structure changes (e.g.: node type or attr changes) we currently
      // don't trigger any selection

      if (step instanceof ReplaceStep) {
        if (
          step.to !== step.from + 1 ||
          step.slice.openStart !== 0 ||
          step.slice.openEnd !== 1 ||
          step.slice.content.size !== 2
        ) {
          throw new Error(
            "Structure change is not in expected format (ReplaceStep)",
          );
        }
      } else if (step instanceof ReplaceAroundStep) {
        // we only support ReplaceAroundSteps generated by SetNodeMarkup
        if (
          step.insert !== 1 ||
          step.slice.size !== 2 ||
          step.gapTo !== step.to - 1 ||
          step.gapFrom !== step.from + 1
        ) {
          throw new Error(
            "Structure change is not in expected format (ReplaceAroundStep)",
          );
        }
      } else {
        throw new Error("Step is not a ReplaceStep or ReplaceAroundStep");
      }

      const from = invertMap.map(step.from);
      const newNode = step.slice.content.firstChild!;
      const oldNode = tr.doc.resolve(tr.mapping.map(from)).nodeAfter!;

      let marks = newNode.marks || [];

      if (newNode.type !== oldNode.type) {
        marks = modification
          .create({
            type: "nodeType",
            previousValue: oldNode.type.name,
            newValue: newNode.type.name,
          })
          .addToSet(marks);
      }

      const attrNames = new Set([
        ...Object.keys(newNode.attrs),
        ...Object.keys(oldNode.attrs),
      ]);
      for (const attr of attrNames) {
        if (newNode.attrs[attr] !== oldNode.attrs[attr]) {
          marks = modification
            .create({
              type: "attr",
              attrName: attr,
              previousValue: oldNode.attrs[attr],
              newValue: newNode.attrs[attr],
            })
            .addToSet(marks);
        }
      }

      const stepIndex = tr.steps.length;
      tr.setNodeMarkup(
        tr.mapping.map(from),
        newNode.type,
        newNode.attrs,
        marks,
      );

      agentSteps.push({
        prosemirrorSteps: tr.steps.slice(stepIndex),
        selection: undefined,
        type: "replace",
      });

      continue;
    }

    if (!(step instanceof ReplaceStep)) {
      throw new Error("Step is not a ReplaceStep");
    }

    const from = invertMap.map(step.from);
    const to = invertMap.map(step.to);

    if (step.slice.openStart > 0 || step.slice.openEnd > 0) {
      // these kind of changes should not be generated by changeset.ts
      throw new Error(
        "Slice has openStart or openEnd > 0, but structure=false",
      );
    }

    // 1. Select text to be removed/replaced
    agentSteps.push({
      prosemirrorSteps: [],
      selection: {
        anchor: tr.mapping.map(from),
        head: tr.mapping.map(to),
      },
      type: "select",
    });

    // Replace the content
    const sliceTextContent = step.slice.content.textBetween(0, step.slice.size);

    const alreadyHasSameText =
      sliceTextContent ===
      tr.doc.textBetween(tr.mapping.map(from), tr.mapping.map(to));

    let sliceTo: number;

    if (alreadyHasSameText) {
      sliceTo = step.slice.content.size; // replace all at once, it's probably a mark update
    } else if (sliceTextContent.length === 0) {
      sliceTo = step.slice.content.size; // there's no replacement text, so use entire slice as replacement
    } else {
      // replace with the first character (similar to how a user would do it when selecting text and starting to type)
      const firstCharIndex = getFirstChar(step.slice.content);
      if (firstCharIndex === undefined) {
        // should have been caught by previous if statement
        throw new Error("unexpected: no first character found");
      }
      sliceTo = firstCharIndex + 1;
    }

    let replaceEnd = tr.mapping.map(to);
    const replaceFrom = tr.mapping.map(to);
    let first = true;

    // Note that below, we don't actually delete content, but we mark it as deleted
    // with a deletion mark. Similarly, we mark inserted content with an insertion mark.
    // It might be cleaner to;
    // a) make this optional
    // b) actually delete / insert the content and let prosemirror-suggest-changes handle the marks
    for (let i = sliceTo; i <= step.slice.content.size; i++) {
      // in the first agent step (first character replacement) we mark existing content (if any) as deleted
      // (step.from !== step.to is used to check for replacements vs inserts)
      const isReplacing = first && from !== to;

      const stepIndex = tr.steps.length;
      if (isReplacing) {
        const $pos = tr.doc.resolve(tr.mapping.map(from));
        if ($pos.nodeAfter?.isBlock) {
          // mark the entire node as deleted. This can be needed for inline nodes or table cells
          tr.addNodeMark($pos.pos, pmSchema.mark("deletion", {}));
        }
        tr.addMark($pos.pos, replaceEnd, pmSchema.mark("deletion", {}));
        replaceEnd = tr.mapping.map(to);
      }

      // note, instead of inserting one charachter at a time at the end (a, b, c)
      // we're replacing the entire part every time (a, ab, abc)
      // would be cleaner to do just insertions, but didn't get this to work with the add operation
      // (and this kept code relatively simple)
      const replacement = new Slice(step.slice.content.cut(0, i), 0, 0);

      tr.replace(replaceFrom, replaceEnd, replacement).addMark(
        replaceFrom,
        replaceFrom + replacement.content.size,
        pmSchema.mark("insertion", {}),
      );

      tr.doc.nodesBetween(
        replaceFrom,
        replaceFrom + replacement.content.size,
        (node, pos) => {
          if (
            pos < replaceFrom ||
            pos > replaceFrom + replacement.content.size
          ) {
            return true;
          }
          if (node.isBlock) {
            tr.addNodeMark(pos, pmSchema.mark("insertion", {}));
          }
          return false;
        },
      );

      replaceEnd = tr.mapping.slice(stepIndex).map(replaceEnd);

      const sel = TextSelection.near(
        tr.doc.resolve(replaceFrom + replacement.content.size),
        -1,
      );

      agentSteps.push({
        prosemirrorSteps: tr.steps.slice(stepIndex),
        selection: {
          anchor: sel.from,
          head: sel.from,
        },
        type: isReplacing
          ? "replace" // 2. Replace the text with the first character (if any) of the replacement
          : "insert", // 3. Insert the replacement character by character
      });
      first = false;
    }
  }

  return agentSteps;
}

export async function delayAgentStep(step: AgentStep) {
  const jitter = Math.random() * 0.3 + 0.85; // Random between 0.85 and 1.15
  if (step.type === "select") {
    await new Promise((resolve) => setTimeout(resolve, 100 * jitter));
  } else if (step.type === "insert") {
    await new Promise((resolve) => setTimeout(resolve, 10 * jitter));
  } else if (step.type === "replace") {
    await new Promise((resolve) => setTimeout(resolve, 200 * jitter));
  } else {
    throw new UnreachableCaseError(step.type);
  }
}

export function applyAgentStep(tr: Transaction, step: AgentStep) {
  tr.setMeta("addToHistory", false);

  if (step.selection) {
    tr.setMeta("aiAgent", {
      selection: {
        anchor: step.selection.anchor,
        head: step.selection.head,
      },
    });
  }
  for (const pmStep of step.prosemirrorSteps) {
    const result = tr.maybeStep(pmStep);
    if (result.failed) {
      // this would fail for tables, but has since been fixed using filterTransaction (in AIExtension)
      // other cases have not been encountered so we throw an error here

      throw new Error("failed to apply step");
    }
  }

  /*
  In getStepsAsAgent, we manually insert the insertion / modification / deletion marks.
  Another approach could be to only issue the change operations, and let prosemirror-suggest-changes
  handle adding the marks. This could be done with changing the getStepsAsAgent, and using
  `withSuggestChanges` like below.

  For now, manual approach seems to work well - keeping below as reference.

  function fakeDispatch(suggestTr: Transaction) {
    tr = suggestTr;
  }

  enableSuggestChanges(editor.prosemirrorState, editor.dispatch);
  if (!isSuggestChangesEnabled(editor.prosemirrorState)) {
    throw new Error(
      "suggest changes could not be enabled, is the AI / suggestion plugin enabled?"
    );
  }
  withSuggestChanges(fakeDispatch).bind({
    get state() {
      return editor.prosemirrorState;
    },
  })(tr);
  disableSuggestChanges(editor.prosemirrorState, editor.dispatch);
  */

  return tr;
}
